<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Analysis/CFG.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_ANALYSIS_CFG_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_ANALYSIS_CFG_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/Support/BumpVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/ConstructionContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/GraphTraits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/None.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerIntPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Allocator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/raw_ostream.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bitset&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iterator&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BinaryOperator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CFG</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXBaseSpecifier</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXBindTemporaryExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXCtorInitializer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXDeleteExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXDestructorDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXNewExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXRecordDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Decl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FieldDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LangOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VarDecl</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>CFGElement</name> <block>{<block_content>
<label><name>public</name>:</label>
<enum>enum <name>Kind</name> <block>{

<decl><name>Initializer</name></decl>,
<decl><name>ScopeBegin</name></decl>,
<decl><name>ScopeEnd</name></decl>,
<decl><name>NewAllocator</name></decl>,
<decl><name>LifetimeEnds</name></decl>,
<decl><name>LoopExit</name></decl>,

<decl><name>Statement</name></decl>,
<decl><name>Constructor</name></decl>,
<decl><name>CXXRecordTypedCall</name></decl>,
<decl><name>STMT_BEGIN</name> <init>= <expr><name>Statement</name></expr></init></decl>,
<decl><name>STMT_END</name> <init>= <expr><name>CXXRecordTypedCall</name></expr></init></decl>,

<decl><name>AutomaticObjectDtor</name></decl>,
<decl><name>DeleteDtor</name></decl>,
<decl><name>BaseDtor</name></decl>,
<decl><name>MemberDtor</name></decl>,
<decl><name>TemporaryDtor</name></decl>,
<decl><name>DTOR_BEGIN</name> <init>= <expr><name>AutomaticObjectDtor</name></expr></init></decl>,
<decl><name>DTOR_END</name> <init>= <expr><name>TemporaryDtor</name></expr></init></decl>
}</block>;</enum>

<label><name>protected</name>:</label>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>Data1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>Data2</name></expr>;</expr_stmt>

<macro><name>CFGElement</name><argument_list>(<argument>Kind kind</argument>, <argument>const void *Ptr1</argument>, <argument>const void *Ptr2 = nullptr</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Data1</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Ptr1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator> <name>kind</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3</literal></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>Data2</name><argument_list>(<argument>const_cast&lt;void*&gt;(Ptr2)</argument>, <argument>(((unsigned) kind) &gt;&gt; <literal type="number">2</literal>) &amp; <literal type="number">0x3</literal></argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>kind</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>CFGElement</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>

<label><name>public</name>:</label>


<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>T</name> <macro><name>castAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>T</name><operator>::</operator><call><name>isKind</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>T</name> <name>t</name></expr>;
<expr><name>CFGElement</name><operator>&amp;</operator> <name>e</name> <operator>=</operator> <name>t</name></expr>;
<expr><name>e</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;
<return>return <expr><name>t</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>getAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>T</name><operator>::</operator><call><name>isKind</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>None</name></expr>;</return></block_content></block></if></if_stmt>
<name>T</name> <name>t</name></block></expr>;</expr_stmt>
<decl_stmt><decl><type><name>CFGElement</name><modifier>&amp;</modifier></type> <name>e</name> <init>= <expr><name>t</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;</expr_stmt>
<return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>unsigned</name> <name>x</name> <operator>=</operator> <call><name><name>Data2</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>x</name> <operator>&lt;&lt;=</operator> <literal type="number">2</literal></expr>;
<expr><name>x</name> <operator>|=</operator> <call><name><name>Data1</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><operator>(</operator><name>Kind</name><operator>)</operator> <name>x</name></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>dumpToStream</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>dumpToStream</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><call><name>errs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CFGStmt</name> <range>: <expr><name>public</name> <name>CFGElement</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <macro><name>CFGStmt</name><argument_list>(<argument>Stmt *S</argument>, <argument>Kind K = Statement</argument>)</argument_list></macro> <operator>:</operator> <macro><name>CFGElement</name><argument_list>(<argument>K</argument>, <argument>S</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isKind</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data1</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CFGElement</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const CFGElement &amp;E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>E</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>STMT_BEGIN</name> <operator>&amp;&amp;</operator> <call><name><name>E</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>STMT_END</name></expr>;</return>
}</block>

<name>protected</name><operator>:</operator>
<call><name>CFGStmt</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
}</block></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>CFGConstructor</name> <range>: <expr><name>public</name> <name>CFGStmt</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>CFGConstructor</name><argument_list>(<argument><expr><name>CXXConstructExpr</name> <operator>*</operator><name>CE</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ConstructionContext</name> <operator>*</operator><name>C</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CFGStmt</name><argument_list>(<argument>CE</argument>, <argument>Constructor</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Data2</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ConstructionContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>const</specifier> <name>ConstructionContext</name> <operator>*</operator><macro><name>getConstructionContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ConstructionContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data2</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CFGElement</name></expr>;

<expr><call><name>CFGConstructor</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const CFGElement &amp;E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>E</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Constructor</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>CFGCXXRecordTypedCall</name> <operator>:</operator> <name>public</name> <name>CFGStmt</name> <block>{
<expr><name>public</name><operator>:</operator>


<specifier>static</specifier> <name>bool</name> <macro><name>isCXXRecordTypedCall</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>CallExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMessageExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;



<return>return <expr><operator>!</operator><call><name><name>E</name><operator>-&gt;</operator><name>isGLValue</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCanonicalType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getAsCXXRecordDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>explicit</name> <call><name>CFGCXXRecordTypedCall</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ConstructionContext</name> <operator>*</operator><name>C</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CFGStmt</name><argument_list>(<argument>E</argument>, <argument>CXXRecordTypedCall</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isCXXRecordTypedCall</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>C</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>TemporaryObjectConstructionContext</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ReturnedValueConstructionContext</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>VariableConstructionContext</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ConstructorInitializerConstructionContext</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ArgumentConstructionContext</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Data2</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ConstructionContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>const</specifier> <name>ConstructionContext</name> <operator>*</operator><macro><name>getConstructionContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ConstructionContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data2</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CFGElement</name></expr>;

<expr><call><name>CFGCXXRecordTypedCall</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const CFGElement &amp;E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>E</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXRecordTypedCall</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>CFGInitializer</name> <operator>:</operator> <name>public</name> <name>CFGElement</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>CFGInitializer</name><argument_list>(<argument><expr><name>CXXCtorInitializer</name> <operator>*</operator><name>initializer</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CFGElement</name><argument_list>(<argument>Initializer</argument>, <argument>initializer</argument>)</argument_list></macro> <block>{}</block>

<name>CXXCtorInitializer</name><operator>*</operator> <macro><name>getInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXCtorInitializer</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data1</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CFGElement</name></expr>;

<expr><call><name>CFGInitializer</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const CFGElement &amp;E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>E</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Initializer</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>CFGNewAllocator</name> <operator>:</operator> <name>public</name> <name>CFGElement</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>CFGNewAllocator</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXNewExpr</name> <operator>*</operator><name>S</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CFGElement</name><argument_list>(<argument>NewAllocator</argument>, <argument>S</argument>)</argument_list></macro> <block>{}</block>


<specifier>const</specifier> <name>CXXNewExpr</name> <operator>*</operator><macro><name>getAllocatorExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXNewExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data1</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CFGElement</name></expr>;

<expr><call><name>CFGNewAllocator</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const CFGElement &amp;elem</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>elem</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NewAllocator</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>CFGLoopExit</name> <operator>:</operator> <name>public</name> <name>CFGElement</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>CFGLoopExit</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>stmt</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>CFGElement</name><argument_list>(<argument>LoopExit</argument>, <argument>stmt</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getLoopStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data1</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CFGElement</name></expr>;

<expr><call><name>CFGLoopExit</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const CFGElement &amp;elem</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>elem</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>LoopExit</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>CFGLifetimeEnds</name> <operator>:</operator> <name>public</name> <name>CFGElement</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>CFGLifetimeEnds</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>var</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>stmt</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CFGElement</name><argument_list>(<argument>LifetimeEnds</argument>, <argument>var</argument>, <argument>stmt</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><macro><name>getVarDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data1</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getTriggerStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data2</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CFGElement</name></expr>;

<expr><call><name>CFGLifetimeEnds</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const CFGElement &amp;elem</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>elem</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>LifetimeEnds</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>CFGScopeBegin</name> <operator>:</operator> <name>public</name> <name>CFGElement</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>CFGScopeBegin</name><argument_list>()</argument_list></macro> <block>{}</block>
<call><name>CFGScopeBegin</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CFGElement</name><argument_list>(<argument>ScopeBegin</argument>, <argument>VD</argument>, <argument>S</argument>)</argument_list></macro> <block>{}</block>


<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getTriggerStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data2</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><macro><name>getVarDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data1</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CFGElement</name></expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const CFGElement &amp;E</argument>)</argument_list></macro> <block>{
<expr><name>Kind</name> <name>kind</name> <operator>=</operator> <call><name><name>E</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>kind</name> <operator>==</operator> <name>ScopeBegin</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>CFGScopeEnd</name> <operator>:</operator> <name>public</name> <name>CFGElement</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>CFGScopeEnd</name><argument_list>()</argument_list></macro> <block>{}</block>
<call><name>CFGScopeEnd</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>CFGElement</name><argument_list>(<argument>ScopeEnd</argument>, <argument>VD</argument>, <argument>S</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><macro><name>getVarDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data1</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getTriggerStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data2</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CFGElement</name></expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const CFGElement &amp;E</argument>)</argument_list></macro> <block>{
<expr><name>Kind</name> <name>kind</name> <operator>=</operator> <call><name><name>E</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>kind</name> <operator>==</operator> <name>ScopeEnd</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>CFGImplicitDtor</name> <operator>:</operator> <name>public</name> <name>CFGElement</name> <block>{
<expr><name>protected</name><operator>:</operator>
<call><name>CFGImplicitDtor</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<macro><name>CFGImplicitDtor</name><argument_list>(<argument>Kind kind</argument>, <argument>const void *data1</argument>, <argument>const void *data2 = nullptr</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CFGElement</name><argument_list>(<argument>kind</argument>, <argument>data1</argument>, <argument>data2</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>kind</name> <operator>&gt;=</operator> <name>DTOR_BEGIN</name> <operator>&amp;&amp;</operator> <name>kind</name> <operator>&lt;=</operator> <name>DTOR_END</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>CXXDestructorDecl</name> <operator>*</operator><macro><name>getDestructorDecl</name><argument_list>(<argument>ASTContext &amp;astContext</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isNoReturn</name><argument_list>(<argument>ASTContext &amp;astContext</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CFGElement</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const CFGElement &amp;E</argument>)</argument_list></macro> <block>{
<expr><name>Kind</name> <name>kind</name> <operator>=</operator> <call><name><name>E</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>kind</name> <operator>&gt;=</operator> <name>DTOR_BEGIN</name> <operator>&amp;&amp;</operator> <name>kind</name> <operator>&lt;=</operator> <name>DTOR_END</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>CFGAutomaticObjDtor</name><operator>:</operator> <name>public</name> <name>CFGImplicitDtor</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>CFGAutomaticObjDtor</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>var</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>stmt</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CFGImplicitDtor</name><argument_list>(<argument>AutomaticObjectDtor</argument>, <argument>var</argument>, <argument>stmt</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><macro><name>getVarDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data1</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getTriggerStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data2</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CFGElement</name></expr>;

<expr><call><name>CFGAutomaticObjDtor</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const CFGElement &amp;elem</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>elem</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>AutomaticObjectDtor</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>CFGDeleteDtor</name> <operator>:</operator> <name>public</name> <name>CFGImplicitDtor</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>CFGDeleteDtor</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CXXDeleteExpr</name> <operator>*</operator><name>DE</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CFGImplicitDtor</name><argument_list>(<argument>DeleteDtor</argument>, <argument>RD</argument>, <argument>DE</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><macro><name>getCXXRecordDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data1</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<specifier>const</specifier> <name>CXXDeleteExpr</name> <operator>*</operator><macro><name>getDeleteExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXDeleteExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data2</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CFGElement</name></expr>;

<expr><call><name>CFGDeleteDtor</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const CFGElement &amp;elem</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>elem</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DeleteDtor</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>CFGBaseDtor</name> <operator>:</operator> <name>public</name> <name>CFGImplicitDtor</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>CFGBaseDtor</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXBaseSpecifier</name> <operator>*</operator><name>base</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CFGImplicitDtor</name><argument_list>(<argument>BaseDtor</argument>, <argument>base</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>CXXBaseSpecifier</name> <operator>*</operator><macro><name>getBaseSpecifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXBaseSpecifier</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data1</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CFGElement</name></expr>;

<expr><call><name>CFGBaseDtor</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const CFGElement &amp;E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>E</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>BaseDtor</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>CFGMemberDtor</name> <operator>:</operator> <name>public</name> <name>CFGImplicitDtor</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>CFGMemberDtor</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><name>field</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CFGImplicitDtor</name><argument_list>(<argument>MemberDtor</argument>, <argument>field</argument>, <argument>nullptr</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><macro><name>getFieldDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>FieldDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data1</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CFGElement</name></expr>;

<expr><call><name>CFGMemberDtor</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const CFGElement &amp;E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>E</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>MemberDtor</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>CFGTemporaryDtor</name> <operator>:</operator> <name>public</name> <name>CFGImplicitDtor</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>CFGTemporaryDtor</name><argument_list>(<argument><expr><name>CXXBindTemporaryExpr</name> <operator>*</operator><name>expr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CFGImplicitDtor</name><argument_list>(<argument>TemporaryDtor</argument>, <argument>expr</argument>, <argument>nullptr</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>CXXBindTemporaryExpr</name> <operator>*</operator><macro><name>getBindTemporaryExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXBindTemporaryExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data1</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CFGElement</name></expr>;

<expr><call><name>CFGTemporaryDtor</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const CFGElement &amp;E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>E</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>TemporaryDtor</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>CFGTerminator</name> <block>{
<expr><name>public</name><operator>:</operator>
enum <name>Kind</name> <block>{


<expr><name>StmtBranch</name></expr>,



<expr><name>TemporaryDtorsBranch</name></expr>,



<expr><name>VirtualBaseBranch</name></expr>,




<expr><name>NumKindsMinusOne</name> <operator>=</operator> <name>VirtualBaseBranch</name></expr>
}</block></expr>;

<expr><name>private</name><operator>:</operator>
<specifier>static</specifier> <name>constexpr</name> <name>int</name> <name>KindBits</name> <operator>=</operator> <literal type="number">2</literal></expr>;
<expr><call><name>static_assert</name><argument_list>(<argument><expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>KindBits</name><operator>)</operator> <operator>&gt;</operator> <name>NumKindsMinusOne</name></expr></argument>,
<argument><expr><literal type="string">"Not enough room for kind!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>, <argument><expr><name>KindBits</name></expr></argument>&gt;</argument_list></name> <name>Data</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>CFGTerminator</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>; }</block>
<macro><name>CFGTerminator</name><argument_list>(<argument>Stmt *S</argument>, <argument>Kind K = StmtBranch</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Data</name><argument_list>(<argument>S</argument>, <argument>K</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <macro><name>isValid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Data</name><operator>.</operator><name>getOpaqueValue</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block>
<name>Stmt</name> <operator>*</operator><macro><name>getStmt</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Data</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Data</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Kind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>isStmtBranch</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>StmtBranch</name></expr>;</return>
}</block>
<name>bool</name> <macro><name>isTemporaryDtorsBranch</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TemporaryDtorsBranch</name></expr>;</return>
}</block>
<name>bool</name> <macro><name>isVirtualBaseBranch</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>VirtualBaseBranch</name></expr>;</return>
}</block>
}</expr>;



























<expr><name>class</name> <name>CFGBlock</name> <block>{
<expr><name>class</name> <name>ElementList</name> <block>{
<expr><name>using</name> <name>ImplTy</name> <operator>=</operator> <name><name>BumpVector</name><argument_list type="generic">&lt;<argument><expr><name>CFGElement</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>ImplTy</name> <name>Impl</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>ElementList</name><argument_list>(<argument><expr><name>BumpVectorContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>Impl</name><argument_list>(<argument>C</argument>, <argument><literal type="number">4</literal></argument>)</argument_list></macro> <block>{}</block>

<name>using</name> <name>iterator</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>reverse_iterator</name><argument_list type="generic">&lt;<argument><expr><name>ImplTy</name><operator>::</operator><name>iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>const_iterator</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>reverse_iterator</name><argument_list type="generic">&lt;<argument><expr><name>ImplTy</name><operator>::</operator><name>const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>reverse_iterator</name> <operator>=</operator> <name>ImplTy</name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>const_reverse_iterator</name> <operator>=</operator> <name>ImplTy</name><operator>::</operator><name>const_iterator</name></expr>;
<expr><name>using</name> <name>const_reference</name> <operator>=</operator> <name>ImplTy</name><operator>::</operator><name>const_reference</name></expr>;

<expr><name>void</name> <macro><name>push_back</name><argument_list>(<argument>CFGElement e</argument>, <argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{ <expr><call><name><name>Impl</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>reverse_iterator</name> <macro><name>insert</name><argument_list>(<argument>reverse_iterator I</argument>, <argument>size_t Cnt</argument>, <argument>CFGElement E</argument>,
<argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Impl</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>Cnt</name></expr></argument>, <argument><expr><name>E</name></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_reference</name> <macro><name>front</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_reference</name> <macro><name>back</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>rbegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>rend</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>rbegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>rend</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>reverse_iterator</name> <macro><name>rbegin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>reverse_iterator</name> <macro><name>rend</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_reverse_iterator</name> <macro><name>rbegin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_reverse_iterator</name> <macro><name>rend</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>CFGElement</name> <name><name>operator</name><index>[]</index></name><operator>(</operator><name>size_t</name> <name>i</name><operator>)</operator> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name><name>Impl</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>Impl</name><index>[<expr><call><name><name>Impl</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name></expr>]</index></name></expr>;</return>
}</block>

<name>size_t</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;




<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>IsConst</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>ElementRefImpl</name> <block>{

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>IsOtherConst</name></expr></argument>&gt;</argument_list></name> <name>friend</name> <name>class</name> <name>ElementRefImpl</name></expr>;

<expr><name>using</name> <name>CFGBlockPtr</name> <operator>=</operator>
<name>std</name><operator>::</operator><name><name>conditional_t</name><argument_list type="generic">&lt;<argument><expr><name>IsConst</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator></expr></argument>, <argument><expr><name>CFGBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>using</name> <name>CFGElementPtr</name> <operator>=</operator>
<name>std</name><operator>::</operator><name><name>conditional_t</name><argument_list type="generic">&lt;<argument><expr><name>IsConst</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CFGElement</name> <operator>*</operator></expr></argument>, <argument><expr><name>CFGElement</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>protected</name><operator>:</operator>
<name>CFGBlockPtr</name> <name>Parent</name></expr>;
<expr><name>size_t</name> <name>Index</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>ElementRefImpl</name><argument_list>(<argument>CFGBlockPtr Parent</argument>, <argument>size_t Index</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Parent</name><argument_list>(<argument><expr><name>Parent</name></expr></argument>)</argument_list></call></expr>, <macro><name>Index</name><argument_list>(<argument>Index</argument>)</argument_list></macro> <expr><block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>IsOtherConst</name></expr></argument>&gt;</argument_list></name>
<call><name>ElementRefImpl</name><argument_list>(<argument><expr><name><name>ElementRefImpl</name><argument_list type="generic">&lt;<argument><expr><name>IsOtherConst</name></expr></argument>&gt;</argument_list></name> <name>Other</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ElementRefImpl</name><argument_list>(<argument>Other.Parent</argument>, <argument>Other.Index</argument>)</argument_list></macro> <block>{}</block>

<name>size_t</name> <macro><name>getIndexInBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Index</name></expr>;</return> }</block>

<name>CFGBlockPtr</name> <macro><name>getParent</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Parent</name></expr>;</return> }</block>
<name>CFGBlockPtr</name> <macro><name>getParent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Parent</name></expr>;</return> }</block>

<name>bool</name> <name>operator</name><operator>&lt;</operator><operator>(</operator><name>ElementRefImpl</name> <name>Other</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>std</name><operator>::</operator><call><name>make_pair</name><argument_list>(<argument><expr><name>Parent</name></expr></argument>, <argument><expr><name>Index</name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
<name>std</name><operator>::</operator><call><name>make_pair</name><argument_list>(<argument><expr><name><name>Other</name><operator>.</operator><name>Parent</name></name></expr></argument>, <argument><expr><name><name>Other</name><operator>.</operator><name>Index</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><name>ElementRefImpl</name> <name>Other</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>Parent</name> <operator>==</operator> <name><name>Other</name><operator>.</operator><name>Parent</name></name> <operator>&amp;&amp;</operator> <name>Index</name> <operator>==</operator> <name><name>Other</name><operator>.</operator><name>Index</name></name></expr>;</return>
}</block>

<name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><name>ElementRefImpl</name> <name>Other</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><operator>(</operator><operator>*</operator><name>this</name> <operator>==</operator> <name>Other</name><operator>)</operator></expr>;</return> }</block>
<name>CFGElement</name> <name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><operator>*</operator><name>Parent</name><operator>)</operator><index>[<expr><name>Index</name></expr>]</index></expr>;</return> }</block>
<name>CFGElementPtr</name> <name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr>) <specifier>const</specifier> <block>{ <return>return <expr><operator>&amp;</operator><operator>*</operator><operator>(</operator><call><name><name>Parent</name><operator>-&gt;</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>Index</name><operator>)</operator></expr>;</return> }</block></block>

<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>llvm::raw_ostream &amp;OS</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>OS</name> <operator>&lt;&lt;</operator> <call><name>getIndexInBlock</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="string">": "</literal></expr>;
<expr><call><name><operator>(</operator><operator>*</operator><name>this</name><operator>)</operator><operator>-&gt;</operator><name>dumpToStream</name></name><argument_list>(<argument><expr><name>OS</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>dumpToStream</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><call><name>errs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>IsReverse</name></expr></argument>, <argument><expr><name>bool</name> <name>IsConst</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>ElementRefIterator</name> <block>{

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>IsOtherReverse</name></expr></argument>, <argument><expr><name>bool</name> <name>IsOtherConst</name></expr></argument>&gt;</argument_list></name>
<name>friend</name> <name>class</name> <name>ElementRefIterator</name></expr>;

<expr><name>using</name> <name>CFGBlockRef</name> <operator>=</operator>
<name>std</name><operator>::</operator><name><name>conditional_t</name><argument_list type="generic">&lt;<argument><expr><name>IsConst</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator></expr></argument>, <argument><expr><name>CFGBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>using</name> <name>UnderlayingIteratorTy</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>conditional_t</name><argument_list type="generic">&lt;
<argument><expr><name>IsConst</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>conditional_t</name><argument_list type="generic">&lt;<argument><expr><name>IsReverse</name></expr></argument>, <argument><expr><name>ElementList</name><operator>::</operator><name>const_reverse_iterator</name></expr></argument>,
<argument><expr><name>ElementList</name><operator>::</operator><name>const_iterator</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>conditional_t</name><argument_list type="generic">&lt;<argument><expr><name>IsReverse</name></expr></argument>, <argument><expr><name>ElementList</name><operator>::</operator><name>reverse_iterator</name></expr></argument>,
<argument><expr><name>ElementList</name><operator>::</operator><name>iterator</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>using</name> <name>IteratorTraits</name> <operator>=</operator> <name>typename</name> <name>std</name><operator>::</operator><name><name>iterator_traits</name><argument_list type="generic">&lt;<argument><expr><name>UnderlayingIteratorTy</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>ElementRef</name> <operator>=</operator> <name>typename</name> <name>CFGBlock</name><operator>::</operator><name><name>ElementRefImpl</name><argument_list type="generic">&lt;<argument><expr><name>IsConst</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>public</name><operator>:</operator>
<name>using</name> <name>difference_type</name> <operator>=</operator> <name>typename</name> <name>IteratorTraits</name><operator>::</operator><name>difference_type</name></expr>;
<expr><name>using</name> <name>value_type</name> <operator>=</operator> <name>ElementRef</name></expr>;
<expr><name>using</name> <name>pointer</name> <operator>=</operator> <name>ElementRef</name> <operator>*</operator></expr>;
<expr><name>using</name> <name>iterator_category</name> <operator>=</operator> <name>typename</name> <name>IteratorTraits</name><operator>::</operator><name>iterator_category</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>CFGBlockRef</name> <name>Parent</name></expr>;
<expr><name>UnderlayingIteratorTy</name> <name>Pos</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>ElementRefIterator</name><argument_list>(<argument>CFGBlockRef Parent</argument>, <argument>UnderlayingIteratorTy Pos</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Parent</name><argument_list>(<argument><expr><name>Parent</name></expr></argument>)</argument_list></call></expr>, <macro><name>Pos</name><argument_list>(<argument>Pos</argument>)</argument_list></macro> <expr><block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>IsOtherConst</name></expr></argument>&gt;</argument_list></name>
<call><name>ElementRefIterator</name><argument_list>(<argument><expr><name><name>ElementRefIterator</name><argument_list type="generic">&lt;<argument><expr><name>false</name></expr></argument>, <argument><expr><name>IsOtherConst</name></expr></argument>&gt;</argument_list></name> <name>E</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ElementRefIterator</name><argument_list>(<argument>E.Parent</argument>, <argument>E.Pos.base()</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>IsOtherConst</name></expr></argument>&gt;</argument_list></name>
<call><name>ElementRefIterator</name><argument_list>(<argument><expr><name><name>ElementRefIterator</name><argument_list type="generic">&lt;<argument><expr><name>true</name></expr></argument>, <argument><expr><name>IsOtherConst</name></expr></argument>&gt;</argument_list></name> <name>E</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ElementRefIterator</name><argument_list>(<argument>E.Parent</argument>, <argument>llvm::make_reverse_iterator(E.Pos)</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <name>operator</name><operator>&lt;</operator><operator>(</operator><name>ElementRefIterator</name> <name>Other</name><operator>)</operator> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Parent</name> <operator>==</operator> <name><name>Other</name><operator>.</operator><name>Parent</name></name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Pos</name> <operator>&lt;</operator> <name><name>Other</name><operator>.</operator><name>Pos</name></name></expr>;</return>
}</block>

<name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><name>ElementRefIterator</name> <name>Other</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>Parent</name> <operator>==</operator> <name><name>Other</name><operator>.</operator><name>Parent</name></name> <operator>&amp;&amp;</operator> <name>Pos</name> <operator>==</operator> <name><name>Other</name><operator>.</operator><name>Pos</name></name></expr>;</return>
}</block>

<name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><name>ElementRefIterator</name> <name>Other</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><operator>*</operator><name>this</name> <operator>==</operator> <name>Other</name><operator>)</operator></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>IsOtherConst</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>size_t</name>
<macro><name>getIndexInBlock</name><argument_list>(<argument>CFGBlock::ElementRefIterator&lt;true</argument>, <argument>IsOtherConst&gt; E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>E</name><operator>.</operator><name>Parent</name><operator>-&gt;</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <operator>(</operator><name><name>E</name><operator>.</operator><name>Pos</name></name> <operator>-</operator> <call><name><name>E</name><operator>.</operator><name>Parent</name><operator>-&gt;</operator><name>rbegin</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>IsOtherConst</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>size_t</name>
<macro><name>getIndexInBlock</name><argument_list>(<argument>CFGBlock::ElementRefIterator&lt;false</argument>, <argument>IsOtherConst&gt; E</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>E</name><operator>.</operator><name>Pos</name></name> <operator>-</operator> <call><name><name>E</name><operator>.</operator><name>Parent</name><operator>-&gt;</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>value_type</name> <name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <block>{ <return>return <expr><block>{<expr><name>Parent</name></expr>, <macro><name>getIndexInBlock</name><argument_list>(<argument>*this</argument>)</argument_list></macro>}</block></expr>;</return> }</block>

<name>difference_type</name> <name>operator</name><operator>-</operator><operator>(</operator><name>ElementRefIterator</name> <name>Other</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>Pos</name> <operator>-</operator> <name><name>Other</name><operator>.</operator><name>Pos</name></name></expr>;</return>
}</block>

<name>ElementRefIterator</name> <name>operator</name><operator>++</operator><operator>(</operator><operator>)</operator> <block>{
<expr><operator>++</operator><name><name>this</name><operator>-&gt;</operator><name>Pos</name></name></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block>
<name>ElementRefIterator</name> <name>operator</name><operator>++</operator><operator>(</operator><name>int</name><operator>)</operator> <block>{
<expr><name>ElementRefIterator</name> <name>Ret</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;
<expr><operator>++</operator><operator>*</operator><name>this</name></expr>;
<return>return <expr><name>Ret</name></expr>;</return>
}</block>
<name>ElementRefIterator</name> <name>operator</name><operator>+</operator><operator>(</operator><name>size_t</name> <name>count</name><operator>)</operator> <block>{
<expr><name><name>this</name><operator>-&gt;</operator><name>Pos</name></name> <operator>+=</operator> <name>count</name></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block>
<name>ElementRefIterator</name> <name>operator</name><operator>-</operator><operator>(</operator><name>size_t</name> <name>count</name><operator>)</operator> <block>{
<expr><name><name>this</name><operator>-&gt;</operator><name>Pos</name></name> <operator>-=</operator> <name>count</name></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block>
}</expr>;

<expr><name>public</name><operator>:</operator>

<name>ElementList</name> <name>Elements</name></expr>;




<expr><name>Stmt</name> <operator>*</operator><name>Label</name> <operator>=</operator> <name>nullptr</name></expr>;



<expr><name>CFGTerminator</name> <name>Terminator</name></expr>;




<expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>LoopTarget</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>unsigned</name> <name>BlockID</name></expr>;

<expr><name>public</name><operator>:</operator>





<name>class</name> <name>AdjacentBlock</name> <block>{
enum <expr><name>Kind</name> <block>{
<expr><name>AB_Normal</name></expr>,
<expr><name>AB_Unreachable</name></expr>,
<expr><name>AB_Alternate</name></expr>
}</block></expr>;

<expr><name>CFGBlock</name> <operator>*</operator><name>ReachableBlock</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>CFGBlock</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>UnreachableBlock</name></expr>;

<expr><name>public</name><operator>:</operator>

<macro><name>AdjacentBlock</name><argument_list>(<argument>CFGBlock *B</argument>, <argument>bool IsReachable</argument>)</argument_list></macro></expr>;



<expr><call><name>AdjacentBlock</name><argument_list>(<argument><expr><name>CFGBlock</name> <operator>*</operator><name>B</name></expr></argument>, <argument><expr><name>CFGBlock</name> <operator>*</operator><name>AlternateBlock</name></expr></argument>)</argument_list></call></expr>;


<expr><name>CFGBlock</name> <operator>*</operator><macro><name>getReachableBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ReachableBlock</name></expr>;</return>
}</block>


<name>CFGBlock</name> <operator>*</operator><macro><name>getPossiblyUnreachableBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>UnreachableBlock</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>operator</name> <name>CFGBlock</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getReachableBlock</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>CFGBlock</name><operator>&amp;</operator> <name>operator</name> <operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><operator>*</operator><call><name>getReachableBlock</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>CFGBlock</name><operator>*</operator> <name><name>operator</name> <operator>-&gt;</operator><name/></name>(</expr>) <specifier>const</specifier> <block>{
<return>return <expr><call><name>getReachableBlock</name><argument_list>()</argument_list></call></expr>;</return>
}</block></block>

<name>bool</name> <macro><name>isReachable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>Kind</name> <name>K</name> <operator>=</operator> <operator>(</operator><name>Kind</name><operator>)</operator> <call><name><name>UnreachableBlock</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>K</name> <operator>==</operator> <name>AB_Normal</name> <operator>||</operator> <name>K</name> <operator>==</operator> <name>AB_Alternate</name></expr>;</return>
}</block>
}</expr>;

<expr><name>private</name><operator>:</operator>

<name>using</name> <name>AdjacentBlocks</name> <operator>=</operator> <name><name>BumpVector</name><argument_list type="generic">&lt;<argument><expr><name>AdjacentBlock</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>AdjacentBlocks</name> <name>Preds</name></expr>;
<expr><name>AdjacentBlocks</name> <name>Succs</name></expr>;










<expr><name>unsigned</name> <name>HasNoReturnElement</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>CFG</name> <operator>*</operator><name>Parent</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <macro><name>CFGBlock</name><argument_list>(<argument>unsigned blockid</argument>, <argument>BumpVectorContext &amp;C</argument>, <argument>CFG *parent</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Elements</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Terminator</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>BlockID</name><argument_list>(<argument><expr><name>blockid</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Preds</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Succs</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>HasNoReturnElement</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>, <macro><name>Parent</name><argument_list>(<argument>parent</argument>)</argument_list></macro> <expr><block>{}</block>


<name>using</name> <name>iterator</name> <operator>=</operator> <name>ElementList</name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>const_iterator</name> <operator>=</operator> <name>ElementList</name><operator>::</operator><name>const_iterator</name></expr>;
<expr><name>using</name> <name>reverse_iterator</name> <operator>=</operator> <name>ElementList</name><operator>::</operator><name>reverse_iterator</name></expr>;
<expr><name>using</name> <name>const_reverse_iterator</name> <operator>=</operator> <name>ElementList</name><operator>::</operator><name>const_reverse_iterator</name></expr>;

<expr><name>size_t</name> <macro><name>getIndexInCFG</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>CFGElement</name> <macro><name>front</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Elements</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>CFGElement</name> <macro><name>back</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Elements</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Elements</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Elements</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Elements</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Elements</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>reverse_iterator</name> <macro><name>rbegin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Elements</name><operator>.</operator><name>rbegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>reverse_iterator</name> <macro><name>rend</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Elements</name><operator>.</operator><name>rend</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_reverse_iterator</name> <macro><name>rbegin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Elements</name><operator>.</operator><name>rbegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_reverse_iterator</name> <macro><name>rend</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Elements</name><operator>.</operator><name>rend</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>using</name> <name>CFGElementRef</name> <operator>=</operator> <name><name>ElementRefImpl</name><argument_list type="generic">&lt;<argument><expr><name>false</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>ConstCFGElementRef</name> <operator>=</operator> <name><name>ElementRefImpl</name><argument_list type="generic">&lt;<argument><expr><name>true</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>using</name> <name>ref_iterator</name> <operator>=</operator> <name><name>ElementRefIterator</name><argument_list type="generic">&lt;<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>ref_iterator_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>ref_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>const_ref_iterator</name> <operator>=</operator> <name><name>ElementRefIterator</name><argument_list type="generic">&lt;<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>const_ref_iterator_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_ref_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>using</name> <name>reverse_ref_iterator</name> <operator>=</operator> <name><name>ElementRefIterator</name><argument_list type="generic">&lt;<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>reverse_ref_iterator_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>reverse_ref_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>using</name> <name>const_reverse_ref_iterator</name> <operator>=</operator> <name><name>ElementRefIterator</name><argument_list type="generic">&lt;<argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>const_reverse_ref_iterator_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_reverse_ref_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>ref_iterator</name> <macro><name>ref_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><block>{<expr><name>this</name></expr>, <macro><name>begin</name><argument_list>()</argument_list></macro>}</block></expr>;</return> }</block>
<name>ref_iterator</name> <macro><name>ref_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><block>{<expr><name>this</name></expr>, <macro><name>end</name><argument_list>()</argument_list></macro>}</block></expr>;</return> }</block>
<name>const_ref_iterator</name> <macro><name>ref_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><block>{<expr><name>this</name></expr>, <macro><name>begin</name><argument_list>()</argument_list></macro>}</block></expr>;</return> }</block>
<name>const_ref_iterator</name> <macro><name>ref_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><block>{<expr><name>this</name></expr>, <macro><name>end</name><argument_list>()</argument_list></macro>}</block></expr>;</return> }</block>

<name>reverse_ref_iterator</name> <macro><name>rref_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><block>{<expr><name>this</name></expr>, <macro><name>rbegin</name><argument_list>()</argument_list></macro>}</block></expr>;</return> }</block>
<name>reverse_ref_iterator</name> <macro><name>rref_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><block>{<expr><name>this</name></expr>, <macro><name>rend</name><argument_list>()</argument_list></macro>}</block></expr>;</return> }</block>
<name>const_reverse_ref_iterator</name> <macro><name>rref_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><block>{<expr><name>this</name></expr>, <macro><name>rbegin</name><argument_list>()</argument_list></macro>}</block></expr>;</return> }</block>
<name>const_reverse_ref_iterator</name> <macro><name>rref_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><block>{<expr><name>this</name></expr>, <macro><name>rend</name><argument_list>()</argument_list></macro>}</block></expr>;</return> }</block>

<name>ref_iterator_range</name> <macro><name>refs</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><block>{<expr><call><name>ref_begin</name><argument_list>()</argument_list></call></expr>, <macro><name>ref_end</name><argument_list>()</argument_list></macro>}</block></expr>;</return> }</block>
<name>const_ref_iterator_range</name> <macro><name>refs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><block>{<expr><call><name>ref_begin</name><argument_list>()</argument_list></call></expr>, <macro><name>ref_end</name><argument_list>()</argument_list></macro>}</block></expr>;</return> }</block>
<name>reverse_ref_iterator_range</name> <macro><name>rrefs</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><block>{<expr><call><name>rref_begin</name><argument_list>()</argument_list></call></expr>, <macro><name>rref_end</name><argument_list>()</argument_list></macro>}</block></expr>;</return> }</block>
<name>const_reverse_ref_iterator_range</name> <macro><name>rrefs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><call><name>rref_begin</name><argument_list>()</argument_list></call></expr>, <macro><name>rref_end</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Elements</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Elements</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>CFGElement</name> <name><name>operator</name><index>[]</index></name><operator>(</operator><name>size_t</name> <name>i</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Elements</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return> }</block>


<name>using</name> <name>pred_iterator</name> <operator>=</operator> <name>AdjacentBlocks</name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>const_pred_iterator</name> <operator>=</operator> <name>AdjacentBlocks</name><operator>::</operator><name>const_iterator</name></expr>;
<expr><name>using</name> <name>pred_reverse_iterator</name> <operator>=</operator> <name>AdjacentBlocks</name><operator>::</operator><name>reverse_iterator</name></expr>;
<expr><name>using</name> <name>const_pred_reverse_iterator</name> <operator>=</operator> <name>AdjacentBlocks</name><operator>::</operator><name>const_reverse_iterator</name></expr>;
<expr><name>using</name> <name>pred_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>pred_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>pred_const_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_pred_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>using</name> <name>succ_iterator</name> <operator>=</operator> <name>AdjacentBlocks</name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>const_succ_iterator</name> <operator>=</operator> <name>AdjacentBlocks</name><operator>::</operator><name>const_iterator</name></expr>;
<expr><name>using</name> <name>succ_reverse_iterator</name> <operator>=</operator> <name>AdjacentBlocks</name><operator>::</operator><name>reverse_iterator</name></expr>;
<expr><name>using</name> <name>const_succ_reverse_iterator</name> <operator>=</operator> <name>AdjacentBlocks</name><operator>::</operator><name>const_reverse_iterator</name></expr>;
<expr><name>using</name> <name>succ_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>succ_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>succ_const_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_succ_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>pred_iterator</name> <macro><name>pred_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Preds</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>pred_iterator</name> <macro><name>pred_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Preds</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_pred_iterator</name> <macro><name>pred_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Preds</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_pred_iterator</name> <macro><name>pred_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Preds</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>pred_reverse_iterator</name> <macro><name>pred_rbegin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Preds</name><operator>.</operator><name>rbegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>pred_reverse_iterator</name> <macro><name>pred_rend</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Preds</name><operator>.</operator><name>rend</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_pred_reverse_iterator</name> <macro><name>pred_rbegin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Preds</name><operator>.</operator><name>rbegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_pred_reverse_iterator</name> <macro><name>pred_rend</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Preds</name><operator>.</operator><name>rend</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>pred_range</name> <macro><name>preds</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>pred_range</name><argument_list>(<argument><expr><call><name>pred_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>pred_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>pred_const_range</name> <macro><name>preds</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>pred_const_range</name><argument_list>(<argument><expr><call><name>pred_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>pred_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>succ_iterator</name> <macro><name>succ_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Succs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>succ_iterator</name> <macro><name>succ_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Succs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_succ_iterator</name> <macro><name>succ_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Succs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_succ_iterator</name> <macro><name>succ_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Succs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>succ_reverse_iterator</name> <macro><name>succ_rbegin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Succs</name><operator>.</operator><name>rbegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>succ_reverse_iterator</name> <macro><name>succ_rend</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Succs</name><operator>.</operator><name>rend</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_succ_reverse_iterator</name> <macro><name>succ_rbegin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Succs</name><operator>.</operator><name>rbegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_succ_reverse_iterator</name> <macro><name>succ_rend</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Succs</name><operator>.</operator><name>rend</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>succ_range</name> <macro><name>succs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>succ_range</name><argument_list>(<argument><expr><call><name>succ_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>succ_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>succ_const_range</name> <macro><name>succs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>succ_const_range</name><argument_list>(<argument><expr><call><name>succ_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>succ_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>succ_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Succs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>succ_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Succs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>unsigned</name> <macro><name>pred_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Preds</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>pred_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Preds</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>class</name> <name>FilterOptions</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>unsigned</name> <name>IgnoreNullPredecessors</name> <operator>:</operator> <literal type="number">1</literal></expr>;
<expr><name>unsigned</name> <name>IgnoreDefaultsWithCoveredEnums</name> <operator>:</operator> <literal type="number">1</literal></expr>;

<expr><call><name>FilterOptions</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>IgnoreNullPredecessors</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>, <macro><name>IgnoreDefaultsWithCoveredEnums</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro> <expr><block>{}</block></expr>
}</block></expr>;

<expr><specifier>static</specifier> <name>bool</name> <call><name>FilterEdge</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FilterOptions</name> <operator>&amp;</operator><name>F</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><name>Src</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><name>Dst</name></expr></argument>)</argument_list></call></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>IMPL</name></expr></argument>, <argument><expr><name>bool</name> <name>IsPred</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>FilteredCFGBlockIterator</name> <block>{
<expr><name>private</name><operator>:</operator>
<name>IMPL</name> <name>I</name></expr>, <expr><name>E</name></expr>;
<expr><specifier>const</specifier> <name>FilterOptions</name> <name>F</name></expr>;
<expr><specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><name>From</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>FilteredCFGBlockIterator</name><argument_list>(<argument><expr><specifier>const</specifier> <name>IMPL</name> <operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>IMPL</name> <operator>&amp;</operator><name>e</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><name>from</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FilterOptions</name> <operator>&amp;</operator><name>f</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>I</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>E</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>F</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>, <macro><name>From</name><argument_list>(<argument>from</argument>)</argument_list></macro> <expr><block>{
<while>while <condition>(<expr><call><name>hasMore</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>Filter</name><argument_list>(<argument><expr><operator>*</operator><name>I</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>I</name></expr>;</expr_stmt></block_content></block></while>
}</block>

<name>bool</name> <macro><name>hasMore</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>I</name> <operator>!=</operator> <name>E</name></expr>;</return> }</block>

<name>FilteredCFGBlockIterator</name> <operator>&amp;</operator><name>operator</name><operator>++</operator><operator>(</operator><operator>)</operator> <block>{
<do>do <block>{<block_content> <expr_stmt><expr><operator>++</operator><name>I</name></expr>;</expr_stmt> <expr_stmt/>}</block_content> while (hasMore(</block></do>) <operator>&amp;&amp;</operator> <call><name>Filter</name><argument_list>(<argument><expr><operator>*</operator><name>I</name></expr></argument>)</argument_list></call>)</block></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block>

<specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>I</name></expr>;</return> }</block>

<name>private</name><operator>:</operator>
<name>bool</name> <macro><name>Filter</name><argument_list>(<argument>const CFGBlock *To</argument>)</argument_list></macro> <block>{
<return>return <expr><name>IsPred</name> <operator>?</operator> <call><name>FilterEdge</name><argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><name>To</name></expr></argument>, <argument><expr><name>From</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>FilterEdge</name><argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><name>From</name></expr></argument>, <argument><expr><name>To</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name>using</name> <name>filtered_pred_iterator</name> <operator>=</operator>
<name><name>FilteredCFGBlockIterator</name><argument_list type="generic">&lt;<argument><expr><name>const_pred_iterator</name></expr></argument>, <argument><expr><name>true</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>using</name> <name>filtered_succ_iterator</name> <operator>=</operator>
<name><name>FilteredCFGBlockIterator</name><argument_list type="generic">&lt;<argument><expr><name>const_succ_iterator</name></expr></argument>, <argument><expr><name>false</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>filtered_pred_iterator</name> <macro><name>filtered_pred_start_end</name><argument_list>(<argument>const FilterOptions &amp;f</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>filtered_pred_iterator</name><argument_list>(<argument><expr><call><name>pred_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>pred_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>filtered_succ_iterator</name> <macro><name>filtered_succ_start_end</name><argument_list>(<argument>const FilterOptions &amp;f</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>filtered_succ_iterator</name><argument_list>(<argument><expr><call><name>succ_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>succ_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>void</name> <macro><name>setTerminator</name><argument_list>(<argument>CFGTerminator Term</argument>)</argument_list></macro> <block>{ <expr><name>Terminator</name> <operator>=</operator> <name>Term</name></expr>; }</block>
<name>void</name> <macro><name>setLabel</name><argument_list>(<argument>Stmt *Statement</argument>)</argument_list></macro> <block>{ <expr><name>Label</name> <operator>=</operator> <name>Statement</name></expr>; }</block>
<name>void</name> <macro><name>setLoopTarget</name><argument_list>(<argument>const Stmt *loopTarget</argument>)</argument_list></macro> <block>{ <expr><name>LoopTarget</name> <operator>=</operator> <name>loopTarget</name></expr>; }</block>
<name>void</name> <macro><name>setHasNoReturnElement</name><argument_list>()</argument_list></macro> <block>{ <expr><name>HasNoReturnElement</name> <operator>=</operator> <name>true</name></expr>; }</block>



<name>bool</name> <macro><name>isInevitablySinking</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>CFGTerminator</name> <macro><name>getTerminator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Terminator</name></expr>;</return> }</block>

<name>Stmt</name> <operator>*</operator><macro><name>getTerminatorStmt</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Terminator</name><operator>.</operator><name>getStmt</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getTerminatorStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Terminator</name><operator>.</operator><name>getStmt</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>







<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getLastCondition</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>Stmt</name> <operator>*</operator><macro><name>getTerminatorCondition</name><argument_list>(<argument>bool StripParens = true</argument>)</argument_list></macro></expr>;

<expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getTerminatorCondition</name><argument_list>(<argument>bool StripParens = true</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CFGBlock</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getTerminatorCondition</name><argument_list>(<argument><expr><name>StripParens</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getLoopTarget</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LoopTarget</name></expr>;</return> }</block>

<name>Stmt</name> <operator>*</operator><macro><name>getLabel</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Label</name></expr>;</return> }</block>
<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getLabel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Label</name></expr>;</return> }</block>

<name>bool</name> <macro><name>hasNoReturnElement</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasNoReturnElement</name></expr>;</return> }</block>

<name>unsigned</name> <macro><name>getBlockID</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BlockID</name></expr>;</return> }</block>

<name>CFG</name> <operator>*</operator><macro><name>getParent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Parent</name></expr>;</return> }</block>

<name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>void</name> <macro><name>dump</name><argument_list>(<argument>const CFG *cfg</argument>, <argument>const LangOptions &amp;LO</argument>, <argument>bool ShowColors = false</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <macro><name>print</name><argument_list>(<argument>raw_ostream &amp;OS</argument>, <argument>const CFG* cfg</argument>, <argument>const LangOptions &amp;LO</argument>,
<argument>bool ShowColors</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>void</name> <macro><name>printTerminator</name><argument_list>(<argument>raw_ostream &amp;OS</argument>, <argument>const LangOptions &amp;LO</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <macro><name>printTerminatorJson</name><argument_list>(<argument>raw_ostream &amp;Out</argument>, <argument>const LangOptions &amp;LO</argument>,
<argument>bool AddQuotes</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>void</name> <macro><name>printAsOperand</name><argument_list>(<argument>raw_ostream &amp;OS</argument>, <argument>bool</argument> )</argument_list></macro> <block>{
<expr><name>OS</name> <operator>&lt;&lt;</operator> <literal type="string">"BB#"</literal> <operator>&lt;&lt;</operator> <call><name>getBlockID</name><argument_list>()</argument_list></call></expr>;
}</block>


<name>void</name> <macro><name>addSuccessor</name><argument_list>(<argument>AdjacentBlock Succ</argument>, <argument>BumpVectorContext &amp;C</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <macro><name>appendStmt</name><argument_list>(<argument>Stmt *statement</argument>, <argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Elements</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CFGStmt</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>appendConstructor</name><argument_list>(<argument>CXXConstructExpr *CE</argument>, <argument>const ConstructionContext *CC</argument>,
<argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Elements</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CFGConstructor</name><argument_list>(<argument><expr><name>CE</name></expr></argument>, <argument><expr><name>CC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>appendCXXRecordTypedCall</name><argument_list>(<argument>Expr *E</argument>,
<argument>const ConstructionContext *CC</argument>,
<argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Elements</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CFGCXXRecordTypedCall</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>CC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>appendInitializer</name><argument_list>(<argument>CXXCtorInitializer *initializer</argument>,
<argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Elements</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CFGInitializer</name><argument_list>(<argument><expr><name>initializer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>appendNewAllocator</name><argument_list>(<argument>CXXNewExpr *NE</argument>,
<argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Elements</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CFGNewAllocator</name><argument_list>(<argument><expr><name>NE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>appendScopeBegin</name><argument_list>(<argument>const VarDecl *VD</argument>, <argument>const Stmt *S</argument>,
<argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Elements</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CFGScopeBegin</name><argument_list>(<argument><expr><name>VD</name></expr></argument>, <argument><expr><name>S</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>prependScopeBegin</name><argument_list>(<argument>const VarDecl *VD</argument>, <argument>const Stmt *S</argument>,
<argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Elements</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>Elements</name><operator>.</operator><name>rbegin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>CFGScopeBegin</name><argument_list>(<argument><expr><name>VD</name></expr></argument>, <argument><expr><name>S</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>appendScopeEnd</name><argument_list>(<argument>const VarDecl *VD</argument>, <argument>const Stmt *S</argument>, <argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Elements</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CFGScopeEnd</name><argument_list>(<argument><expr><name>VD</name></expr></argument>, <argument><expr><name>S</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>prependScopeEnd</name><argument_list>(<argument>const VarDecl *VD</argument>, <argument>const Stmt *S</argument>, <argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Elements</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>Elements</name><operator>.</operator><name>rbegin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>CFGScopeEnd</name><argument_list>(<argument><expr><name>VD</name></expr></argument>, <argument><expr><name>S</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>appendBaseDtor</name><argument_list>(<argument>const CXXBaseSpecifier *BS</argument>, <argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Elements</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CFGBaseDtor</name><argument_list>(<argument><expr><name>BS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>appendMemberDtor</name><argument_list>(<argument>FieldDecl *FD</argument>, <argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Elements</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CFGMemberDtor</name><argument_list>(<argument><expr><name>FD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>appendTemporaryDtor</name><argument_list>(<argument>CXXBindTemporaryExpr *E</argument>, <argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Elements</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CFGTemporaryDtor</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>appendAutomaticObjDtor</name><argument_list>(<argument>VarDecl *VD</argument>, <argument>Stmt *S</argument>, <argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Elements</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CFGAutomaticObjDtor</name><argument_list>(<argument><expr><name>VD</name></expr></argument>, <argument><expr><name>S</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>appendLifetimeEnds</name><argument_list>(<argument>VarDecl *VD</argument>, <argument>Stmt *S</argument>, <argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Elements</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CFGLifetimeEnds</name><argument_list>(<argument><expr><name>VD</name></expr></argument>, <argument><expr><name>S</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>appendLoopExit</name><argument_list>(<argument>const Stmt *LoopStmt</argument>, <argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Elements</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CFGLoopExit</name><argument_list>(<argument><expr><name>LoopStmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>appendDeleteDtor</name><argument_list>(<argument>CXXRecordDecl *RD</argument>, <argument>CXXDeleteExpr *DE</argument>, <argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Elements</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CFGDeleteDtor</name><argument_list>(<argument><expr><name>RD</name></expr></argument>, <argument><expr><name>DE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
}</block>




<name>iterator</name> <macro><name>beginAutomaticObjDtorsInsert</name><argument_list>(<argument>iterator I</argument>, <argument>size_t Cnt</argument>,
<argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>iterator</name><argument_list>(<argument><expr><call><name><name>Elements</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>I</name><operator>.</operator><name>base</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Cnt</name></expr></argument>,
<argument><expr><call><name>CFGAutomaticObjDtor</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>iterator</name> <macro><name>insertAutomaticObjDtor</name><argument_list>(<argument>iterator I</argument>, <argument>VarDecl *VD</argument>, <argument>Stmt *S</argument>)</argument_list></macro> <block>{
<expr><operator>*</operator><name>I</name> <operator>=</operator> <call><name>CFGAutomaticObjDtor</name><argument_list>(<argument><expr><name>VD</name></expr></argument>, <argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>++</operator><name>I</name></expr>;</return>
}</block>




<name>iterator</name> <macro><name>beginLifetimeEndsInsert</name><argument_list>(<argument>iterator I</argument>, <argument>size_t Cnt</argument>,
<argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>iterator</name><argument_list>(
<argument><expr><call><name><name>Elements</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>I</name><operator>.</operator><name>base</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Cnt</name></expr></argument>, <argument><expr><call><name>CFGLifetimeEnds</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>iterator</name> <macro><name>insertLifetimeEnds</name><argument_list>(<argument>iterator I</argument>, <argument>VarDecl *VD</argument>, <argument>Stmt *S</argument>)</argument_list></macro> <block>{
<expr><operator>*</operator><name>I</name> <operator>=</operator> <call><name>CFGLifetimeEnds</name><argument_list>(<argument><expr><name>VD</name></expr></argument>, <argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>++</operator><name>I</name></expr>;</return>
}</block>




<name>iterator</name> <macro><name>beginScopeEndInsert</name><argument_list>(<argument>iterator I</argument>, <argument>size_t Cnt</argument>, <argument>BumpVectorContext &amp;C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>iterator</name><argument_list>(
<argument><expr><call><name><name>Elements</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>I</name><operator>.</operator><name>base</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Cnt</name></expr></argument>, <argument><expr><call><name>CFGScopeEnd</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>iterator</name> <macro><name>insertScopeEnd</name><argument_list>(<argument>iterator I</argument>, <argument>VarDecl *VD</argument>, <argument>Stmt *S</argument>)</argument_list></macro> <block>{
<expr><operator>*</operator><name>I</name> <operator>=</operator> <call><name>CFGScopeEnd</name><argument_list>(<argument><expr><name>VD</name></expr></argument>, <argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>++</operator><name>I</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>CFGCallback</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>CFGCallback</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><name>virtual</name> <operator>~</operator><call><name>CFGCallback</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>virtual</name> <name>void</name> <macro><name>compareAlwaysTrue</name><argument_list>(<argument>const BinaryOperator *B</argument>, <argument>bool isAlwaysTrue</argument>)</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>void</name> <macro><name>compareBitwiseEquality</name><argument_list>(<argument>const BinaryOperator *B</argument>,
<argument>bool isAlwaysTrue</argument>)</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>void</name> <macro><name>compareBitwiseOr</name><argument_list>(<argument>const BinaryOperator *B</argument>)</argument_list></macro> <block>{}</block></expr>
}</block></expr>;








<expr><name>class</name> <name>CFG</name> <block>{
<expr><name>public</name><operator>:</operator>




<name>class</name> <name>BuildOptions</name> <block>{
<expr><name>std</name><operator>::</operator><name><name>bitset</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name><operator>::</operator><name>lastStmtConstant</name></expr></argument>&gt;</argument_list></name> <name>alwaysAddMask</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>using</name> <name>ForcedBlkExprs</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>ForcedBlkExprs</name> <operator>*</operator><operator>*</operator><name>forcedBlkExprs</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>CFGCallback</name> <operator>*</operator><name>Observer</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>bool</name> <name>PruneTriviallyFalseEdges</name> <operator>=</operator> <name>true</name></expr>;
<expr><name>bool</name> <name>AddEHEdges</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>AddInitializers</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>AddImplicitDtors</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>AddLifetime</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>AddLoopExit</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>AddTemporaryDtors</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>AddScopes</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>AddStaticInitBranches</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>AddCXXNewAllocator</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>AddCXXDefaultInitExprInCtors</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>AddCXXDefaultInitExprInAggregates</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>AddRichCXXConstructors</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>MarkElidedCXXConstructors</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>AddVirtualBaseBranches</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>OmitImplicitValueInitializers</name> <operator>=</operator> <name>false</name></expr>;

<expr><call><name>BuildOptions</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>bool</name> <macro><name>alwaysAdd</name><argument_list>(<argument>const Stmt *stmt</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>alwaysAddMask</name><index>[<expr><call><name><name>stmt</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</return>
}</block>

<name>BuildOptions</name> <operator>&amp;</operator><macro><name>setAlwaysAdd</name><argument_list>(<argument>Stmt::StmtClass stmtClass</argument>, <argument>bool val = true</argument>)</argument_list></macro> <block>{
<expr><name><name>alwaysAddMask</name><index>[<expr><name>stmtClass</name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block>

<name>BuildOptions</name> <operator>&amp;</operator><macro><name>setAllAlwaysAdd</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name><name>alwaysAddMask</name><operator>.</operator><name>set</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block>
}</expr>;


<expr><specifier>static</specifier> <name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CFG</name></expr></argument>&gt;</argument_list></name> <call><name>buildCFG</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator><name>AST</name></expr></argument>, <argument><expr><name>ASTContext</name> <operator>*</operator><name>C</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>BuildOptions</name> <operator>&amp;</operator><name>BO</name></expr></argument>)</argument_list></call></expr>;



<expr><name>CFGBlock</name> <operator>*</operator><call><name>createBlock</name><argument_list>()</argument_list></call></expr>;




<expr><name>void</name> <macro><name>setEntry</name><argument_list>(<argument>CFGBlock *B</argument>)</argument_list></macro> <block>{ <expr><name>Entry</name> <operator>=</operator> <name>B</name></expr>; }</block>



<name>void</name> <macro><name>setIndirectGotoBlock</name><argument_list>(<argument>CFGBlock *B</argument>)</argument_list></macro> <block>{ <expr><name>IndirectGotoBlock</name> <operator>=</operator> <name>B</name></expr>; }</block>





<name>using</name> <name>CFGBlockListTy</name> <operator>=</operator> <name><name>BumpVector</name><argument_list type="generic">&lt;<argument><expr><name>CFGBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>iterator</name> <operator>=</operator> <name>CFGBlockListTy</name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>const_iterator</name> <operator>=</operator> <name>CFGBlockListTy</name><operator>::</operator><name>const_iterator</name></expr>;
<expr><name>using</name> <name>reverse_iterator</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>reverse_iterator</name><argument_list type="generic">&lt;<argument><expr><name>iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>const_reverse_iterator</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>reverse_iterator</name><argument_list type="generic">&lt;<argument><expr><name>const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>CFGBlock</name> <operator>&amp;</operator> <macro><name>front</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><operator>*</operator><call><name><name>Blocks</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>CFGBlock</name> <operator>&amp;</operator> <macro><name>back</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><operator>*</operator><call><name><name>Blocks</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Blocks</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Blocks</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Blocks</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Blocks</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>iterator</name> <macro><name>nodes_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>iterator</name><argument_list>(<argument><expr><call><name><name>Blocks</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>iterator</name> <macro><name>nodes_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>iterator</name><argument_list>(<argument><expr><call><name><name>Blocks</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>iterator</name></expr></argument>&gt;</argument_list></name> <macro><name>nodes</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><block>{<expr><call><name>begin</name><argument_list>()</argument_list></call></expr>, <macro><name>end</name><argument_list>()</argument_list></macro>}</block></expr>;</return> }</block>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_iterator</name></expr></argument>&gt;</argument_list></name> <macro><name>const_nodes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><call><name>begin</name><argument_list>()</argument_list></call></expr>, <macro><name>end</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block>

<name>const_iterator</name> <macro><name>nodes_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>const_iterator</name><argument_list>(<argument><expr><call><name><name>Blocks</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>const_iterator</name> <macro><name>nodes_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>const_iterator</name><argument_list>(<argument><expr><call><name><name>Blocks</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>reverse_iterator</name> <macro><name>rbegin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Blocks</name><operator>.</operator><name>rbegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>reverse_iterator</name> <macro><name>rend</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Blocks</name><operator>.</operator><name>rend</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_reverse_iterator</name> <macro><name>rbegin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Blocks</name><operator>.</operator><name>rbegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_reverse_iterator</name> <macro><name>rend</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Blocks</name><operator>.</operator><name>rend</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>reverse_iterator</name></expr></argument>&gt;</argument_list></name> <macro><name>reverse_nodes</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><block>{<expr><call><name>rbegin</name><argument_list>()</argument_list></call></expr>, <macro><name>rend</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_reverse_iterator</name></expr></argument>&gt;</argument_list></name> <macro><name>const_reverse_nodes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><call><name>rbegin</name><argument_list>()</argument_list></call></expr>, <macro><name>rend</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block>

<name>CFGBlock</name> <operator>&amp;</operator> <macro><name>getEntry</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><operator>*</operator><name>Entry</name></expr>;</return> }</block>
<specifier>const</specifier> <name>CFGBlock</name> <operator>&amp;</operator> <macro><name>getEntry</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>Entry</name></expr>;</return> }</block>
<name>CFGBlock</name> <operator>&amp;</operator> <macro><name>getExit</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><operator>*</operator><name>Exit</name></expr>;</return> }</block>
<specifier>const</specifier> <name>CFGBlock</name> <operator>&amp;</operator> <macro><name>getExit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>Exit</name></expr>;</return> }</block>

<name>CFGBlock</name> <operator>*</operator> <macro><name>getIndirectGotoBlock</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>IndirectGotoBlock</name></expr>;</return> }</block>
<specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator> <macro><name>getIndirectGotoBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IndirectGotoBlock</name></expr>;</return> }</block>

<name>using</name> <name>try_block_iterator</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name></expr>;

<expr><name>try_block_iterator</name> <macro><name>try_blocks_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>TryDispatchBlocks</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>try_block_iterator</name> <macro><name>try_blocks_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>TryDispatchBlocks</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>addTryDispatchBlock</name><argument_list>(<argument>const CFGBlock *block</argument>)</argument_list></macro> <block>{
<expr><call><name><name>TryDispatchBlocks</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;
}</block>





<name>void</name> <macro><name>addSyntheticDeclStmt</name><argument_list>(<argument>const DeclStmt *Synthetic</argument>,
<argument>const DeclStmt *Source</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Synthetic</name><operator>-&gt;</operator><name>isSingleDecl</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Can handle single declarations only"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Synthetic</name> <operator>!=</operator> <name>Source</name> <operator>&amp;&amp;</operator> <literal type="string">"Don't include original DeclStmts in map"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>SyntheticDeclStmts</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>Synthetic</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Already in map"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>SyntheticDeclStmts</name><index>[<expr><name>Synthetic</name></expr>]</index></name> <operator>=</operator> <name>Source</name></expr>;
}</block>

<name>using</name> <name>synthetic_stmt_iterator</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>DeclStmt</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>DeclStmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name></expr>;
<expr><name>using</name> <name>synthetic_stmt_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>synthetic_stmt_iterator</name></expr></argument>&gt;</argument_list></name></expr>;






<expr><name>synthetic_stmt_iterator</name> <macro><name>synthetic_stmt_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>SyntheticDeclStmts</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>synthetic_stmt_iterator</name> <macro><name>synthetic_stmt_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>SyntheticDeclStmts</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>synthetic_stmt_range</name> <macro><name>synthetic_stmts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>synthetic_stmt_range</name><argument_list>(<argument><expr><call><name>synthetic_stmt_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>synthetic_stmt_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Callback</name></expr></argument>&gt;</argument_list></name> <name>void</name> <macro><name>VisitBlockStmts</name><argument_list>(<argument>Callback &amp;O</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<for>for <control>(<init><decl><type><name>const_iterator</name></type> <name>I</name> <init>= <expr><call><name>begin</name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>E</name> <init>= <expr><call><name>end</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>E</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>CFGBlock</name><operator>::</operator><name>const_iterator</name> <name>BI</name> <operator>=</operator> <call><name><operator>(</operator><operator>*</operator><name>I</name><operator>)</operator><operator>-&gt;</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>, <expr><name>BE</name> <operator>=</operator> <call><name><operator>(</operator><operator>*</operator><name>I</name><operator>)</operator><operator>-&gt;</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>BI</name> <operator>!=</operator> <name>BE</name></expr>;</condition> <incr><expr><operator>++</operator><name>BI</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>CFGStmt</name></expr></argument>&gt;</argument_list></name></type> <name>stmt</name> <init>= <expr><name><name>BI</name><operator>-&gt;</operator><name>getAs</name></name><operator>&lt;</operator><name>CFGStmt</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>O</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>stmt</name><operator>-&gt;</operator><name>getStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt/>}</block_content>
}






unsigned getNumBlockIDs(</block></for></block_content></block></for>) <specifier>const</specifier> <block>{ <return>return <expr><name>NumBlockIDs</name></expr>;</return> }</block></block>




<name>unsigned</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumBlockIDs</name></expr>;</return> }</block>





<name>bool</name> <macro><name>isLinear</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;





<expr><name>void</name> <macro><name>viewCFG</name><argument_list>(<argument>const LangOptions &amp;LO</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <macro><name>print</name><argument_list>(<argument>raw_ostream &amp;OS</argument>, <argument>const LangOptions &amp;LO</argument>, <argument>bool ShowColors</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <macro><name>dump</name><argument_list>(<argument>const LangOptions &amp;LO</argument>, <argument>bool ShowColors</argument>)</argument_list></macro> <specifier>const</specifier></expr>;





<expr><call><name>CFG</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Blocks</name><argument_list>(<argument>BlkBVC</argument>, <argument><literal type="number">10</literal></argument>)</argument_list></macro> <block>{}</block>

<name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name><operator>&amp;</operator> <macro><name>getAllocator</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>BlkBVC</name><operator>.</operator><name>getAllocator</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>BumpVectorContext</name> <operator>&amp;</operator><macro><name>getBumpVectorContext</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>BlkBVC</name></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>CFGBlock</name> <operator>*</operator><name>Entry</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>CFGBlock</name> <operator>*</operator><name>Exit</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>CFGBlock</name><operator>*</operator> <name>IndirectGotoBlock</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>unsigned</name> <name>NumBlockIDs</name> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>BumpVectorContext</name> <name>BlkBVC</name></expr>;

<expr><name>CFGBlockListTy</name> <name>Blocks</name></expr>;



<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>TryDispatchBlocks</name></expr>;



<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>DeclStmt</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>DeclStmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>SyntheticDeclStmts</name></expr>;
}</block></expr>;

}</block>





<name>namespace</name> <name>llvm</name> <block>{



<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>simplify_type</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>CFGTerminator</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>using</name> <name>SimpleType</name> <operator>=</operator> <operator>::</operator><name>clang</name><operator>::</operator><name>Stmt</name> <operator>*</operator></expr>;

<expr><specifier>static</specifier> <name>SimpleType</name> <macro><name>getSimplifiedValue</name><argument_list>(<argument>::clang::CFGTerminator Val</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Val</name><operator>.</operator><name>getStmt</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>GraphTraits</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>CFGBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>using</name> <name>NodeRef</name> <operator>=</operator> <operator>::</operator><name>clang</name><operator>::</operator><name>CFGBlock</name> <operator>*</operator></expr>;
<expr><name>using</name> <name>ChildIteratorType</name> <operator>=</operator> <operator>::</operator><name>clang</name><operator>::</operator><name>CFGBlock</name><operator>::</operator><name>succ_iterator</name></expr>;

<expr><specifier>static</specifier> <name>NodeRef</name> <macro><name>getEntryNode</name><argument_list>(<argument>::clang::CFGBlock *BB</argument>)</argument_list></macro> <block>{ <return>return <expr><name>BB</name></expr>;</return> }</block>
<specifier>static</specifier> <name>ChildIteratorType</name> <macro><name>child_begin</name><argument_list>(<argument>NodeRef N</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>N</name><operator>-&gt;</operator><name>succ_begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>ChildIteratorType</name> <macro><name>child_end</name><argument_list>(<argument>NodeRef N</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>N</name><operator>-&gt;</operator><name>succ_end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>GraphTraits</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>CFGBlock</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name><name>GraphTraits</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>CFGBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>GraphTraits</name><argument_list type="generic">&lt; <argument><expr><specifier>const</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>CFGBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>using</name> <name>NodeRef</name> <operator>=</operator> <specifier>const</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>CFGBlock</name> <operator>*</operator></expr>;
<expr><name>using</name> <name>ChildIteratorType</name> <operator>=</operator> <operator>::</operator><name>clang</name><operator>::</operator><name>CFGBlock</name><operator>::</operator><name>const_succ_iterator</name></expr>;

<expr><specifier>static</specifier> <name>NodeRef</name> <macro><name>getEntryNode</name><argument_list>(<argument>const clang::CFGBlock *BB</argument>)</argument_list></macro> <block>{ <return>return <expr><name>BB</name></expr>;</return> }</block>
<specifier>static</specifier> <name>ChildIteratorType</name> <macro><name>child_begin</name><argument_list>(<argument>NodeRef N</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>N</name><operator>-&gt;</operator><name>succ_begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>ChildIteratorType</name> <macro><name>child_end</name><argument_list>(<argument>NodeRef N</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>N</name><operator>-&gt;</operator><name>succ_end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>GraphTraits</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>clang</name><operator>::</operator><name>CFGBlock</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name><name>GraphTraits</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>CFGBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>GraphTraits</name><argument_list type="generic">&lt;<argument><expr><name><name>Inverse</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>CFGBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>using</name> <name>NodeRef</name> <operator>=</operator> <operator>::</operator><name>clang</name><operator>::</operator><name>CFGBlock</name> <operator>*</operator></expr>;
<expr><name>using</name> <name>ChildIteratorType</name> <operator>=</operator> <operator>::</operator><name>clang</name><operator>::</operator><name>CFGBlock</name><operator>::</operator><name>const_pred_iterator</name></expr>;

<expr><specifier>static</specifier> <name>NodeRef</name> <macro><name>getEntryNode</name><argument_list>(<argument>Inverse&lt;::clang::CFGBlock *&gt; G</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>G</name><operator>.</operator><name>Graph</name></name></expr>;</return>
}</block>

<specifier>static</specifier> <name>ChildIteratorType</name> <macro><name>child_begin</name><argument_list>(<argument>NodeRef N</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>N</name><operator>-&gt;</operator><name>pred_begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>ChildIteratorType</name> <macro><name>child_end</name><argument_list>(<argument>NodeRef N</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>N</name><operator>-&gt;</operator><name>pred_end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>GraphTraits</name><argument_list type="generic">&lt;<argument><expr><name><name>Inverse</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>CFGBlock</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name><name>GraphTraits</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>CFGBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>GraphTraits</name><argument_list type="generic">&lt;<argument><expr><name><name>Inverse</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>CFGBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>using</name> <name>NodeRef</name> <operator>=</operator> <specifier>const</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>CFGBlock</name> <operator>*</operator></expr>;
<expr><name>using</name> <name>ChildIteratorType</name> <operator>=</operator> <operator>::</operator><name>clang</name><operator>::</operator><name>CFGBlock</name><operator>::</operator><name>const_pred_iterator</name></expr>;

<expr><specifier>static</specifier> <name>NodeRef</name> <macro><name>getEntryNode</name><argument_list>(<argument>Inverse&lt;const ::clang::CFGBlock *&gt; G</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>G</name><operator>.</operator><name>Graph</name></name></expr>;</return>
}</block>

<specifier>static</specifier> <name>ChildIteratorType</name> <macro><name>child_begin</name><argument_list>(<argument>NodeRef N</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>N</name><operator>-&gt;</operator><name>pred_begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>ChildIteratorType</name> <macro><name>child_end</name><argument_list>(<argument>NodeRef N</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>N</name><operator>-&gt;</operator><name>pred_end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>GraphTraits</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name><name>Inverse</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>CFGBlock</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name><name>GraphTraits</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>CFGBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>GraphTraits</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>CFG</name><operator>*</operator></expr></argument> &gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name><name>GraphTraits</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>CFGBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>using</name> <name>nodes_iterator</name> <operator>=</operator> <operator>::</operator><name>clang</name><operator>::</operator><name>CFG</name><operator>::</operator><name>iterator</name></expr>;

<expr><specifier>static</specifier> <name>NodeRef</name> <macro><name>getEntryNode</name><argument_list>(<argument>::clang::CFG *F</argument>)</argument_list></macro> <block>{ <return>return <expr><operator>&amp;</operator><call><name><name>F</name><operator>-&gt;</operator><name>getEntry</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>nodes_iterator</name> <macro><name>nodes_begin</name><argument_list>(<argument>::clang::CFG* F</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>F</name><operator>-&gt;</operator><name>nodes_begin</name></name><argument_list>()</argument_list></call></expr>;</return>}</block>
<specifier>static</specifier> <name>nodes_iterator</name> <macro><name>nodes_end</name><argument_list>(<argument>::clang::CFG* F</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>F</name><operator>-&gt;</operator><name>nodes_end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>unsigned</name> <macro><name>size</name><argument_list>(<argument>::clang::CFG* F</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>F</name><operator>-&gt;</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>GraphTraits</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>CFG</name><operator>*</operator></expr></argument> &gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name><name>GraphTraits</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>CFGBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>using</name> <name>nodes_iterator</name> <operator>=</operator> <operator>::</operator><name>clang</name><operator>::</operator><name>CFG</name><operator>::</operator><name>const_iterator</name></expr>;

<expr><specifier>static</specifier> <name>NodeRef</name> <macro><name>getEntryNode</name><argument_list>(<argument>const ::clang::CFG *F</argument>)</argument_list></macro> <block>{ <return>return <expr><operator>&amp;</operator><call><name><name>F</name><operator>-&gt;</operator><name>getEntry</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>nodes_iterator</name> <macro><name>nodes_begin</name><argument_list>( <argument>const ::clang::CFG* F</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>F</name><operator>-&gt;</operator><name>nodes_begin</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>nodes_iterator</name> <macro><name>nodes_end</name><argument_list>( <argument>const ::clang::CFG* F</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>F</name><operator>-&gt;</operator><name>nodes_end</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>unsigned</name> <macro><name>size</name><argument_list>(<argument>const ::clang::CFG* F</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>F</name><operator>-&gt;</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>GraphTraits</name><argument_list type="generic">&lt;<argument><expr><name><name>Inverse</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>CFG</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name><name>GraphTraits</name><argument_list type="generic">&lt;<argument><expr><name><name>Inverse</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>CFGBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>using</name> <name>nodes_iterator</name> <operator>=</operator> <operator>::</operator><name>clang</name><operator>::</operator><name>CFG</name><operator>::</operator><name>iterator</name></expr>;

<expr><specifier>static</specifier> <name>NodeRef</name> <macro><name>getEntryNode</name><argument_list>(<argument>::clang::CFG *F</argument>)</argument_list></macro> <block>{ <return>return <expr><operator>&amp;</operator><call><name><name>F</name><operator>-&gt;</operator><name>getExit</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>nodes_iterator</name> <macro><name>nodes_begin</name><argument_list>( <argument>::clang::CFG* F</argument>)</argument_list></macro> <block>{<return>return <expr><call><name><name>F</name><operator>-&gt;</operator><name>nodes_begin</name></name><argument_list>()</argument_list></call></expr>;</return>}</block>
<specifier>static</specifier> <name>nodes_iterator</name> <macro><name>nodes_end</name><argument_list>( <argument>::clang::CFG* F</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>F</name><operator>-&gt;</operator><name>nodes_end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>GraphTraits</name><argument_list type="generic">&lt;<argument><expr><name><name>Inverse</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>CFG</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name><name>GraphTraits</name><argument_list type="generic">&lt;<argument><expr><name><name>Inverse</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>CFGBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>using</name> <name>nodes_iterator</name> <operator>=</operator> <operator>::</operator><name>clang</name><operator>::</operator><name>CFG</name><operator>::</operator><name>const_iterator</name></expr>;

<expr><specifier>static</specifier> <name>NodeRef</name> <macro><name>getEntryNode</name><argument_list>(<argument>const ::clang::CFG *F</argument>)</argument_list></macro> <block>{ <return>return <expr><operator>&amp;</operator><call><name><name>F</name><operator>-&gt;</operator><name>getExit</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>nodes_iterator</name> <macro><name>nodes_begin</name><argument_list>(<argument>const ::clang::CFG* F</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>F</name><operator>-&gt;</operator><name>nodes_begin</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>nodes_iterator</name> <macro><name>nodes_end</name><argument_list>(<argument>const ::clang::CFG* F</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>F</name><operator>-&gt;</operator><name>nodes_end</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;

}</block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></range></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
