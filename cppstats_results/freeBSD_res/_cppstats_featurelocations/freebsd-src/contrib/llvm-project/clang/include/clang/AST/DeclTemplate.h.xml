<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/DeclTemplate.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_DECLTEMPLATE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_DECLTEMPLATE_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTConcept.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclBase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclarationName.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Redeclarable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TemplateBase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Specifiers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/FoldingSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerIntPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerUnion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/TrailingObjects.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iterator&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<enum_decl>enum <name>BuiltinTemplateKind</name> : <type><name>int</name></type>;</enum_decl>
<decl_stmt><decl><type><name>class</name></type> <name>ClassTemplateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ClassTemplatePartialSpecializationDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionTemplateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>IdentifierInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>NonTypeTemplateParmDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateTemplateParmDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateTypeParmDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ConceptDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UnresolvedSetImpl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VarTemplateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VarTemplatePartialSpecializationDecl</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>TemplateParameter</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>TemplateTypeParmDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>NonTypeTemplateParmDecl</name> <operator>*</operator></expr></argument>,
<argument><expr><name>TemplateTemplateParmDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>getAsNamedDecl</name><parameter_list>(<parameter><decl><type><name>TemplateParameter</name></type> <name>P</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>class</name> <name>TemplateParameterList</name></type> <name>final</name>
<range>: <expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TemplateParameterList</name></expr></argument>, <argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{

<expr><name>SourceLocation</name> <name>TemplateLoc</name></expr>;


<expr><name>SourceLocation</name> <name>LAngleLoc</name></expr>, <expr><name>RAngleLoc</name></expr>;



<expr><name>unsigned</name> <name>NumParams</name> <operator>:</operator> <literal type="number">29</literal></expr>;



<expr><name>unsigned</name> <name>ContainsUnexpandedParameterPack</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>unsigned</name> <name>HasRequiresClause</name> <operator>:</operator> <literal type="number">1</literal></expr>;



<expr><name>unsigned</name> <name>HasConstrainedParameters</name> <operator>:</operator> <literal type="number">1</literal></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>TemplateParameterList</name><argument_list>(<argument>const ASTContext&amp; C</argument>, <argument>SourceLocation TemplateLoc</argument>,
<argument>SourceLocation LAngleLoc</argument>, <argument>ArrayRef&lt;NamedDecl *&gt; Params</argument>,
<argument>SourceLocation RAngleLoc</argument>, <argument>Expr *RequiresClause</argument>)</argument_list></macro></expr>;

<expr><name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;NamedDecl *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumParams</name></expr>;</return>
}</block>

<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;Expr *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>HasRequiresClause</name> <operator>?</operator> <literal type="number">1</literal> <operator>:</operator> <literal type="number">0</literal></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>size_t</name> <name>N</name></expr></argument>, <argument><expr><name>bool</name> <name>HasRequiresClause</name></expr></argument>&gt;</argument_list></name>
<name>friend</name> <name>class</name> <name>FixedSizeTemplateParameterListStorage</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;

<expr><specifier>static</specifier> <name>TemplateParameterList</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>SourceLocation TemplateLoc</argument>,
<argument>SourceLocation LAngleLoc</argument>,
<argument>ArrayRef&lt;NamedDecl *&gt; Params</argument>,
<argument>SourceLocation RAngleLoc</argument>,
<argument>Expr *RequiresClause</argument>)</argument_list></macro></expr>;


<expr><name>using</name> <name>iterator</name> <operator>=</operator> <name>NamedDecl</name> <operator>*</operator><operator>*</operator></expr>;


<expr><name>using</name> <name>const_iterator</name> <operator>=</operator> <name>NamedDecl</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator></expr>;

<expr><name>iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>begin</name><argument_list>()</argument_list></call> <operator>+</operator> <name>NumParams</name></expr>;</return> }</block>
<name>const_iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>begin</name><argument_list>()</argument_list></call> <operator>+</operator> <name>NumParams</name></expr>;</return> }</block>

<name>unsigned</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumParams</name></expr>;</return> }</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>asArray</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>NamedDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>asArray</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>NamedDecl</name><operator>*</operator> <macro><name>getParam</name><argument_list>(<argument>unsigned Idx</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Idx</name> <operator>&lt;</operator> <call><name>size</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Template parameter index out-of-range"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>begin</name><argument_list>()</argument_list></call><index>[<expr><name>Idx</name></expr>]</index></expr>;</return>
}</block>
<specifier>const</specifier> <name>NamedDecl</name><operator>*</operator> <macro><name>getParam</name><argument_list>(<argument>unsigned Idx</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Idx</name> <operator>&lt;</operator> <call><name>size</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Template parameter index out-of-range"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>begin</name><argument_list>()</argument_list></call><index>[<expr><name>Idx</name></expr>]</index></expr>;</return>
}</block>






<name>unsigned</name> <macro><name>getMinRequiredArguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;






<expr><name>unsigned</name> <macro><name>getDepth</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>containsUnexpandedParameterPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>hasParameterPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>P</name> <range>: <expr><call><name>asArray</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>P</name><operator>-&gt;</operator><name>isParameterPack</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>


<function><type><name>Expr</name> <modifier>*</modifier></type><name>getRequiresClause</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><name>HasRequiresClause</name></expr> ?</condition><then> <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr> </then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getRequiresClause</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>HasRequiresClause</name> <operator>?</operator> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>:</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>







<decl_stmt><decl><type><name>void</name></type> <name>getAssociatedConstraints</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>AC</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasAssociatedConstraints</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getTemplateLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TemplateLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getLAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LAngleLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getRAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RAngleLoc</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>TemplateLoc</name></expr></argument>, <argument><expr><name>RAngleLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>print</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>Out</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>,
<argument><expr><name>bool</name> <name>OmitTemplateKW</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>print</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>Out</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>Policy</name></expr></argument>, <argument><expr><name>bool</name> <name>OmitTemplateKW</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>shouldIncludeTypeForArgument</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateParameterList</name> <modifier>*</modifier></type><name>TPL</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Idx</name></decl></parameter>)</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>size_t</name> <name>N</name></expr></argument>, <argument><expr><name>bool</name> <name>HasRequiresClause</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>FixedSizeTemplateParameterListStorage</name>
<range>: <expr><name>public</name> <name>TemplateParameterList</name><operator>::</operator><name>FixedSizeStorageOwner</name> <block>{
<expr><name>typename</name> <name>TemplateParameterList</name><operator>::</operator><name><name>FixedSizeStorage</name><argument_list type="generic">&lt;
<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>with_counts</name><operator>&lt;</operator>
<name>N</name></expr>, <expr><name>HasRequiresClause</name> <operator>?</operator> <literal type="number">1u</literal> <operator>:</operator> <literal type="number">0u</literal>
<operator>&gt;</operator><operator>::</operator><name>type</name> <name>storage</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>FixedSizeTemplateParameterListStorage</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>SourceLocation TemplateLoc</argument>,
<argument>SourceLocation LAngleLoc</argument>,
<argument>ArrayRef&lt;NamedDecl *&gt; Params</argument>,
<argument>SourceLocation RAngleLoc</argument>,
<argument>Expr *RequiresClause</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>FixedSizeStorageOwner</name><argument_list>(
<argument>(assert(N == Params.size()),
assert(HasRequiresClause == (RequiresClause != nullptr)),
new (static_cast&lt;void *&gt;(&amp;storage)) TemplateParameterList(C,
TemplateLoc, LAngleLoc, Params, RAngleLoc, RequiresClause))</argument>)</argument_list></macro> <block>{}</block></expr>
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>TemplateArgumentList</name></type> <name>final</name>
<range>: <expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentList</name></expr></argument>, <argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <block>{

<expr><specifier>const</specifier> <name>TemplateArgument</name> <operator>*</operator><name>Arguments</name></expr>;



<expr><name>unsigned</name> <name>NumArguments</name></expr>;



<expr><call><name>TemplateArgumentList</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>TrailingObjects</name></expr>;

<expr><call><name>TemplateArgumentList</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TemplateArgumentList</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><name>TemplateArgumentList</name> <operator>&amp;</operator><name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>TemplateArgumentList</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr>;



enum <expr><name>OnStackType</name> <block>{ <expr><name>OnStack</name></expr> }</block></expr>;



<expr><specifier>static</specifier> <name>TemplateArgumentList</name> <operator>*</operator><call><name>CreateCopy</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>)</argument_list></call></expr>;





<expr><name>explicit</name> <call><name>TemplateArgumentList</name><argument_list>(<argument><expr><name>OnStackType</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Arguments</name><argument_list>(<argument><expr><call><name><name>Args</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>, <macro><name>NumArguments</name><argument_list>(<argument>Args.size()</argument>)</argument_list></macro> <expr><block>{}</block>







<name>explicit</name> <call><name>TemplateArgumentList</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TemplateArgumentList</name> <operator>*</operator><name>Other</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Arguments</name><argument_list>(<argument><expr><call><name><name>Other</name><operator>-&gt;</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>, <macro><name>NumArguments</name><argument_list>(<argument>Other-&gt;size()</argument>)</argument_list></macro> <expr><block>{}</block>


<specifier>const</specifier> <name>TemplateArgument</name> <operator>&amp;</operator><macro><name>get</name><argument_list>(<argument>unsigned Idx</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Idx</name> <operator>&lt;</operator> <name>NumArguments</name> <operator>&amp;&amp;</operator> <literal type="string">"Invalid template argument index"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><index>[<expr><name>Idx</name></expr>]</index></expr>;</return>
}</block>


<specifier>const</specifier> <name>TemplateArgument</name> <operator>&amp;</operator><name><name>operator</name><index>[]</index></name><operator>(</operator><name>unsigned</name> <name>Idx</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><call><name>get</name><argument_list>(<argument><expr><name>Idx</name></expr></argument>)</argument_list></call></expr>;</return> }</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <macro><name>asArray</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>data</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>unsigned</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumArguments</name></expr>;</return> }</block>


<specifier>const</specifier> <name>TemplateArgument</name> <operator>*</operator><macro><name>data</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Arguments</name></expr>;</return> }</block>
}</expr>;

<expr><name>void</name> <operator>*</operator><call><name>allocateDefaultArgStorageChain</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list></call></expr>;









<expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ParmDecl</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgType</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>DefaultArgStorage</name> <block>{



struct <expr><name>Chain</name> <block>{
<expr><name>ParmDecl</name> <operator>*</operator><name>PrevDeclWithDefaultArg</name></expr>;
<expr><name>ArgType</name> <name>Value</name></expr>;
}</block></expr>;
<expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Chain</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>,
<argument><expr><literal type="string">"non-pointer argument type?"</literal></expr></argument>)</argument_list></call></expr>;

<expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>ArgType</name></expr></argument>, <argument><expr><name>ParmDecl</name><operator>*</operator></expr></argument>, <argument><expr><name>Chain</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ValueOrInherited</name></expr>;

<expr><specifier>static</specifier> <name>ParmDecl</name> <operator>*</operator><macro><name>getParmOwningDefaultArg</name><argument_list>(<argument>ParmDecl *Parm</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>DefaultArgStorage</name> <operator>&amp;</operator><name>Storage</name> <operator>=</operator> <call><name><name>Parm</name><operator>-&gt;</operator><name>getDefaultArgStorage</name></name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>Prev</name> <operator>=</operator> <name><name>Storage</name><operator>.</operator><name>ValueOrInherited</name><operator>.</operator><name>template</name></name> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ParmDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Parm</name> <operator>=</operator> <name>Prev</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<macro><name>assert</name><argument_list>(<argument>!Parm-&gt;getDefaultArgStorage()
.ValueOrInherited.template is&lt;ParmDecl *&gt;() &amp;&amp;
<literal type="string">"should only be one level of indirection"</literal></argument>)</argument_list></macro></block></expr>;
<return>return <expr><name>Parm</name></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<call><name>DefaultArgStorage</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>ValueOrInherited</name><argument_list>(<argument>ArgType()</argument>)</argument_list></macro> <block>{}</block>


<name>bool</name> <macro><name>isSet</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name><name>ValueOrInherited</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>bool</name> <macro><name>isInherited</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ValueOrInherited</name><operator>.</operator><name>template</name></name> <call><name><name>is</name><argument_list type="generic">&lt;<argument><expr><name>ParmDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>ArgType</name> <macro><name>get</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>DefaultArgStorage</name> <operator>*</operator><name>Storage</name> <operator>=</operator> <name>this</name></expr>;
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>Prev</name> <init>= <expr><name><name>ValueOrInherited</name><operator>.</operator><name>template</name></name> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ParmDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Storage</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>Prev</name><operator>-&gt;</operator><name>getDefaultArgStorage</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>C</name> <init>= <expr><name><name>Storage</name><operator>-&gt;</operator><name>ValueOrInherited</name><operator>.</operator><name>template</name></name> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>Chain</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>C</name><operator>-&gt;</operator><name>Value</name></name></expr>;</return></block_content></block></if></if_stmt></block></expr></range></decl></decl_stmt>
<return>return <expr><name><name>Storage</name><operator>-&gt;</operator><name>ValueOrInherited</name><operator>.</operator><name>template</name></name> <call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>ArgType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}



const <expr_stmt><expr><name>ParmDecl</name> <operator>*</operator><macro><name>getInheritedFrom</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>D</name> <init>= <expr><name><name>ValueOrInherited</name><operator>.</operator><name>template</name></name> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ParmDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>D</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>C</name> <init>= <expr><name><name>ValueOrInherited</name><operator>.</operator><name>template</name></name> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>Chain</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>C</name><operator>-&gt;</operator><name>PrevDeclWithDefaultArg</name></name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>nullptr</name></expr>;</return>
}


void <macro><name>set</name><argument_list>(<argument>ArgType Arg</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isSet</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"default argument already set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ValueOrInherited</name> <operator>=</operator> <name>Arg</name></expr>;</expr_stmt>
</block_content>}</block>


<function><type><name>void</name></type> <name>setInherited</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>, <parameter><decl><type><name>ParmDecl</name> <modifier>*</modifier></type><name>InheritedFrom</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isInherited</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"default argument already inherited"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>InheritedFrom</name> <operator>=</operator> <call><name>getParmOwningDefaultArg</name><argument_list>(<argument><expr><name>InheritedFrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isSet</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ValueOrInherited</name> <operator>=</operator> <name>InheritedFrom</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ValueOrInherited</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>allocateDefaultArgStorageChain(C)</argument>)</argument_list></macro>
<name>Chain</name><block>{<expr><name>InheritedFrom</name></expr>, <expr><name><name>ValueOrInherited</name><operator>.</operator><name>template</name></name> <macro><name>get</name></macro><operator>&lt;</operator><name>ArgType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>}</block></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>clear</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>ValueOrInherited</name> <operator>=</operator> <call><name>ArgType</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
};










<decl_stmt><decl><type><name>class</name></type> <name>TemplateDecl</name> <range>: <expr><name>public</name> <name>NamedDecl</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>protected</name><operator>:</operator>

<macro><name>TemplateDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>, <argument>DeclarationName Name</argument>,
<argument>TemplateParameterList *Params</argument>, <argument>NamedDecl *Decl</argument>)</argument_list></macro></expr>;



<macro><name>TemplateDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>, <argument>DeclarationName Name</argument>,
<argument>TemplateParameterList *Params</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>TemplateDecl</name><argument_list>(<argument>DK</argument>, <argument>DC</argument>, <argument>L</argument>, <argument>Name</argument>, <argument>Params</argument>, <argument>nullptr</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;


<expr><name>TemplateParameterList</name> <operator>*</operator><macro><name>getTemplateParameters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TemplateParams</name></expr>;</return>
}</block>





<name>void</name> <macro><name>getAssociatedConstraints</name><argument_list>(<argument>llvm::SmallVectorImpl&lt;const Expr *&gt; &amp;AC</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>hasAssociatedConstraints</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>NamedDecl</name> <operator>*</operator><macro><name>getTemplatedDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TemplatedDecl</name></expr>;</return> }</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{
<return>return <expr><name>K</name> <operator>&gt;=</operator> <name>firstTemplate</name> <operator>&amp;&amp;</operator> <name>K</name> <operator>&lt;=</operator> <name>lastTemplate</name></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getTemplateParameters</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTemplateLoc</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TemplatedDecl</name><operator>-&gt;</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getEnd</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>protected</name><operator>:</operator>
<name>NamedDecl</name> <operator>*</operator><name>TemplatedDecl</name></expr>;
<expr><name>TemplateParameterList</name> <operator>*</operator><name>TemplateParams</name></expr>;

<expr><name>void</name> <macro><name>setTemplateParameters</name><argument_list>(<argument>TemplateParameterList *TParams</argument>)</argument_list></macro> <block>{
<expr><name>TemplateParams</name> <operator>=</operator> <name>TParams</name></expr>;
}</block>

<name>public</name><operator>:</operator>


<name>void</name> <macro><name>init</name><argument_list>(<argument>NamedDecl *templatedDecl</argument>, <argument>TemplateParameterList* templateParams</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>TemplatedDecl</name> <operator>&amp;&amp;</operator> <literal type="string">"TemplatedDecl already set!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>TemplateParams</name> <operator>&amp;&amp;</operator> <literal type="string">"TemplateParams already set!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>TemplatedDecl</name> <operator>=</operator> <name>templatedDecl</name></expr>;
<expr><name>TemplateParams</name> <operator>=</operator> <name>templateParams</name></expr>;
}</block></expr>
}</block></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>class</name> <name>FunctionTemplateSpecializationInfo</name></type> <name>final</name>
<range>: <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name></expr></range></decl>,
<decl><type ref="prev"/><name>private</name> <name>llvm</name>::<name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTemplateSpecializationInfo</name></expr></argument>,
<argument><expr><name>MemberSpecializationInfo</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <block>{<block_content>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>Function</name></expr>;</expr_stmt>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTemplateDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>Template</name></expr>;</expr_stmt>

<label><name>public</name>:</label>


<decl_stmt><decl><type><specifier>const</specifier> <name>TemplateArgumentList</name> <modifier>*</modifier></type><name>TemplateArguments</name></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>ASTTemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgumentsAsWritten</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name></decl>;</decl_stmt>

<label><name>private</name>:</label>
<macro><name>FunctionTemplateSpecializationInfo</name><argument_list>(
<argument>FunctionDecl *FD</argument>, <argument>FunctionTemplateDecl *Template</argument>,
<argument>TemplateSpecializationKind TSK</argument>, <argument>const TemplateArgumentList *TemplateArgs</argument>,
<argument>const ASTTemplateArgumentListInfo *TemplateArgsAsWritten</argument>,
<argument>SourceLocation POI</argument>, <argument>MemberSpecializationInfo *MSInfo</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Function</name><argument_list>(<argument><expr><name>FD</name></expr></argument>, <argument><expr><ternary><condition><expr><name>MSInfo</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Template</name><argument_list>(<argument><expr><name>Template</name></expr></argument>, <argument><expr><name>TSK</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>TemplateArguments</name><argument_list>(<argument><expr><name>TemplateArgs</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>TemplateArgumentsAsWritten</name><argument_list>(<argument><expr><name>TemplateArgsAsWritten</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>PointOfInstantiation</name><argument_list>(<argument>POI</argument>)</argument_list></macro> <expr><block>{
<if_stmt><if>if <condition>(<expr><name>MSInfo</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>MemberSpecializationInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>MSInfo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>numTrailingObjects</name><argument_list>(<argument><expr><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>MemberSpecializationInfo</name><operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>Function</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>friend</name></type> <name>TrailingObjects</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>FunctionTemplateSpecializationInfo</name> <modifier>*</modifier></type>
<name>Create</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>, <parameter><decl><type><name>FunctionTemplateDecl</name> <modifier>*</modifier></type><name>Template</name></decl></parameter>,
<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentList</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgsAsWritten</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>POI</name></decl></parameter>, <parameter><decl><type><name>MemberSpecializationInfo</name> <modifier>*</modifier></type><name>MSInfo</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>FunctionDecl</name> <operator>*</operator><macro><name>getFunction</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Function</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>FunctionTemplateDecl</name> <operator>*</operator><macro><name>getTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Template</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>TemplateSpecializationKind</name> <macro><name>getTemplateSpecializationKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>TemplateSpecializationKind</name><operator>)</operator><operator>(</operator><call><name><name>Template</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isExplicitSpecialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTemplateSpecializationKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TSK_ExplicitSpecialization</name></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>isExplicitInstantiationOrSpecialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isTemplateExplicitInstantiationOrSpecialization</name><argument_list>(
<argument><expr><call><name>getTemplateSpecializationKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setTemplateSpecializationKind</name><parameter_list>(<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TSK</name> <operator>!=</operator> <name>TSK_Undeclared</name> <operator>&amp;&amp;</operator>
<literal type="string">"Cannot encode TSK_Undeclared for a function template specialization"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Template</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>TSK</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<expr_stmt><expr><name>SourceLocation</name> <macro><name>getPointOfInstantiation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PointOfInstantiation</name></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>void</name></type> <name>setPointOfInstantiation</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>POI</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>PointOfInstantiation</name> <operator>=</operator> <name>POI</name></expr>;</expr_stmt>
</block_content>}</block></function>































<expr_stmt><expr><name>MemberSpecializationInfo</name> <operator>*</operator><macro><name>getMemberSpecializationInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>numTrailingObjects</name><argument_list>(<argument><expr><call><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>MemberSpecializationInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>?</operator> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>MemberSpecializationInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index>
<operator>:</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name><name>TemplateArguments</name><operator>-&gt;</operator><name>asArray</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getFunction</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>TemplateArgs</name></expr></argument>,
<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><call><name><name>TemplateArgs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>TemplateArgument</name> <modifier>&amp;</modifier></type><name>TemplateArg</name> <range>: <expr><name>TemplateArgs</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>TemplateArg</name><operator>.</operator><name>Profile</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>MemberSpecializationInfo</name> <block>{<block_content>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>MemberAndTSK</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>explicit</name></macro>
<macro><name>MemberSpecializationInfo</name><argument_list>(<argument>NamedDecl *IF</argument>, <argument>TemplateSpecializationKind TSK</argument>,
<argument>SourceLocation POI = SourceLocation()</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>MemberAndTSK</name><argument_list>(<argument><expr><name>IF</name></expr></argument>, <argument><expr><name>TSK</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>PointOfInstantiation</name><argument_list>(<argument>POI</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>TSK</name> <operator>!=</operator> <name>TSK_Undeclared</name> <operator>&amp;&amp;</operator>
<literal type="string">"Cannot encode undeclared template specializations for members"</literal></expr></argument>)</argument_list></call></expr>;
}</block>



<name>NamedDecl</name> <operator>*</operator><macro><name>getInstantiatedFrom</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>MemberAndTSK</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>TemplateSpecializationKind</name> <macro><name>getTemplateSpecializationKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>TemplateSpecializationKind</name><operator>)</operator><operator>(</operator><call><name><name>MemberAndTSK</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isExplicitSpecialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTemplateSpecializationKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TSK_ExplicitSpecialization</name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setTemplateSpecializationKind</name><parameter_list>(<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TSK</name> <operator>!=</operator> <name>TSK_Undeclared</name> <operator>&amp;&amp;</operator>
<literal type="string">"Cannot encode undeclared template specializations for members"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>MemberAndTSK</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>TSK</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<expr_stmt><expr><name>SourceLocation</name> <macro><name>getPointOfInstantiation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PointOfInstantiation</name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setPointOfInstantiation</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>POI</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>PointOfInstantiation</name> <operator>=</operator> <name>POI</name></expr>;</expr_stmt>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>















<decl_stmt><decl><type><name>class</name> <name>DependentFunctionTemplateSpecializationInfo</name></type> <name>final</name>
<range>: <expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>DependentFunctionTemplateSpecializationInfo</name></expr></argument>,
<argument><expr><name>TemplateArgumentLoc</name></expr></argument>,
<argument><expr><name>FunctionTemplateDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{

<expr><name>unsigned</name> <name>NumTemplates</name></expr>;


<expr><name>unsigned</name> <name>NumArgs</name></expr>;


<expr><name>SourceRange</name> <name>AngleLocs</name></expr>;

<expr><name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;TemplateArgumentLoc&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumArgs</name></expr>;</return>
}</block>
<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;FunctionTemplateDecl *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumTemplates</name></expr>;</return>
}</block>

<call><name>DependentFunctionTemplateSpecializationInfo</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>UnresolvedSetImpl</name> <operator>&amp;</operator><name>Templates</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <operator>&amp;</operator><name>TemplateArgs</name></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>TrailingObjects</name></expr>;

<expr><specifier>static</specifier> <name>DependentFunctionTemplateSpecializationInfo</name> <operator>*</operator>
<call><name>Create</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>UnresolvedSetImpl</name> <operator>&amp;</operator><name>Templates</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <operator>&amp;</operator><name>TemplateArgs</name></expr></argument>)</argument_list></call></expr>;



<expr><name>unsigned</name> <macro><name>getNumTemplates</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumTemplates</name></expr>;</return> }</block>


<name>FunctionTemplateDecl</name> <operator>*</operator><macro><name>getTemplate</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <call><name>getNumTemplates</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"template index out of range"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTemplateDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index></expr>;</return>
}</block>


<specifier>const</specifier> <name>TemplateArgumentLoc</name> <operator>*</operator><macro><name>getTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>unsigned</name> <macro><name>getNumTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumArgs</name></expr>;</return> }</block>


<specifier>const</specifier> <name>TemplateArgumentLoc</name> <operator>&amp;</operator><macro><name>getTemplateArg</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <call><name>getNumTemplateArgs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"template arg index out of range"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getTemplateArgs</name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getLAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>AngleLocs</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getRAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>AngleLocs</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>RedeclarableTemplateDecl</name> <operator>:</operator> <name>public</name> <name>TemplateDecl</name></expr>,
<expr><name>public</name> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>RedeclarableTemplateDecl</name></expr></argument>&gt;</argument_list></name>
<block>{
<expr><name>using</name> <name>redeclarable_base</name> <operator>=</operator> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>RedeclarableTemplateDecl</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>RedeclarableTemplateDecl</name> <operator>*</operator><macro><name>getNextRedeclarationImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getNextRedeclaration</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>RedeclarableTemplateDecl</name> <operator>*</operator><macro><name>getPreviousDeclImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>RedeclarableTemplateDecl</name> <operator>*</operator><macro><name>getMostRecentDeclImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>protected</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>EntryType</name></expr></argument>&gt;</argument_list></name> struct <name>SpecEntryTraits</name> <block>{
<expr><name>using</name> <name>DeclType</name> <operator>=</operator> <name>EntryType</name></expr>;

<expr><specifier>static</specifier> <name>DeclType</name> <operator>*</operator><macro><name>getDecl</name><argument_list>(<argument>EntryType *D</argument>)</argument_list></macro> <block>{
<return>return <expr><name>D</name></expr>;</return>
}</block>

<specifier>static</specifier> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <macro><name>getTemplateArgs</name><argument_list>(<argument>EntryType *D</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>D</name><operator>-&gt;</operator><name>getTemplateArgs</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>asArray</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>EntryType</name></expr></argument>, <argument><expr><name>typename</name> <name>SETraits</name> <operator>=</operator> <name><name>SpecEntryTraits</name><argument_list type="generic">&lt;<argument><expr><name>EntryType</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>typename</name> <name>DeclType</name> <operator>=</operator> <name>typename</name> <name>SETraits</name><operator>::</operator><name>DeclType</name></expr></argument>&gt;</argument_list></name>
struct <name>SpecIterator</name>
<operator>:</operator> <name>llvm</name><operator>::</operator><name><name>iterator_adaptor_base</name><argument_list type="generic">&lt;
<argument><expr><name><name>SpecIterator</name><argument_list type="generic">&lt;<argument><expr><name>EntryType</name></expr></argument>, <argument><expr><name>SETraits</name></expr></argument>, <argument><expr><name>DeclType</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>typename</name> <name>llvm</name><operator>::</operator><name><name>FoldingSetVector</name><argument_list type="generic">&lt;<argument><expr><name>EntryType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr></argument>,
<argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>iterator_traits</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>llvm</name><operator>::</operator><name><name>FoldingSetVector</name><argument_list type="generic">&lt;
<argument><expr><name>EntryType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator_category</name></expr></argument>,
<argument><expr><name>DeclType</name> <operator>*</operator></expr></argument>, <argument><expr><name>ptrdiff_t</name></expr></argument>, <argument><expr><name>DeclType</name> <operator>*</operator></expr></argument>, <argument><expr><name>DeclType</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><call><name>SpecIterator</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><name>explicit</name> <macro><name>SpecIterator</name><argument_list>(
<argument>typename llvm::FoldingSetVector&lt;EntryType&gt;::iterator SetIter</argument>)</argument_list></macro>
<operator>:</operator> <name>SpecIterator</name><operator>::</operator><macro><name>iterator_adaptor_base</name><argument_list>(<argument>std::move(SetIter)</argument>)</argument_list></macro> <block>{}</block>

<name>DeclType</name> <operator>*</operator><name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>SETraits</name><operator>::</operator><call><name>getDecl</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>I</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>DeclType</name> <operator>*</operator><name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr>) <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><operator>*</operator><name>this</name></expr>;</return> }</block></block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>EntryType</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name><name>SpecIterator</name><argument_list type="generic">&lt;<argument><expr><name>EntryType</name></expr></argument>&gt;</argument_list></name>
<macro><name>makeSpecIterator</name><argument_list>(<argument>llvm::FoldingSetVector&lt;EntryType&gt; &amp;Specs</argument>, <argument>bool isEnd</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SpecIterator</name><argument_list type="generic">&lt;<argument><expr><name>EntryType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>isEnd</name> <operator>?</operator> <call><name><name>Specs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>:</operator> <call><name><name>Specs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>loadLazySpecializationsImpl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>EntryType</name></expr></argument>, <argument><expr><name>typename</name> <modifier>...</modifier><name>ProfileArguments</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name><name>SpecEntryTraits</name><argument_list type="generic">&lt;<argument><expr><name>EntryType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>DeclType</name><operator>*</operator>
<call><name>findSpecializationImpl</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>FoldingSetVector</name><argument_list type="generic">&lt;<argument><expr><name>EntryType</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Specs</name></expr></argument>,
<argument><expr><name>void</name> <operator>*</operator><operator>&amp;</operator><name>InsertPos</name></expr></argument>, <argument><expr><name>ProfileArguments</name> <operator>&amp;&amp;</operator><operator>...</operator><name>ProfileArgs</name></expr></argument>)</argument_list></call></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Derived</name></expr></argument>, <argument><expr><name>class</name> <name>EntryType</name></expr></argument>&gt;</argument_list></name>
<name>void</name> <call><name>addSpecializationImpl</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>FoldingSetVector</name><argument_list type="generic">&lt;<argument><expr><name>EntryType</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Specs</name></expr></argument>,
<argument><expr><name>EntryType</name> <operator>*</operator><name>Entry</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>InsertPos</name></expr></argument>)</argument_list></call></expr>;

struct <expr><name>CommonBase</name> <block>{
<expr><call><name>CommonBase</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>InstantiatedFromMember</name><argument_list>(<argument>nullptr</argument>, <argument>false</argument>)</argument_list></macro> <block>{}</block>






<name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>RedeclarableTemplateDecl</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name>
<name>InstantiatedFromMember</name></expr>;






<expr><name>uint32_t</name> <operator>*</operator><name>LazySpecializations</name> <operator>=</operator> <name>nullptr</name></expr>;
}</block></expr>;



<expr><name>mutable</name> <name>CommonBase</name> <operator>*</operator><name>Common</name> <operator>=</operator> <name>nullptr</name></expr>;




<expr><name>CommonBase</name> <operator>*</operator><macro><name>getCommonPtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>virtual</name> <name>CommonBase</name> <operator>*</operator><macro><name>newCommon</name><argument_list>(<argument>ASTContext &amp;C</argument>)</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;


<macro><name>RedeclarableTemplateDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation L</argument>, <argument>DeclarationName Name</argument>,
<argument>TemplateParameterList *Params</argument>, <argument>NamedDecl *Decl</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>TemplateDecl</name><argument_list>(<argument><expr><name>DK</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>L</name></expr></argument>, <argument><expr><name>Name</name></expr></argument>, <argument><expr><name>Params</name></expr></argument>, <argument><expr><name>Decl</name></expr></argument>)</argument_list></call></expr>, <macro><name>redeclarable_base</name><argument_list>(<argument>C</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>decl_type</name></expr></argument>&gt;</argument_list></name> <name>friend</name> <name>class</name> <name>RedeclarableTemplate</name></expr>;


<expr><name>RedeclarableTemplateDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>RedeclarableTemplateDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



















<name>bool</name> <macro><name>isMemberSpecialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCommonPtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>InstantiatedFromMember</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>void</name> <macro><name>setMemberSpecialization</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getCommonPtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>InstantiatedFromMember</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Only member templates can be member template specializations"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getCommonPtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>InstantiatedFromMember</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;
}</block>





































<name>RedeclarableTemplateDecl</name> <operator>*</operator><macro><name>getInstantiatedFromMemberTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCommonPtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>InstantiatedFromMember</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setInstantiatedFromMemberTemplate</name><argument_list>(<argument>RedeclarableTemplateDecl *TD</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>getCommonPtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>InstantiatedFromMember</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getCommonPtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>InstantiatedFromMember</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><name>TD</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>using</name> <name>redecl_range</name> <operator>=</operator> <name>redeclarable_base</name><operator>::</operator><name>redecl_range</name></expr>;
<expr><name>using</name> <name>redecl_iterator</name> <operator>=</operator> <name>redeclarable_base</name><operator>::</operator><name>redecl_iterator</name></expr>;

<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_begin</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_end</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getPreviousDecl</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getMostRecentDecl</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>isFirstDecl</name></expr>;


<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{
<return>return <expr><name>K</name> <operator>&gt;=</operator> <name>firstRedeclarableTemplate</name> <operator>&amp;&amp;</operator> <name>K</name> <operator>&lt;=</operator> <name>lastRedeclarableTemplate</name></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name>RedeclarableTemplateDecl</name><operator>::</operator>
<name><name>SpecEntryTraits</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTemplateSpecializationInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>using</name> <name>DeclType</name> <operator>=</operator> <name>FunctionDecl</name></expr>;

<expr><specifier>static</specifier> <name>DeclType</name> <operator>*</operator><macro><name>getDecl</name><argument_list>(<argument>FunctionTemplateSpecializationInfo *I</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>I</name><operator>-&gt;</operator><name>getFunction</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name>
<macro><name>getTemplateArgs</name><argument_list>(<argument>FunctionTemplateSpecializationInfo *I</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>I</name><operator>-&gt;</operator><name>TemplateArguments</name><operator>-&gt;</operator><name>asArray</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>FunctionTemplateDecl</name> <operator>:</operator> <name>public</name> <name>RedeclarableTemplateDecl</name> <block>{
<expr><name>protected</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>FunctionDecl</name></expr>;



struct <expr><name>Common</name> <operator>:</operator> <name>CommonBase</name> <block>{


<expr><name>llvm</name><operator>::</operator><name><name>FoldingSetVector</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTemplateSpecializationInfo</name></expr></argument>&gt;</argument_list></name> <name>Specializations</name></expr>;








<expr><name>TemplateArgument</name> <operator>*</operator><name>InjectedArgs</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><call><name>Common</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
}</block></expr>;

<macro><name>FunctionTemplateDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>,
<argument>DeclarationName Name</argument>, <argument>TemplateParameterList *Params</argument>,
<argument>NamedDecl *Decl</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>RedeclarableTemplateDecl</name><argument_list>(<argument>FunctionTemplate</argument>, <argument>C</argument>, <argument>DC</argument>, <argument>L</argument>, <argument>Name</argument>, <argument>Params</argument>,
<argument>Decl</argument>)</argument_list></macro> <expr><block>{}</block>

<name>CommonBase</name> <operator>*</operator><macro><name>newCommon</name><argument_list>(<argument>ASTContext &amp;C</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>Common</name> <operator>*</operator><macro><name>getCommonPtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Common</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RedeclarableTemplateDecl</name><operator>::</operator><call><name>getCommonPtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>llvm</name><operator>::</operator><name><name>FoldingSetVector</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTemplateSpecializationInfo</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator>
<macro><name>getSpecializations</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;





<expr><name>void</name> <call><name>addSpecialization</name><argument_list>(<argument><expr><name>FunctionTemplateSpecializationInfo</name><operator>*</operator> <name>Info</name></expr></argument>,
<argument><expr><name>void</name> <operator>*</operator><name>InsertPos</name></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;


<expr><name>void</name> <macro><name>LoadLazySpecializations</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>FunctionDecl</name> <operator>*</operator><macro><name>getTemplatedDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TemplatedDecl</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isThisDeclarationADefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTemplatedDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isThisDeclarationADefinition</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>FunctionDecl</name> <operator>*</operator><call><name>findSpecialization</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><name>void</name> <operator>*</operator><operator>&amp;</operator><name>InsertPos</name></expr></argument>)</argument_list></call></expr>;

<expr><name>FunctionTemplateDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>RedeclarableTemplateDecl</name><operator>::</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>FunctionTemplateDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>RedeclarableTemplateDecl</name><operator>::</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>FunctionTemplateDecl</name> <operator>*</operator><macro><name>getPreviousDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>RedeclarableTemplateDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>FunctionTemplateDecl</name> <operator>*</operator><macro><name>getPreviousDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>RedeclarableTemplateDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>FunctionTemplateDecl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>RedeclarableTemplateDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>FunctionTemplateDecl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTemplateDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>FunctionTemplateDecl</name> <operator>*</operator><macro><name>getInstantiatedFromMemberTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>RedeclarableTemplateDecl</name><operator>::</operator><call><name>getInstantiatedFromMemberTemplate</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>spec_iterator</name> <operator>=</operator> <name><name>SpecIterator</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTemplateSpecializationInfo</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>spec_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>spec_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>spec_range</name> <macro><name>specializations</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>spec_range</name><argument_list>(<argument><expr><call><name>spec_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>spec_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>spec_iterator</name> <macro><name>spec_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>makeSpecIterator</name><argument_list>(<argument><expr><call><name>getSpecializations</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>spec_iterator</name> <macro><name>spec_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>makeSpecIterator</name><argument_list>(<argument><expr><call><name>getSpecializations</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>








<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <call><name>getInjectedTemplateArgs</name><argument_list>()</argument_list></call></expr>;



<expr><name>bool</name> <macro><name>isAbbreviated</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{




<expr><specifier>const</specifier> <name>TemplateParameterList</name> <operator>*</operator><name>TPL</name> <operator>=</operator> <call><name>getTemplateParameters</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name><name>TPL</name><operator>-&gt;</operator><name>getParam</name></name><argument_list>(<argument><expr><call><name><name>TPL</name><operator>-&gt;</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>isImplicit</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>void</name> <call><name>mergePrevDecl</name><argument_list>(<argument><expr><name>FunctionTemplateDecl</name> <operator>*</operator><name>Prev</name></expr></argument>)</argument_list></call></expr>;


<expr><specifier>static</specifier> <name>FunctionTemplateDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation L</argument>,
<argument>DeclarationName Name</argument>,
<argument>TemplateParameterList *Params</argument>,
<argument>NamedDecl *Decl</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>FunctionTemplateDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>FunctionTemplate</name></expr>;</return> }</block>
}</expr>;














<expr><name>class</name> <name>TemplateParmPosition</name> <block>{
<expr><name>protected</name><operator>:</operator>


<name>unsigned</name> <name>Depth</name></expr>;
<expr><name>unsigned</name> <name>Position</name></expr>;

<macro><name>TemplateParmPosition</name><argument_list>(<argument>unsigned D</argument>, <argument>unsigned P</argument>)</argument_list></macro> <operator>:</operator> <expr><call><name>Depth</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>, <macro><name>Position</name><argument_list>(<argument>P</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<call><name>TemplateParmPosition</name><argument_list>()</argument_list></call> <operator>=</operator> <name>delete</name></expr>;


<expr><name>unsigned</name> <macro><name>getDepth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Depth</name></expr>;</return> }</block>
<name>void</name> <macro><name>setDepth</name><argument_list>(<argument>unsigned D</argument>)</argument_list></macro> <block>{ <expr><name>Depth</name> <operator>=</operator> <name>D</name></expr>; }</block>


<name>unsigned</name> <macro><name>getPosition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Position</name></expr>;</return> }</block>
<name>void</name> <macro><name>setPosition</name><argument_list>(<argument>unsigned P</argument>)</argument_list></macro> <block>{ <expr><name>Position</name> <operator>=</operator> <name>P</name></expr>; }</block>


<name>unsigned</name> <macro><name>getIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Position</name></expr>;</return> }</block>
}</expr>;







<expr><name>class</name> <name>TemplateTypeParmDecl</name> <name>final</name> <operator>:</operator> <name>public</name> <name>TypeDecl</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TemplateTypeParmDecl</name></expr></argument>, <argument><expr><name>TypeConstraint</name></expr></argument>&gt;</argument_list></name> <block>{

<expr><name>friend</name> <name>class</name> <name>Sema</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;





<expr><name>bool</name> <name>Typename</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>bool</name> <name>HasTypeConstraint</name> <operator>:</operator> <literal type="number">1</literal></expr>;




<expr><name>bool</name> <name>TypeConstraintInitialized</name> <operator>:</operator> <literal type="number">1</literal></expr>;




<expr><name>bool</name> <name>ExpandedParameterPack</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>unsigned</name> <name>NumExpanded</name> <operator>=</operator> <literal type="number">0</literal></expr>;


<expr><name>using</name> <name>DefArgStorage</name> <operator>=</operator>
<name><name>DefaultArgStorage</name><argument_list type="generic">&lt;<argument><expr><name>TemplateTypeParmDecl</name></expr></argument>, <argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>DefArgStorage</name> <name>DefaultArgument</name></expr>;

<macro><name>TemplateTypeParmDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation KeyLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>IdentifierInfo *Id</argument>,
<argument>bool Typename</argument>, <argument>bool HasTypeConstraint</argument>,
<argument>Optional&lt;unsigned&gt; NumExpanded</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>TypeDecl</name><argument_list>(<argument><expr><name>TemplateTypeParm</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>IdLoc</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>, <argument><expr><name>KeyLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Typename</name><argument_list>(<argument><expr><name>Typename</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>HasTypeConstraint</name><argument_list>(<argument><expr><name>HasTypeConstraint</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>TypeConstraintInitialized</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ExpandedParameterPack</name><argument_list>(<argument><expr><name>NumExpanded</name></expr></argument>)</argument_list></call></expr>,
<macro><name>NumExpanded</name><argument_list>(<argument>NumExpanded ? *NumExpanded : <literal type="number">0</literal></argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>TemplateTypeParmDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation KeyLoc</argument>,
<argument>SourceLocation NameLoc</argument>,
<argument>unsigned D</argument>, <argument>unsigned P</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>bool Typename</argument>,
<argument>bool ParameterPack</argument>,
<argument>bool HasTypeConstraint = false</argument>,
<argument>Optional&lt;unsigned&gt; NumExpanded = None</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>TemplateTypeParmDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned ID</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>TemplateTypeParmDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned ID</argument>,
<argument>bool HasTypeConstraint</argument>)</argument_list></macro></expr>;






<expr><name>bool</name> <macro><name>wasDeclaredWithTypename</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Typename</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>HasTypeConstraint</name></expr>;</return>
}</block>

<specifier>const</specifier> <name>DefArgStorage</name> <operator>&amp;</operator><macro><name>getDefaultArgStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DefaultArgument</name></expr>;</return> }</block>



<name>bool</name> <macro><name>hasDefaultArgument</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>DefaultArgument</name><operator>.</operator><name>isSet</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>QualType</name> <macro><name>getDefaultArgument</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>DefaultArgument</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getDefaultArgumentInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>DefaultArgument</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getDefaultArgumentLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>defaultArgumentWasInherited</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>DefaultArgument</name><operator>.</operator><name>isInherited</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>void</name> <macro><name>setDefaultArgument</name><argument_list>(<argument>TypeSourceInfo *DefArg</argument>)</argument_list></macro> <block>{
<expr><call><name><name>DefaultArgument</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>DefArg</name></expr></argument>)</argument_list></call></expr>;
}</block>



<name>void</name> <macro><name>setInheritedDefaultArgument</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>TemplateTypeParmDecl *Prev</argument>)</argument_list></macro> <block>{
<expr><call><name><name>DefaultArgument</name><operator>.</operator><name>setInherited</name></name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Prev</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>void</name> <macro><name>removeDefaultArgument</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name><name>DefaultArgument</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;
}</block>



<name>void</name> <macro><name>setDeclaredWithTypename</name><argument_list>(<argument>bool withTypename</argument>)</argument_list></macro> <block>{ <expr><name>Typename</name> <operator>=</operator> <name>withTypename</name></expr>; }</block>


<name>unsigned</name> <macro><name>getDepth</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>unsigned</name> <macro><name>getIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isParameterPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;





<expr><name>bool</name> <macro><name>isPackExpansion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isParameterPack</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>TypeConstraint</name> <modifier>*</modifier></type><name>TC</name> <init>= <expr><call><name>getTypeConstraint</name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>TC</name><operator>-&gt;</operator><name>hasExplicitTemplateArgs</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>ArgLoc</name> <range>: <expr><call><name><name>TC</name><operator>-&gt;</operator><name>getTemplateArgsAsWritten</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>arguments</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>ArgLoc</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>containsUnexpandedParameterPack</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>






















<name>bool</name> <macro><name>isExpandedParameterPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ExpandedParameterPack</name></expr>;</return> }</block>


<name>unsigned</name> <macro><name>getNumExpansionParameters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>ExpandedParameterPack</name> <operator>&amp;&amp;</operator> <literal type="string">"Not an expansion parameter pack"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>NumExpanded</name></expr>;</return>
}</block>



<specifier>const</specifier> <name>TypeConstraint</name> <operator>*</operator><macro><name>getTypeConstraint</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TypeConstraintInitialized</name> <operator>?</operator> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TypeConstraint</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>:</operator>
<name>nullptr</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setTypeConstraint</name><argument_list>(<argument>NestedNameSpecifierLoc NNS</argument>,
<argument>DeclarationNameInfo NameInfo</argument>, <argument>NamedDecl *FoundDecl</argument>,
<argument>ConceptDecl *CD</argument>,
<argument>const ASTTemplateArgumentListInfo *ArgsAsWritten</argument>,
<argument>Expr *ImmediatelyDeclaredConstraint</argument>)</argument_list></macro></expr>;


<expr><name>bool</name> <macro><name>hasTypeConstraint</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>HasTypeConstraint</name></expr>;</return>
}</block>






<name>void</name> <macro><name>getAssociatedConstraints</name><argument_list>(<argument>llvm::SmallVectorImpl&lt;const Expr *&gt; &amp;AC</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>HasTypeConstraint</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>AC</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>getTypeConstraint</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getImmediatelyDeclaredConstraint</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;


<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>TemplateTypeParm</name></expr>;</return> }</block>
}</expr>;






<expr><name>class</name> <name>NonTypeTemplateParmDecl</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>DeclaratorDecl</name></expr>,
<expr><name>protected</name> <name>TemplateParmPosition</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>NonTypeTemplateParmDecl</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;



<expr><name>using</name> <name>DefArgStorage</name> <operator>=</operator> <name><name>DefaultArgStorage</name><argument_list type="generic">&lt;<argument><expr><name>NonTypeTemplateParmDecl</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>DefArgStorage</name> <name>DefaultArgument</name></expr>;





<expr><name>bool</name> <name>ParameterPack</name></expr>;




<expr><name>bool</name> <name>ExpandedParameterPack</name> <operator>=</operator> <name>false</name></expr>;


<expr><name>unsigned</name> <name>NumExpandedTypes</name> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(
<argument>OverloadToken&lt;std::pair&lt;QualType</argument>, <argument>TypeSourceInfo *&gt;&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumExpandedTypes</name></expr>;</return>
}</block>

<macro><name>NonTypeTemplateParmDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>unsigned D</argument>, <argument>unsigned P</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>QualType T</argument>,
<argument>bool ParameterPack</argument>, <argument>TypeSourceInfo *TInfo</argument>)</argument_list></macro>
<operator>:</operator> <call><name>DeclaratorDecl</name><argument_list>(<argument><expr><name>NonTypeTemplateParm</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>IdLoc</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>TInfo</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TemplateParmPosition</name><argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>, <macro><name>ParameterPack</name><argument_list>(<argument>ParameterPack</argument>)</argument_list></macro> <expr><block>{}</block>

<macro><name>NonTypeTemplateParmDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>unsigned D</argument>, <argument>unsigned P</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>QualType T</argument>,
<argument>TypeSourceInfo *TInfo</argument>,
<argument>ArrayRef&lt;QualType&gt; ExpandedTypes</argument>,
<argument>ArrayRef&lt;TypeSourceInfo *&gt; ExpandedTInfos</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>NonTypeTemplateParmDecl</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>unsigned D</argument>, <argument>unsigned P</argument>, <argument>IdentifierInfo *Id</argument>,
<argument>QualType T</argument>, <argument>bool ParameterPack</argument>, <argument>TypeSourceInfo *TInfo</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>NonTypeTemplateParmDecl</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>unsigned D</argument>, <argument>unsigned P</argument>, <argument>IdentifierInfo *Id</argument>,
<argument>QualType T</argument>, <argument>TypeSourceInfo *TInfo</argument>, <argument>ArrayRef&lt;QualType&gt; ExpandedTypes</argument>,
<argument>ArrayRef&lt;TypeSourceInfo *&gt; ExpandedTInfos</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>NonTypeTemplateParmDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>,
<argument>unsigned ID</argument>,
<argument>bool HasTypeConstraint</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>NonTypeTemplateParmDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>,
<argument>unsigned ID</argument>,
<argument>unsigned NumExpandedTypes</argument>,
<argument>bool HasTypeConstraint</argument>)</argument_list></macro></expr>;

<expr><name>using</name> <name>TemplateParmPosition</name><operator>::</operator><name>getDepth</name></expr>;
<expr><name>using</name> <name>TemplateParmPosition</name><operator>::</operator><name>setDepth</name></expr>;
<expr><name>using</name> <name>TemplateParmPosition</name><operator>::</operator><name>getPosition</name></expr>;
<expr><name>using</name> <name>TemplateParmPosition</name><operator>::</operator><name>setPosition</name></expr>;
<expr><name>using</name> <name>TemplateParmPosition</name><operator>::</operator><name>getIndex</name></expr>;

<expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;

<expr><specifier>const</specifier> <name>DefArgStorage</name> <operator>&amp;</operator><macro><name>getDefaultArgStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DefaultArgument</name></expr>;</return> }</block>



<name>bool</name> <macro><name>hasDefaultArgument</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>DefaultArgument</name><operator>.</operator><name>isSet</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getDefaultArgument</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>DefaultArgument</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getDefaultArgumentLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>defaultArgumentWasInherited</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>DefaultArgument</name><operator>.</operator><name>isInherited</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>




<name>void</name> <macro><name>setDefaultArgument</name><argument_list>(<argument>Expr *DefArg</argument>)</argument_list></macro> <block>{ <expr><call><name><name>DefaultArgument</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>DefArg</name></expr></argument>)</argument_list></call></expr>; }</block>
<name>void</name> <macro><name>setInheritedDefaultArgument</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>NonTypeTemplateParmDecl *Parm</argument>)</argument_list></macro> <block>{
<expr><call><name><name>DefaultArgument</name><operator>.</operator><name>setInherited</name></name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Parm</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>void</name> <macro><name>removeDefaultArgument</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name><name>DefaultArgument</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>; }</block>










<name>bool</name> <macro><name>isParameterPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ParameterPack</name></expr>;</return> }</block>






<name>bool</name> <macro><name>isPackExpansion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ParameterPack</name> <operator>&amp;&amp;</operator> <call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>PackExpansionType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

























<name>bool</name> <macro><name>isExpandedParameterPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ExpandedParameterPack</name></expr>;</return> }</block>



<name>unsigned</name> <macro><name>getNumExpansionTypes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>ExpandedParameterPack</name> <operator>&amp;&amp;</operator> <literal type="string">"Not an expansion parameter pack"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>NumExpandedTypes</name></expr>;</return>
}</block>



<name>QualType</name> <macro><name>getExpansionType</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <name>NumExpandedTypes</name> <operator>&amp;&amp;</operator> <literal type="string">"Out-of-range expansion type index"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>TypesAndInfos</name> <operator>=</operator>
<call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name><name>TypesAndInfos</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><name>first</name></expr>;</return>
}</block>



<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getExpansionTypeSourceInfo</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <name>NumExpandedTypes</name> <operator>&amp;&amp;</operator> <literal type="string">"Out-of-range expansion type index"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>TypesAndInfos</name> <operator>=</operator>
<call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name><name>TypesAndInfos</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><name>second</name></expr>;</return>
}</block>



<name>Expr</name> <operator>*</operator><macro><name>getPlaceholderTypeConstraint</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasPlaceholderTypeConstraint</name><argument_list>()</argument_list></call> <operator>?</operator> <operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>:</operator>
<name>nullptr</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setPlaceholderTypeConstraint</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{
<expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>=</operator> <name>E</name></expr>;
}</block>



<name>bool</name> <macro><name>hasPlaceholderTypeConstraint</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <operator>*</operator><name>AT</name> <operator>=</operator> <call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getContainedAutoType</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>AT</name> <operator>&amp;&amp;</operator> <call><name><name>AT</name><operator>-&gt;</operator><name>isConstrained</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>







<name>void</name> <macro><name>getAssociatedConstraints</name><argument_list>(<argument>llvm::SmallVectorImpl&lt;const Expr *&gt; &amp;AC</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name> <init>= <expr><call><name>getPlaceholderTypeConstraint</name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>AC</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>NonTypeTemplateParm</name></expr>;</return> }</block>
}</expr>;








<expr><name>class</name> <name>TemplateTemplateParmDecl</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>TemplateDecl</name></expr>,
<expr><name>protected</name> <name>TemplateParmPosition</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TemplateTemplateParmDecl</name></expr></argument>,
<argument><expr><name>TemplateParameterList</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{

<expr><name>using</name> <name>DefArgStorage</name> <operator>=</operator>
<name><name>DefaultArgStorage</name><argument_list type="generic">&lt;<argument><expr><name>TemplateTemplateParmDecl</name></expr></argument>, <argument><expr><name>TemplateArgumentLoc</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>DefArgStorage</name> <name>DefaultArgument</name></expr>;


<expr><name>bool</name> <name>ParameterPack</name></expr>;




<expr><name>bool</name> <name>ExpandedParameterPack</name> <operator>=</operator> <name>false</name></expr>;


<expr><name>unsigned</name> <name>NumExpandedParams</name> <operator>=</operator> <literal type="number">0</literal></expr>;

<macro><name>TemplateTemplateParmDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>,
<argument>unsigned D</argument>, <argument>unsigned P</argument>, <argument>bool ParameterPack</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>TemplateParameterList *Params</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>TemplateDecl</name><argument_list>(<argument><expr><name>TemplateTemplateParm</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>L</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>, <argument><expr><name>Params</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TemplateParmPosition</name><argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>, <macro><name>ParameterPack</name><argument_list>(<argument>ParameterPack</argument>)</argument_list></macro> <expr><block>{}</block>

<macro><name>TemplateTemplateParmDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>,
<argument>unsigned D</argument>, <argument>unsigned P</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>TemplateParameterList *Params</argument>,
<argument>ArrayRef&lt;TemplateParameterList *&gt; Expansions</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;

<expr><specifier>static</specifier> <name>TemplateTemplateParmDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation L</argument>, <argument>unsigned D</argument>,
<argument>unsigned P</argument>, <argument>bool ParameterPack</argument>,
<argument>IdentifierInfo *Id</argument>,
<argument>TemplateParameterList *Params</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>TemplateTemplateParmDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation L</argument>, <argument>unsigned D</argument>,
<argument>unsigned P</argument>,
<argument>IdentifierInfo *Id</argument>,
<argument>TemplateParameterList *Params</argument>,
<argument>ArrayRef&lt;TemplateParameterList *&gt; Expansions</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>TemplateTemplateParmDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>,
<argument>unsigned ID</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>TemplateTemplateParmDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>,
<argument>unsigned ID</argument>,
<argument>unsigned NumExpansions</argument>)</argument_list></macro></expr>;

<expr><name>using</name> <name>TemplateParmPosition</name><operator>::</operator><name>getDepth</name></expr>;
<expr><name>using</name> <name>TemplateParmPosition</name><operator>::</operator><name>setDepth</name></expr>;
<expr><name>using</name> <name>TemplateParmPosition</name><operator>::</operator><name>getPosition</name></expr>;
<expr><name>using</name> <name>TemplateParmPosition</name><operator>::</operator><name>setPosition</name></expr>;
<expr><name>using</name> <name>TemplateParmPosition</name><operator>::</operator><name>getIndex</name></expr>;







<expr><name>bool</name> <macro><name>isParameterPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ParameterPack</name></expr>;</return> }</block>





<name>bool</name> <macro><name>isPackExpansion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ParameterPack</name> <operator>&amp;&amp;</operator>
<call><name>getTemplateParameters</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>containsUnexpandedParameterPack</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



















<name>bool</name> <macro><name>isExpandedParameterPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ExpandedParameterPack</name></expr>;</return> }</block>



<name>unsigned</name> <macro><name>getNumExpansionTemplateParameters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>ExpandedParameterPack</name> <operator>&amp;&amp;</operator> <literal type="string">"Not an expansion parameter pack"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>NumExpandedParams</name></expr>;</return>
}</block>



<name>TemplateParameterList</name> <operator>*</operator><macro><name>getExpansionTemplateParameters</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <name>NumExpandedParams</name> <operator>&amp;&amp;</operator> <literal type="string">"Out-of-range expansion type index"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TemplateParameterList</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index></expr>;</return>
}</block>

<specifier>const</specifier> <name>DefArgStorage</name> <operator>&amp;</operator><macro><name>getDefaultArgStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DefaultArgument</name></expr>;</return> }</block>



<name>bool</name> <macro><name>hasDefaultArgument</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>DefaultArgument</name><operator>.</operator><name>isSet</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<specifier>const</specifier> <name>TemplateArgumentLoc</name> <operator>&amp;</operator><macro><name>getDefaultArgument</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>static</specifier> <specifier>const</specifier> <name>TemplateArgumentLoc</name> <name>NoneLoc</name></expr>;
<return>return <expr><ternary><condition><expr><call><name><name>DefaultArgument</name><operator>.</operator><name>isSet</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><operator>*</operator><call><name><name>DefaultArgument</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>NoneLoc</name></expr></else></ternary></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getDefaultArgumentLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>defaultArgumentWasInherited</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>DefaultArgument</name><operator>.</operator><name>isInherited</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>




<name>void</name> <call><name>setDefaultArgument</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TemplateArgumentLoc</name> <operator>&amp;</operator><name>DefArg</name></expr></argument>)</argument_list></call></expr>;
<expr><name>void</name> <macro><name>setInheritedDefaultArgument</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>TemplateTemplateParmDecl *Prev</argument>)</argument_list></macro> <block>{
<expr><call><name><name>DefaultArgument</name><operator>.</operator><name>setInherited</name></name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Prev</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>void</name> <macro><name>removeDefaultArgument</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name><name>DefaultArgument</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>; }</block>

<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<expr><name>SourceLocation</name> <name>End</name> <operator>=</operator> <call><name>getLocation</name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name>hasDefaultArgument</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defaultArgumentWasInherited</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>End</name> <operator>=</operator> <call><name>getDefaultArgument</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSourceRange</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getTemplateParameters</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTemplateLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>End</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>TemplateTemplateParm</name></expr>;</return> }</block>
}</expr>;




<expr><name>class</name> <name>BuiltinTemplateDecl</name> <operator>:</operator> <name>public</name> <name>TemplateDecl</name> <block>{
<expr><name>BuiltinTemplateKind</name> <name>BTK</name></expr>;

<macro><name>BuiltinTemplateDecl</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>DeclarationName Name</argument>, <argument>BuiltinTemplateKind BTK</argument>)</argument_list></macro>;

<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>BuiltinTemplate</name></expr>;</return> }</block>

<specifier>static</specifier> <name>BuiltinTemplateDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>DeclarationName Name</argument>,
<argument>BuiltinTemplateKind BTK</argument>)</argument_list></macro> <block>{
<return>return <macro><name>new</name> <argument_list>(<argument>C</argument>, <argument>DC</argument>)</argument_list></macro> <expr><call><name>BuiltinTemplateDecl</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>Name</name></expr></argument>, <argument><expr><name>BTK</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<return>return <expr><block>{}</block></expr>;</return>
}</block>

<name>BuiltinTemplateKind</name> <macro><name>getBuiltinTemplateKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BTK</name></expr>;</return> }</block>
}</expr>;














<expr><name>class</name> <name>ClassTemplateSpecializationDecl</name>
<operator>:</operator> <name>public</name> <name>CXXRecordDecl</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{



struct <expr><name>SpecializedPartialSpecialization</name> <block>{


<expr><name>ClassTemplatePartialSpecializationDecl</name> <operator>*</operator><name>PartialSpecialization</name></expr>;



<expr><specifier>const</specifier> <name>TemplateArgumentList</name> <operator>*</operator><name>TemplateArgs</name></expr>;
}</block></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>SpecializedPartialSpecialization</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>SpecializedTemplate</name></expr>;


struct <expr><name>ExplicitSpecializationInfo</name> <block>{

<expr><name>TypeSourceInfo</name> <operator>*</operator><name>TypeAsWritten</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>SourceLocation</name> <name>ExternLoc</name></expr>;


<expr><name>SourceLocation</name> <name>TemplateKeywordLoc</name></expr>;

<expr><call><name>ExplicitSpecializationInfo</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
}</block></expr>;



<expr><name>ExplicitSpecializationInfo</name> <operator>*</operator><name>ExplicitInfo</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><specifier>const</specifier> <name>TemplateArgumentList</name> <operator>*</operator><name>TemplateArgs</name></expr>;


<expr><name>SourceLocation</name> <name>PointOfInstantiation</name></expr>;



<expr><name>unsigned</name> <name>SpecializationKind</name> <operator>:</operator> <literal type="number">3</literal></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>ClassTemplateSpecializationDecl</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>Kind DK</argument>, <argument>TagKind TK</argument>,
<argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>,
<argument>ClassTemplateDecl *SpecializedTemplate</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; Args</argument>,
<argument>ClassTemplateSpecializationDecl *PrevDecl</argument>)</argument_list></macro></expr>;

<expr><name>explicit</name> <macro><name>ClassTemplateSpecializationDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>Kind DK</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;

<expr><specifier>static</specifier> <name>ClassTemplateSpecializationDecl</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>TagKind TK</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation IdLoc</argument>,
<argument>ClassTemplateDecl *SpecializedTemplate</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; Args</argument>,
<argument>ClassTemplateSpecializationDecl *PrevDecl</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>ClassTemplateSpecializationDecl</name> <operator>*</operator>
<macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <macro><name>getNameForDiagnostic</name><argument_list>(<argument>raw_ostream &amp;OS</argument>, <argument>const PrintingPolicy &amp;Policy</argument>,
<argument>bool Qualified</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;






<expr><name>ClassTemplateSpecializationDecl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateSpecializationDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getMostRecentNonInjectedDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>ClassTemplateDecl</name> <operator>*</operator><macro><name>getSpecializedTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><specifier>const</specifier> <name>TemplateArgumentList</name> <operator>&amp;</operator><macro><name>getTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>*</operator><name>TemplateArgs</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setTemplateArgs</name><argument_list>(<argument>TemplateArgumentList *Args</argument>)</argument_list></macro> <block>{
<expr><name>TemplateArgs</name> <operator>=</operator> <name>Args</name></expr>;
}</block>



<name>TemplateSpecializationKind</name> <macro><name>getSpecializationKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TemplateSpecializationKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SpecializationKind</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isExplicitSpecialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getSpecializationKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TSK_ExplicitSpecialization</name></expr>;</return>
}</block>










<name>bool</name> <macro><name>isClassScopeExplicitSpecialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isExplicitSpecialization</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getLexicalDeclContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>bool</name> <macro><name>isExplicitInstantiationOrSpecialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isTemplateExplicitInstantiationOrSpecialization</name><argument_list>(
<argument><expr><call><name>getTemplateSpecializationKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setSpecializedTemplate</name><argument_list>(<argument>ClassTemplateDecl *Specialized</argument>)</argument_list></macro> <block>{
<expr><name>SpecializedTemplate</name> <operator>=</operator> <name>Specialized</name></expr>;
}</block>

<name>void</name> <macro><name>setSpecializationKind</name><argument_list>(<argument>TemplateSpecializationKind TSK</argument>)</argument_list></macro> <block>{
<expr><name>SpecializationKind</name> <operator>=</operator> <name>TSK</name></expr>;
}</block>


<name>SourceLocation</name> <macro><name>getPointOfInstantiation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PointOfInstantiation</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setPointOfInstantiation</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Loc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"point of instantiation must be valid!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>PointOfInstantiation</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>





<name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateDecl</name> <operator>*</operator></expr></argument>,
<argument><expr><name>ClassTemplatePartialSpecializationDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<macro><name>getInstantiatedFrom</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isTemplateInstantiation</name><argument_list>(<argument><expr><call><name>getSpecializationKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>llvm</name><operator>::</operator><call><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateDecl</name> <operator>*</operator></expr></argument>,
<argument><expr><name>ClassTemplatePartialSpecializationDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name>getSpecializedTemplateOrPartial</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateDecl</name> <operator>*</operator></expr></argument>,
<argument><expr><name>ClassTemplatePartialSpecializationDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<macro><name>getSpecializedTemplateOrPartial</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>PartialSpec</name> <init>=
<expr><name><name>SpecializedTemplate</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>SpecializedPartialSpecialization</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>PartialSpec</name><operator>-&gt;</operator><name>PartialSpecialization</name></name></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><name><name>SpecializedTemplate</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>ClassTemplateDecl</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>












<specifier>const</specifier> <name>TemplateArgumentList</name> <operator>&amp;</operator><macro><name>getTemplateInstantiationArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>PartialSpec</name> <init>=
<expr><name><name>SpecializedTemplate</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>SpecializedPartialSpecialization</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>*</operator><name><name>PartialSpec</name><operator>-&gt;</operator><name>TemplateArgs</name></name></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name>getTemplateArgs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>




<name>void</name> <macro><name>setInstantiationOf</name><argument_list>(<argument>ClassTemplatePartialSpecializationDecl *PartialSpec</argument>,
<argument>const TemplateArgumentList *TemplateArgs</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>SpecializedTemplate</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>SpecializedPartialSpecialization</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Already set to a class template partial specialization!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <operator>*</operator><name>PS</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>getASTContext()</argument>)</argument_list></macro> <call><name>SpecializedPartialSpecialization</name><argument_list>()</argument_list></call></expr>;
<expr><name><name>PS</name><operator>-&gt;</operator><name>PartialSpecialization</name></name> <operator>=</operator> <name>PartialSpec</name></expr>;
<expr><name><name>PS</name><operator>-&gt;</operator><name>TemplateArgs</name></name> <operator>=</operator> <name>TemplateArgs</name></expr>;
<expr><name>SpecializedTemplate</name> <operator>=</operator> <name>PS</name></expr>;
}</block>



<name>void</name> <macro><name>setInstantiationOf</name><argument_list>(<argument>ClassTemplateDecl *TemplDecl</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>SpecializedTemplate</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>SpecializedPartialSpecialization</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Previously set to a class template partial specialization!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>SpecializedTemplate</name> <operator>=</operator> <name>TemplDecl</name></expr>;
}</block>



<name>void</name> <macro><name>setTypeAsWritten</name><argument_list>(<argument>TypeSourceInfo *T</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ExplicitInfo</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ExplicitInfo</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>getASTContext()</argument>)</argument_list></macro> <name>ExplicitSpecializationInfo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<name><name>ExplicitInfo</name><operator>-&gt;</operator><name>TypeAsWritten</name></name> <operator>=</operator> <name>T</name></block></expr>;
}</block>



<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ExplicitInfo</name> <operator>?</operator> <name><name>ExplicitInfo</name><operator>-&gt;</operator><name>TypeAsWritten</name></name> <operator>:</operator> <name>nullptr</name></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getExternLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><name>ExplicitInfo</name></expr> ?</condition><then> <expr><name><name>ExplicitInfo</name><operator>-&gt;</operator><name>ExternLoc</name></name></expr> </then><else>: <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>


<name>void</name> <macro><name>setExternLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ExplicitInfo</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ExplicitInfo</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>getASTContext()</argument>)</argument_list></macro> <name>ExplicitSpecializationInfo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<name><name>ExplicitInfo</name><operator>-&gt;</operator><name>ExternLoc</name></name> <operator>=</operator> <name>Loc</name></block></expr>;
}</block>


<name>void</name> <macro><name>setTemplateKeywordLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ExplicitInfo</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ExplicitInfo</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>getASTContext()</argument>)</argument_list></macro> <name>ExplicitSpecializationInfo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<name><name>ExplicitInfo</name><operator>-&gt;</operator><name>TemplateKeywordLoc</name></name> <operator>=</operator> <name>Loc</name></block></expr>;
}</block>


<name>SourceLocation</name> <macro><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ExplicitInfo</name> <operator>?</operator> <name><name>ExplicitInfo</name><operator>-&gt;</operator><name>TemplateKeywordLoc</name></name> <operator>:</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name><name>TemplateArgs</name><operator>-&gt;</operator><name>asArray</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name>
<macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>ArrayRef&lt;TemplateArgument&gt; TemplateArgs</argument>,
<argument>ASTContext &amp;Context</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><call><name><name>TemplateArgs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>TemplateArgument</name> <modifier>&amp;</modifier></type><name>TemplateArg</name> <range>: <expr><name>TemplateArgs</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>TemplateArg</name><operator>.</operator><name>Profile</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{
<return>return <expr><name>K</name> <operator>&gt;=</operator> <name>firstClassTemplateSpecialization</name> <operator>&amp;&amp;</operator>
<name>K</name> <operator>&lt;=</operator> <name>lastClassTemplateSpecialization</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>ClassTemplatePartialSpecializationDecl</name>
<operator>:</operator> <name>public</name> <name>ClassTemplateSpecializationDecl</name> <block>{

<expr><name>TemplateParameterList</name><operator>*</operator> <name>TemplateParams</name> <operator>=</operator> <name>nullptr</name></expr>;



<expr><specifier>const</specifier> <name>ASTTemplateArgumentListInfo</name> <operator>*</operator><name>ArgsAsWritten</name> <operator>=</operator> <name>nullptr</name></expr>;






<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplatePartialSpecializationDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name>
<name>InstantiatedFromMember</name></expr>;

<macro><name>ClassTemplatePartialSpecializationDecl</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>TagKind TK</argument>,
<argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>,
<argument>TemplateParameterList *Params</argument>,
<argument>ClassTemplateDecl *SpecializedTemplate</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; Args</argument>,
<argument>const ASTTemplateArgumentListInfo *ArgsAsWritten</argument>,
<argument>ClassTemplatePartialSpecializationDecl *PrevDecl</argument>)</argument_list></macro>;

<expr><call><name>ClassTemplatePartialSpecializationDecl</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>ClassTemplateSpecializationDecl</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>ClassTemplatePartialSpecialization</name></expr></argument>)</argument_list></call></expr>,
<macro><name>InstantiatedFromMember</name><argument_list>(<argument>nullptr</argument>, <argument>false</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;

<expr><specifier>static</specifier> <name>ClassTemplatePartialSpecializationDecl</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>TagKind TK</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation IdLoc</argument>,
<argument>TemplateParameterList *Params</argument>,
<argument>ClassTemplateDecl *SpecializedTemplate</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; Args</argument>,
<argument>const TemplateArgumentListInfo &amp;ArgInfos</argument>,
<argument>QualType CanonInjectedType</argument>,
<argument>ClassTemplatePartialSpecializationDecl *PrevDecl</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>ClassTemplatePartialSpecializationDecl</name> <operator>*</operator>
<macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>ClassTemplatePartialSpecializationDecl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplatePartialSpecializationDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateSpecializationDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>TemplateParameterList</name> <operator>*</operator><macro><name>getTemplateParameters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TemplateParams</name></expr>;</return>
}</block>







<name>void</name> <macro><name>getAssociatedConstraints</name><argument_list>(<argument>llvm::SmallVectorImpl&lt;const Expr *&gt; &amp;AC</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name><name>TemplateParams</name><operator>-&gt;</operator><name>getAssociatedConstraints</name></name><argument_list>(<argument><expr><name>AC</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>bool</name> <macro><name>hasAssociatedConstraints</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>TemplateParams</name><operator>-&gt;</operator><name>hasAssociatedConstraints</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<specifier>const</specifier> <name>ASTTemplateArgumentListInfo</name> <operator>*</operator><macro><name>getTemplateArgsAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ArgsAsWritten</name></expr>;</return>
}</block>





















<name>ClassTemplatePartialSpecializationDecl</name> <operator>*</operator><macro><name>getInstantiatedFromMember</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>auto</name> <operator>*</operator><name>First</name> <operator>=</operator>
<call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplatePartialSpecializationDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>First</name><operator>-&gt;</operator><name>InstantiatedFromMember</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>ClassTemplatePartialSpecializationDecl</name> <operator>*</operator>
<macro><name>getInstantiatedFromMemberTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getInstantiatedFromMember</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setInstantiatedFromMember</name><argument_list>(
<argument>ClassTemplatePartialSpecializationDecl *PartialSpec</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <operator>*</operator><name>First</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplatePartialSpecializationDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>First</name><operator>-&gt;</operator><name>InstantiatedFromMember</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><name>PartialSpec</name></expr></argument>)</argument_list></call></expr>;
}</block>

















<name>bool</name> <macro><name>isMemberSpecialization</name><argument_list>()</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>auto</name> <operator>*</operator><name>First</name> <operator>=</operator>
<call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplatePartialSpecializationDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>First</name><operator>-&gt;</operator><name>InstantiatedFromMember</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>void</name> <macro><name>setMemberSpecialization</name><argument_list>()</argument_list></macro> <block>{
<expr><name>auto</name> <operator>*</operator><name>First</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplatePartialSpecializationDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>First</name><operator>-&gt;</operator><name>InstantiatedFromMember</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Only member templates can be member template specializations"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>First</name><operator>-&gt;</operator><name>InstantiatedFromMember</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>QualType</name> <macro><name>getInjectedSpecializationType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getTypeForDecl</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"partial specialization has no type set!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>InjectedClassNameType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getTypeForDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>getInjectedSpecializationType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getTemplateArgs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>asArray</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getTemplateParameters</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name>
<call><name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>TemplateArgs</name></expr></argument>,
<argument><expr><name>TemplateParameterList</name> <operator>*</operator><name>TPL</name></expr></argument>, <argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{
<return>return <expr><name>K</name> <operator>==</operator> <name>ClassTemplatePartialSpecialization</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>ClassTemplateDecl</name> <operator>:</operator> <name>public</name> <name>RedeclarableTemplateDecl</name> <block>{
<expr><name>protected</name><operator>:</operator>


struct <name>Common</name> <operator>:</operator> <name>CommonBase</name> <block>{


<expr><name>llvm</name><operator>::</operator><name><name>FoldingSetVector</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateSpecializationDecl</name></expr></argument>&gt;</argument_list></name> <name>Specializations</name></expr>;



<expr><name>llvm</name><operator>::</operator><name><name>FoldingSetVector</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplatePartialSpecializationDecl</name></expr></argument>&gt;</argument_list></name>
<name>PartialSpecializations</name></expr>;


<expr><name>QualType</name> <name>InjectedClassNameType</name></expr>;

<expr><call><name>Common</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
}</block></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>FoldingSetVector</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateSpecializationDecl</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator>
<macro><name>getSpecializations</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>llvm</name><operator>::</operator><name><name>FoldingSetVector</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplatePartialSpecializationDecl</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator>
<macro><name>getPartialSpecializations</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<macro><name>ClassTemplateDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>,
<argument>DeclarationName Name</argument>, <argument>TemplateParameterList *Params</argument>,
<argument>NamedDecl *Decl</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>RedeclarableTemplateDecl</name><argument_list>(<argument>ClassTemplate</argument>, <argument>C</argument>, <argument>DC</argument>, <argument>L</argument>, <argument>Name</argument>, <argument>Params</argument>, <argument>Decl</argument>)</argument_list></macro> <expr><block>{}</block>

<name>CommonBase</name> <operator>*</operator><macro><name>newCommon</name><argument_list>(<argument>ASTContext &amp;C</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>Common</name> <operator>*</operator><macro><name>getCommonPtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Common</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RedeclarableTemplateDecl</name><operator>::</operator><call><name>getCommonPtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;


<expr><name>void</name> <macro><name>LoadLazySpecializations</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>CXXRecordDecl</name> <operator>*</operator><macro><name>getTemplatedDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TemplatedDecl</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isThisDeclarationADefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTemplatedDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isThisDeclarationADefinition</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>ClassTemplateDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation L</argument>,
<argument>DeclarationName Name</argument>,
<argument>TemplateParameterList *Params</argument>,
<argument>NamedDecl *Decl</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>ClassTemplateDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;



<expr><name>ClassTemplateSpecializationDecl</name> <operator>*</operator>
<call><name>findSpecialization</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><operator>&amp;</operator><name>InsertPos</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <call><name>AddSpecialization</name><argument_list>(<argument><expr><name>ClassTemplateSpecializationDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>InsertPos</name></expr></argument>)</argument_list></call></expr>;

<expr><name>ClassTemplateDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>RedeclarableTemplateDecl</name><operator>::</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>ClassTemplateDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>RedeclarableTemplateDecl</name><operator>::</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>ClassTemplateDecl</name> <operator>*</operator><macro><name>getPreviousDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>RedeclarableTemplateDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>ClassTemplateDecl</name> <operator>*</operator><macro><name>getPreviousDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>RedeclarableTemplateDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>ClassTemplateDecl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>RedeclarableTemplateDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>ClassTemplateDecl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ClassTemplateDecl</name> <operator>*</operator><macro><name>getInstantiatedFromMemberTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>RedeclarableTemplateDecl</name><operator>::</operator><call><name>getInstantiatedFromMemberTemplate</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>ClassTemplatePartialSpecializationDecl</name> <operator>*</operator>
<call><name>findPartialSpecialization</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><name>TemplateParameterList</name> <operator>*</operator><name>TPL</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><operator>&amp;</operator><name>InsertPos</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <call><name>AddPartialSpecialization</name><argument_list>(<argument><expr><name>ClassTemplatePartialSpecializationDecl</name> <operator>*</operator><name>D</name></expr></argument>,
<argument><expr><name>void</name> <operator>*</operator><name>InsertPos</name></expr></argument>)</argument_list></call></expr>;


<expr><name>void</name> <macro><name>getPartialSpecializations</name><argument_list>(
<argument>SmallVectorImpl&lt;ClassTemplatePartialSpecializationDecl *&gt; &amp;PS</argument>)</argument_list></macro> <specifier>const</specifier></expr>;









<expr><name>ClassTemplatePartialSpecializationDecl</name> <operator>*</operator><macro><name>findPartialSpecialization</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro></expr>;









<expr><name>ClassTemplatePartialSpecializationDecl</name> <operator>*</operator>
<call><name>findPartialSpecInstantiatedFromMember</name><argument_list>(
<argument><expr><name>ClassTemplatePartialSpecializationDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;















<expr><name>QualType</name> <call><name>getInjectedClassNameSpecialization</name><argument_list>()</argument_list></call></expr>;

<expr><name>using</name> <name>spec_iterator</name> <operator>=</operator> <name><name>SpecIterator</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateSpecializationDecl</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>spec_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>spec_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>spec_range</name> <macro><name>specializations</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>spec_range</name><argument_list>(<argument><expr><call><name>spec_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>spec_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>spec_iterator</name> <macro><name>spec_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>makeSpecIterator</name><argument_list>(<argument><expr><call><name>getSpecializations</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>spec_iterator</name> <macro><name>spec_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>makeSpecIterator</name><argument_list>(<argument><expr><call><name>getSpecializations</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>ClassTemplate</name></expr>;</return> }</block>
}</expr>;














<expr><name>class</name> <name>FriendTemplateDecl</name> <operator>:</operator> <name>public</name> <name>Decl</name> <block>{
<expr><name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<name>using</name> <name>FriendUnion</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>,<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>private</name><operator>:</operator>

<name>unsigned</name> <name>NumParams</name> <operator>=</operator> <literal type="number">0</literal></expr>;


<expr><name>TemplateParameterList</name> <operator>*</operator><operator>*</operator><name>Params</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>FriendUnion</name> <name>Friend</name></expr>;


<expr><name>SourceLocation</name> <name>FriendLoc</name></expr>;

<macro><name>FriendTemplateDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation Loc</argument>,
<argument>MutableArrayRef&lt;TemplateParameterList *&gt; Params</argument>,
<argument>FriendUnion Friend</argument>, <argument>SourceLocation FriendLoc</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Decl</name><argument_list>(<argument><expr><name>Decl</name><operator>::</operator><name>FriendTemplate</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NumParams</name><argument_list>(<argument><expr><call><name><name>Params</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Params</name><argument_list>(<argument><expr><call><name><name>Params</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>, <expr><call><name>Friend</name><argument_list>(<argument><expr><name>Friend</name></expr></argument>)</argument_list></call></expr>, <macro><name>FriendLoc</name><argument_list>(<argument>FriendLoc</argument>)</argument_list></macro> <expr><block>{}</block>

<macro><name>FriendTemplateDecl</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Decl</name><argument_list>(<argument>Decl::FriendTemplate</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;

<expr><specifier>static</specifier> <name>FriendTemplateDecl</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation Loc</argument>,
<argument>MutableArrayRef&lt;TemplateParameterList *&gt; Params</argument>, <argument>FriendUnion Friend</argument>,
<argument>SourceLocation FriendLoc</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>FriendTemplateDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;




<expr><name>TypeSourceInfo</name> <operator>*</operator><macro><name>getFriendType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Friend</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>TypeSourceInfo</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>




<name>NamedDecl</name> <operator>*</operator><macro><name>getFriendDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Friend</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>NamedDecl</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getFriendLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>FriendLoc</name></expr>;</return>
}</block>

<name>TemplateParameterList</name> <operator>*</operator><macro><name>getTemplateParameterList</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;=</operator> <name>NumParams</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>Params</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumTemplateParameters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumParams</name></expr>;</return>
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>Decl</name><operator>::</operator><name>FriendTemplate</name></expr>;</return> }</block>
}</expr>;







<expr><name>class</name> <name>TypeAliasTemplateDecl</name> <operator>:</operator> <name>public</name> <name>RedeclarableTemplateDecl</name> <block>{
<expr><name>protected</name><operator>:</operator>
<name>using</name> <name>Common</name> <operator>=</operator> <name>CommonBase</name></expr>;

<macro><name>TypeAliasTemplateDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>,
<argument>DeclarationName Name</argument>, <argument>TemplateParameterList *Params</argument>,
<argument>NamedDecl *Decl</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>RedeclarableTemplateDecl</name><argument_list>(<argument>TypeAliasTemplate</argument>, <argument>C</argument>, <argument>DC</argument>, <argument>L</argument>, <argument>Name</argument>, <argument>Params</argument>,
<argument>Decl</argument>)</argument_list></macro> <expr><block>{}</block>

<name>CommonBase</name> <operator>*</operator><macro><name>newCommon</name><argument_list>(<argument>ASTContext &amp;C</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>Common</name> <operator>*</operator><macro><name>getCommonPtr</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Common</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RedeclarableTemplateDecl</name><operator>::</operator><call><name>getCommonPtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;


<expr><name>TypeAliasDecl</name> <operator>*</operator><macro><name>getTemplatedDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TypeAliasDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TemplatedDecl</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>TypeAliasTemplateDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>TypeAliasTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>RedeclarableTemplateDecl</name><operator>::</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>TypeAliasTemplateDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>TypeAliasTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>RedeclarableTemplateDecl</name><operator>::</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>TypeAliasTemplateDecl</name> <operator>*</operator><macro><name>getPreviousDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>TypeAliasTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>RedeclarableTemplateDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>TypeAliasTemplateDecl</name> <operator>*</operator><macro><name>getPreviousDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>TypeAliasTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>RedeclarableTemplateDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>TypeAliasTemplateDecl</name> <operator>*</operator><macro><name>getInstantiatedFromMemberTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>TypeAliasTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>RedeclarableTemplateDecl</name><operator>::</operator><call><name>getInstantiatedFromMemberTemplate</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>TypeAliasTemplateDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation L</argument>,
<argument>DeclarationName Name</argument>,
<argument>TemplateParameterList *Params</argument>,
<argument>NamedDecl *Decl</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>TypeAliasTemplateDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>TypeAliasTemplate</name></expr>;</return> }</block>
}</expr>;


















<expr><name>class</name> <name>ClassScopeFunctionSpecializationDecl</name> <operator>:</operator> <name>public</name> <name>Decl</name> <block>{
<expr><name>CXXMethodDecl</name> <operator>*</operator><name>Specialization</name></expr>;
<expr><specifier>const</specifier> <name>ASTTemplateArgumentListInfo</name> <operator>*</operator><name>TemplateArgs</name></expr>;

<macro><name>ClassScopeFunctionSpecializationDecl</name><argument_list>(
<argument>DeclContext *DC</argument>, <argument>SourceLocation Loc</argument>, <argument>CXXMethodDecl *FD</argument>,
<argument>const ASTTemplateArgumentListInfo *TemplArgs</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Decl</name><argument_list>(<argument><expr><name>Decl</name><operator>::</operator><name>ClassScopeFunctionSpecialization</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Specialization</name><argument_list>(<argument><expr><name>FD</name></expr></argument>)</argument_list></call></expr>, <macro><name>TemplateArgs</name><argument_list>(<argument>TemplArgs</argument>)</argument_list></macro> <expr><block>{}</block>

<macro><name>ClassScopeFunctionSpecializationDecl</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Decl</name><argument_list>(<argument>Decl::ClassScopeFunctionSpecialization</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;

<expr><name>CXXMethodDecl</name> <operator>*</operator><macro><name>getSpecialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Specialization</name></expr>;</return> }</block>
<name>bool</name> <macro><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TemplateArgs</name></expr>;</return> }</block>
<specifier>const</specifier> <name>ASTTemplateArgumentListInfo</name> <operator>*</operator><macro><name>getTemplateArgsAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TemplateArgs</name></expr>;</return>
}</block>

<specifier>static</specifier> <name>ClassScopeFunctionSpecializationDecl</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation Loc</argument>, <argument>CXXMethodDecl *FD</argument>,
<argument>bool HasExplicitTemplateArgs</argument>,
<argument>const TemplateArgumentListInfo &amp;TemplateArgs</argument>)</argument_list></macro> <block>{
<return>return <macro><name>new</name> <argument_list>(<argument>C</argument>, <argument>DC</argument>)</argument_list></macro> <expr><call><name>ClassScopeFunctionSpecializationDecl</name><argument_list>(
<argument><expr><name>DC</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>FD</name></expr></argument>,
<argument><expr><name>HasExplicitTemplateArgs</name>
<operator>?</operator> <name>ASTTemplateArgumentListInfo</name><operator>::</operator><call><name>Create</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>TemplateArgs</name></expr></argument>)</argument_list></call>
<operator>:</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>ClassScopeFunctionSpecializationDecl</name> <operator>*</operator>
<macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{
<return>return <expr><name>K</name> <operator>==</operator> <name>Decl</name><operator>::</operator><name>ClassScopeFunctionSpecialization</name></expr>;</return>
}</block>
}</expr>;














<expr><name>class</name> <name>VarTemplateSpecializationDecl</name> <operator>:</operator> <name>public</name> <name>VarDecl</name></expr>,
<expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{




struct <expr><name>SpecializedPartialSpecialization</name> <block>{


<expr><name>VarTemplatePartialSpecializationDecl</name> <operator>*</operator><name>PartialSpecialization</name></expr>;



<expr><specifier>const</specifier> <name>TemplateArgumentList</name> <operator>*</operator><name>TemplateArgs</name></expr>;
}</block></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplateDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>SpecializedPartialSpecialization</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>SpecializedTemplate</name></expr>;


struct <expr><name>ExplicitSpecializationInfo</name> <block>{

<expr><name>TypeSourceInfo</name> <operator>*</operator><name>TypeAsWritten</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>SourceLocation</name> <name>ExternLoc</name></expr>;


<expr><name>SourceLocation</name> <name>TemplateKeywordLoc</name></expr>;

<expr><call><name>ExplicitSpecializationInfo</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
}</block></expr>;



<expr><name>ExplicitSpecializationInfo</name> <operator>*</operator><name>ExplicitInfo</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><specifier>const</specifier> <name>TemplateArgumentList</name> <operator>*</operator><name>TemplateArgs</name></expr>;
<expr><name>TemplateArgumentListInfo</name> <name>TemplateArgsInfo</name></expr>;


<expr><name>SourceLocation</name> <name>PointOfInstantiation</name></expr>;



<expr><name>unsigned</name> <name>SpecializationKind</name> <operator>:</operator> <literal type="number">3</literal></expr>;





<expr><name>unsigned</name> <name>IsCompleteDefinition</name> <operator>:</operator> <literal type="number">1</literal></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>VarTemplateSpecializationDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>ASTContext &amp;Context</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation IdLoc</argument>,
<argument>VarTemplateDecl *SpecializedTemplate</argument>,
<argument>QualType T</argument>, <argument>TypeSourceInfo *TInfo</argument>,
<argument>StorageClass S</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; Args</argument>)</argument_list></macro></expr>;

<expr><name>explicit</name> <macro><name>VarTemplateSpecializationDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>ASTContext &amp;Context</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;
<expr><name>friend</name> <name>class</name> <name>VarDecl</name></expr>;

<expr><specifier>static</specifier> <name>VarTemplateSpecializationDecl</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>VarTemplateDecl *SpecializedTemplate</argument>, <argument>QualType T</argument>,
<argument>TypeSourceInfo *TInfo</argument>, <argument>StorageClass S</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; Args</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>VarTemplateSpecializationDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>,
<argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <macro><name>getNameForDiagnostic</name><argument_list>(<argument>raw_ostream &amp;OS</argument>, <argument>const PrintingPolicy &amp;Policy</argument>,
<argument>bool Qualified</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>VarTemplateSpecializationDecl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <block>{
<expr><name>VarDecl</name> <operator>*</operator><name>Recent</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplateSpecializationDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Recent</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>VarTemplateDecl</name> <operator>*</operator><macro><name>getSpecializedTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><specifier>const</specifier> <name>TemplateArgumentList</name> <operator>&amp;</operator><macro><name>getTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>TemplateArgs</name></expr>;</return> }</block>


<name>void</name> <call><name>setTemplateArgsInfo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <operator>&amp;</operator><name>ArgsInfo</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <operator>&amp;</operator><macro><name>getTemplateArgsInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TemplateArgsInfo</name></expr>;</return>
}</block>



<name>TemplateSpecializationKind</name> <macro><name>getSpecializationKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TemplateSpecializationKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SpecializationKind</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isExplicitSpecialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getSpecializationKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TSK_ExplicitSpecialization</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isClassScopeExplicitSpecialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isExplicitSpecialization</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getLexicalDeclContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>bool</name> <macro><name>isExplicitInstantiationOrSpecialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isTemplateExplicitInstantiationOrSpecialization</name><argument_list>(
<argument><expr><call><name>getTemplateSpecializationKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setSpecializationKind</name><argument_list>(<argument>TemplateSpecializationKind TSK</argument>)</argument_list></macro> <block>{
<expr><name>SpecializationKind</name> <operator>=</operator> <name>TSK</name></expr>;
}</block>


<name>SourceLocation</name> <macro><name>getPointOfInstantiation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PointOfInstantiation</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setPointOfInstantiation</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Loc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"point of instantiation must be valid!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>PointOfInstantiation</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>void</name> <macro><name>setCompleteDefinition</name><argument_list>()</argument_list></macro> <block>{ <expr><name>IsCompleteDefinition</name> <operator>=</operator> <name>true</name></expr>; }</block>





<name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplateDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>VarTemplatePartialSpecializationDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<macro><name>getInstantiatedFrom</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isTemplateInstantiation</name><argument_list>(<argument><expr><call><name>getSpecializationKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>llvm</name><operator>::</operator><call><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplateDecl</name> <operator>*</operator></expr></argument>,
<argument><expr><name>VarTemplatePartialSpecializationDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name>getSpecializedTemplateOrPartial</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplateDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>VarTemplatePartialSpecializationDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<macro><name>getSpecializedTemplateOrPartial</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>PartialSpec</name> <init>=
<expr><name><name>SpecializedTemplate</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>SpecializedPartialSpecialization</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>PartialSpec</name><operator>-&gt;</operator><name>PartialSpecialization</name></name></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><name><name>SpecializedTemplate</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>VarTemplateDecl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>












<specifier>const</specifier> <name>TemplateArgumentList</name> <operator>&amp;</operator><macro><name>getTemplateInstantiationArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>PartialSpec</name> <init>=
<expr><name><name>SpecializedTemplate</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>SpecializedPartialSpecialization</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>*</operator><name><name>PartialSpec</name><operator>-&gt;</operator><name>TemplateArgs</name></name></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name>getTemplateArgs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>




<name>void</name> <macro><name>setInstantiationOf</name><argument_list>(<argument>VarTemplatePartialSpecializationDecl *PartialSpec</argument>,
<argument>const TemplateArgumentList *TemplateArgs</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>SpecializedTemplate</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>SpecializedPartialSpecialization</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Already set to a variable template partial specialization!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <operator>*</operator><name>PS</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>getASTContext()</argument>)</argument_list></macro> <call><name>SpecializedPartialSpecialization</name><argument_list>()</argument_list></call></expr>;
<expr><name><name>PS</name><operator>-&gt;</operator><name>PartialSpecialization</name></name> <operator>=</operator> <name>PartialSpec</name></expr>;
<expr><name><name>PS</name><operator>-&gt;</operator><name>TemplateArgs</name></name> <operator>=</operator> <name>TemplateArgs</name></expr>;
<expr><name>SpecializedTemplate</name> <operator>=</operator> <name>PS</name></expr>;
}</block>



<name>void</name> <macro><name>setInstantiationOf</name><argument_list>(<argument>VarTemplateDecl *TemplDecl</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>SpecializedTemplate</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>SpecializedPartialSpecialization</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Previously set to a variable template partial specialization!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>SpecializedTemplate</name> <operator>=</operator> <name>TemplDecl</name></expr>;
}</block>



<name>void</name> <macro><name>setTypeAsWritten</name><argument_list>(<argument>TypeSourceInfo *T</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ExplicitInfo</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ExplicitInfo</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>getASTContext()</argument>)</argument_list></macro> <name>ExplicitSpecializationInfo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<name><name>ExplicitInfo</name><operator>-&gt;</operator><name>TypeAsWritten</name></name> <operator>=</operator> <name>T</name></block></expr>;
}</block>



<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ExplicitInfo</name> <operator>?</operator> <name><name>ExplicitInfo</name><operator>-&gt;</operator><name>TypeAsWritten</name></name> <operator>:</operator> <name>nullptr</name></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getExternLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><name>ExplicitInfo</name></expr> ?</condition><then> <expr><name><name>ExplicitInfo</name><operator>-&gt;</operator><name>ExternLoc</name></name></expr> </then><else>: <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>


<name>void</name> <macro><name>setExternLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ExplicitInfo</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ExplicitInfo</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>getASTContext()</argument>)</argument_list></macro> <name>ExplicitSpecializationInfo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<name><name>ExplicitInfo</name><operator>-&gt;</operator><name>ExternLoc</name></name> <operator>=</operator> <name>Loc</name></block></expr>;
}</block>


<name>void</name> <macro><name>setTemplateKeywordLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ExplicitInfo</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ExplicitInfo</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>getASTContext()</argument>)</argument_list></macro> <name>ExplicitSpecializationInfo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<name><name>ExplicitInfo</name><operator>-&gt;</operator><name>TemplateKeywordLoc</name></name> <operator>=</operator> <name>Loc</name></block></expr>;
}</block>


<name>SourceLocation</name> <macro><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ExplicitInfo</name> <operator>?</operator> <name><name>ExplicitInfo</name><operator>-&gt;</operator><name>TemplateKeywordLoc</name></name> <operator>:</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name><name>TemplateArgs</name><operator>-&gt;</operator><name>asArray</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; TemplateArgs</argument>,
<argument>ASTContext &amp;Context</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><call><name><name>TemplateArgs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>TemplateArgument</name> <modifier>&amp;</modifier></type><name>TemplateArg</name> <range>: <expr><name>TemplateArgs</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>TemplateArg</name><operator>.</operator><name>Profile</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{
<return>return <expr><name>K</name> <operator>&gt;=</operator> <name>firstVarTemplateSpecialization</name> <operator>&amp;&amp;</operator>
<name>K</name> <operator>&lt;=</operator> <name>lastVarTemplateSpecialization</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>VarTemplatePartialSpecializationDecl</name>
<operator>:</operator> <name>public</name> <name>VarTemplateSpecializationDecl</name> <block>{

<expr><name>TemplateParameterList</name> <operator>*</operator><name>TemplateParams</name> <operator>=</operator> <name>nullptr</name></expr>;



<expr><specifier>const</specifier> <name>ASTTemplateArgumentListInfo</name> <operator>*</operator><name>ArgsAsWritten</name> <operator>=</operator> <name>nullptr</name></expr>;






<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplatePartialSpecializationDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name>
<name>InstantiatedFromMember</name></expr>;

<macro><name>VarTemplatePartialSpecializationDecl</name><argument_list>(
<argument>ASTContext &amp;Context</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>TemplateParameterList *Params</argument>,
<argument>VarTemplateDecl *SpecializedTemplate</argument>, <argument>QualType T</argument>, <argument>TypeSourceInfo *TInfo</argument>,
<argument>StorageClass S</argument>, <argument>ArrayRef&lt;TemplateArgument&gt; Args</argument>,
<argument>const ASTTemplateArgumentListInfo *ArgInfos</argument>)</argument_list></macro>;

<expr><call><name>VarTemplatePartialSpecializationDecl</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>VarTemplateSpecializationDecl</name><argument_list>(<argument><expr><name>VarTemplatePartialSpecialization</name></expr></argument>,
<argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr>,
<macro><name>InstantiatedFromMember</name><argument_list>(<argument>nullptr</argument>, <argument>false</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;

<expr><specifier>static</specifier> <name>VarTemplatePartialSpecializationDecl</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>TemplateParameterList *Params</argument>,
<argument>VarTemplateDecl *SpecializedTemplate</argument>, <argument>QualType T</argument>,
<argument>TypeSourceInfo *TInfo</argument>, <argument>StorageClass S</argument>, <argument>ArrayRef&lt;TemplateArgument&gt; Args</argument>,
<argument>const TemplateArgumentListInfo &amp;ArgInfos</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>VarTemplatePartialSpecializationDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>,
<argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>VarTemplatePartialSpecializationDecl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplatePartialSpecializationDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplateSpecializationDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>TemplateParameterList</name> <operator>*</operator><macro><name>getTemplateParameters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TemplateParams</name></expr>;</return>
}</block>


<specifier>const</specifier> <name>ASTTemplateArgumentListInfo</name> <operator>*</operator><macro><name>getTemplateArgsAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ArgsAsWritten</name></expr>;</return>
}</block>







<name>void</name> <macro><name>getAssociatedConstraints</name><argument_list>(<argument>llvm::SmallVectorImpl&lt;const Expr *&gt; &amp;AC</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name><name>TemplateParams</name><operator>-&gt;</operator><name>getAssociatedConstraints</name></name><argument_list>(<argument><expr><name>AC</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>bool</name> <macro><name>hasAssociatedConstraints</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>TemplateParams</name><operator>-&gt;</operator><name>hasAssociatedConstraints</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>





















<name>VarTemplatePartialSpecializationDecl</name> <operator>*</operator><macro><name>getInstantiatedFromMember</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>auto</name> <operator>*</operator><name>First</name> <operator>=</operator>
<call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplatePartialSpecializationDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>First</name><operator>-&gt;</operator><name>InstantiatedFromMember</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name>
<macro><name>setInstantiatedFromMember</name><argument_list>(<argument>VarTemplatePartialSpecializationDecl *PartialSpec</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <operator>*</operator><name>First</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplatePartialSpecializationDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>First</name><operator>-&gt;</operator><name>InstantiatedFromMember</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><name>PartialSpec</name></expr></argument>)</argument_list></call></expr>;
}</block>

















<name>bool</name> <macro><name>isMemberSpecialization</name><argument_list>()</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>auto</name> <operator>*</operator><name>First</name> <operator>=</operator>
<call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplatePartialSpecializationDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>First</name><operator>-&gt;</operator><name>InstantiatedFromMember</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>void</name> <macro><name>setMemberSpecialization</name><argument_list>()</argument_list></macro> <block>{
<expr><name>auto</name> <operator>*</operator><name>First</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplatePartialSpecializationDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>First</name><operator>-&gt;</operator><name>InstantiatedFromMember</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Only member templates can be member template specializations"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>First</name><operator>-&gt;</operator><name>InstantiatedFromMember</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getTemplateArgs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>asArray</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getTemplateParameters</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name>
<call><name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>TemplateArgs</name></expr></argument>,
<argument><expr><name>TemplateParameterList</name> <operator>*</operator><name>TPL</name></expr></argument>, <argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{
<return>return <expr><name>K</name> <operator>==</operator> <name>VarTemplatePartialSpecialization</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>VarTemplateDecl</name> <operator>:</operator> <name>public</name> <name>RedeclarableTemplateDecl</name> <block>{
<expr><name>protected</name><operator>:</operator>


struct <name>Common</name> <operator>:</operator> <name>CommonBase</name> <block>{


<expr><name>llvm</name><operator>::</operator><name><name>FoldingSetVector</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplateSpecializationDecl</name></expr></argument>&gt;</argument_list></name> <name>Specializations</name></expr>;



<expr><name>llvm</name><operator>::</operator><name><name>FoldingSetVector</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplatePartialSpecializationDecl</name></expr></argument>&gt;</argument_list></name>
<name>PartialSpecializations</name></expr>;

<expr><call><name>Common</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
}</block></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>FoldingSetVector</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplateSpecializationDecl</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator>
<macro><name>getSpecializations</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>llvm</name><operator>::</operator><name><name>FoldingSetVector</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplatePartialSpecializationDecl</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator>
<macro><name>getPartialSpecializations</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<macro><name>VarTemplateDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>,
<argument>DeclarationName Name</argument>, <argument>TemplateParameterList *Params</argument>,
<argument>NamedDecl *Decl</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>RedeclarableTemplateDecl</name><argument_list>(<argument>VarTemplate</argument>, <argument>C</argument>, <argument>DC</argument>, <argument>L</argument>, <argument>Name</argument>, <argument>Params</argument>, <argument>Decl</argument>)</argument_list></macro> <expr><block>{}</block>

<name>CommonBase</name> <operator>*</operator><macro><name>newCommon</name><argument_list>(<argument>ASTContext &amp;C</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>Common</name> <operator>*</operator><macro><name>getCommonPtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Common</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RedeclarableTemplateDecl</name><operator>::</operator><call><name>getCommonPtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;


<expr><name>void</name> <macro><name>LoadLazySpecializations</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>VarDecl</name> <operator>*</operator><macro><name>getTemplatedDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TemplatedDecl</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isThisDeclarationADefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTemplatedDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isThisDeclarationADefinition</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>VarTemplateDecl</name> <operator>*</operator><call><name>getDefinition</name><argument_list>()</argument_list></call></expr>;


<expr><specifier>static</specifier> <name>VarTemplateDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation L</argument>, <argument>DeclarationName Name</argument>,
<argument>TemplateParameterList *Params</argument>,
<argument>VarDecl *Decl</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>VarTemplateDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;



<expr><name>VarTemplateSpecializationDecl</name> <operator>*</operator>
<call><name>findSpecialization</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><operator>&amp;</operator><name>InsertPos</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <call><name>AddSpecialization</name><argument_list>(<argument><expr><name>VarTemplateSpecializationDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>InsertPos</name></expr></argument>)</argument_list></call></expr>;

<expr><name>VarTemplateDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RedeclarableTemplateDecl</name><operator>::</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>VarTemplateDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RedeclarableTemplateDecl</name><operator>::</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>VarTemplateDecl</name> <operator>*</operator><macro><name>getPreviousDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>RedeclarableTemplateDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>VarTemplateDecl</name> <operator>*</operator><macro><name>getPreviousDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>RedeclarableTemplateDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>VarTemplateDecl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>RedeclarableTemplateDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>VarTemplateDecl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplateDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>VarTemplateDecl</name> <operator>*</operator><macro><name>getInstantiatedFromMemberTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>RedeclarableTemplateDecl</name><operator>::</operator><call><name>getInstantiatedFromMemberTemplate</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>VarTemplatePartialSpecializationDecl</name> <operator>*</operator>
<call><name>findPartialSpecialization</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><name>TemplateParameterList</name> <operator>*</operator><name>TPL</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><operator>&amp;</operator><name>InsertPos</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <call><name>AddPartialSpecialization</name><argument_list>(<argument><expr><name>VarTemplatePartialSpecializationDecl</name> <operator>*</operator><name>D</name></expr></argument>,
<argument><expr><name>void</name> <operator>*</operator><name>InsertPos</name></expr></argument>)</argument_list></call></expr>;


<expr><name>void</name> <macro><name>getPartialSpecializations</name><argument_list>(
<argument>SmallVectorImpl&lt;VarTemplatePartialSpecializationDecl *&gt; &amp;PS</argument>)</argument_list></macro> <specifier>const</specifier></expr>;











<expr><name>VarTemplatePartialSpecializationDecl</name> <operator>*</operator><call><name>findPartialSpecInstantiatedFromMember</name><argument_list>(
<argument><expr><name>VarTemplatePartialSpecializationDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;

<expr><name>using</name> <name>spec_iterator</name> <operator>=</operator> <name><name>SpecIterator</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplateSpecializationDecl</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>spec_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>spec_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>spec_range</name> <macro><name>specializations</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>spec_range</name><argument_list>(<argument><expr><call><name>spec_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>spec_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>spec_iterator</name> <macro><name>spec_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>makeSpecIterator</name><argument_list>(<argument><expr><call><name>getSpecializations</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>spec_iterator</name> <macro><name>spec_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>makeSpecIterator</name><argument_list>(<argument><expr><call><name>getSpecializations</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>VarTemplate</name></expr>;</return> }</block>
}</expr>;


<expr><name>class</name> <name>ConceptDecl</name> <operator>:</operator> <name>public</name> <name>TemplateDecl</name></expr>, <expr><name>public</name> <name><name>Mergeable</name><argument_list type="generic">&lt;<argument><expr><name>ConceptDecl</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>protected</name><operator>:</operator>
<name>Expr</name> <operator>*</operator><name>ConstraintExpr</name></expr>;

<macro><name>ConceptDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>, <argument>DeclarationName Name</argument>,
<argument>TemplateParameterList *Params</argument>, <argument>Expr *ConstraintExpr</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>TemplateDecl</name><argument_list>(<argument><expr><name>Concept</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>L</name></expr></argument>, <argument><expr><name>Name</name></expr></argument>, <argument><expr><name>Params</name></expr></argument>)</argument_list></call></expr>,
<macro><name>ConstraintExpr</name><argument_list>(<argument>ConstraintExpr</argument>)</argument_list></macro> <expr><block>{}</block></expr>;
<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>ConceptDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation L</argument>, <argument>DeclarationName Name</argument>,
<argument>TemplateParameterList *Params</argument>,
<argument>Expr *ConstraintExpr</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>ConceptDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>Expr</name> <operator>*</operator><macro><name>getConstraintExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ConstraintExpr</name></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getTemplateParameters</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTemplateLoc</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>ConstraintExpr</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isTypeConcept</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>TemplateTypeParmDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getTemplateParameters</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getParam</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>ConceptDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{ <return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>ConceptDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>Concept</name></expr>;</return> }</block>

<name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;
}</block></expr>;













<expr><name>class</name> <name>TemplateParamObjectDecl</name> <operator>:</operator> <name>public</name> <name>ValueDecl</name></expr>,
<expr><name>public</name> <name><name>Mergeable</name><argument_list type="generic">&lt;<argument><expr><name>TemplateParamObjectDecl</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>private</name><operator>:</operator>

<name>APValue</name> <name>Value</name></expr>;

<macro><name>TemplateParamObjectDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>QualType T</argument>, <argument>const APValue &amp;V</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>ValueDecl</name><argument_list>(<argument><expr><name>TemplateParamObject</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>DeclarationName</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Value</name><argument_list>(<argument>V</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>TemplateParamObjectDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>QualType T</argument>,
<argument>const APValue &amp;V</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>TemplateParamObjectDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>,
<argument>unsigned ID</argument>)</argument_list></macro></expr>;



<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;

<expr><name>public</name><operator>:</operator>

<name>void</name> <macro><name>printName</name><argument_list>(<argument>llvm::raw_ostream &amp;OS</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;


<expr><name>void</name> <macro><name>printAsExpr</name><argument_list>(<argument>llvm::raw_ostream &amp;OS</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>void</name> <macro><name>printAsInit</name><argument_list>(<argument>llvm::raw_ostream &amp;OS</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>const</specifier> <name>APValue</name> <operator>&amp;</operator><macro><name>getValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Value</name></expr>;</return> }</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>QualType T</argument>,
<argument>const APValue &amp;V</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>T</name><operator>.</operator><name>getCanonicalType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAsOpaquePtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>V</name><operator>.</operator><name>Profile</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getValue</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>TemplateParamObjectDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>TemplateParamObjectDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>TemplateParamObject</name></expr>;</return> }</block>
}</expr>;

<expr><specifier>inline</specifier> <name>NamedDecl</name> <operator>*</operator><macro><name>getAsNamedDecl</name><argument_list>(<argument>TemplateParameter P</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>PD</name> <operator>=</operator> <name><name>P</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>TemplateTypeParmDecl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>PD</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>PD</name> <operator>=</operator> <name><name>P</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>NonTypeTemplateParmDecl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>PD</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name><name>P</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>TemplateTemplateParmDecl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>

<specifier>inline</specifier> <name>TemplateDecl</name> <operator>*</operator><macro><name>getAsTypeTemplateDecl</name><argument_list>(<argument>Decl *D</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <operator>*</operator><name>TD</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>TemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><ternary><condition><expr><name>TD</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TD</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplatePartialSpecializationDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TD</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>TypeAliasTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TD</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>TemplateTemplateParmDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TD</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
?</condition><then> <expr><name>TD</name></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>












<specifier>inline</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <macro><name>getExpandedPackSize</name><argument_list>(<argument>const NamedDecl *Param</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>TTP</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>TemplateTypeParmDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>TTP</name><operator>-&gt;</operator><name>isExpandedParameterPack</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>TTP</name><operator>-&gt;</operator><name>getNumExpansionParameters</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/>}</block_content>

if (const auto *NTTP = dyn_cast&lt;NonTypeTemplateParmDecl&gt;(Param</block></if></if_stmt>))</block> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>NTTP</name><operator>-&gt;</operator><name>isExpandedParameterPack</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>NTTP</name><operator>-&gt;</operator><name>getNumExpansionTypes</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
}</block></expr>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>TTP</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>TemplateTemplateParmDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>TTP</name><operator>-&gt;</operator><name>isExpandedParameterPack</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>TTP</name><operator>-&gt;</operator><name>getNumExpansionTemplateParameters</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/>}</block_content>

return None</block><empty_stmt>;</empty_stmt></if></if_stmt>
}</block>

}</expr></block></expr></block></expr></range></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
