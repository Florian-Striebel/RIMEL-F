<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/CanonicalType.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_CANONICALTYPE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_CANONICALTYPE_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Diagnostic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/FoldingSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/PointerLikeTypeTraits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iterator&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;type_traits&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>CanProxy</name></decl>;</decl_stmt>
<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator> struct <name>CanProxyAdaptor</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXRecordDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>EnumDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>IdentifierInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCInterfaceDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>RecordDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TagDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateTypeParmDecl</name></decl>;</decl_stmt>























<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name> <operator>=</operator> <name>Type</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>CanQual</name> <block>{<block_content>

<decl_stmt><decl><type><name>QualType</name></type> <name>Stored</name></decl>;</decl_stmt>

<label><name>public</name>:</label>

<expr_stmt><expr><call><name>CanQual</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name></type>
<name>CanQual</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Other</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>enable_if_t</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>, <argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <operator>=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>





<expr_stmt><expr><specifier>const</specifier> <name>T</name> <operator>*</operator><macro><name>getTypePtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Stored</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>T</name> <operator>*</operator><macro><name>getTypePtrOrNull</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Stored</name><operator>.</operator><name>getTypePtrOrNull</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>operator</name> <macro><name>QualType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Stored</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>explicit</name> <name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isNull</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Stored</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>SplitQualType</name> <macro><name>split</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Stored</name><operator>.</operator><name>split</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


















<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name> <name><name>CanProxy</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <macro><name>getAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name> <name><name>CanProxy</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <macro><name>castAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name><name>CanProxy</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>)</block_content> const</block></decl>;</decl_stmt>


<expr_stmt><expr><name>Qualifiers</name> <macro><name>getQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Stored</name><operator>.</operator><name>getLocalQualifiers</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getCVRQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Stored</name><operator>.</operator><name>getLocalCVRQualifiers</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Stored</name><operator>.</operator><name>hasLocalQualifiers</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isConstQualified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Stored</name><operator>.</operator><name>isLocalConstQualified</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isVolatileQualified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Stored</name><operator>.</operator><name>isLocalVolatileQualified</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isRestrictQualified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Stored</name><operator>.</operator><name>isLocalRestrictQualified</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>isCanonicalAsParam</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Stored</name><operator>.</operator><name>isCanonicalAsParam</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>getUnqualifiedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>QualType</name> <macro><name>withConst</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Stored</name><operator>.</operator><name>withConst</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isMoreQualifiedThan</name><argument_list>(<argument><expr><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name>Other</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>Stored</name><operator>.</operator><name>isMoreQualifiedThan</name></name><argument_list>(<argument><expr><name><name>Other</name><operator>.</operator><name>Stored</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isAtLeastAsQualifiedAs</name><argument_list>(<argument><expr><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name>Other</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>Stored</name><operator>.</operator><name>isAtLeastAsQualifiedAs</name></name><argument_list>(<argument><expr><name><name>Other</name><operator>.</operator><name>Stored</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>Type</name></expr></argument>&gt;</argument_list></name> <macro><name>getNonReferenceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>void</name> <operator>*</operator><macro><name>getAsOpaquePtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Stored</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<function_decl><type><specifier>static</specifier> <name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>getFromOpaquePtr</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>Ptr</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><specifier>static</specifier> <name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>CreateUnsafe</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Other</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <expr><call><name><name>Stored</name><operator>.</operator><name>dump</name></name><argument_list>()</argument_list></call></expr>; }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name>getAsOpaquePtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name>x</name><operator>,</operator> <name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <name>y</name><operator>)</operator> <block>{
<return>return <expr><call><name><name>x</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>y</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name>x</name><operator>,</operator> <name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <name>y</name><operator>)</operator> <block>{
<return>return <expr><call><name><name>x</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>y</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>CanQualType</name> <init>= <expr><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>Type</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>CanQualType</name> <name>Type</name><operator>::</operator><macro><name>getCanonicalTypeUnqualified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>CanQualType</name><operator>::</operator><call><name>CreateUnsafe</name><argument_list>(<argument><expr><call><name>getCanonicalTypeInternal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>inline</specifier> <specifier>const</specifier> <name>StreamingDiagnostic</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><specifier>const</specifier> <name>StreamingDiagnostic</name> <operator>&amp;</operator><name>DB</name><operator>,</operator>
<name>CanQualType</name> <name>T</name><operator>)</operator> <block>{
<expr><name>DB</name> <operator>&lt;&lt;</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>DB</name></expr>;</return>
}</block></expr></expr_stmt>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><parameter_list>(<parameter><type><name>Accessor</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CanQualType Accessor() const { return CanQualType::CreateUnsafe(this-&gt;getTypePtr()-&gt;Accessor()); }</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><parameter_list>(<parameter><type><name>Type</name></type></parameter>, <parameter><type><name>Accessor</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Type Accessor() const { return this-&gt;getTypePtr()-&gt;Accessor(); }</cpp:value></cpp:define>




<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>CanProxyBase</name> <block>{<block_content>
<label><name>protected</name>:</label>
<decl_stmt><decl><type><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>Stored</name></decl>;</decl_stmt>

<label><name>public</name>:</label>

<expr_stmt><expr><specifier>const</specifier> <name>T</name> <operator>*</operator><macro><name>getTypePtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Stored</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>








<expr_stmt><expr><name>operator</name> <specifier>const</specifier> <name>T</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>Stored</name><operator>.</operator><name>getTypePtrOrNull</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name> <name><name>CanProxy</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <macro><name>getAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>this</name><operator>-&gt;</operator><name>Stored</name><operator>.</operator><name>template</name></name> <call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>Type::TypeClass</argument>, <argument>getTypeClass</argument>)</argument_list></macro>


<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isObjectType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isIncompleteType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isSizelessType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isSizelessBuiltinType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isIncompleteOrObjectType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isVariablyModifiedType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isIntegerType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isEnumeralType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isBooleanType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isCharType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isWideCharType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isIntegralType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isIntegralOrEnumerationType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isRealFloatingType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isComplexType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isAnyComplexType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isFloatingType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isRealType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isArithmeticType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isVoidType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isDerivedType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isScalarType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isAggregateType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isAnyPointerType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isVoidPointerType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isFunctionPointerType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isMemberFunctionPointerType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isClassType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isStructureType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isInterfaceType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isStructureOrClassType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isUnionType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isComplexIntegerType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isNullPtrType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isDependentType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isOverloadableType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isArrayType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>hasPointerRepresentation</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>hasObjCPointerRepresentation</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>hasIntegerRepresentation</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>hasSignedIntegerRepresentation</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>hasUnsignedIntegerRepresentation</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>hasFloatingRepresentation</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isPromotableIntegerType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isSignedIntegerType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isUnsignedIntegerType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isSignedIntegerOrEnumerationType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isUnsignedIntegerOrEnumerationType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isConstantSizeType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isSpecifierType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>CXXRecordDecl*</argument>, <argument>getAsCXXRecordDecl</argument>)</argument_list></macro>







<expr_stmt><expr><specifier>const</specifier> <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <operator>*</operator><name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>)</block_content> const <block>{<block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></block></decl></decl_stmt>
};











<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
struct</type> <name>CanProxyAdaptor</name> <range>: <expr><name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{}</block></expr></range></decl>;</decl_stmt>








<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>CanProxy</name> <range>: <expr><name>public</name> <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>

<call><name>CanProxy</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;


<macro><name>CanProxy</name><argument_list>(<argument>CanQual&lt;T&gt; Stored</argument>)</argument_list></macro> <expr><block>{ <expr><name><name>this</name><operator>-&gt;</operator><name>Stored</name></name> <operator>=</operator> <name>Stored</name></expr>; }</block>


<name>operator</name> <macro><name>CanQual</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name><name>this</name><operator>-&gt;</operator><name>Stored</name></name></expr>;</return> }</block>
}</expr>;

}</block>

<name>namespace</name> <name>llvm</name> <block>{




<expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
struct <name><name>simplify_type</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>using</name> <name>SimpleType</name> <operator>=</operator> <specifier>const</specifier> <name>T</name> <operator>*</operator></expr>;

<expr><specifier>static</specifier> <name>SimpleType</name> <macro><name>getSimplifiedValue</name><argument_list>(<argument>::clang::CanQual&lt;T&gt; Val</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Val</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
struct <name><name>PointerLikeTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <name>void</name> <operator>*</operator><macro><name>getAsVoidPointer</name><argument_list>(<argument>clang::CanQual&lt;T&gt; P</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>P</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>clang</name><operator>::</operator><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>getFromVoidPointer</name><argument_list>(<argument>void *P</argument>)</argument_list></macro> <block>{
<return>return <expr><name>clang</name><operator>::</operator><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>getFromOpaquePtr</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>constexpr</name> <name>int</name> <name>NumLowBitsAvailable</name> <operator>=</operator> <literal type="number">0</literal></expr>;
}</block></expr>;

}</block>

<name>namespace</name> <name>clang</name> <block>{







<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>InputIterator</name></expr></argument>&gt;</argument_list></name>
struct <name>CanTypeIterator</name>
<operator>:</operator> <name>llvm</name><operator>::</operator><name><name>iterator_adaptor_base</name><argument_list type="generic">&lt;
<argument><expr><name><name>CanTypeIterator</name><argument_list type="generic">&lt;<argument><expr><name>InputIterator</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>InputIterator</name></expr></argument>,
<argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>iterator_traits</name><argument_list type="generic">&lt;<argument><expr><name>InputIterator</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator_category</name></expr></argument>,
<argument><expr><name>CanQualType</name></expr></argument>,
<argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>iterator_traits</name><argument_list type="generic">&lt;<argument><expr><name>InputIterator</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>difference_type</name></expr></argument>,
<argument><expr><name><name>CanProxy</name><argument_list type="generic">&lt;<argument><expr><name>Type</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>CanQualType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><call><name>CanTypeIterator</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><name>explicit</name> <macro><name>CanTypeIterator</name><argument_list>(<argument>InputIterator Iter</argument>)</argument_list></macro>
<operator>:</operator> <name>CanTypeIterator</name><operator>::</operator><macro><name>iterator_adaptor_base</name><argument_list>(<argument>std::move(Iter)</argument>)</argument_list></macro> <block>{}</block>

<name>CanQualType</name> <name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>CanQualType</name><operator>::</operator><call><name>CreateUnsafe</name><argument_list>(<argument><expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>I</name></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name><name>CanProxy</name><argument_list type="generic">&lt;<argument><expr><name>Type</name></expr></argument>&gt;</argument_list></name> <name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr>) <specifier>const</specifier></block></expr>;
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>ComplexType</name></expr></argument>&gt;</argument_list></name> <operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>ComplexType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getElementType</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>PointerType</name></expr></argument>&gt;</argument_list></name> <operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>PointerType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getPointeeType</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>BlockPointerType</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>BlockPointerType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getPointeeType</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>ReferenceType</name></expr></argument>&gt;</argument_list></name> <operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>ReferenceType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getPointeeType</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>LValueReferenceType</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>LValueReferenceType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getPointeeType</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>RValueReferenceType</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>RValueReferenceType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getPointeeType</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>MemberPointerType</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>MemberPointerType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getPointeeType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>const Type *</argument>, <argument>getClass</argument>)</argument_list></macro>
}</block></expr>;



<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>ArrayType</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>ConstantArrayType</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>IncompleteArrayType</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>VariableArrayType</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>DependentSizedArrayType</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>DependentSizedExtVectorType</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>DependentSizedExtVectorType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getElementType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>const Expr *</argument>, <argument>getSizeExpr</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>SourceLocation</argument>, <argument>getAttributeLoc</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>VectorType</name></expr></argument>&gt;</argument_list></name> <operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>VectorType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getElementType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>unsigned</argument>, <argument>getNumElements</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>ExtVectorType</name></expr></argument>&gt;</argument_list></name> <operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>ExtVectorType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getElementType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>unsigned</argument>, <argument>getNumElements</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>FunctionType</name></expr></argument>&gt;</argument_list></name> <operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>FunctionType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getReturnType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>FunctionType::ExtInfo</argument>, <argument>getExtInfo</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>FunctionNoProtoType</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>FunctionNoProtoType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getReturnType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>FunctionType::ExtInfo</argument>, <argument>getExtInfo</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getReturnType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>FunctionType::ExtInfo</argument>, <argument>getExtInfo</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>unsigned</argument>, <argument>getNumParams</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>hasExtParameterInfos</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(
<argument>ArrayRef&lt;FunctionProtoType::ExtParameterInfo&gt;</argument>, <argument>getExtParameterInfos</argument>)</argument_list></macro>

<expr><name>CanQualType</name> <macro><name>getParamType</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>CanQualType</name><operator>::</operator><call><name>CreateUnsafe</name><argument_list>(<argument><expr><call><name><name>this</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getParamType</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isVariadic</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>Qualifiers</argument>, <argument>getMethodQuals</argument>)</argument_list></macro>

<name>using</name> <name>param_type_iterator</name> <operator>=</operator>
<name><name>CanTypeIterator</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name><operator>::</operator><name>param_type_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>param_type_iterator</name> <macro><name>param_type_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>param_type_iterator</name><argument_list>(<argument><expr><call><name><name>this</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>param_type_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>param_type_iterator</name> <macro><name>param_type_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>param_type_iterator</name><argument_list>(<argument><expr><call><name><name>this</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>param_type_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


}</expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>TypeOfType</name></expr></argument>&gt;</argument_list></name> <operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>TypeOfType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getUnderlyingType</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>DecltypeType</name></expr></argument>&gt;</argument_list></name> <operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>DecltypeType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>Expr *</argument>, <argument>getUnderlyingExpr</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getUnderlyingType</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>UnaryTransformType</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>UnaryTransformType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getBaseType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getUnderlyingType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>UnaryTransformType::UTTKind</argument>, <argument>getUTTKind</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>TagType</name></expr></argument>&gt;</argument_list></name> <operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>TagType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>TagDecl *</argument>, <argument>getDecl</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isBeingDefined</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>RecordType</name></expr></argument>&gt;</argument_list></name> <operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>RecordType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>RecordDecl *</argument>, <argument>getDecl</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isBeingDefined</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>hasConstFields</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>EnumType</name></expr></argument>&gt;</argument_list></name> <operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>EnumType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>EnumDecl *</argument>, <argument>getDecl</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isBeingDefined</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>TemplateTypeParmType</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>TemplateTypeParmType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>unsigned</argument>, <argument>getDepth</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>unsigned</argument>, <argument>getIndex</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isParameterPack</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>TemplateTypeParmDecl *</argument>, <argument>getDecl</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>IdentifierInfo *</argument>, <argument>getIdentifier</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectType</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getBaseType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>const ObjCInterfaceDecl *</argument>,
<argument>getInterface</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isObjCUnqualifiedId</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isObjCUnqualifiedClass</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isObjCQualifiedId</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isObjCQualifiedClass</argument>)</argument_list></macro>

<expr><name>using</name> <name>qual_iterator</name> <operator>=</operator> <name>ObjCObjectPointerType</name><operator>::</operator><name>qual_iterator</name></expr>;

<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>qual_iterator</argument>, <argument>qual_begin</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>qual_iterator</argument>, <argument>qual_end</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>qual_empty</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>unsigned</argument>, <argument>getNumProtocols</argument>)</argument_list></macro>
}</block></expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>CanProxyAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectPointerType</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name><name>CanProxyBase</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectPointerType</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>LLVM_CLANG_CANPROXY_TYPE_ACCESSOR</name><argument_list>(<argument>getPointeeType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>const ObjCInterfaceType *</argument>,
<argument>getInterfaceType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isObjCIdType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isObjCClassType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isObjCQualifiedIdType</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>isObjCQualifiedClassType</argument>)</argument_list></macro>

<expr><name>using</name> <name>qual_iterator</name> <operator>=</operator> <name>ObjCObjectPointerType</name><operator>::</operator><name>qual_iterator</name></expr>;

<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>qual_iterator</argument>, <argument>qual_begin</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>qual_iterator</argument>, <argument>qual_end</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>bool</argument>, <argument>qual_empty</argument>)</argument_list></macro>
<macro><name>LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR</name><argument_list>(<argument>unsigned</argument>, <argument>getNumProtocols</argument>)</argument_list></macro>
}</block></expr>;




<expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>getUnqualifiedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>CreateUnsafe</name><argument_list>(<argument><expr><call><name><name>Stored</name><operator>.</operator><name>getLocalUnqualifiedType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>Type</name></expr></argument>&gt;</argument_list></name> <name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>getNonReferenceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>ReferenceType</name></expr></argument>&gt;</argument_list></name></type> <name>RefType</name> <init>= <expr><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>ReferenceType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>RefType</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return></block_content></block></else></if_stmt>
}</block>

<name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>getFromOpaquePtr</name><argument_list>(<argument>void *Ptr</argument>)</argument_list></macro> <block>{
<expr><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name>Result</name></expr>;
<expr><name><name>Result</name><operator>.</operator><name>Stored</name></name> <operator>=</operator> <name>QualType</name><operator>::</operator><call><name>getFromOpaquePtr</name><argument_list>(<argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>!</operator><name>Result</name> <operator>||</operator> <call><name><name>Result</name><operator>.</operator><name>Stored</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call> <operator>==</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>-</operator><literal type="number">1</literal> <operator>||</operator>
<call><name><name>Result</name><operator>.</operator><name>Stored</name><operator>.</operator><name>isCanonical</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Type is not canonical!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Result</name></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>CreateUnsafe</name><argument_list>(<argument>QualType Other</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name><name>Other</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>Other</name><operator>.</operator><name>isCanonical</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Type is not canonical!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name><name>Other</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Other</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Dynamic type does not meet the static type's requires"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name>Result</name></expr>;
<expr><name><name>Result</name><operator>.</operator><name>Stored</name></name> <operator>=</operator> <name>Other</name></expr>;
<return>return <expr><name>Result</name></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
<name><name>CanProxy</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>getAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>TypeIsArrayType</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"ArrayType cannot be used with getAs!"</literal></expr></argument>)</argument_list></call></expr>;

<if_stmt><if>if <condition>(<expr><call><name><name>Stored</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>CanProxy</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Stored</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>CreateUnsafe</name><argument_list>(<argument><expr><name>Stored</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name><name>CanProxy</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
<name><name>CanProxy</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>castAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>TypeIsArrayType</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"ArrayType cannot be used with castAs!"</literal></expr></argument>)</argument_list></call></expr>;

<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>Stored</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Stored</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>CreateUnsafe</name><argument_list>(<argument><expr><name>Stored</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>CanProxy</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>) <expr_stmt><expr><specifier>const</specifier> <block>{
<return>return <expr><call><name><name>CanProxy</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>InputIterator</name></expr></argument>&gt;</argument_list></name>
<name><name>CanProxy</name><argument_list type="generic">&lt;<argument><expr><name>Type</name></expr></argument>&gt;</argument_list></name> <name><name>CanTypeIterator</name><argument_list type="generic">&lt;<argument><expr><name>InputIterator</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>) <expr_stmt><expr><specifier>const</specifier> <block>{
<return>return <expr><call><name><name>CanProxy</name><argument_list type="generic">&lt;<argument><expr><name>Type</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
