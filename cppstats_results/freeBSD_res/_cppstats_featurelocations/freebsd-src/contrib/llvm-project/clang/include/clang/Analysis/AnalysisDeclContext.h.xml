<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Analysis/AnalysisDeclContext.h">















<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_ANALYSIS_ANALYSISDECLCONTEXT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_ANALYSIS_ANALYSISDECLCONTEXT_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclBase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/BodyFarm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/CFG.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/CodeInjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/FoldingSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Allocator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;functional&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>AnalysisDeclContextManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BlockDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BlockInvocationContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CFGReverseBlockReachabilityAnalysis</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CFGStmtMap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ImplicitParamDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LocationContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LocationContextManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ParentMap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>StackFrameContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Stmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VarDecl</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>ManagedAnalysis</name> <block>{<block_content>
<label><name>protected</name>:</label>
<expr_stmt><expr><call><name>ManagedAnalysis</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>ManagedAnalysis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>











</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>AnalysisDeclContext</name> <block>{<block_content>


<decl_stmt><decl><type><name>AnalysisDeclContextManager</name> <modifier>*</modifier></type><name>ADCMgr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier><specifier>const</specifier></type> <name>D</name></decl>;</decl_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CFG</name></expr></argument>&gt;</argument_list></name> <name>cfg</name></expr><operator>,</operator> <expr><name>completeCFG</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CFGStmtMap</name></expr></argument>&gt;</argument_list></name> <name>cfgStmtMap</name></expr>;</expr_stmt>

<expr_stmt><expr><name>CFG</name><operator>::</operator><name>BuildOptions</name> <name>cfgBuildOptions</name></expr>;</expr_stmt>
<expr_stmt><expr><name>CFG</name><operator>::</operator><name>BuildOptions</name><operator>::</operator><name>ForcedBlkExprs</name> <operator>*</operator><name>forcedBlkExprs</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>builtCFG</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>builtCompleteCFG</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ParentMap</name></expr></argument>&gt;</argument_list></name> <name>PM</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CFGReverseBlockReachabilityAnalysis</name></expr></argument>&gt;</argument_list></name> <name>CFA</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name> <name>A</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>BlockDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>void</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>ReferencedBlockVars</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ManagedAnalyses</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>AnalysisDeclContext</name><argument_list>(<argument><expr><name>AnalysisDeclContextManager</name> <operator>*</operator><name>Mgr</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>AnalysisDeclContext</name><argument_list>(<argument><expr><name>AnalysisDeclContextManager</name> <operator>*</operator><name>Mgr</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CFG</name><operator>::</operator><name>BuildOptions</name> <operator>&amp;</operator><name>BuildOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>~</operator><call><name>AnalysisDeclContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ASTContext</name> <operator>&amp;</operator><macro><name>getASTContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>D</name><operator>-&gt;</operator><name>getASTContext</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>D</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>AnalysisDeclContextManager</name> <operator>*</operator><macro><name>getManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ADCMgr</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>CFG</name><operator>::</operator><name>BuildOptions</name> <operator>&amp;</operator><macro><name>getCFGBuildOptions</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>cfgBuildOptions</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>CFG</name><operator>::</operator><name>BuildOptions</name> <operator>&amp;</operator><macro><name>getCFGBuildOptions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>cfgBuildOptions</name></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>getAddEHEdges</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>cfgBuildOptions</name><operator>.</operator><name>AddEHEdges</name></name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>getUseUnoptimizedCFG</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><name><name>cfgBuildOptions</name><operator>.</operator><name>PruneTriviallyFalseEdges</name></name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>getAddImplicitDtors</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>cfgBuildOptions</name><operator>.</operator><name>AddImplicitDtors</name></name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>getAddInitializers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>cfgBuildOptions</name><operator>.</operator><name>AddInitializers</name></name></expr>;</return> }</block></expr></expr_stmt>

<function_decl><type><name>void</name></type> <name>registerForcedBlockExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>getBlockForRegisteredExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>Stmt</name> <operator>*</operator><macro><name>getBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<decl_stmt><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>getBody</name><argument_list>(<argument><expr><name>bool</name> <operator>&amp;</operator><name>IsAutosynthesized</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<expr_stmt><expr><name>bool</name> <macro><name>isBodyAutosynthesized</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>







<expr_stmt><expr><name>bool</name> <macro><name>isBodyAutosynthesizedFromModelFile</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function_decl><type><name>CFG</name> <modifier>*</modifier></type><name>getCFG</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>CFGStmtMap</name> <modifier>*</modifier></type><name>getCFGStmtMap</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>CFGReverseBlockReachabilityAnalysis</name> <modifier>*</modifier></type><name>getCFGReachablityAnalysis</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>CFG</name> <modifier>*</modifier></type><name>getUnoptimizedCFG</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>dumpCFG</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>ShowColors</name></decl></parameter>)</parameter_list>;</function_decl>





<expr_stmt><expr><name>bool</name> <macro><name>isCFGBuilt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>builtCFG</name></expr>;</return> }</block></expr></expr_stmt>

<function_decl><type><name>ParentMap</name> <modifier>&amp;</modifier></type><name>getParentMap</name><parameter_list>()</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>using</name></type> <name>referenced_decls_iterator</name> <init>= <expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>referenced_decls_iterator</name></expr></argument>&gt;</argument_list></name>
<call><name>getReferencedBlockVars</name><argument_list>(<argument><expr><specifier>const</specifier> <name>BlockDecl</name> <operator>*</operator><name>BD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>ImplicitParamDecl</name> <operator>*</operator><macro><name>getSelfDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<function_decl><type><specifier>const</specifier> <name>StackFrameContext</name> <modifier>*</modifier></type><name>getStackFrame</name><parameter_list>(<parameter><decl><type><name>LocationContext</name> <specifier>const</specifier> <modifier>*</modifier></type><name>ParentLC</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>Blk</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>BlockCount</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Index</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>const</specifier> <name>BlockInvocationContext</name> <modifier>*</modifier></type>
<name>getBlockInvocationContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LocationContext</name> <modifier>*</modifier></type><name>ParentLC</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>BlockDecl</name> <modifier>*</modifier></type><name>BD</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>Data</name></decl></parameter>)</parameter_list>;</function_decl>



<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>T</name> <modifier>*</modifier></type><name>getAnalysis</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>tag</name> <init>= <expr><name>T</name><operator>::</operator><call><name>getTag</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ManagedAnalysis</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>data</name> <operator>=</operator> <call><name>getAnalysisImpl</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>data</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>data</name> <operator>=</operator> <name>T</name><operator>::</operator><call><name>create</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>data</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isInStdNamespace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name> <call><name>getFunctionName</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ManagedAnalysis</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><call><name>getAnalysisImpl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>LocationContextManager</name> <modifier>&amp;</modifier></type><name>getLocationContextManager</name><parameter_list>()</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>





<decl_stmt><decl><type><name>class</name></type> <name>LocationContext</name> <range>: <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>public</name><operator>:</operator>
enum <name>ContextKind</name> <block>{ <expr><name>StackFrame</name></expr>, <expr><name>Block</name></expr> }</block></expr>;

<expr><name>private</name><operator>:</operator>
<name>ContextKind</name> <name>Kind</name></expr>;



<expr><name>AnalysisDeclContext</name> <operator>*</operator><name>Ctx</name></expr>;

<expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>Parent</name></expr>;
<expr><name>int64_t</name> <name>ID</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>LocationContext</name><argument_list>(<argument>ContextKind k</argument>, <argument>AnalysisDeclContext *ctx</argument>,
<argument>const LocationContext *parent</argument>, <argument>int64_t ID</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Ctx</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Parent</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>, <macro><name>ID</name><argument_list>(<argument>ID</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>virtual</name> <operator>~</operator><call><name>LocationContext</name><argument_list>()</argument_list></call></expr>;

<expr><name>ContextKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block>

<name>int64_t</name> <macro><name>getID</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ID</name></expr>;</return> }</block>

<name>AnalysisDeclContext</name> <operator>*</operator><macro><name>getAnalysisDeclContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Ctx</name></expr>;</return> }</block>

<specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><macro><name>getParent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Parent</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isParentOf</name><argument_list>(<argument>const LocationContext *LC</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Ctx</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>CFG</name> <operator>*</operator><macro><name>getCFG</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Ctx</name><operator>-&gt;</operator><name>getCFG</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>T</name> <operator>*</operator><macro><name>getAnalysis</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Ctx</name><operator>-&gt;</operator><name>getAnalysis</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block>

<specifier>const</specifier> <name>ParentMap</name> <operator>&amp;</operator><macro><name>getParentMap</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Ctx</name><operator>-&gt;</operator><name>getParentMap</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<specifier>const</specifier> <name>ImplicitParamDecl</name> <operator>*</operator><macro><name>getSelfDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Ctx</name><operator>-&gt;</operator><name>getSelfDecl</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><macro><name>getStackFrame</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>virtual</name> <name>bool</name> <macro><name>inTopFrame</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>virtual</name> <name>void</name> <call><name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;




<expr><name>LLVM_DUMP_METHOD</name> <name>void</name> <macro><name>dumpStack</name><argument_list>(<argument>raw_ostream &amp;Out</argument>)</argument_list></macro> <specifier>const</specifier></expr>;












<expr><name>void</name> <macro><name>printJson</name><argument_list>(
<argument>raw_ostream &amp;Out</argument>, <argument>const char *NL = <literal type="string">"\n"</literal></argument>, <argument>unsigned int Space = <literal type="number">0</literal></argument>,
<argument>bool IsDot = false</argument>,
<argument>std::function&lt;void(const LocationContext *)&gt; printMoreInfoPerContext =
[](const LocationContext *) {}</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>LLVM_DUMP_METHOD</name> <name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>void</name> <macro><name>ProfileCommon</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>ContextKind ck</argument>,
<argument>AnalysisDeclContext *ctx</argument>,
<argument>const LocationContext *parent</argument>, <argument>const void *data</argument>)</argument_list></macro></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>StackFrameContext</name> <range>: <expr><name>public</name> <name>LocationContext</name> <block>{
<expr><name>friend</name> <name>class</name> <name>LocationContextManager</name></expr>;


<expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>CallSite</name></expr>;


<expr><specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><name>Block</name></expr>;




<expr><specifier>const</specifier> <name>unsigned</name> <name>BlockCount</name></expr>;


<expr><specifier>const</specifier> <name>unsigned</name> <name>Index</name></expr>;

<macro><name>StackFrameContext</name><argument_list>(<argument>AnalysisDeclContext *ADC</argument>, <argument>const LocationContext *ParentLC</argument>,
<argument>const Stmt *S</argument>, <argument>const CFGBlock *Block</argument>, <argument>unsigned BlockCount</argument>,
<argument>unsigned Index</argument>, <argument>int64_t ID</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>LocationContext</name><argument_list>(<argument><expr><name>StackFrame</name></expr></argument>, <argument><expr><name>ADC</name></expr></argument>, <argument><expr><name>ParentLC</name></expr></argument>, <argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>CallSite</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Block</name><argument_list>(<argument><expr><name>Block</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>BlockCount</name><argument_list>(<argument><expr><name>BlockCount</name></expr></argument>)</argument_list></call></expr>, <macro><name>Index</name><argument_list>(<argument>Index</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<operator>~</operator><macro><name>StackFrameContext</name><argument_list>()</argument_list></macro> <name>override</name> <operator>=</operator> default</expr>;

<expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getCallSite</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CallSite</name></expr>;</return> }</block>

<specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><macro><name>getCallSiteBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Block</name></expr>;</return> }</block>

<name>bool</name> <macro><name>inTopFrame</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><call><name>getParent</name><argument_list>()</argument_list></call> <operator>==</operator> <name>nullptr</name></expr>;</return> }</block>

<name>unsigned</name> <macro><name>getIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Index</name></expr>;</return> }</block>

<name>CFGElement</name> <macro><name>getCallSiteCFGElement</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><operator>*</operator><name>Block</name><operator>)</operator><index>[<expr><name>Index</name></expr>]</index></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>AnalysisDeclContext *ADC</argument>,
<argument>const LocationContext *ParentLC</argument>, <argument>const Stmt *S</argument>,
<argument>const CFGBlock *Block</argument>, <argument>unsigned BlockCount</argument>,
<argument>unsigned Index</argument>)</argument_list></macro> <block>{
<expr><call><name>ProfileCommon</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>StackFrame</name></expr></argument>, <argument><expr><name>ADC</name></expr></argument>, <argument><expr><name>ParentLC</name></expr></argument>, <argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>Block</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>BlockCount</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const LocationContext *LC</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>LC</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>StackFrame</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>BlockInvocationContext</name> <operator>:</operator> <name>public</name> <name>LocationContext</name> <block>{
<expr><name>friend</name> <name>class</name> <name>LocationContextManager</name></expr>;

<expr><specifier>const</specifier> <name>BlockDecl</name> <operator>*</operator><name>BD</name></expr>;


<expr><specifier>const</specifier> <name>void</name> <operator>*</operator><name>Data</name></expr>;

<macro><name>BlockInvocationContext</name><argument_list>(<argument>AnalysisDeclContext *ADC</argument>,
<argument>const LocationContext *ParentLC</argument>, <argument>const BlockDecl *BD</argument>,
<argument>const void *Data</argument>, <argument>int64_t ID</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>LocationContext</name><argument_list>(<argument><expr><name>Block</name></expr></argument>, <argument><expr><name>ADC</name></expr></argument>, <argument><expr><name>ParentLC</name></expr></argument>, <argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>BD</name><argument_list>(<argument><expr><name>BD</name></expr></argument>)</argument_list></call></expr>, <macro><name>Data</name><argument_list>(<argument>Data</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<operator>~</operator><macro><name>BlockInvocationContext</name><argument_list>()</argument_list></macro> <name>override</name> <operator>=</operator> default</expr>;

<expr><specifier>const</specifier> <name>BlockDecl</name> <operator>*</operator><macro><name>getBlockDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BD</name></expr>;</return> }</block>

<specifier>const</specifier> <name>void</name> <operator>*</operator><macro><name>getData</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Data</name></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>AnalysisDeclContext *ADC</argument>,
<argument>const LocationContext *ParentLC</argument>, <argument>const BlockDecl *BD</argument>,
<argument>const void *Data</argument>)</argument_list></macro> <block>{
<expr><call><name>ProfileCommon</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Block</name></expr></argument>, <argument><expr><name>ADC</name></expr></argument>, <argument><expr><name>ParentLC</name></expr></argument>, <argument><expr><name>BD</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>Data</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const LocationContext *LC</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>LC</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Block</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>LocationContextManager</name> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>LocationContext</name></expr></argument>&gt;</argument_list></name> <name>Contexts</name></expr>;


<expr><name>int64_t</name> <name>NewID</name> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>public</name><operator>:</operator>
<operator>~</operator><call><name>LocationContextManager</name><argument_list>()</argument_list></call></expr>;










<expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><macro><name>getStackFrame</name><argument_list>(<argument>AnalysisDeclContext *ADC</argument>,
<argument>const LocationContext *ParentLC</argument>,
<argument>const Stmt *S</argument>, <argument>const CFGBlock *Block</argument>,
<argument>unsigned BlockCount</argument>, <argument>unsigned Index</argument>)</argument_list></macro></expr>;







<expr><specifier>const</specifier> <name>BlockInvocationContext</name> <operator>*</operator>
<call><name>getBlockInvocationContext</name><argument_list>(<argument><expr><name>AnalysisDeclContext</name> <operator>*</operator><name>ADC</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>ParentLC</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>BlockDecl</name> <operator>*</operator><name>BD</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator><name>Data</name></expr></argument>)</argument_list></call></expr>;


<expr><name>void</name> <call><name>clear</name><argument_list>()</argument_list></call></expr>;
}</block></expr>;

<expr><name>class</name> <name>AnalysisDeclContextManager</name> <block>{
<expr><name>using</name> <name>ContextMap</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>AnalysisDeclContext</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>ContextMap</name> <name>Contexts</name></expr>;
<expr><name>LocationContextManager</name> <name>LocCtxMgr</name></expr>;
<expr><name>CFG</name><operator>::</operator><name>BuildOptions</name> <name>cfgBuildOptions</name></expr>;



<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CodeInjector</name></expr></argument>&gt;</argument_list></name> <name>Injector</name></expr>;



<expr><name>BodyFarm</name> <name>FunctionBodyFarm</name></expr>;



<expr><name>bool</name> <name>SynthesizeBodies</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>AnalysisDeclContextManager</name><argument_list>(
<argument>ASTContext &amp;ASTCtx</argument>, <argument>bool useUnoptimizedCFG = false</argument>,
<argument>bool addImplicitDtors = false</argument>, <argument>bool addInitializers = false</argument>,
<argument>bool addTemporaryDtors = false</argument>, <argument>bool addLifetime = false</argument>,
<argument>bool addLoopExit = false</argument>, <argument>bool addScopes = false</argument>,
<argument>bool synthesizeBodies = false</argument>, <argument>bool addStaticInitBranches = false</argument>,
<argument>bool addCXXNewAllocator = true</argument>, <argument>bool addRichCXXConstructors = true</argument>,
<argument>bool markElidedCXXConstructors = true</argument>, <argument>bool addVirtualBaseBranches = true</argument>,
<argument>CodeInjector *injector = nullptr</argument>)</argument_list></macro></expr>;

<expr><name>AnalysisDeclContext</name> <operator>*</operator><call><name>getContext</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;

<expr><name>bool</name> <macro><name>getUseUnoptimizedCFG</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><name><name>cfgBuildOptions</name><operator>.</operator><name>PruneTriviallyFalseEdges</name></name></expr>;</return>
}</block>

<name>CFG</name><operator>::</operator><name>BuildOptions</name> <operator>&amp;</operator><macro><name>getCFGBuildOptions</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>cfgBuildOptions</name></expr>;</return> }</block>


<name>bool</name> <macro><name>synthesizeBodies</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SynthesizeBodies</name></expr>;</return> }</block>




<specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><macro><name>getStackFrame</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>LocCtxMgr</name><operator>.</operator><name>getStackFrame</name></name><argument_list>(<argument><expr><call><name>getContext</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><macro><name>getStackFrame</name><argument_list>(<argument>AnalysisDeclContext *ADC</argument>,
<argument>const LocationContext *Parent</argument>,
<argument>const Stmt *S</argument>, <argument>const CFGBlock *Block</argument>,
<argument>unsigned BlockCount</argument>, <argument>unsigned Index</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>LocCtxMgr</name><operator>.</operator><name>getStackFrame</name></name><argument_list>(<argument><expr><name>ADC</name></expr></argument>, <argument><expr><name>Parent</name></expr></argument>, <argument><expr><name>S</name></expr></argument>, <argument><expr><name>Block</name></expr></argument>, <argument><expr><name>BlockCount</name></expr></argument>, <argument><expr><name>Index</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>BodyFarm</name> <operator>&amp;</operator><call><name>getBodyFarm</name><argument_list>()</argument_list></call></expr>;


<expr><name>void</name> <call><name>clear</name><argument_list>()</argument_list></call></expr>;

<expr><name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>AnalysisDeclContext</name></expr>;

<expr><name>LocationContextManager</name> <operator>&amp;</operator><macro><name>getLocationContextManager</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>LocCtxMgr</name></expr>;</return> }</block>
}</expr>;

}</block></expr></block></expr></block></expr></range></decl></decl_stmt></block_content></block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
