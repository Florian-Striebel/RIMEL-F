<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h">












































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYTIL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYTIL_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/Analyses/ThreadSafetyUtil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/None.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/raw_ostream.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;algorithm&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iterator&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>CallExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Stmt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>threadSafety</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>til</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>BasicBlock</name></decl>;</decl_stmt>


<enum>enum <name>TIL_Opcode</name> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIL_OPCODE_DEF</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>COP_##X,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ThreadSafetyOps.def"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TIL_OPCODE_DEF</name></cpp:undef>
}</block>;</enum>


<enum>enum <name>TIL_UnaryOpcode</name> : <type><name>unsigned</name> <name>char</name></type> <block>{
<decl><name>UOP_Minus</name></decl>,
<decl><name>UOP_BitNot</name></decl>,
<decl><name>UOP_LogicNot</name></decl>
}</block>;</enum>


<enum>enum <name>TIL_BinaryOpcode</name> : <type><name>unsigned</name> <name>char</name></type> <block>{
<decl><name>BOP_Add</name></decl>,
<decl><name>BOP_Sub</name></decl>,
<decl><name>BOP_Mul</name></decl>,
<decl><name>BOP_Div</name></decl>,
<decl><name>BOP_Rem</name></decl>,
<decl><name>BOP_Shl</name></decl>,
<decl><name>BOP_Shr</name></decl>,
<decl><name>BOP_BitAnd</name></decl>,
<decl><name>BOP_BitXor</name></decl>,
<decl><name>BOP_BitOr</name></decl>,
<decl><name>BOP_Eq</name></decl>,
<decl><name>BOP_Neq</name></decl>,
<decl><name>BOP_Lt</name></decl>,
<decl><name>BOP_Leq</name></decl>,
<decl><name>BOP_Cmp</name></decl>,
<decl><name>BOP_LogicAnd</name></decl>,
<decl><name>BOP_LogicOr</name></decl>
}</block>;</enum>


<enum>enum <name>TIL_CastOpcode</name> : <type><name>unsigned</name> <name>char</name></type> <block>{
<decl><name>CAST_none</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,


<decl><name>CAST_extendNum</name></decl>,


<decl><name>CAST_truncNum</name></decl>,


<decl><name>CAST_toFloat</name></decl>,


<decl><name>CAST_toInt</name></decl>,


<decl><name>CAST_objToPtr</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><specifier>const</specifier> <name>TIL_Opcode</name></type> <name>COP_Min</name> <init>= <expr><name>COP_Future</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TIL_Opcode</name></type> <name>COP_Max</name> <init>= <expr><name>COP_Branch</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TIL_UnaryOpcode</name></type> <name>UOP_Min</name> <init>= <expr><name>UOP_Minus</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TIL_UnaryOpcode</name></type> <name>UOP_Max</name> <init>= <expr><name>UOP_LogicNot</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TIL_BinaryOpcode</name></type> <name>BOP_Min</name> <init>= <expr><name>BOP_Add</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TIL_BinaryOpcode</name></type> <name>BOP_Max</name> <init>= <expr><name>BOP_LogicOr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TIL_CastOpcode</name></type> <name>CAST_Min</name> <init>= <expr><name>CAST_none</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TIL_CastOpcode</name></type> <name>CAST_Max</name> <init>= <expr><name>CAST_toInt</name></expr></init></decl>;</decl_stmt>


<function_decl><type><name>StringRef</name></type> <name>getUnaryOpcodeString</name><parameter_list>(<parameter><decl><type><name>TIL_UnaryOpcode</name></type> <name>Op</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StringRef</name></type> <name>getBinaryOpcodeString</name><parameter_list>(<parameter><decl><type><name>TIL_BinaryOpcode</name></type> <name>Op</name></decl></parameter>)</parameter_list>;</function_decl>







<struct>struct <name>ValueType</name> <block>{
<enum>enum <name>BaseType</name> : <type><name>unsigned</name> <name>char</name></type> <block>{
<decl><name>BT_Void</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>BT_Bool</name></decl>,
<decl><name>BT_Int</name></decl>,
<decl><name>BT_Float</name></decl>,
<decl><name>BT_String</name></decl>,
<decl><name>BT_Pointer</name></decl>,
<decl><name>BT_ValueRef</name></decl>
}</block>;</enum>

<enum>enum <name>SizeType</name> : <type><name>unsigned</name> <name>char</name></type> <block>{
<decl><name>ST_0</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>ST_1</name></decl>,
<decl><name>ST_8</name></decl>,
<decl><name>ST_16</name></decl>,
<decl><name>ST_32</name></decl>,
<decl><name>ST_64</name></decl>,
<decl><name>ST_128</name></decl>
}</block>;</enum>

<macro><name>ValueType</name><argument_list>(<argument>BaseType B</argument>, <argument>SizeType Sz</argument>, <argument>bool S</argument>, <argument>unsigned char VS</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Base</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Size</name><argument_list>(<argument><expr><name>Sz</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Signed</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>VectSize</name><argument_list>(<argument>VS</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>inline</specifier> <specifier>static</specifier> <name>SizeType</name> <macro><name>getSizeType</name><argument_list>(<argument>unsigned nbytes</argument>)</argument_list></macro></expr>;</expr_stmt>

<function_decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <specifier>static</specifier> <name>ValueType</name></type> <name>getValueType</name><parameter_list>()</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>BaseType</name></type> <name>Base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SizeType</name></type> <name>Size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Signed</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>VectSize</name></decl>;</decl_stmt>
}</block>;</struct>

<expr_stmt><expr><specifier>inline</specifier> <name>ValueType</name><operator>::</operator><name>SizeType</name> <name>ValueType</name><operator>::</operator><macro><name>getSizeType</name><argument_list>(<argument>unsigned nbytes</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><name>nbytes</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><name>ST_8</name></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><name>ST_16</name></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><name>ST_32</name></expr>;</return>
<case>case <expr><literal type="number">8</literal></expr>:</case> <return>return <expr><name>ST_64</name></expr>;</return>
<case>case <expr><literal type="number">16</literal></expr>:</case> <return>return <expr><name>ST_128</name></expr>;</return>
<default>default:</default> <return>return <expr><name>ST_0</name></expr>;</return>
<expr_stmt/>}</block_content>
}

template&lt;&gt;
<namespace><specifier>inline</specifier> ValueType <name>ValueType</name>::<name><name>getValueType</name><argument_list type="generic">&lt;<argument><expr><name>void</name></expr></argument>&gt;</argument_list></name>(</namespace></block></switch>) <block>{
<return>return <expr><call><name>ValueType</name><argument_list>(<argument><expr><name>BT_Void</name></expr></argument>, <argument><expr><name>ST_0</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>ValueType</name> <name>ValueType</name><operator>::</operator><macro><name>getValueType</name></macro><operator>&lt;</operator><name>bool</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <block>{
<return>return <expr><call><name>ValueType</name><argument_list>(<argument><expr><name>BT_Bool</name></expr></argument>, <argument><expr><name>ST_1</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>ValueType</name> <name>ValueType</name><operator>::</operator><macro><name>getValueType</name></macro><operator>&lt;</operator><name>int8_t</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <block>{
<return>return <expr><call><name>ValueType</name><argument_list>(<argument><expr><name>BT_Int</name></expr></argument>, <argument><expr><name>ST_8</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>ValueType</name> <name>ValueType</name><operator>::</operator><macro><name>getValueType</name></macro><operator>&lt;</operator><name>uint8_t</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <block>{
<return>return <expr><call><name>ValueType</name><argument_list>(<argument><expr><name>BT_Int</name></expr></argument>, <argument><expr><name>ST_8</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>ValueType</name> <name>ValueType</name><operator>::</operator><macro><name>getValueType</name></macro><operator>&lt;</operator><name>int16_t</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <block>{
<return>return <expr><call><name>ValueType</name><argument_list>(<argument><expr><name>BT_Int</name></expr></argument>, <argument><expr><name>ST_16</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>ValueType</name> <name>ValueType</name><operator>::</operator><macro><name>getValueType</name></macro><operator>&lt;</operator><name>uint16_t</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <block>{
<return>return <expr><call><name>ValueType</name><argument_list>(<argument><expr><name>BT_Int</name></expr></argument>, <argument><expr><name>ST_16</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>ValueType</name> <name>ValueType</name><operator>::</operator><macro><name>getValueType</name></macro><operator>&lt;</operator><name>int32_t</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <block>{
<return>return <expr><call><name>ValueType</name><argument_list>(<argument><expr><name>BT_Int</name></expr></argument>, <argument><expr><name>ST_32</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>ValueType</name> <name>ValueType</name><operator>::</operator><macro><name>getValueType</name></macro><operator>&lt;</operator><name>uint32_t</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <block>{
<return>return <expr><call><name>ValueType</name><argument_list>(<argument><expr><name>BT_Int</name></expr></argument>, <argument><expr><name>ST_32</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>ValueType</name> <name>ValueType</name><operator>::</operator><macro><name>getValueType</name></macro><operator>&lt;</operator><name>int64_t</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <block>{
<return>return <expr><call><name>ValueType</name><argument_list>(<argument><expr><name>BT_Int</name></expr></argument>, <argument><expr><name>ST_64</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>ValueType</name> <name>ValueType</name><operator>::</operator><macro><name>getValueType</name></macro><operator>&lt;</operator><name>uint64_t</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <block>{
<return>return <expr><call><name>ValueType</name><argument_list>(<argument><expr><name>BT_Int</name></expr></argument>, <argument><expr><name>ST_64</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>ValueType</name> <name>ValueType</name><operator>::</operator><macro><name>getValueType</name></macro><operator>&lt;</operator><name>float</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <block>{
<return>return <expr><call><name>ValueType</name><argument_list>(<argument><expr><name>BT_Float</name></expr></argument>, <argument><expr><name>ST_32</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>ValueType</name> <name>ValueType</name><operator>::</operator><macro><name>getValueType</name></macro><operator>&lt;</operator><name>double</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <block>{
<return>return <expr><call><name>ValueType</name><argument_list>(<argument><expr><name>BT_Float</name></expr></argument>, <argument><expr><name>ST_64</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>ValueType</name> <name>ValueType</name><operator>::</operator><macro><name>getValueType</name></macro><operator>&lt;</operator><name>long</name> <name>double</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <block>{
<return>return <expr><call><name>ValueType</name><argument_list>(<argument><expr><name>BT_Float</name></expr></argument>, <argument><expr><name>ST_128</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>ValueType</name> <name>ValueType</name><operator>::</operator><macro><name>getValueType</name></macro><operator>&lt;</operator><name>StringRef</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <block>{
<return>return <expr><call><name>ValueType</name><argument_list>(<argument><expr><name>BT_String</name></expr></argument>, <argument><expr><call><name>getSizeType</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StringRef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>ValueType</name> <name>ValueType</name><operator>::</operator><macro><name>getValueType</name></macro><operator>&lt;</operator><name>void</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator> <block>{
<return>return <expr><call><name>ValueType</name><argument_list>(<argument><expr><name>BT_Pointer</name></expr></argument>, <argument><expr><call><name>getSizeType</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>class</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>SExpr</name><argument_list>()</argument_list></call> <operator>=</operator> <name>delete</name></expr>;

<expr><name>TIL_Opcode</name> <macro><name>opcode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TIL_Opcode</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Opcode</name></expr></argument>)</argument_list></call></expr>;</return> }</block>















<name>void</name> <operator>*</operator><name>operator</name> <macro><name>new</name><argument_list>(<argument>size_t S</argument>, <argument>MemRegionRef &amp;R</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>::</operator><name>operator</name> <call><name>new</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>void</name> <operator>*</operator><name>operator</name> <call><name>new</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;




<expr><name>void</name> <name>operator</name> <call><name>delete</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;



<expr><name>unsigned</name> <macro><name>id</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SExprID</name></expr>;</return> }</block>



<name>BasicBlock</name> <operator>*</operator><macro><name>block</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Block</name></expr>;</return> }</block>


<name>void</name> <macro><name>setID</name><argument_list>(<argument>BasicBlock *B</argument>, <argument>unsigned id</argument>)</argument_list></macro> <block>{ <expr><name>Block</name> <operator>=</operator> <name>B</name></expr>; <expr><name>SExprID</name> <operator>=</operator> <name>id</name></expr>; }</block>

<name>protected</name><operator>:</operator>
<macro><name>SExpr</name><argument_list>(<argument>TIL_Opcode Op</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Opcode</name><argument_list>(<argument>Op</argument>)</argument_list></macro> <block>{}</block>
<call><name>SExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>SExpr</name> <operator>&amp;</operator><name>E</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>Opcode</name><argument_list>(<argument><expr><name><name>E</name><operator>.</operator><name>Opcode</name></name></expr></argument>)</argument_list></call></expr>, <macro><name>Flags</name><argument_list>(<argument>E.Flags</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>const</specifier> <name>unsigned</name> <name>char</name> <name>Opcode</name></expr>;
<expr><name>unsigned</name> <name>char</name> <name>Reserved</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>unsigned</name> <name>short</name> <name>Flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>unsigned</name> <name>SExprID</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>BasicBlock</name> <operator>*</operator><name>Block</name> <operator>=</operator> <name>nullptr</name></expr>;
}</block></block></expr>;</expr_stmt>


<decl_stmt><decl><type><name>namespace</name></type> <name>ThreadSafetyTIL</name> <block>{<block_content>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>isTrivial</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>Op</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>Op</name> <operator>==</operator> <name>COP_Variable</name> <operator>||</operator> <name>Op</name> <operator>==</operator> <name>COP_Literal</name> <operator>||</operator> <name>Op</name> <operator>==</operator> <name>COP_LiteralPtr</name></expr>;</return>
</block_content>}</block></function>

</block_content>}</block></decl></decl_stmt>















<decl_stmt><decl><type><name>class</name></type> <name>Variable</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
enum <name>VariableKind</name> <block>{

<expr><name>VK_Let</name></expr>,


<expr><name>VK_Fun</name></expr>,


<expr><name>VK_SFun</name></expr>
}</block></expr>;

<macro><name>Variable</name><argument_list>(<argument>StringRef s</argument>, <argument>SExpr *D = nullptr</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>SExpr</name><argument_list>(<argument><expr><name>COP_Variable</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Name</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>, <macro><name>Definition</name><argument_list>(<argument>D</argument>)</argument_list></macro> <expr><block>{
<expr><name>Flags</name> <operator>=</operator> <name>VK_Let</name></expr>;
}</block>

<call><name>Variable</name><argument_list>(<argument><expr><name>SExpr</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><name>Cvd</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_Variable</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Name</name><argument_list>(<argument><expr><ternary><condition><expr><name>Cvd</name></expr> ?</condition><then> <expr><call><name><name>Cvd</name><operator>-&gt;</operator><name>getName</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="string">"_x"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Definition</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>, <macro><name>Cvdecl</name><argument_list>(<argument>Cvd</argument>)</argument_list></macro> <expr><block>{
<expr><name>Flags</name> <operator>=</operator> <name>VK_Let</name></expr>;
}</block>

<call><name>Variable</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Variable</name> <operator>&amp;</operator><name>Vd</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>Vd</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Name</name><argument_list>(<argument><expr><name><name>Vd</name><operator>.</operator><name>Name</name></name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Definition</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>, <macro><name>Cvdecl</name><argument_list>(<argument>Vd.Cvdecl</argument>)</argument_list></macro> <expr><block>{
<expr><name>Flags</name> <operator>=</operator> <call><name><name>Vd</name><operator>.</operator><name>kind</name></name><argument_list>()</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Variable</name></expr>;</return> }</block>


<name>VariableKind</name> <macro><name>kind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>VariableKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Flags</name></expr></argument>)</argument_list></call></expr>;</return> }</block>


<name>StringRef</name> <macro><name>name</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Name</name></expr>;</return> }</block>


<specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><macro><name>clangDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Cvdecl</name></expr>;</return> }</block>




<name>SExpr</name> <operator>*</operator><macro><name>definition</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Definition</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>definition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Definition</name></expr>;</return> }</block>

<name>void</name> <macro><name>setName</name><argument_list>(<argument>StringRef S</argument>)</argument_list></macro> <block>{ <expr><name>Name</name> <operator>=</operator> <name>S</name></expr>; }</block>
<name>void</name> <macro><name>setKind</name><argument_list>(<argument>VariableKind K</argument>)</argument_list></macro> <block>{ <expr><name>Flags</name> <operator>=</operator> <name>K</name></expr>; }</block>
<name>void</name> <macro><name>setDefinition</name><argument_list>(<argument>SExpr *E</argument>)</argument_list></macro> <block>{ <expr><name>Definition</name> <operator>=</operator> <name>E</name></expr>; }</block>
<name>void</name> <macro><name>setClangDecl</name><argument_list>(<argument>const ValueDecl *VD</argument>)</argument_list></macro> <block>{ <expr><name>Cvdecl</name> <operator>=</operator> <name>VD</name></expr>; }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{

<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceVariableRef</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Variable* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>compareVariableRefs</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>BasicBlock</name></expr>;
<expr><name>friend</name> <name>class</name> <name>Function</name></expr>;
<expr><name>friend</name> <name>class</name> <name>Let</name></expr>;
<expr><name>friend</name> <name>class</name> <name>SFunction</name></expr>;


<expr><name>StringRef</name> <name>Name</name></expr>;


<expr><name>SExpr</name> <operator>*</operator><name>Definition</name></expr>;


<expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><name>Cvdecl</name> <operator>=</operator> <name>nullptr</name></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>Future</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
enum <name>FutureStatus</name> <block>{
<expr><name>FS_pending</name></expr>,
<expr><name>FS_evaluating</name></expr>,
<expr><name>FS_done</name></expr>
}</block></expr>;

<expr><call><name>Future</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>SExpr</name><argument_list>(<argument>COP_Future</argument>)</argument_list></macro> <block>{}</block>
<name>virtual</name> <operator>~</operator><call><name>Future</name><argument_list>()</argument_list></call> <operator>=</operator> <name>delete</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Future</name></expr>;</return> }</block>


<name>virtual</name> <name>SExpr</name> <operator>*</operator><macro><name>compute</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block>


<name>SExpr</name> <operator>*</operator><macro><name>maybeGetResult</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Result</name></expr>;</return> }</block>


<name>SExpr</name> <operator>*</operator><macro><name>result</name><argument_list>()</argument_list></macro> <block>{
<switch>switch <condition>(<expr><name>Status</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>FS_pending</name></expr>:</case>
<return>return <expr><call><name>force</name><argument_list>()</argument_list></call></expr>;</return>
<case>case <expr><name>FS_evaluating</name></expr>:</case>
<return>return <expr><name>nullptr</name></expr>;</return>
<case>case <expr><name>FS_done</name></expr>:</case>
<return>return <expr><name>Result</name></expr>;</return>
<expr_stmt/>}</block_content>
}

template &lt;class V&gt;
typename V::R_SExpr traverse(V &amp;Vs</block><operator>,</operator> <expr_stmt><expr><name>typename</name> <name>V</name><operator>::</operator><name>R_Ctx</name> <name>Ctx</name></expr></expr_stmt></switch>) <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Result</name> <operator>&amp;&amp;</operator> <literal type="string">"Cannot traverse Future that has not been forced."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Result</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Future* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Result</name> <operator>||</operator> <operator>!</operator><name><name>E</name><operator>-&gt;</operator><name>Result</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>comparePointers</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name>Result</name></expr></argument>, <argument><expr><name><name>E</name><operator>-&gt;</operator><name>Result</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<label><name>private</name>:</label>
<function_decl><type><name>SExpr</name><modifier>*</modifier></type> <name>force</name><parameter_list>()</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>FutureStatus</name></type> <name>Status</name> <init>= <expr><name>FS_pending</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SExpr</name> <modifier>*</modifier></type><name>Result</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>Undefined</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>Undefined</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_Undefined</name></expr></argument>)</argument_list></call></expr>, <macro><name>Cstmt</name><argument_list>(<argument>S</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>Undefined</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Undefined</name> <operator>&amp;</operator><name>U</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>, <macro><name>Cstmt</name><argument_list>(<argument>U.Cstmt</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Undefined</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceUndefined</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Undefined* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>trueResult</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>Cstmt</name></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>Wildcard</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>Wildcard</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>SExpr</name><argument_list>(<argument>COP_Wildcard</argument>)</argument_list></macro> <block>{}</block>
<call><name>Wildcard</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Wildcard</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Wildcard</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name> <name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceWildcard</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Wildcard* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>trueResult</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>LiteralT</name></expr>;


<expr><name>class</name> <name>Literal</name> <operator>:</operator> <name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>Literal</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>C</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_Literal</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ValType</name><argument_list>(<argument><expr><name>ValueType</name><operator>::</operator><call><name><name>getValueType</name><argument_list type="generic">&lt;<argument><expr><name>void</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>, <macro><name>Cexpr</name><argument_list>(<argument>C</argument>)</argument_list></macro> <expr><block>{}</block>
<macro><name>Literal</name><argument_list>(<argument>ValueType VT</argument>)</argument_list></macro> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_Literal</name></expr></argument>)</argument_list></call></expr>, <macro><name>ValType</name><argument_list>(<argument>VT</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>Literal</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Literal</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Literal</name></expr>;</return> }</block>


<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>clangExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Cexpr</name></expr>;</return> }</block>

<name>ValueType</name> <macro><name>valueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ValType</name></expr>;</return> }</block>

<name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier> <name><name>LiteralT</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <macro><name>as</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>*</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name><name>LiteralT</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name><name>LiteralT</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <macro><name>as</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><operator>*</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name><name>LiteralT</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name> <name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Literal* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{

<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>trueResult</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>ValueType</name> <name>ValType</name></expr>;
<expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>Cexpr</name> <operator>=</operator> <name>nullptr</name></expr>;
}</block></expr>;


<expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>LiteralT</name> <operator>:</operator> <name>public</name> <name>Literal</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>LiteralT</name><argument_list>(<argument>T Dat</argument>)</argument_list></macro> <operator>:</operator> <call><name>Literal</name><argument_list>(<argument><expr><name>ValueType</name><operator>::</operator><call><name><name>getValueType</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>, <macro><name>Val</name><argument_list>(<argument>Dat</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>LiteralT</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>LiteralT</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>L</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>Literal</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>, <macro><name>Val</name><argument_list>(<argument>L.Val</argument>)</argument_list></macro> <expr><block>{}</block>

<name>T</name> <macro><name>value</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Val</name></expr>;</return>}</block>
<name>T</name><operator>&amp;</operator> <macro><name>value</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Val</name></expr>;</return> }</block>

<name>private</name><operator>:</operator>
<name>T</name> <name>Val</name></expr>;
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <name>Literal</name><operator>::</operator><macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>Cexpr</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceLiteral</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<switch>switch <condition>(<expr><name><name>ValType</name><operator>.</operator><name>Base</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ValueType</name><operator>::</operator><name>BT_Void</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>ValueType</name><operator>::</operator><name>BT_Bool</name></expr>:</case>
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceLiteralT</name></name><argument_list>(<argument><expr><call><name><name>as</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>ValueType</name><operator>::</operator><name>BT_Int</name></expr>:</case> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>ValType</name><operator>.</operator><name>Size</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ValueType</name><operator>::</operator><name>ST_8</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>ValType</name><operator>.</operator><name>Signed</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceLiteralT</name></name><argument_list>(<argument><expr><call><name><name>as</name><argument_list type="generic">&lt;<argument><expr><name>int8_t</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceLiteralT</name></name><argument_list>(<argument><expr><call><name><name>as</name><argument_list type="generic">&lt;<argument><expr><name>uint8_t</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
<case>case <expr><name>ValueType</name><operator>::</operator><name>ST_16</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>ValType</name><operator>.</operator><name>Signed</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceLiteralT</name></name><argument_list>(<argument><expr><call><name><name>as</name><argument_list type="generic">&lt;<argument><expr><name>int16_t</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceLiteralT</name></name><argument_list>(<argument><expr><call><name><name>as</name><argument_list type="generic">&lt;<argument><expr><name>uint16_t</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
<case>case <expr><name>ValueType</name><operator>::</operator><name>ST_32</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>ValType</name><operator>.</operator><name>Signed</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceLiteralT</name></name><argument_list>(<argument><expr><call><name><name>as</name><argument_list type="generic">&lt;<argument><expr><name>int32_t</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceLiteralT</name></name><argument_list>(<argument><expr><call><name><name>as</name><argument_list type="generic">&lt;<argument><expr><name>uint32_t</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
<case>case <expr><name>ValueType</name><operator>::</operator><name>ST_64</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>ValType</name><operator>.</operator><name>Signed</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceLiteralT</name></name><argument_list>(<argument><expr><call><name><name>as</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceLiteralT</name></name><argument_list>(<argument><expr><call><name><name>as</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
<default>default:</default>
<break>break;</break>
<expr_stmt/>}</block_content>
}
case ValueType::BT_Float: <block>{<block_content>
<switch>switch <condition>(<expr><name><name>ValType</name><operator>.</operator><name>Size</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ValueType</name><operator>::</operator><name>ST_32</name></expr>:</case>
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceLiteralT</name></name><argument_list>(<argument><expr><call><name><name>as</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>ValueType</name><operator>::</operator><name>ST_64</name></expr>:</case>
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceLiteralT</name></name><argument_list>(<argument><expr><call><name><name>as</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<default>default:</default>
<break>break;</break>
<expr_stmt/>}</block_content>
}
case ValueType::BT_String:
return Vs.reduceLiteralT(as&lt;StringRef&gt;(</block></switch>)</block_content></block></block></switch>)</block_content></block><empty_stmt>;</empty_stmt>
<case>case <expr><name>ValueType</name><operator>::</operator><name>BT_Pointer</name></expr>:</case>
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceLiteralT</name></name><argument_list>(<argument><expr><call><name><name>as</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>ValueType</name><operator>::</operator><name>BT_ValueRef</name></expr>:</case>
<break>break;</break>
<expr_stmt/>}</block_content>
return Vs.reduceLiteral(*this</block></switch>)</block></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>LiteralPtr</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>LiteralPtr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_LiteralPtr</name></expr></argument>)</argument_list></call></expr>, <macro><name>Cvdecl</name><argument_list>(<argument>D</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>D</name> <operator>&amp;&amp;</operator> <literal type="string">"ValueDecl must not be null"</literal></expr></argument>)</argument_list></call></expr>;
}</block>
<call><name>LiteralPtr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LiteralPtr</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_LiteralPtr</name></expr>;</return> }</block>


<specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><macro><name>clangDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Cvdecl</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceLiteralPtr</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const LiteralPtr* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>comparePointers</name></name><argument_list>(<argument><expr><name>Cvdecl</name></expr></argument>, <argument><expr><name><name>E</name><operator>-&gt;</operator><name>Cvdecl</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><name>Cvdecl</name></expr>;
}</block></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>Function</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>Function</name><argument_list>(<argument><expr><name>Variable</name> <operator>*</operator><name>Vd</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>Bd</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_Function</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>VarDecl</name><argument_list>(<argument><expr><name>Vd</name></expr></argument>)</argument_list></call></expr>, <macro><name>Body</name><argument_list>(<argument>Bd</argument>)</argument_list></macro> <expr><block>{
<expr><call><name><name>Vd</name><operator>-&gt;</operator><name>setKind</name></name><argument_list>(<argument><expr><name>Variable</name><operator>::</operator><name>VK_Fun</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>Function</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Function</name> <operator>&amp;</operator><name>F</name></expr></argument>, <argument><expr><name>Variable</name> <operator>*</operator><name>Vd</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>Bd</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>F</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>VarDecl</name><argument_list>(<argument><expr><name>Vd</name></expr></argument>)</argument_list></call></expr>, <macro><name>Body</name><argument_list>(<argument>Bd</argument>)</argument_list></macro> <expr><block>{
<expr><call><name><name>Vd</name><operator>-&gt;</operator><name>setKind</name></name><argument_list>(<argument><expr><name>Variable</name><operator>::</operator><name>VK_Fun</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Function</name></expr>;</return> }</block>

<name>Variable</name> <operator>*</operator><macro><name>variableDecl</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>VarDecl</name></expr>;</return> }</block>
<specifier>const</specifier> <name>Variable</name> <operator>*</operator><macro><name>variableDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>VarDecl</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>body</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Body</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>body</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Body</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{

<expr><name>auto</name> <name>E0</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name><name>VarDecl</name><operator>-&gt;</operator><name>Definition</name></name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>typeCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

<expr><name>Variable</name> <operator>*</operator><name>Nvd</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>enterScope</name></name><argument_list>(<argument><expr><operator>*</operator><name>VarDecl</name></expr></argument>, <argument><expr><name>E0</name></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>E1</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Body</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>declCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Vs</name><operator>.</operator><name>exitScope</name></name><argument_list>(<argument><expr><operator>*</operator><name>VarDecl</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceFunction</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Nvd</name></expr></argument>, <argument><expr><name>E1</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Function* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <name>Ct</name> <operator>=</operator>
<call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name><name>VarDecl</name><operator>-&gt;</operator><name>definition</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>VarDecl</name><operator>-&gt;</operator><name>definition</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cmp</name><operator>.</operator><name>notTrue</name></name><argument_list>(<argument><expr><name>Ct</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ct</name></expr>;</return></block_content></block></if></if_stmt>
<call><name><name>Cmp</name><operator>.</operator><name>enterScope</name></name><argument_list>(<argument><expr><call><name>variableDecl</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>variableDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;
<expr><name>Ct</name> <operator>=</operator> <call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>body</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>body</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Cmp</name><operator>.</operator><name>leaveScope</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>Ct</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>Variable</name> <modifier>*</modifier></type><name>VarDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Body</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>SFunction</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>SFunction</name><argument_list>(<argument><expr><name>Variable</name> <operator>*</operator><name>Vd</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>B</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_SFunction</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>VarDecl</name><argument_list>(<argument><expr><name>Vd</name></expr></argument>)</argument_list></call></expr>, <macro><name>Body</name><argument_list>(<argument>B</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>Vd</name><operator>-&gt;</operator><name>Definition</name></name> <operator>==</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Vd</name><operator>-&gt;</operator><name>setKind</name></name><argument_list>(<argument><expr><name>Variable</name><operator>::</operator><name>VK_SFun</name></expr></argument>)</argument_list></call></expr>;
<expr><name><name>Vd</name><operator>-&gt;</operator><name>Definition</name></name> <operator>=</operator> <name>this</name></expr>;
}</block>

<call><name>SFunction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>SFunction</name> <operator>&amp;</operator><name>F</name></expr></argument>, <argument><expr><name>Variable</name> <operator>*</operator><name>Vd</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>B</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>F</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>VarDecl</name><argument_list>(<argument><expr><name>Vd</name></expr></argument>)</argument_list></call></expr>, <macro><name>Body</name><argument_list>(<argument>B</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>Vd</name><operator>-&gt;</operator><name>Definition</name></name> <operator>==</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Vd</name><operator>-&gt;</operator><name>setKind</name></name><argument_list>(<argument><expr><name>Variable</name><operator>::</operator><name>VK_SFun</name></expr></argument>)</argument_list></call></expr>;
<expr><name><name>Vd</name><operator>-&gt;</operator><name>Definition</name></name> <operator>=</operator> <name>this</name></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_SFunction</name></expr>;</return> }</block>

<name>Variable</name> <operator>*</operator><macro><name>variableDecl</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>VarDecl</name></expr>;</return> }</block>
<specifier>const</specifier> <name>Variable</name> <operator>*</operator><macro><name>variableDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>VarDecl</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>body</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Body</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>body</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Body</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{



<expr><name>Variable</name> <operator>*</operator><name>Nvd</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>enterScope</name></name><argument_list>(<argument><expr><operator>*</operator><name>VarDecl</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>E1</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Body</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>declCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Vs</name><operator>.</operator><name>exitScope</name></name><argument_list>(<argument><expr><operator>*</operator><name>VarDecl</name></expr></argument>)</argument_list></call></expr>;

<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceSFunction</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Nvd</name></expr></argument>, <argument><expr><name>E1</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const SFunction* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name><name>Cmp</name><operator>.</operator><name>enterScope</name></name><argument_list>(<argument><expr><call><name>variableDecl</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>variableDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <name>Ct</name> <operator>=</operator> <call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>body</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>body</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Cmp</name><operator>.</operator><name>leaveScope</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>Ct</name></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>Variable</name> <operator>*</operator><name>VarDecl</name></expr>;
<expr><name>SExpr</name><operator>*</operator> <name>Body</name></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>Code</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>Code</name><argument_list>(<argument><expr><name>SExpr</name> <operator>*</operator><name>T</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>B</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_Code</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ReturnType</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>, <macro><name>Body</name><argument_list>(<argument>B</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>Code</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Code</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>T</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>B</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ReturnType</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>, <macro><name>Body</name><argument_list>(<argument>B</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Code</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>returnType</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>ReturnType</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>returnType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ReturnType</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>body</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Body</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>body</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Body</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Nt</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>ReturnType</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>typeCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>Nb</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Body</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>lazyCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceCode</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Nt</name></expr></argument>, <argument><expr><name>Nb</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Code* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <name>Ct</name> <operator>=</operator> <call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>returnType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>returnType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cmp</name><operator>.</operator><name>notTrue</name></name><argument_list>(<argument><expr><name>Ct</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ct</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>body</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>body</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>ReturnType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Body</name></decl>;</decl_stmt>
};


<decl_stmt><decl><type><name>class</name></type> <name>Field</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>Field</name><argument_list>(<argument><expr><name>SExpr</name> <operator>*</operator><name>R</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>B</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_Field</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Range</name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>, <macro><name>Body</name><argument_list>(<argument>B</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>Field</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Field</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>R</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>B</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Range</name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>, <macro><name>Body</name><argument_list>(<argument>B</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Field</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>range</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Range</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>range</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Range</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>body</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Body</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>body</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Body</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Nr</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Range</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>typeCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>Nb</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Body</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>lazyCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceField</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Nr</name></expr></argument>, <argument><expr><name>Nb</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Field* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <name>Ct</name> <operator>=</operator> <call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>range</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>range</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cmp</name><operator>.</operator><name>notTrue</name></name><argument_list>(<argument><expr><name>Ct</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ct</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>body</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>body</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Range</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Body</name></decl>;</decl_stmt>
};






<decl_stmt><decl><type><name>class</name></type> <name>Apply</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>Apply</name><argument_list>(<argument><expr><name>SExpr</name> <operator>*</operator><name>F</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>A</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_Apply</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Fun</name><argument_list>(<argument><expr><name>F</name></expr></argument>)</argument_list></call></expr>, <macro><name>Arg</name><argument_list>(<argument>A</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>Apply</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Apply</name> <operator>&amp;</operator><name>A</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>F</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>Ar</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Fun</name><argument_list>(<argument><expr><name>F</name></expr></argument>)</argument_list></call></expr>, <macro><name>Arg</name><argument_list>(<argument>Ar</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Apply</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>fun</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Fun</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>fun</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Fun</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>arg</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Arg</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>arg</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Arg</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Nf</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Fun</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>Na</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Arg</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceApply</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Nf</name></expr></argument>, <argument><expr><name>Na</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Apply* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <name>Ct</name> <operator>=</operator> <call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>fun</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>fun</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cmp</name><operator>.</operator><name>notTrue</name></name><argument_list>(<argument><expr><name>Ct</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ct</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>arg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>arg</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Fun</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Arg</name></decl>;</decl_stmt>
};


<decl_stmt><decl><type><name>class</name></type> <name>SApply</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>SApply</name><argument_list>(<argument><expr><name>SExpr</name> <operator>*</operator><name>Sf</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>A</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_SApply</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Sfun</name><argument_list>(<argument><expr><name>Sf</name></expr></argument>)</argument_list></call></expr>, <macro><name>Arg</name><argument_list>(<argument>A</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>SApply</name><argument_list>(<argument><expr><name>SApply</name> <operator>&amp;</operator><name>A</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>Sf</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>Ar</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Sfun</name><argument_list>(<argument><expr><name>Sf</name></expr></argument>)</argument_list></call></expr>, <macro><name>Arg</name><argument_list>(<argument>Ar</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_SApply</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>sfun</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Sfun</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>sfun</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Sfun</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>arg</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Arg</name> <operator>?</operator> <name>Arg</name> <operator>:</operator> <name>Sfun</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>arg</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><ternary><condition><expr><name>Arg</name></expr> ?</condition><then> <expr><name>Arg</name></expr> </then><else>: <expr><name>Sfun</name></expr></else></ternary></expr>;</return> }</block>

<name>bool</name> <macro><name>isDelegation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Arg</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Nf</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Sfun</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <name>Na</name> <operator>=</operator> <ternary><condition><expr><name>Arg</name></expr> ?</condition><then> <expr><call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Arg</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceSApply</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Nf</name></expr></argument>, <argument><expr><name>Na</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const SApply* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <name>Ct</name> <operator>=</operator> <call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>sfun</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>sfun</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cmp</name><operator>.</operator><name>notTrue</name></name><argument_list>(<argument><expr><name>Ct</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><operator>!</operator><call><name>arg</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>E</name><operator>-&gt;</operator><name>arg</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ct</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>arg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>arg</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Sfun</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Arg</name></decl>;</decl_stmt>
};


<decl_stmt><decl><type><name>class</name></type> <name>Project</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>Project</name><argument_list>(<argument><expr><name>SExpr</name> <operator>*</operator><name>R</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><name>Cvd</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_Project</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Rec</name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>, <macro><name>Cvdecl</name><argument_list>(<argument>Cvd</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Cvd</name> <operator>&amp;&amp;</operator> <literal type="string">"ValueDecl must not be null"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Project</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>record</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Rec</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>record</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Rec</name></expr>;</return> }</block>

<specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><macro><name>clangDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Cvdecl</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isArrow</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>Flags</name> <operator>&amp;</operator> <literal type="number">0x01</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return> }</block>

<name>void</name> <macro><name>setArrow</name><argument_list>(<argument>bool b</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>b</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Flags</name> <operator>|=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>Flags</name> <operator>&amp;=</operator> <literal type="number">0xFFFE</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
}</block>

<name>StringRef</name> <macro><name>slotName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Cvdecl</name><operator>-&gt;</operator><name>getDeclName</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isIdentifier</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Cvdecl</name><operator>-&gt;</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>SlotName</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>SlotName</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>raw_string_ostream</name> <call><name>OS</name><argument_list>(<argument><expr><operator>*</operator><name>SlotName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Cvdecl</name><operator>-&gt;</operator><name>printName</name></name><argument_list>(<argument><expr><name>OS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
return *SlotName</block><empty_stmt>;</empty_stmt></if></if_stmt>
}</block></expr></range></decl></decl_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Nr</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Rec</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceProject</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Nr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Project* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <name>Ct</name> <operator>=</operator> <call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>record</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>record</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cmp</name><operator>.</operator><name>notTrue</name></name><argument_list>(<argument><expr><name>Ct</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ct</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>comparePointers</name></name><argument_list>(<argument><expr><name>Cvdecl</name></expr></argument>, <argument><expr><name><name>E</name><operator>-&gt;</operator><name>Cvdecl</name></name></expr></argument>)</argument_list></call></expr>;</return>
}

private:
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Rec</name></decl>;</decl_stmt>
<expr_stmt><expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>SlotName</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ValueDecl</name> <modifier>*</modifier></type><name>Cvdecl</name></decl>;</decl_stmt>
};


<decl_stmt><decl><type><name>class</name></type> <name>Call</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>Call</name><argument_list>(<argument><expr><name>SExpr</name> <operator>*</operator><name>T</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CallExpr</name> <operator>*</operator><name>Ce</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_Call</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Target</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>, <macro><name>Cexpr</name><argument_list>(<argument>Ce</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>Call</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Call</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Target</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>, <macro><name>Cexpr</name><argument_list>(<argument>C.Cexpr</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Call</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>target</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Target</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>target</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Target</name></expr>;</return> }</block>

<specifier>const</specifier> <name>CallExpr</name> <operator>*</operator><macro><name>clangCallExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Cexpr</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Nt</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Target</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceCall</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Nt</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Call* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>target</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>target</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>SExpr</name><operator>*</operator> <name>Target</name></expr>;
<expr><specifier>const</specifier> <name>CallExpr</name> <operator>*</operator><name>Cexpr</name></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>Alloc</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
enum <name>AllocKind</name> <block>{
<expr><name>AK_Stack</name></expr>,
<expr><name>AK_Heap</name></expr>
}</block></expr>;

<macro><name>Alloc</name><argument_list>(<argument>SExpr *D</argument>, <argument>AllocKind K</argument>)</argument_list></macro> <operator>:</operator> <expr><call><name>SExpr</name><argument_list>(<argument><expr><name>COP_Alloc</name></expr></argument>)</argument_list></call></expr>, <macro><name>Dtype</name><argument_list>(<argument>D</argument>)</argument_list></macro> <expr><block>{ <expr><name>Flags</name> <operator>=</operator> <name>K</name></expr>; }</block>
<call><name>Alloc</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Alloc</name> <operator>&amp;</operator><name>A</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>Dt</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>, <macro><name>Dtype</name><argument_list>(<argument>Dt</argument>)</argument_list></macro> <expr><block>{ <expr><name>Flags</name> <operator>=</operator> <call><name><name>A</name><operator>.</operator><name>kind</name></name><argument_list>()</argument_list></call></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Call</name></expr>;</return> }</block>

<name>AllocKind</name> <macro><name>kind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>AllocKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Flags</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>dataType</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Dtype</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>dataType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Dtype</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Nd</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Dtype</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>declCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceAlloc</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Nd</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Alloc* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <name>Ct</name> <operator>=</operator> <call><name><name>Cmp</name><operator>.</operator><name>compareIntegers</name></name><argument_list>(<argument><expr><call><name>kind</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>kind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cmp</name><operator>.</operator><name>notTrue</name></name><argument_list>(<argument><expr><name>Ct</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ct</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>dataType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>dataType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Dtype</name></decl>;</decl_stmt>
};


<decl_stmt><decl><type><name>class</name></type> <name>Load</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>Load</name><argument_list>(<argument><expr><name>SExpr</name> <operator>*</operator><name>P</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_Load</name></expr></argument>)</argument_list></call></expr>, <macro><name>Ptr</name><argument_list>(<argument>P</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>Load</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Load</name> <operator>&amp;</operator><name>L</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>P</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>, <macro><name>Ptr</name><argument_list>(<argument>P</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Load</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>pointer</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Ptr</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>pointer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Ptr</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Np</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Ptr</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceLoad</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Np</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Load* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>pointer</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>pointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>SExpr</name><operator>*</operator> <name>Ptr</name></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>Store</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>Store</name><argument_list>(<argument><expr><name>SExpr</name> <operator>*</operator><name>P</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>V</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_Store</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Dest</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>, <macro><name>Source</name><argument_list>(<argument>V</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>Store</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Store</name> <operator>&amp;</operator><name>S</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>P</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>V</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Dest</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>, <macro><name>Source</name><argument_list>(<argument>V</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Store</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>destination</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Dest</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>destination</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Dest</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>source</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Source</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>source</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Source</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Np</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Dest</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>Nv</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Source</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceStore</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Np</name></expr></argument>, <argument><expr><name>Nv</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Store* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <name>Ct</name> <operator>=</operator> <call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>destination</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>destination</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cmp</name><operator>.</operator><name>notTrue</name></name><argument_list>(<argument><expr><name>Ct</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ct</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>source</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>source</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Dest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Source</name></decl>;</decl_stmt>
};



<decl_stmt><decl><type><name>class</name></type> <name>ArrayIndex</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>ArrayIndex</name><argument_list>(<argument><expr><name>SExpr</name> <operator>*</operator><name>A</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_ArrayIndex</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Array</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>, <macro><name>Index</name><argument_list>(<argument>N</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>ArrayIndex</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ArrayIndex</name> <operator>&amp;</operator><name>E</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>A</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Array</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>, <macro><name>Index</name><argument_list>(<argument>N</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_ArrayIndex</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>array</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Array</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>array</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Array</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>index</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Index</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>index</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Index</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Na</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Array</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>Ni</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Index</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceArrayIndex</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Na</name></expr></argument>, <argument><expr><name>Ni</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const ArrayIndex* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <name>Ct</name> <operator>=</operator> <call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>array</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>array</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cmp</name><operator>.</operator><name>notTrue</name></name><argument_list>(<argument><expr><name>Ct</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ct</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>index</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>index</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Array</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Index</name></decl>;</decl_stmt>
};




<decl_stmt><decl><type><name>class</name></type> <name>ArrayAdd</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>ArrayAdd</name><argument_list>(<argument><expr><name>SExpr</name> <operator>*</operator><name>A</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_ArrayAdd</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Array</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>, <macro><name>Index</name><argument_list>(<argument>N</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>ArrayAdd</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ArrayAdd</name> <operator>&amp;</operator><name>E</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>A</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Array</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>, <macro><name>Index</name><argument_list>(<argument>N</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_ArrayAdd</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>array</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Array</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>array</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Array</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>index</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Index</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>index</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Index</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Na</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Array</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>Ni</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Index</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceArrayAdd</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Na</name></expr></argument>, <argument><expr><name>Ni</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const ArrayAdd* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <name>Ct</name> <operator>=</operator> <call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>array</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>array</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cmp</name><operator>.</operator><name>notTrue</name></name><argument_list>(<argument><expr><name>Ct</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ct</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>index</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>index</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Array</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Index</name></decl>;</decl_stmt>
};



<decl_stmt><decl><type><name>class</name></type> <name>UnaryOp</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>UnaryOp</name><argument_list>(<argument>TIL_UnaryOpcode Op</argument>, <argument>SExpr *E</argument>)</argument_list></macro> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_UnaryOp</name></expr></argument>)</argument_list></call></expr>, <macro><name>Expr0</name><argument_list>(<argument>E</argument>)</argument_list></macro> <expr><block>{
<expr><name>Flags</name> <operator>=</operator> <name>Op</name></expr>;
}</block>

<call><name>UnaryOp</name><argument_list>(<argument><expr><specifier>const</specifier> <name>UnaryOp</name> <operator>&amp;</operator><name>U</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>, <macro><name>Expr0</name><argument_list>(<argument>E</argument>)</argument_list></macro> <expr><block>{ <expr><name>Flags</name> <operator>=</operator> <name><name>U</name><operator>.</operator><name>Flags</name></name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_UnaryOp</name></expr>;</return> }</block>

<name>TIL_UnaryOpcode</name> <macro><name>unaryOpcode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TIL_UnaryOpcode</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Flags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SExpr</name> <operator>*</operator><macro><name>expr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Expr0</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>expr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Expr0</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Ne</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Expr0</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceUnaryOp</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Ne</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const UnaryOp* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <name>Ct</name> <operator>=</operator>
<call><name><name>Cmp</name><operator>.</operator><name>compareIntegers</name></name><argument_list>(<argument><expr><call><name>unaryOpcode</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>unaryOpcode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cmp</name><operator>.</operator><name>notTrue</name></name><argument_list>(<argument><expr><name>Ct</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ct</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>expr</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>expr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Expr0</name></decl>;</decl_stmt>
};



<decl_stmt><decl><type><name>class</name></type> <name>BinaryOp</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>BinaryOp</name><argument_list>(<argument>TIL_BinaryOpcode Op</argument>, <argument>SExpr *E0</argument>, <argument>SExpr *E1</argument>)</argument_list></macro>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_BinaryOp</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Expr0</name><argument_list>(<argument><expr><name>E0</name></expr></argument>)</argument_list></call></expr>, <macro><name>Expr1</name><argument_list>(<argument>E1</argument>)</argument_list></macro> <expr><block>{
<expr><name>Flags</name> <operator>=</operator> <name>Op</name></expr>;
}</block>

<call><name>BinaryOp</name><argument_list>(<argument><expr><specifier>const</specifier> <name>BinaryOp</name> <operator>&amp;</operator><name>B</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>E0</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>E1</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Expr0</name><argument_list>(<argument><expr><name>E0</name></expr></argument>)</argument_list></call></expr>, <macro><name>Expr1</name><argument_list>(<argument>E1</argument>)</argument_list></macro> <expr><block>{
<expr><name>Flags</name> <operator>=</operator> <name><name>B</name><operator>.</operator><name>Flags</name></name></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_BinaryOp</name></expr>;</return> }</block>

<name>TIL_BinaryOpcode</name> <macro><name>binaryOpcode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TIL_BinaryOpcode</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Flags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SExpr</name> <operator>*</operator><macro><name>expr0</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Expr0</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>expr0</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Expr0</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>expr1</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Expr1</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>expr1</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Expr1</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Ne0</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Expr0</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>Ne1</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Expr1</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceBinaryOp</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Ne0</name></expr></argument>, <argument><expr><name>Ne1</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const BinaryOp* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <name>Ct</name> <operator>=</operator>
<call><name><name>Cmp</name><operator>.</operator><name>compareIntegers</name></name><argument_list>(<argument><expr><call><name>binaryOpcode</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>binaryOpcode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cmp</name><operator>.</operator><name>notTrue</name></name><argument_list>(<argument><expr><name>Ct</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ct</name></expr>;</return></block_content></block></if></if_stmt>
<name>Ct</name> <operator>=</operator> <call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>expr0</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>expr0</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cmp</name><operator>.</operator><name>notTrue</name></name><argument_list>(<argument><expr><name>Ct</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ct</name></expr>;</return></block_content></block></if></if_stmt></block></expr></range></decl></decl_stmt>
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>expr1</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>expr1</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

private:
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Expr0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Expr1</name></decl>;</decl_stmt>
};




<decl_stmt><decl><type><name>class</name></type> <name>Cast</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>Cast</name><argument_list>(<argument>TIL_CastOpcode Op</argument>, <argument>SExpr *E</argument>)</argument_list></macro> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_Cast</name></expr></argument>)</argument_list></call></expr>, <macro><name>Expr0</name><argument_list>(<argument>E</argument>)</argument_list></macro> <expr><block>{ <expr><name>Flags</name> <operator>=</operator> <name>Op</name></expr>; }</block>
<call><name>Cast</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Cast</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>, <macro><name>Expr0</name><argument_list>(<argument>E</argument>)</argument_list></macro> <expr><block>{ <expr><name>Flags</name> <operator>=</operator> <name><name>C</name><operator>.</operator><name>Flags</name></name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Cast</name></expr>;</return> }</block>

<name>TIL_CastOpcode</name> <macro><name>castOpcode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TIL_CastOpcode</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Flags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SExpr</name> <operator>*</operator><macro><name>expr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Expr0</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>expr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Expr0</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Ne</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Expr0</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceCast</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Ne</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Cast* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <name>Ct</name> <operator>=</operator>
<call><name><name>Cmp</name><operator>.</operator><name>compareIntegers</name></name><argument_list>(<argument><expr><call><name>castOpcode</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>castOpcode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cmp</name><operator>.</operator><name>notTrue</name></name><argument_list>(<argument><expr><name>Ct</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ct</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>expr</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>expr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Expr0</name></decl>;</decl_stmt>
};

<decl_stmt><decl><type><name>class</name></type> <name>SCFG</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>Phi</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>using</name> <name>ValArray</name> <operator>=</operator> <name><name>SimpleArray</name><argument_list type="generic">&lt;<argument><expr><name>SExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;




enum <expr><name>Status</name> <block>{
<expr><name>PH_MultiVal</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><name>PH_SingleVal</name></expr>,
<expr><name>PH_Incomplete</name></expr>
}</block></expr>;

<expr><call><name>Phi</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>SExpr</name><argument_list>(<argument>COP_Phi</argument>)</argument_list></macro> <block>{}</block>
<macro><name>Phi</name><argument_list>(<argument>MemRegionRef A</argument>, <argument>unsigned Nvals</argument>)</argument_list></macro> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_Phi</name></expr></argument>)</argument_list></call></expr>, <macro><name>Values</name><argument_list>(<argument>A</argument>, <argument>Nvals</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>Phi</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Phi</name> <operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>ValArray</name> <operator>&amp;&amp;</operator><name>Vs</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>, <macro><name>Values</name><argument_list>(<argument>std::move(Vs)</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Phi</name></expr>;</return> }</block>

<specifier>const</specifier> <name>ValArray</name> <operator>&amp;</operator><macro><name>values</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Values</name></expr>;</return> }</block>
<name>ValArray</name> <operator>&amp;</operator><macro><name>values</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Values</name></expr>;</return> }</block>

<name>Status</name> <macro><name>status</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Status</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Flags</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setStatus</name><argument_list>(<argument>Status s</argument>)</argument_list></macro> <block>{ <expr><name>Flags</name> <operator>=</operator> <name>s</name></expr>; }</block>


<specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><macro><name>clangDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Cvdecl</name></expr>;</return> }</block>


<name>void</name> <macro><name>setClangDecl</name><argument_list>(<argument>const ValueDecl *Cvd</argument>)</argument_list></macro> <block>{ <expr><name>Cvdecl</name> <operator>=</operator> <name>Cvd</name></expr>; }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>typename</name> <name>V</name><operator>::</operator><name>template</name> <name><name>Container</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name></expr></argument>&gt;</argument_list></name>
<call><name>Nvs</name><argument_list>(<argument><expr><name>Vs</name></expr></argument>, <argument><expr><call><name><name>Values</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;

<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>Val</name> <range>: <expr><name>Values</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Nvs</name><operator>.</operator><name>push_back</name></name><argument_list>( <argument><expr><call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Val</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></for></block></expr>
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reducePhi</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Nvs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Phi *E</argument>, <argument>C &amp;Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{

<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>comparePointers</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>ValArray</name></type> <name>Values</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ValueDecl</name><modifier>*</modifier></type> <name>Cvdecl</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
};


<decl_stmt><decl><type><name>class</name></type> <name>Terminator</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>protected</name><operator>:</operator>
<macro><name>Terminator</name><argument_list>(<argument>TIL_Opcode Op</argument>)</argument_list></macro> <operator>:</operator> <macro><name>SExpr</name><argument_list>(<argument>Op</argument>)</argument_list></macro> <block>{}</block>
<call><name>Terminator</name><argument_list>(<argument><expr><specifier>const</specifier> <name>SExpr</name> <operator>&amp;</operator><name>E</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>SExpr</name><argument_list>(<argument>E</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>COP_Goto</name> <operator>&amp;&amp;</operator> <call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>COP_Return</name></expr>;</return>
}</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>BasicBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <call><name>successors</name><argument_list>()</argument_list></call></expr>;

<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>BasicBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>successors</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Terminator</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>successors</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;






<expr><name>class</name> <name>Goto</name> <operator>:</operator> <name>public</name> <name>Terminator</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>Goto</name><argument_list>(<argument>BasicBlock *B</argument>, <argument>unsigned I</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Terminator</name><argument_list>(<argument><expr><name>COP_Goto</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>TargetBlock</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>, <macro><name>Index</name><argument_list>(<argument>I</argument>)</argument_list></macro> <expr><block>{}</block>
<macro><name>Goto</name><argument_list>(<argument>const Goto &amp;G</argument>, <argument>BasicBlock *B</argument>, <argument>unsigned I</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Terminator</name><argument_list>(<argument><expr><name>COP_Goto</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>TargetBlock</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>, <macro><name>Index</name><argument_list>(<argument>I</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Goto</name></expr>;</return> }</block>

<specifier>const</specifier> <name>BasicBlock</name> <operator>*</operator><macro><name>targetBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TargetBlock</name></expr>;</return> }</block>
<name>BasicBlock</name> <operator>*</operator><macro><name>targetBlock</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>TargetBlock</name></expr>;</return> }</block>


<name>unsigned</name> <macro><name>index</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Index</name></expr>;</return> }</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>BasicBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>successors</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>TargetBlock</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>BasicBlock</name> <operator>*</operator><name>Ntb</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>reduceBasicBlockRef</name></name><argument_list>(<argument><expr><name>TargetBlock</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceGoto</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Ntb</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Goto *E</argument>, <argument>C &amp;Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{

<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>comparePointers</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>BasicBlock</name> <operator>*</operator><name>TargetBlock</name></expr>;
<expr><name>unsigned</name> <name>Index</name></expr>;
}</block></expr>;




<expr><name>class</name> <name>Branch</name> <operator>:</operator> <name>public</name> <name>Terminator</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>Branch</name><argument_list>(<argument><expr><name>SExpr</name> <operator>*</operator><name>C</name></expr></argument>, <argument><expr><name>BasicBlock</name> <operator>*</operator><name>T</name></expr></argument>, <argument><expr><name>BasicBlock</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Terminator</name><argument_list>(<argument><expr><name>COP_Branch</name></expr></argument>)</argument_list></call></expr>, <macro><name>Condition</name><argument_list>(<argument>C</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>Branches</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>T</name></expr>;
<expr><name><name>Branches</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>E</name></expr>;
}</block>

<call><name>Branch</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Branch</name> <operator>&amp;</operator><name>Br</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>C</name></expr></argument>, <argument><expr><name>BasicBlock</name> <operator>*</operator><name>T</name></expr></argument>, <argument><expr><name>BasicBlock</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Terminator</name><argument_list>(<argument><expr><name>Br</name></expr></argument>)</argument_list></call></expr>, <macro><name>Condition</name><argument_list>(<argument>C</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>Branches</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>T</name></expr>;
<expr><name><name>Branches</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>E</name></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Branch</name></expr>;</return> }</block>

<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>condition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Condition</name></expr>;</return> }</block>
<name>SExpr</name> <operator>*</operator><macro><name>condition</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Condition</name></expr>;</return> }</block>

<specifier>const</specifier> <name>BasicBlock</name> <operator>*</operator><macro><name>thenBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Branches</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return> }</block>
<name>BasicBlock</name> <operator>*</operator><macro><name>thenBlock</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name><name>Branches</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return> }</block>

<specifier>const</specifier> <name>BasicBlock</name> <operator>*</operator><macro><name>elseBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Branches</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return> }</block>
<name>BasicBlock</name> <operator>*</operator><macro><name>elseBlock</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name><name>Branches</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return> }</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>BasicBlock</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>successors</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><name>Branches</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Nc</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Condition</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>BasicBlock</name> <operator>*</operator><name>Ntb</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>reduceBasicBlockRef</name></name><argument_list>(<argument><expr><name><name>Branches</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;
<expr><name>BasicBlock</name> <operator>*</operator><name>Nte</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>reduceBasicBlockRef</name></name><argument_list>(<argument><expr><name><name>Branches</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceBranch</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Nc</name></expr></argument>, <argument><expr><name>Ntb</name></expr></argument>, <argument><expr><name>Nte</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Branch *E</argument>, <argument>C &amp;Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{

<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>comparePointers</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>SExpr</name> <operator>*</operator><name>Condition</name></expr>;
<expr><name>BasicBlock</name> <operator>*</operator><name><name>Branches</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;
}</block></expr>;



<expr><name>class</name> <name>Return</name> <operator>:</operator> <name>public</name> <name>Terminator</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>Return</name><argument_list>(<argument><expr><name>SExpr</name><operator>*</operator> <name>Rval</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>Terminator</name><argument_list>(<argument><expr><name>COP_Return</name></expr></argument>)</argument_list></call></expr>, <macro><name>Retval</name><argument_list>(<argument>Rval</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>Return</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Return</name> <operator>&amp;</operator><name>R</name></expr></argument>, <argument><expr><name>SExpr</name><operator>*</operator> <name>Rval</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>Terminator</name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>, <macro><name>Retval</name><argument_list>(<argument>Rval</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Return</name></expr>;</return> }</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>BasicBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>successors</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>None</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>returnValue</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Retval</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>returnValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Retval</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Ne</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Retval</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceReturn</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Ne</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Return *E</argument>, <argument>C &amp;Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name>Retval</name></expr></argument>, <argument><expr><name><name>E</name><operator>-&gt;</operator><name>Retval</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>SExpr</name><operator>*</operator> <name>Retval</name></expr>;
}</block></expr>;

<expr><specifier>inline</specifier> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>BasicBlock</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Terminator</name><operator>::</operator><macro><name>successors</name><argument_list>()</argument_list></macro> <block>{
<switch>switch <condition>(<expr><call><name>opcode</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>COP_Goto</name></expr>:</case> <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Goto</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>successors</name><argument_list>()</argument_list></call></expr>;</return>
<case>case <expr><name>COP_Branch</name></expr>:</case> <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Branch</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>successors</name><argument_list>()</argument_list></call></expr>;</return>
<case>case <expr><name>COP_Return</name></expr>:</case> <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Return</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>successors</name><argument_list>()</argument_list></call></expr>;</return>
<default>default:</default>
<return>return <expr><name>None</name></expr>;</return>
<expr_stmt/>}</block_content>
}






class BasicBlock : public SExpr <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><name>using</name></type> <name>InstrArray</name> <init>= <expr><name><name>SimpleArray</name><argument_list type="generic">&lt;<argument><expr><name>SExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>BlockArray</name> <init>= <expr><name><name>SimpleArray</name><argument_list type="generic">&lt;<argument><expr><name>BasicBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>





<struct>struct <name>TopologyNode</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>NodeID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>SizeOfSubTree</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>BasicBlock</name> <modifier>*</modifier></type><name>Parent</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TopologyNode</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>

<function><type><name>bool</name></type> <name>isParentOf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TopologyNode</name><modifier>&amp;</modifier></type> <name>OtherNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name><name>OtherNode</name><operator>.</operator><name>NodeID</name></name> <operator>&gt;</operator> <name>NodeID</name> <operator>&amp;&amp;</operator>
<name><name>OtherNode</name><operator>.</operator><name>NodeID</name></name> <operator>&lt;</operator> <name>NodeID</name> <operator>+</operator> <name>SizeOfSubTree</name></expr>;</return>
<expr_stmt/>}</block_content>

bool isParentOfOrEqual(const TopologyNode&amp; OtherNode</block></function>)</block> <block>{<block_content>
<return>return <expr><name><name>OtherNode</name><operator>.</operator><name>NodeID</name></name> <operator>&gt;=</operator> <name>NodeID</name> <operator>&amp;&amp;</operator>
<name><name>OtherNode</name><operator>.</operator><name>NodeID</name></name> <operator>&lt;</operator> <name>NodeID</name> <operator>+</operator> <name>SizeOfSubTree</name></expr>;</return>
<expr_stmt/>}</block_content>
}</block>;</struct>

<macro><name>explicit</name></macro> <macro><name>BasicBlock</name><argument_list>(<argument>MemRegionRef A</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>SExpr</name><argument_list>(<argument><expr><name>COP_BasicBlock</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Arena</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>BlockID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Visited</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>
<macro><name>BasicBlock</name><argument_list>(<argument>BasicBlock &amp;B</argument>, <argument>MemRegionRef A</argument>, <argument>InstrArray &amp;&amp;As</argument>, <argument>InstrArray &amp;&amp;Is</argument>,
<argument>Terminator *T</argument>)</argument_list></macro>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_BasicBlock</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Arena</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>BlockID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Visited</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>Args</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>As</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Instrs</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Is</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>TermInstr</name><argument_list>(<argument>T</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_BasicBlock</name></expr>;</return> }</block>


<name>int</name> <macro><name>blockID</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BlockID</name></expr>;</return> }</block>


<name>size_t</name> <macro><name>numPredecessors</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Predecessors</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>size_t</name> <macro><name>numSuccessors</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>successors</name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>const</specifier> <name>SCFG</name><operator>*</operator> <macro><name>cfg</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CFGPtr</name></expr>;</return> }</block>
<name>SCFG</name><operator>*</operator> <macro><name>cfg</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>CFGPtr</name></expr>;</return> }</block>

<specifier>const</specifier> <name>BasicBlock</name> <operator>*</operator><macro><name>parent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>DominatorNode</name><operator>.</operator><name>Parent</name></name></expr>;</return> }</block>
<name>BasicBlock</name> <operator>*</operator><macro><name>parent</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name><name>DominatorNode</name><operator>.</operator><name>Parent</name></name></expr>;</return> }</block>

<specifier>const</specifier> <name>InstrArray</name> <operator>&amp;</operator><macro><name>arguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Args</name></expr>;</return> }</block>
<name>InstrArray</name> <operator>&amp;</operator><macro><name>arguments</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Args</name></expr>;</return> }</block>

<name>InstrArray</name> <operator>&amp;</operator><macro><name>instructions</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Instrs</name></expr>;</return> }</block>
<specifier>const</specifier> <name>InstrArray</name> <operator>&amp;</operator><macro><name>instructions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Instrs</name></expr>;</return> }</block>




<name>BlockArray</name> <operator>&amp;</operator><macro><name>predecessors</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Predecessors</name></expr>;</return> }</block>
<specifier>const</specifier> <name>BlockArray</name> <operator>&amp;</operator><macro><name>predecessors</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Predecessors</name></expr>;</return> }</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>BasicBlock</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>successors</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>TermInstr</name><operator>-&gt;</operator><name>successors</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>BasicBlock</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>successors</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>TermInstr</name><operator>-&gt;</operator><name>successors</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>const</specifier> <name>Terminator</name> <operator>*</operator><macro><name>terminator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TermInstr</name></expr>;</return> }</block>
<name>Terminator</name> <operator>*</operator><macro><name>terminator</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>TermInstr</name></expr>;</return> }</block>

<name>void</name> <macro><name>setTerminator</name><argument_list>(<argument>Terminator *E</argument>)</argument_list></macro> <block>{ <expr><name>TermInstr</name> <operator>=</operator> <name>E</name></expr>; }</block>

<name>bool</name> <macro><name>Dominates</name><argument_list>(<argument>const BasicBlock &amp;Other</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>DominatorNode</name><operator>.</operator><name>isParentOfOrEqual</name></name><argument_list>(<argument><expr><name><name>Other</name><operator>.</operator><name>DominatorNode</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>PostDominates</name><argument_list>(<argument>const BasicBlock &amp;Other</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>PostDominatorNode</name><operator>.</operator><name>isParentOfOrEqual</name></name><argument_list>(<argument><expr><name><name>Other</name><operator>.</operator><name>PostDominatorNode</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>void</name> <macro><name>addArgument</name><argument_list>(<argument>Phi *V</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Args</name><operator>.</operator><name>reserveCheck</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>Arena</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Args</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>void</name> <macro><name>addInstruction</name><argument_list>(<argument>SExpr *V</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Instrs</name><operator>.</operator><name>reserveCheck</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>Arena</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Instrs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr>;
}</block>



<name>unsigned</name> <call><name>addPredecessor</name><argument_list>(<argument><expr><name>BasicBlock</name> <operator>*</operator><name>Pred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function><type><name>void</name></type> <name>reserveArguments</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Nargs</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>Args</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><name>Nargs</name></expr></argument>, <argument><expr><name>Arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt/>}</block_content>


void reserveInstructions(unsigned Nins</block></function>)</block_content> <block>{<block_content> <expr_stmt><expr><call><name><name>Instrs</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><name>Nins</name></expr></argument>, <argument><expr><name>Arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt/>}</block_content>


void reservePredecessors(unsigned NumPreds</block></block></block></switch>)</block></expr>;


<expr><name>unsigned</name> <macro><name>findPredecessorIndex</name><argument_list>(<argument>const BasicBlock *BB</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>I</name> <operator>=</operator> <name>llvm</name><operator>::</operator><call><name>find</name><argument_list>(<argument><expr><name>Predecessors</name></expr></argument>, <argument><expr><name>BB</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>std</name><operator>::</operator><call><name>distance</name><argument_list>(<argument><expr><call><name><name>Predecessors</name><operator>.</operator><name>cbegin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_BasicBlock</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>typename</name> <name>V</name><operator>::</operator><name>template</name> <name><name>Container</name><argument_list type="generic">&lt;<argument><expr><name>SExpr</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <call><name>Nas</name><argument_list>(<argument><expr><name>Vs</name></expr></argument>, <argument><expr><call><name><name>Args</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>typename</name> <name>V</name><operator>::</operator><name>template</name> <name><name>Container</name><argument_list type="generic">&lt;<argument><expr><name>SExpr</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <call><name>Nis</name><argument_list>(<argument><expr><name>Vs</name></expr></argument>, <argument><expr><call><name><name>Instrs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;


<expr><call><name><name>Vs</name><operator>.</operator><name>enterBasicBlock</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;

<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>E</name> <range>: <expr><name>Args</name></expr></range></decl></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>Ne</name> <init>= <expr><call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Nas</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>Ne</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
for (const auto *E : Instrs</block></for>) <block>{
<expr><name>auto</name> <name>Ne</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Nis</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>Ne</name></expr></argument>)</argument_list></call></expr>;
}</block></block>
<name>auto</name> <name>Nt</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>TermInstr</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr>;


<expr><call><name><name>Vs</name><operator>.</operator><name>exitBasicBlock</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;

<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceBasicBlock</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Nas</name></expr></argument>, <argument><expr><name>Nis</name></expr></argument>, <argument><expr><name>Nt</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const BasicBlock *E</argument>, <argument>C &amp;Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{

<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>comparePointers</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>SCFG</name></decl>;</decl_stmt>


<function_decl><type><name>unsigned</name></type> <name>renumberInstrs</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>id</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>unsigned</name></type> <name>topologicalSort</name><parameter_list>(<parameter><decl><type><name><name>SimpleArray</name><argument_list type="generic">&lt;<argument><expr><name>BasicBlock</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Blocks</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>unsigned</name></type> <name>topologicalFinalSort</name><parameter_list>(<parameter><decl><type><name><name>SimpleArray</name><argument_list type="generic">&lt;<argument><expr><name>BasicBlock</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Blocks</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>computeDominator</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>computePostDominator</name><parameter_list>()</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>MemRegionRef</name></type> <name>Arena</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SCFG</name> <modifier>*</modifier></type><name>CFGPtr</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>BlockID</name> <range>: <expr><literal type="number">31</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>Visited</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>BlockArray</name></type> <name>Predecessors</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>InstrArray</name></type> <name>Args</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>InstrArray</name></type> <name>Instrs</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Terminator</name> <modifier>*</modifier></type><name>TermInstr</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>TopologyNode</name></type> <name>DominatorNode</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>TopologyNode</name></type> <name>PostDominatorNode</name></decl>;</decl_stmt>
};




<decl_stmt><decl><type><name>class</name></type> <name>SCFG</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>using</name> <name>BlockArray</name> <operator>=</operator> <name><name>SimpleArray</name><argument_list type="generic">&lt;<argument><expr><name>BasicBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>iterator</name> <operator>=</operator> <name>BlockArray</name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>const_iterator</name> <operator>=</operator> <name>BlockArray</name><operator>::</operator><name>const_iterator</name></expr>;

<macro><name>SCFG</name><argument_list>(<argument>MemRegionRef A</argument>, <argument>unsigned Nblocks</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>SExpr</name><argument_list>(<argument><expr><name>COP_SCFG</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Arena</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>, <macro><name>Blocks</name><argument_list>(<argument>A</argument>, <argument>Nblocks</argument>)</argument_list></macro> <expr><block>{
<expr><name>Entry</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>A</argument>)</argument_list></macro> <call><name>BasicBlock</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Exit</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>A</argument>)</argument_list></macro> <call><name>BasicBlock</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <operator>*</operator><name>V</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>A</argument>)</argument_list></macro> <call><name>Phi</name><argument_list>()</argument_list></call></expr>;
<expr><call><name><name>Exit</name><operator>-&gt;</operator><name>addArgument</name></name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Exit</name><operator>-&gt;</operator><name>setTerminator</name></name><argument_list>(<argument><expr><macro><name>new</name> <argument_list>(<argument>A</argument>)</argument_list></macro> <call><name>Return</name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>add</name><argument_list>(<argument><expr><name>Entry</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>add</name><argument_list>(<argument><expr><name>Exit</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>SCFG</name><argument_list>(<argument><expr><specifier>const</specifier> <name>SCFG</name> <operator>&amp;</operator><name>Cfg</name></expr></argument>, <argument><expr><name>BlockArray</name> <operator>&amp;&amp;</operator><name>Ba</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_SCFG</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Arena</name><argument_list>(<argument><expr><name><name>Cfg</name><operator>.</operator><name>Arena</name></name></expr></argument>)</argument_list></call></expr>, <macro><name>Blocks</name><argument_list>(<argument>std::move(Ba)</argument>)</argument_list></macro> <expr><block>{

}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_SCFG</name></expr>;</return> }</block>


<name>bool</name> <macro><name>valid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Entry</name> <operator>&amp;&amp;</operator> <name>Exit</name> <operator>&amp;&amp;</operator> <call><name><name>Blocks</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return> }</block>




<name>bool</name> <macro><name>normal</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Normal</name></expr>;</return> }</block>

<name>iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Blocks</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Blocks</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>const_iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>cbegin</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>cend</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>const_iterator</name> <macro><name>cbegin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Blocks</name><operator>.</operator><name>cbegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_iterator</name> <macro><name>cend</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Blocks</name><operator>.</operator><name>cend</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>const</specifier> <name>BasicBlock</name> <operator>*</operator><macro><name>entry</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Entry</name></expr>;</return> }</block>
<name>BasicBlock</name> <operator>*</operator><macro><name>entry</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Entry</name></expr>;</return> }</block>
<specifier>const</specifier> <name>BasicBlock</name> <operator>*</operator><macro><name>exit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Exit</name></expr>;</return> }</block>
<name>BasicBlock</name> <operator>*</operator><macro><name>exit</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Exit</name></expr>;</return> }</block>



<name>size_t</name> <macro><name>numBlocks</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Blocks</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>




<name>unsigned</name> <macro><name>numInstructions</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>NumInstructions</name></expr>;</return> }</block>

<specifier>inline</specifier> <name>void</name> <macro><name>add</name><argument_list>(<argument>BasicBlock *BB</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>BB</name><operator>-&gt;</operator><name>CFGPtr</name></name> <operator>==</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;
<expr><name><name>BB</name><operator>-&gt;</operator><name>CFGPtr</name></name> <operator>=</operator> <name>this</name></expr>;
<expr><call><name><name>Blocks</name><operator>.</operator><name>reserveCheck</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>Arena</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Blocks</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>BB</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>setEntry</name><argument_list>(<argument>BasicBlock *BB</argument>)</argument_list></macro> <block>{ <expr><name>Entry</name> <operator>=</operator> <name>BB</name></expr>; }</block>
<name>void</name> <macro><name>setExit</name><argument_list>(<argument>BasicBlock *BB</argument>)</argument_list></macro> <block>{ <expr><name>Exit</name> <operator>=</operator> <name>BB</name></expr>; }</block>

<name>void</name> <call><name>computeNormalForm</name><argument_list>()</argument_list></call></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Vs</name><operator>.</operator><name>enterCFG</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;
<expr><name>typename</name> <name>V</name><operator>::</operator><name>template</name> <name><name>Container</name><argument_list type="generic">&lt;<argument><expr><name>BasicBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <call><name>Bbs</name><argument_list>(<argument><expr><name>Vs</name></expr></argument>, <argument><expr><call><name><name>Blocks</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;

<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>B</name> <range>: <expr><name>Blocks</name></expr></range></decl></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name><name>Bbs</name><operator>.</operator><name>push_back</name></name><argument_list>( <argument><expr><call><name><name>B</name><operator>-&gt;</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Vs</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
Vs.exitCFG(*this</block></for>)</block></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceSCFG</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Bbs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const SCFG *E</argument>, <argument>C &amp;Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{

<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>comparePointers</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>

<function_decl><type><name>void</name></type> <name>renumberInstrs</name><parameter_list>()</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>MemRegionRef</name></type> <name>Arena</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BlockArray</name></type> <name>Blocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BasicBlock</name> <modifier>*</modifier></type><name>Entry</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BasicBlock</name> <modifier>*</modifier></type><name>Exit</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumInstructions</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Normal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
};



<decl_stmt><decl><type><name>class</name></type> <name>Identifier</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>Identifier</name><argument_list>(<argument>StringRef Id</argument>)</argument_list></macro><operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_Identifier</name></expr></argument>)</argument_list></call></expr>, <macro><name>Name</name><argument_list>(<argument>Id</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>Identifier</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Identifier</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Identifier</name></expr>;</return> }</block>

<name>StringRef</name> <macro><name>name</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Name</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceIdentifier</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Identifier* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>compareStrings</name></name><argument_list>(<argument><expr><call><name>name</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>name</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>StringRef</name> <name>Name</name></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>IfThenElse</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>IfThenElse</name><argument_list>(<argument><expr><name>SExpr</name> <operator>*</operator><name>C</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>T</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_IfThenElse</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Condition</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ThenExpr</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>, <macro><name>ElseExpr</name><argument_list>(<argument>E</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>IfThenElse</name><argument_list>(<argument><expr><specifier>const</specifier> <name>IfThenElse</name> <operator>&amp;</operator><name>I</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>C</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>T</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Condition</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ThenExpr</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>, <macro><name>ElseExpr</name><argument_list>(<argument>E</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_IfThenElse</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>condition</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Condition</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>condition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Condition</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>thenExpr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>ThenExpr</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>thenExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ThenExpr</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>elseExpr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>ElseExpr</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>elseExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ElseExpr</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Nc</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Condition</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>Nt</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>ThenExpr</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>Ne</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>ElseExpr</name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceIfThenElse</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Nc</name></expr></argument>, <argument><expr><name>Nt</name></expr></argument>, <argument><expr><name>Ne</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const IfThenElse* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <name>Ct</name> <operator>=</operator> <call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>condition</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>condition</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cmp</name><operator>.</operator><name>notTrue</name></name><argument_list>(<argument><expr><name>Ct</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ct</name></expr>;</return></block_content></block></if></if_stmt>
<name>Ct</name> <operator>=</operator> <call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>thenExpr</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>thenExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cmp</name><operator>.</operator><name>notTrue</name></name><argument_list>(<argument><expr><name>Ct</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ct</name></expr>;</return></block_content></block></if></if_stmt></block></expr></range></decl></decl_stmt>
<return>return <expr><call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>elseExpr</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>elseExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

private:
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Condition</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>ThenExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>ElseExpr</name></decl>;</decl_stmt>
};



<decl_stmt><decl><type><name>class</name></type> <name>Let</name> <range>: <expr><name>public</name> <name>SExpr</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>Let</name><argument_list>(<argument><expr><name>Variable</name> <operator>*</operator><name>Vd</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>Bd</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>COP_Let</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>VarDecl</name><argument_list>(<argument><expr><name>Vd</name></expr></argument>)</argument_list></call></expr>, <macro><name>Body</name><argument_list>(<argument>Bd</argument>)</argument_list></macro> <expr><block>{
<expr><call><name><name>Vd</name><operator>-&gt;</operator><name>setKind</name></name><argument_list>(<argument><expr><name>Variable</name><operator>::</operator><name>VK_Let</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>Let</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Let</name> <operator>&amp;</operator><name>L</name></expr></argument>, <argument><expr><name>Variable</name> <operator>*</operator><name>Vd</name></expr></argument>, <argument><expr><name>SExpr</name> <operator>*</operator><name>Bd</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>SExpr</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>VarDecl</name><argument_list>(<argument><expr><name>Vd</name></expr></argument>)</argument_list></call></expr>, <macro><name>Body</name><argument_list>(<argument>Bd</argument>)</argument_list></macro> <expr><block>{
<expr><call><name><name>Vd</name><operator>-&gt;</operator><name>setKind</name></name><argument_list>(<argument><expr><name>Variable</name><operator>::</operator><name>VK_Let</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SExpr *E</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Let</name></expr>;</return> }</block>

<name>Variable</name> <operator>*</operator><macro><name>variableDecl</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>VarDecl</name></expr>;</return> }</block>
<specifier>const</specifier> <name>Variable</name> <operator>*</operator><macro><name>variableDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>VarDecl</name></expr>;</return> }</block>

<name>SExpr</name> <operator>*</operator><macro><name>body</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Body</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SExpr</name> <operator>*</operator><macro><name>body</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Body</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>V</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>V</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>V &amp;Vs</argument>, <argument>typename V::R_Ctx Ctx</argument>)</argument_list></macro> <block>{

<expr><name>auto</name> <name>E0</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name><name>VarDecl</name><operator>-&gt;</operator><name>Definition</name></name></expr></argument>, <argument><expr><call><name><name>Vs</name><operator>.</operator><name>subExprCtx</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

<expr><name>Variable</name> <operator>*</operator><name>Nvd</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>enterScope</name></name><argument_list>(<argument><expr><operator>*</operator><name>VarDecl</name></expr></argument>, <argument><expr><name>E0</name></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>E1</name> <operator>=</operator> <call><name><name>Vs</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>Body</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Vs</name><operator>.</operator><name>exitScope</name></name><argument_list>(<argument><expr><operator>*</operator><name>VarDecl</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Vs</name><operator>.</operator><name>reduceLet</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Nvd</name></expr></argument>, <argument><expr><name>E1</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <macro><name>compare</name><argument_list>(<argument>const Let* E</argument>, <argument>C&amp; Cmp</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>typename</name> <name>C</name><operator>::</operator><name>CType</name> <name>Ct</name> <operator>=</operator>
<call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name><name>VarDecl</name><operator>-&gt;</operator><name>definition</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>VarDecl</name><operator>-&gt;</operator><name>definition</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cmp</name><operator>.</operator><name>notTrue</name></name><argument_list>(<argument><expr><name>Ct</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ct</name></expr>;</return></block_content></block></if></if_stmt>
<call><name><name>Cmp</name><operator>.</operator><name>enterScope</name></name><argument_list>(<argument><expr><call><name>variableDecl</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>variableDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;
<expr><name>Ct</name> <operator>=</operator> <call><name><name>Cmp</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name>body</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>body</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Cmp</name><operator>.</operator><name>leaveScope</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>Ct</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>Variable</name> <modifier>*</modifier></type><name>VarDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SExpr</name><modifier>*</modifier></type> <name>Body</name></decl>;</decl_stmt>
};

<function_decl><type><specifier>const</specifier> <name>SExpr</name> <modifier>*</modifier></type><name>getCanonicalVal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>SExpr</name><modifier>*</modifier></type> <name>simplifyToCanonicalVal</name><parameter_list>(<parameter><decl><type><name>SExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>simplifyIncompleteArg</name><argument_list>(<argument><expr><name>til</name><operator>::</operator><name>Phi</name> <operator>*</operator><name>Ph</name></expr></argument>)</argument_list></decl>;</decl_stmt>

}
}

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
