<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Frontend/ASTUnit.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_FRONTEND_ASTUNIT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_FRONTEND_ASTUNIT_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang-c/Index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Diagnostic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/FileSystemOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LangOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TargetOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/HeaderSearchOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/ModuleLoader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/PreprocessingRecord.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/CodeCompleteConsumer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Serialization/ASTBitCodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Frontend/PrecompiledPreamble.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/IntrusiveRefCntPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/None.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/STLExtras.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>MemoryBuffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>vfs</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>FileSystem</name></decl>;</decl_stmt>

</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTDeserializationListener</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTMutationListener</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CompilerInstance</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CompilerInvocation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Decl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FileEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FileManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FrontendAction</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>HeaderSearch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>InputKind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>InMemoryModuleCache</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>PCHContainerOperations</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>PCHContainerReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Preprocessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>PreprocessorOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Sema</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TargetInfo</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>SkipFunctionBodiesScope</name> <block>{<block_content> <expr_stmt><expr><name>None</name></expr><operator>,</operator> <expr><name>Preamble</name></expr><operator>,</operator> <expr><name>PreambleAndMainFile</name></expr></expr_stmt> </block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>CaptureDiagsKind</name> <block>{<block_content> <expr_stmt><expr><name>None</name></expr><operator>,</operator> <expr><name>All</name></expr><operator>,</operator> <expr><name>AllWithoutNonErrorsFromIncludes</name></expr></expr_stmt> </block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>ASTUnit</name> <block>{<block_content>
<label><name>public</name>:</label>
<struct>struct <name>StandaloneFixIt</name> <block>{
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>RemoveRange</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>InsertFromRange</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>CodeToInsert</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>BeforePreviousInsertions</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>StandaloneDiagnostic</name> <block>{
<decl_stmt><decl><type><name>unsigned</name></type> <name>ID</name></decl>;</decl_stmt>
<expr_stmt><expr><name>DiagnosticsEngine</name><operator>::</operator><name>Level</name> <name>Level</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>Message</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>Filename</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>LocOffset</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>Ranges</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>StandaloneFixIt</name></expr></argument>&gt;</argument_list></name> <name>FixIts</name></expr>;</expr_stmt>
}</block>;</struct>

<label><name>private</name>:</label>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>LangOptions</name></expr></argument>&gt;</argument_list></name> <name>LangOpts</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>DiagnosticsEngine</name></expr></argument>&gt;</argument_list></name></type> <name>Diagnostics</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>FileManager</name></expr></argument>&gt;</argument_list></name></type> <name>FileMgr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>SourceManager</name></expr></argument>&gt;</argument_list></name></type> <name>SourceMgr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>InMemoryModuleCache</name></expr></argument>&gt;</argument_list></name></type> <name>ModuleCache</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>HeaderSearch</name></expr></argument>&gt;</argument_list></name> <name>HeaderInfo</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>TargetInfo</name></expr></argument>&gt;</argument_list></name></type> <name>Target</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Preprocessor</name></expr></argument>&gt;</argument_list></name> <name>PP</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>ASTContext</name></expr></argument>&gt;</argument_list></name></type> <name>Ctx</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>TargetOptions</name></expr></argument>&gt;</argument_list></name> <name>TargetOpts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>HeaderSearchOptions</name></expr></argument>&gt;</argument_list></name> <name>HSOpts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PreprocessorOptions</name></expr></argument>&gt;</argument_list></name> <name>PPOpts</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>ASTReader</name></expr></argument>&gt;</argument_list></name></type> <name>Reader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>HadModuleLoaderFatalFailure</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<struct_decl>struct <name>ASTWriterData</name>;</struct_decl>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTWriterData</name></expr></argument>&gt;</argument_list></name> <name>WriterData</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>FileSystemOptions</name></type> <name>FileSystemOpts</name></decl>;</decl_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTConsumer</name></expr></argument>&gt;</argument_list></name> <name>Consumer</name></expr>;</expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Sema</name></expr></argument>&gt;</argument_list></name> <name>TheSema</name></expr>;</expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CompilerInvocation</name></expr></argument>&gt;</argument_list></name> <name>Invocation</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>TrivialModuleLoader</name></type> <name>ModuleLoader</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>OnlyLocalDecls</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>CaptureDiagsKind</name></type> <name>CaptureDiagnostics</name> <init>= <expr><name>CaptureDiagsKind</name><operator>::</operator><name>None</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>MainFileIsAST</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>TranslationUnitKind</name></type> <name>TUKind</name> <init>= <expr><name>TU_Complete</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>WantTiming</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>OwnsRemappedFileBuffers</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>








<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>TopLevelDecls</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>LocDeclsTy</name> <init>= <expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>FileDeclsTy</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>FileID</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>LocDeclsTy</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>FileDeclsTy</name></type> <name>FileDecls</name></decl>;</decl_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>OriginalSourceFile</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>StandaloneDiagnostic</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>PreambleDiagnostics</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>StoredDiagnostic</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>StoredDiagnostics</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>StoredDiagnostic</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>FailedParseDiagnostics</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>unsigned</name></type> <name>NumStoredDiagnosticsFromDriver</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>










<decl_stmt><decl><type><name>unsigned</name></type> <name>PreambleRebuildCountdown</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>PreambleCounter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>







<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <name>PreambleSrcLocCache</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>PrecompiledPreamble</name></expr></argument>&gt;</argument_list></name> <name>Preamble</name></expr>;</expr_stmt>




<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>MemoryBuffer</name></expr></argument>&gt;</argument_list></name> <name>SavedMainFileBuffer</name></expr>;</expr_stmt>







<decl_stmt><decl><type><name>unsigned</name></type> <name>NumWarningsInPreamble</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>&gt;</argument_list></name> <name>TopLevelDeclsInPreamble</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>ShouldCacheCodeCompletionResults</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>IncludeBriefCommentsInCodeCompletion</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>UserFilesAreVolatile</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ConfigureDiags</name><parameter_list>(<parameter><decl><type><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>DiagnosticsEngine</name></expr></argument>&gt;</argument_list></name></type> <name>Diags</name></decl></parameter>,
<parameter><decl><type><name>ASTUnit</name> <modifier>&amp;</modifier></type><name>AST</name></decl></parameter>, <parameter><decl><type><name>CaptureDiagsKind</name></type> <name>CaptureDiagnostics</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>TranslateStoredDiagnostics</name><parameter_list>(<parameter><decl><type><name>FileManager</name> <modifier>&amp;</modifier></type><name>FileMgr</name></decl></parameter>,
<parameter><decl><type><name>SourceManager</name> <modifier>&amp;</modifier></type><name>SrcMan</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>StandaloneDiagnostic</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Diags</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>StoredDiagnostic</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Out</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>clearFileLevelDecls</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>public</name>:</label>


<struct>struct <name>CachedCodeCompletionResult</name> <block>{


<decl_stmt><decl><type><name>CodeCompletionString</name> <modifier>*</modifier></type><name>Completion</name></decl>;</decl_stmt>








<decl_stmt><decl><type><name>uint64_t</name></type> <name>ShowInContexts</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>Priority</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>CXCursorKind</name></type> <name>Kind</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>CXAvailabilityKind</name></type> <name>Availability</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SimplifiedTypeClass</name></type> <name>TypeClass</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>unsigned</name></type> <name>Type</name></decl>;</decl_stmt>
}</block>;</struct>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><macro><name>getCachedCompletionTypes</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>CachedCompletionTypes</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>GlobalCodeCompletionAllocator</name></expr></argument>&gt;</argument_list></name>
<macro><name>getCachedCompletionAllocator</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>CachedCompletionAllocator</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>CodeCompletionTUInfo</name> <modifier>&amp;</modifier></type><name>getCodeCompletionTUInfo</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CCTUInfo</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>CCTUInfo</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name><name>make_unique</name><argument_list type="generic">&lt;<argument><expr><name>CodeCompletionTUInfo</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>std</name><operator>::</operator><call><name><name>make_shared</name><argument_list type="generic">&lt;<argument><expr><name>GlobalCodeCompletionAllocator</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>*</operator><name>CCTUInfo</name></expr>;</return>
</block_content>}</block></function>

<label><name>private</name>:</label>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>GlobalCodeCompletionAllocator</name></expr></argument>&gt;</argument_list></name> <name>CachedCompletionAllocator</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CodeCompletionTUInfo</name></expr></argument>&gt;</argument_list></name> <name>CCTUInfo</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CachedCodeCompletionResult</name></expr></argument>&gt;</argument_list></name> <name>CachedCompletionResults</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>CachedCompletionTypes</name></expr>;</expr_stmt>






<decl_stmt><decl><type><name>unsigned</name></type> <name>CompletionCacheTopLevelHashValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>






<decl_stmt><decl><type><name>unsigned</name></type> <name>PreambleTopLevelHashValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>CurrentTopLevelHashValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>UnsafeToFree</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SkipFunctionBodiesScope</name></type> <name>SkipFunctionBodies</name> <init>= <expr><name>SkipFunctionBodiesScope</name><operator>::</operator><name>None</name></expr></init></decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>CacheCodeCompletionResults</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ClearCachedCompletionResults</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>explicit</name></type> <name>ASTUnit</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>MainFileIsAST</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>bool</name></type> <name>Parse</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PCHContainerOperations</name></expr></argument>&gt;</argument_list></name> <name>PCHContainerOps</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>MemoryBuffer</name></expr></argument>&gt;</argument_list></name> <name>OverrideMainBuffer</name></expr></argument>,
<argument><expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>vfs</name><operator>::</operator><name>FileSystem</name></expr></argument>&gt;</argument_list></name> <name>VFS</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>MemoryBuffer</name></expr></argument>&gt;</argument_list></name> <macro><name>getMainBufferWithPrecompiledPreamble</name><argument_list>(
<argument>std::shared_ptr&lt;PCHContainerOperations&gt; PCHContainerOps</argument>,
<argument>CompilerInvocation &amp;PreambleInvocationIn</argument>,
<argument>IntrusiveRefCntPtr&lt;llvm::vfs::FileSystem&gt; VFS</argument>, <argument>bool AllowRebuild = true</argument>,
<argument>unsigned MaxLines = <literal type="number">0</literal></argument>)</argument_list></macro></expr>;</expr_stmt>
<function_decl><type><name>void</name></type> <name>RealizeTopLevelDeclsFromPreamble</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>transferASTDataFromCompilerInstance</name><parameter_list>(<parameter><decl><type><name>CompilerInstance</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>)</parameter_list>;</function_decl>








<decl_stmt><decl><type><name>class</name></type> <name>ConcurrencyState</name> <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>Mutex</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>ConcurrencyState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>~</operator><call><name>ConcurrencyState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>start</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>finish</name><parameter_list>()</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<decl_stmt><decl><type><name>ConcurrencyState</name></type> <name>ConcurrencyCheckValue</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ConcurrencyCheck</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>ConcurrencyCheck</name> <block>{<block_content>
<decl_stmt><decl><type><name>ASTUnit</name> <modifier>&amp;</modifier></type><name>Self</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>ConcurrencyCheck</name><argument_list>(<argument><expr><name>ASTUnit</name> <operator>&amp;</operator><name>Self</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>Self</name><argument_list>(<argument>Self</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Self</name><operator>.</operator><name>ConcurrencyCheckValue</name><operator>.</operator><name>start</name></name><argument_list>()</argument_list></call></expr>;
}</block>

<operator>~</operator><macro><name>ConcurrencyCheck</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name><name>Self</name><operator>.</operator><name>ConcurrencyCheckValue</name><operator>.</operator><name>finish</name></name><argument_list>()</argument_list></call></expr>;
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><call><name>ASTUnit</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTUnit</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ASTUnit</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>ASTUnit</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>~</operator><call><name>ASTUnit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isMainFileAST</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MainFileIsAST</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isUnsafeToFree</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>UnsafeToFree</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setUnsafeToFree</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Value</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>UnsafeToFree</name> <operator>=</operator> <name>Value</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>DiagnosticsEngine</name> <operator>&amp;</operator><macro><name>getDiagnostics</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>Diagnostics</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>DiagnosticsEngine</name> <modifier>&amp;</modifier></type><name>getDiagnostics</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><name>Diagnostics</name></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>SourceManager</name> <operator>&amp;</operator><macro><name>getSourceManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>SourceMgr</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>SourceManager</name> <modifier>&amp;</modifier></type><name>getSourceManager</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><name>SourceMgr</name></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>Preprocessor</name> <operator>&amp;</operator><macro><name>getPreprocessor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>PP</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>Preprocessor</name> <modifier>&amp;</modifier></type><name>getPreprocessor</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><name>PP</name></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Preprocessor</name></expr></argument>&gt;</argument_list></name> <macro><name>getPreprocessorPtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PP</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><macro><name>getASTContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>Ctx</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>getASTContext</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><name>Ctx</name></expr>;</return> </block_content>}</block></function>

<function><type><name>void</name></type> <name>setASTContext</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Ctx</name> <operator>=</operator> <name>ctx</name></expr>;</expr_stmt> </block_content>}</block></function>
<decl_stmt><decl><type><name>void</name></type> <name>setPreprocessor</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Preprocessor</name></expr></argument>&gt;</argument_list></name> <name>pp</name></expr></argument>)</argument_list></decl>;</decl_stmt>








<function_decl><type><name>void</name></type> <name>enableSourceFileDiagnostics</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>bool</name> <macro><name>hasSema</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>bool</name><operator>)</operator><name>TheSema</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>Sema</name> <operator>&amp;</operator><macro><name>getSema</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>TheSema</name> <operator>&amp;&amp;</operator> <literal type="string">"ASTUnit does not have a Sema object!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>TheSema</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><macro><name>getLangOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>LangOpts</name> <operator>&amp;&amp;</operator> <literal type="string">"ASTUnit does not have language options"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>LangOpts</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>HeaderSearchOptions</name> <operator>&amp;</operator><macro><name>getHeaderSearchOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>HSOpts</name> <operator>&amp;&amp;</operator> <literal type="string">"ASTUnit does not have header search options"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>HSOpts</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>PreprocessorOptions</name> <operator>&amp;</operator><macro><name>getPreprocessorOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>PPOpts</name> <operator>&amp;&amp;</operator> <literal type="string">"ASTUnit does not have preprocessor options"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>PPOpts</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>FileManager</name> <operator>&amp;</operator><macro><name>getFileManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>FileMgr</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>FileManager</name> <modifier>&amp;</modifier></type><name>getFileManager</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><name>FileMgr</name></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>FileSystemOptions</name> <operator>&amp;</operator><macro><name>getFileSystemOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FileSystemOpts</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>ASTReader</name></expr></argument>&gt;</argument_list></name> <macro><name>getASTReader</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>StringRef</name> <macro><name>getOriginalSourceFileName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>OriginalSourceFile</name></expr>;</return>
}</block></expr></expr_stmt>

<function_decl><type><name>ASTMutationListener</name> <modifier>*</modifier></type><name>getASTMutationListener</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>ASTDeserializationListener</name> <modifier>*</modifier></type><name>getDeserializationListener</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>bool</name> <macro><name>getOnlyLocalDecls</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OnlyLocalDecls</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>getOwnsRemappedFileBuffers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OwnsRemappedFileBuffers</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setOwnsRemappedFileBuffers</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>OwnsRemappedFileBuffers</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>StringRef</name> <macro><name>getMainFileName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>StringRef</name> <macro><name>getASTFileName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>top_level_iterator</name> <init>= <expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr></init></decl>;</decl_stmt>

<function><type><name>top_level_iterator</name></type> <name>top_level_begin</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isMainFileAST</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid call for AST based ASTUnit!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>TopLevelDeclsInPreamble</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>RealizeTopLevelDeclsFromPreamble</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>TopLevelDecls</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>top_level_iterator</name></type> <name>top_level_end</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isMainFileAST</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid call for AST based ASTUnit!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>TopLevelDeclsInPreamble</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>RealizeTopLevelDeclsFromPreamble</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>TopLevelDecls</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>std</name><operator>::</operator><name>size_t</name> <macro><name>top_level_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isMainFileAST</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid call for AST based ASTUnit!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>TopLevelDeclsInPreamble</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>TopLevelDecls</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>top_level_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isMainFileAST</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid call for AST based ASTUnit!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>TopLevelDeclsInPreamble</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>TopLevelDecls</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>addTopLevelDecl</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>TopLevelDecls</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>addFileLevelDecl</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>findFileRegionDecls</name><parameter_list>(<parameter><decl><type><name>FileID</name></type> <name>File</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Offset</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Length</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Decls</name></decl></parameter>)</parameter_list>;</function_decl>




<function><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>getCurrentTopLevelHashValue</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>CurrentTopLevelHashValue</name></expr>;</return> </block_content>}</block></function>






<decl_stmt><decl><type><name>SourceLocation</name></type> <name>getLocation</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator><name>File</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>Line</name></expr></argument>, <argument><expr><name>unsigned</name> <name>Col</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>getLocation</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator><name>File</name></expr></argument>, <argument><expr><name>unsigned</name> <name>Offset</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<decl_stmt><decl><type><name>SourceLocation</name></type> <name>mapLocationFromPreamble</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<decl_stmt><decl><type><name>SourceLocation</name></type> <name>mapLocationToPreamble</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isInPreambleFileID</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isInMainFileID</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getStartOfMainFileID</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndOfPreambleFileID</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<decl_stmt><decl><type><name>SourceRange</name></type> <name>mapRangeFromPreamble</name><argument_list>(<argument><expr><name>SourceRange</name> <name>R</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>mapLocationFromPreamble</name><argument_list>(<argument><expr><call><name><name>R</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>mapLocationFromPreamble</name><argument_list>(<argument><expr><call><name><name>R</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>SourceRange</name></type> <name>mapRangeToPreamble</name><argument_list>(<argument><expr><name>SourceRange</name> <name>R</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>mapLocationToPreamble</name><argument_list>(<argument><expr><call><name><name>R</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>mapLocationToPreamble</name><argument_list>(<argument><expr><call><name><name>R</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>getPreambleCounterForTests</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PreambleCounter</name></expr>;</return> }</block></expr></expr_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>stored_diag_iterator</name> <init>= <expr><name>StoredDiagnostic</name> <operator>*</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>stored_diag_const_iterator</name> <init>= <expr><specifier>const</specifier> <name>StoredDiagnostic</name> <operator>*</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>stored_diag_const_iterator</name> <macro><name>stored_diag_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>StoredDiagnostics</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>stored_diag_iterator</name></type> <name>stored_diag_begin</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>StoredDiagnostics</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>stored_diag_const_iterator</name> <macro><name>stored_diag_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>StoredDiagnostics</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>stored_diag_iterator</name></type> <name>stored_diag_end</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>StoredDiagnostics</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>unsigned</name> <macro><name>stored_diag_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>StoredDiagnostics</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>stored_diag_iterator</name></type> <name>stored_diag_afterDriver_begin</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>NumStoredDiagnosticsFromDriver</name> <operator>&gt;</operator> <call><name><name>StoredDiagnostics</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>NumStoredDiagnosticsFromDriver</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>StoredDiagnostics</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>NumStoredDiagnosticsFromDriver</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>using</name></type> <name>cached_completion_iterator</name> <init>=
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CachedCodeCompletionResult</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr></init></decl>;</decl_stmt>

<function><type><name>cached_completion_iterator</name></type> <name>cached_completion_begin</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>CachedCompletionResults</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>cached_completion_iterator</name></type> <name>cached_completion_end</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>CachedCompletionResults</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>unsigned</name> <macro><name>cached_completion_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>CachedCompletionResults</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>PreprocessingRecord</name><operator>::</operator><name>iterator</name></expr></argument>&gt;</argument_list></name>
<macro><name>getLocalPreprocessingEntities</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<decl_stmt><decl><type><name>using</name></type> <name>DeclVisitorFn</name> <init>= <expr><call><call><name>bool</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>context</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>





<function_decl><type><name>bool</name></type> <name>visitLocalTopLevelDecls</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>DeclVisitorFn</name></type> <name>Fn</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>getPCHFile</name><parameter_list>()</parameter_list>;</function_decl>



<expr_stmt><expr><name>bool</name> <macro><name>isModuleFile</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>MemoryBuffer</name></expr></argument>&gt;</argument_list></name>
<macro><name>getBufferForFile</name><argument_list>(<argument>StringRef Filename</argument>, <argument>std::string *ErrorStr = nullptr</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><name>TranslationUnitKind</name> <macro><name>getTranslationUnitKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TUKind</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>InputKind</name> <macro><name>getInputKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<decl_stmt><decl><type><name>using</name></type> <name>RemappedFile</name> <init>= <expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>MemoryBuffer</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTUnit</name></expr></argument>&gt;</argument_list></name>
<macro><name>create</name><argument_list>(<argument>std::shared_ptr&lt;CompilerInvocation&gt; CI</argument>,
<argument>IntrusiveRefCntPtr&lt;DiagnosticsEngine&gt; Diags</argument>,
<argument>CaptureDiagsKind CaptureDiagnostics</argument>, <argument>bool UserFilesAreVolatile</argument>)</argument_list></macro></expr>;</expr_stmt>

<enum>enum <name>WhatToLoad</name> <block>{

<decl><name>LoadPreprocessorOnly</name></decl>,


<decl><name>LoadASTOnly</name></decl>,


<decl><name>LoadEverything</name></decl>
}</block>;</enum>











<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTUnit</name></expr></argument>&gt;</argument_list></name>
<macro><name>LoadFromASTFile</name><argument_list>(<argument>const std::string &amp;Filename</argument>,
<argument>const PCHContainerReader &amp;PCHContainerRdr</argument>, <argument>WhatToLoad ToLoad</argument>,
<argument>IntrusiveRefCntPtr&lt;DiagnosticsEngine&gt; Diags</argument>,
<argument>const FileSystemOptions &amp;FileSystemOpts</argument>,
<argument>bool UseDebugInfo = false</argument>, <argument>bool OnlyLocalDecls = false</argument>,
<argument>CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None</argument>,
<argument>bool AllowASTWithCompilerErrors = false</argument>,
<argument>bool UserFilesAreVolatile = false</argument>)</argument_list></macro></expr>;</expr_stmt>

<label><name>private</name>:</label>














<decl_stmt><decl><type><name>bool</name></type> <name>LoadFromCompilerInvocation</name><argument_list>(
<argument><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PCHContainerOperations</name></expr></argument>&gt;</argument_list></name> <name>PCHContainerOps</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>PrecompilePreambleAfterNParses</name></expr></argument>,
<argument><expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>vfs</name><operator>::</operator><name>FileSystem</name></expr></argument>&gt;</argument_list></name> <name>VFS</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<label><name>public</name>:</label>




























<decl_stmt><decl><type><specifier>static</specifier> <name>ASTUnit</name> <modifier>*</modifier></type><name>LoadFromCompilerInvocationAction</name><argument_list>(
<argument><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CompilerInvocation</name></expr></argument>&gt;</argument_list></name> <name>CI</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PCHContainerOperations</name></expr></argument>&gt;</argument_list></name> <name>PCHContainerOps</name></expr></argument>,
<argument><expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>DiagnosticsEngine</name></expr></argument>&gt;</argument_list></name> <name>Diags</name></expr></argument>,
<argument><expr><name>FrontendAction</name> <operator>*</operator><name>Action</name> <operator>=</operator> <name>nullptr</name></expr></argument>, <argument><expr><name>ASTUnit</name> <operator>*</operator><name>Unit</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>bool</name> <name>Persistent</name> <operator>=</operator> <name>true</name></expr></argument>, <argument><expr><name>StringRef</name> <name>ResourceFilesPath</name> <operator>=</operator> <call><name>StringRef</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>bool</name> <name>OnlyLocalDecls</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>CaptureDiagsKind</name> <name>CaptureDiagnostics</name> <operator>=</operator> <name>CaptureDiagsKind</name><operator>::</operator><name>None</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>PrecompilePreambleAfterNParses</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><name>bool</name> <name>CacheCodeCompletionResults</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>bool</name> <name>UserFilesAreVolatile</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTUnit</name></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>ErrAST</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>















<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTUnit</name></expr></argument>&gt;</argument_list></name> <macro><name>LoadFromCompilerInvocation</name><argument_list>(
<argument>std::shared_ptr&lt;CompilerInvocation&gt; CI</argument>,
<argument>std::shared_ptr&lt;PCHContainerOperations&gt; PCHContainerOps</argument>,
<argument>IntrusiveRefCntPtr&lt;DiagnosticsEngine&gt; Diags</argument>, <argument>FileManager *FileMgr</argument>,
<argument>bool OnlyLocalDecls = false</argument>,
<argument>CaptureDiagsKind CaptureDiagnostics = CaptureDiagsKind::None</argument>,
<argument>unsigned PrecompilePreambleAfterNParses = <literal type="number">0</literal></argument>,
<argument>TranslationUnitKind TUKind = TU_Complete</argument>,
<argument>bool CacheCodeCompletionResults = false</argument>,
<argument>bool IncludeBriefCommentsInCodeCompletion = false</argument>,
<argument>bool UserFilesAreVolatile = false</argument>)</argument_list></macro></expr>;</expr_stmt>






























<decl_stmt><decl><type><specifier>static</specifier> <name>ASTUnit</name> <modifier>*</modifier></type><name>LoadFromCommandLine</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><name>ArgBegin</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><name>ArgEnd</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PCHContainerOperations</name></expr></argument>&gt;</argument_list></name> <name>PCHContainerOps</name></expr></argument>,
<argument><expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>DiagnosticsEngine</name></expr></argument>&gt;</argument_list></name> <name>Diags</name></expr></argument>, <argument><expr><name>StringRef</name> <name>ResourceFilesPath</name></expr></argument>,
<argument><expr><name>bool</name> <name>OnlyLocalDecls</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>CaptureDiagsKind</name> <name>CaptureDiagnostics</name> <operator>=</operator> <name>CaptureDiagsKind</name><operator>::</operator><name>None</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>RemappedFile</name></expr></argument>&gt;</argument_list></name> <name>RemappedFiles</name> <operator>=</operator> <name>None</name></expr></argument>,
<argument><expr><name>bool</name> <name>RemappedFilesKeepOriginalName</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>PrecompilePreambleAfterNParses</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><name>TranslationUnitKind</name> <name>TUKind</name> <operator>=</operator> <name>TU_Complete</name></expr></argument>,
<argument><expr><name>bool</name> <name>CacheCodeCompletionResults</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>bool</name> <name>IncludeBriefCommentsInCodeCompletion</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>bool</name> <name>AllowPCHWithCompilerErrors</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>SkipFunctionBodiesScope</name> <name>SkipFunctionBodies</name> <operator>=</operator>
<name>SkipFunctionBodiesScope</name><operator>::</operator><name>None</name></expr></argument>,
<argument><expr><name>bool</name> <name>SingleFileParse</name> <operator>=</operator> <name>false</name></expr></argument>, <argument><expr><name>bool</name> <name>UserFilesAreVolatile</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>bool</name> <name>ForSerialization</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>bool</name> <name>RetainExcludedConditionalBlocks</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <name>ModuleFormat</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name>None</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTUnit</name></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>ErrAST</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>vfs</name><operator>::</operator><name>FileSystem</name></expr></argument>&gt;</argument_list></name> <name>VFS</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>












<decl_stmt><decl><type><name>bool</name></type> <name>Reparse</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PCHContainerOperations</name></expr></argument>&gt;</argument_list></name> <name>PCHContainerOps</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>RemappedFile</name></expr></argument>&gt;</argument_list></name> <name>RemappedFiles</name> <operator>=</operator> <name>None</name></expr></argument>,
<argument><expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>vfs</name><operator>::</operator><name>FileSystem</name></expr></argument>&gt;</argument_list></name> <name>VFS</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<function_decl><type><name>void</name></type> <name>ResetForParse</name><parameter_list>()</parameter_list>;</function_decl>





















<decl_stmt><decl><type><name>void</name></type> <name>CodeComplete</name><argument_list>(<argument><expr><name>StringRef</name> <name>File</name></expr></argument>, <argument><expr><name>unsigned</name> <name>Line</name></expr></argument>, <argument><expr><name>unsigned</name> <name>Column</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>RemappedFile</name></expr></argument>&gt;</argument_list></name> <name>RemappedFiles</name></expr></argument>, <argument><expr><name>bool</name> <name>IncludeMacros</name></expr></argument>,
<argument><expr><name>bool</name> <name>IncludeCodePatterns</name></expr></argument>, <argument><expr><name>bool</name> <name>IncludeBriefComments</name></expr></argument>,
<argument><expr><name>CodeCompleteConsumer</name> <operator>&amp;</operator><name>Consumer</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PCHContainerOperations</name></expr></argument>&gt;</argument_list></name> <name>PCHContainerOps</name></expr></argument>,
<argument><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diag</name></expr></argument>, <argument><expr><name>LangOptions</name> <operator>&amp;</operator><name>LangOpts</name></expr></argument>,
<argument><expr><name>SourceManager</name> <operator>&amp;</operator><name>SourceMgr</name></expr></argument>, <argument><expr><name>FileManager</name> <operator>&amp;</operator><name>FileMgr</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>StoredDiagnostic</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>StoredDiagnostics</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>MemoryBuffer</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>OwnedBuffers</name></expr></argument>)</argument_list></decl>;</decl_stmt>





<function_decl><type><name>bool</name></type> <name>Save</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>File</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>serialize</name><parameter_list>(<parameter><decl><type><name>raw_ostream</name> <modifier>&amp;</modifier></type><name>OS</name></decl></parameter>)</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

</block_content>}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
