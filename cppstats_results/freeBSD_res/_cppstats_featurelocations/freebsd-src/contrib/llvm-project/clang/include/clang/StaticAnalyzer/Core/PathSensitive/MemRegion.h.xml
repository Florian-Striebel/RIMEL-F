<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h">













<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_MEMREGION_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_MEMREGION_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/CharUnits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclarationName.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/AnalysisDeclContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/SVals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/FoldingSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerIntPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Allocator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>AnalysisDeclContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXRecordDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Decl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LocationContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>StackFrameContext</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>ento</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>CodeTextRegion</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MemRegion</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MemRegionManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MemSpaceRegion</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SValBuilder</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SymbolicRegion</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VarRegion</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>RegionOffset</name> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>MemRegion</name> <modifier>*</modifier></type><name>R</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int64_t</name></type> <name>Offset</name></decl>;</decl_stmt>

<label><name>public</name>:</label>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int64_t</name></type> <name>Symbolic</name> <init>= <expr><name>std</name><operator>::</operator><name><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>max</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RegionOffset</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<macro><name>RegionOffset</name><argument_list>(<argument>const MemRegion *r</argument>, <argument>int64_t off</argument>)</argument_list></macro> : <expr_stmt><expr><call><name>R</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Offset</name><argument_list>(<argument>off</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><macro><name>getRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>R</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasSymbolicOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Offset</name> <operator>==</operator> <name>Symbolic</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>int64_t</name> <macro><name>getOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>hasSymbolicOffset</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Offset</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isValid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>R</name></expr>;</return> }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>






<decl_stmt><decl><type><name>class</name></type> <name>MemRegion</name> <range>: <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>public</name><operator>:</operator>
enum <name>Kind</name> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGION</name><parameter_list>(<parameter><type><name>Id</name></type></parameter>, <parameter><type><name>Parent</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Id ##Kind,</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGION_RANGE</name><parameter_list>(<parameter><type><name>Id</name></type></parameter>, <parameter><type><name>First</name></type></parameter>, <parameter><type><name>Last</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>BEGIN_##Id = First, END_##Id = Last,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/Regions.def"</cpp:file></cpp:include>
}</block></expr>;

<expr><name>private</name><operator>:</operator>
<specifier>const</specifier> <name>Kind</name> <name>kind</name></expr>;
<expr><name>mutable</name> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>RegionOffset</name></expr></argument>&gt;</argument_list></name> <name>cachedOffset</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>MemRegion</name><argument_list>(<argument>Kind k</argument>)</argument_list></macro> <operator>:</operator> <macro><name>kind</name><argument_list>(<argument>k</argument>)</argument_list></macro> <block>{}</block>
<name>virtual</name> <operator>~</operator><call><name>MemRegion</name><argument_list>()</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<name>ASTContext</name> <operator>&amp;</operator><macro><name>getContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>virtual</name> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; ID</argument>)</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>MemRegionManager</name> <operator>&amp;</operator><macro><name>getMemRegionManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><specifier>const</specifier> <name>MemSpaceRegion</name> <operator>*</operator><macro><name>getMemorySpace</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><macro><name>getBaseRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><macro><name>getMostDerivedObjectRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>virtual</name> <name>bool</name> <macro><name>isSubRegionOf</name><argument_list>(<argument>const MemRegion *R</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><macro><name>StripCasts</name><argument_list>(<argument>bool StripBaseAndDerivedCasts = true</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><specifier>const</specifier> <name>SymbolicRegion</name> <operator>*</operator><macro><name>getSymbolicBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>hasGlobalsOrParametersStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>hasStackStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>hasStackNonParametersStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>hasStackParametersStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>RegionOffset</name> <macro><name>getAsOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getString</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>virtual</name> <name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>virtual</name> <name>bool</name> <macro><name>canPrintPretty</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>virtual</name> <name>void</name> <macro><name>printPretty</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>virtual</name> <name>bool</name> <macro><name>canPrintPrettyAsExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;





<expr><name>virtual</name> <name>void</name> <macro><name>printPrettyAsExpr</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>kind</name></expr>;</return> }</block>

<name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>RegionTy</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier> <name>RegionTy</name><operator>*</operator> <macro><name>getAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>RegionTy</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier> <name>RegionTy</name><operator>*</operator> <macro><name>castAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>isBoundable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>









<name>std</name><operator>::</operator><name>string</name> <macro><name>getDescriptiveName</name><argument_list>(<argument>bool UseQuotes = true</argument>)</argument_list></macro> <specifier>const</specifier></expr>;









<expr><name>SourceRange</name> <macro><name>sourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>MemSpaceRegion</name> <range>: <expr><name>public</name> <name>MemRegion</name> <block>{
<expr><name>protected</name><operator>:</operator>
<name>MemRegionManager</name> <operator>&amp;</operator><name>Mgr</name></expr>;

<macro><name>MemSpaceRegion</name><argument_list>(<argument>MemRegionManager &amp;mgr</argument>, <argument>Kind k</argument>)</argument_list></macro> <operator>:</operator> <expr><call><name>MemRegion</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>, <macro><name>Mgr</name><argument_list>(<argument>mgr</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>classof</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>MemRegionManager</name> <operator>&amp;</operator><macro><name>getMemRegionManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>Mgr</name></expr>;</return> }</block>

<name>public</name><operator>:</operator>
<name>bool</name> <macro><name>isBoundable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion *R</argument>)</argument_list></macro> <block>{
<expr><name>Kind</name> <name>k</name> <operator>=</operator> <call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>k</name> <operator>&gt;=</operator> <name>BEGIN_MEMSPACES</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;=</operator> <name>END_MEMSPACES</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>CodeSpaceRegion</name> <operator>:</operator> <name>public</name> <name>MemSpaceRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><call><name>CodeSpaceRegion</name><argument_list>(<argument><expr><name>MemRegionManager</name> <operator>&amp;</operator><name>mgr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>MemSpaceRegion</name><argument_list>(<argument>mgr</argument>, <argument>CodeSpaceRegionKind</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion *R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CodeSpaceRegionKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>GlobalsSpaceRegion</name> <operator>:</operator> <name>public</name> <name>MemSpaceRegion</name> <block>{
<expr><name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>GlobalsSpaceRegion</name><argument_list>(<argument>MemRegionManager &amp;mgr</argument>, <argument>Kind k</argument>)</argument_list></macro> <operator>:</operator> <macro><name>MemSpaceRegion</name><argument_list>(<argument>mgr</argument>, <argument>k</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>classof</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion *R</argument>)</argument_list></macro> <block>{
<expr><name>Kind</name> <name>k</name> <operator>=</operator> <call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>k</name> <operator>&gt;=</operator> <name>BEGIN_GLOBAL_MEMSPACES</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;=</operator> <name>END_GLOBAL_MEMSPACES</name></expr>;</return>
}</block>
}</expr>;






<expr><name>class</name> <name>StaticGlobalSpaceRegion</name> <operator>:</operator> <name>public</name> <name>GlobalsSpaceRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><specifier>const</specifier> <name>CodeTextRegion</name> <operator>*</operator><name>CR</name></expr>;

<expr><call><name>StaticGlobalSpaceRegion</name><argument_list>(<argument><expr><name>MemRegionManager</name> <operator>&amp;</operator><name>mgr</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CodeTextRegion</name> <operator>*</operator><name>cr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>GlobalsSpaceRegion</name><argument_list>(<argument><expr><name>mgr</name></expr></argument>, <argument><expr><name>StaticGlobalSpaceRegionKind</name></expr></argument>)</argument_list></call></expr>, <macro><name>CR</name><argument_list>(<argument>cr</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>const</specifier> <name>CodeTextRegion</name> <operator>*</operator><macro><name>getCodeRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CR</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion *R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>StaticGlobalSpaceRegionKind</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>NonStaticGlobalSpaceRegion</name> <operator>:</operator> <name>public</name> <name>GlobalsSpaceRegion</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>NonStaticGlobalSpaceRegion</name><argument_list>(<argument>MemRegionManager &amp;mgr</argument>, <argument>Kind k</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>GlobalsSpaceRegion</name><argument_list>(<argument>mgr</argument>, <argument>k</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>classof</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion *R</argument>)</argument_list></macro> <block>{
<expr><name>Kind</name> <name>k</name> <operator>=</operator> <call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>k</name> <operator>&gt;=</operator> <name>BEGIN_NON_STATIC_GLOBAL_MEMSPACES</name> <operator>&amp;&amp;</operator>
<name>k</name> <operator>&lt;=</operator> <name>END_NON_STATIC_GLOBAL_MEMSPACES</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>GlobalSystemSpaceRegion</name> <operator>:</operator> <name>public</name> <name>NonStaticGlobalSpaceRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><call><name>GlobalSystemSpaceRegion</name><argument_list>(<argument><expr><name>MemRegionManager</name> <operator>&amp;</operator><name>mgr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>NonStaticGlobalSpaceRegion</name><argument_list>(<argument>mgr</argument>, <argument>GlobalSystemSpaceRegionKind</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion *R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>GlobalSystemSpaceRegionKind</name></expr>;</return>
}</block>
}</expr>;






<expr><name>class</name> <name>GlobalImmutableSpaceRegion</name> <operator>:</operator> <name>public</name> <name>NonStaticGlobalSpaceRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><call><name>GlobalImmutableSpaceRegion</name><argument_list>(<argument><expr><name>MemRegionManager</name> <operator>&amp;</operator><name>mgr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>NonStaticGlobalSpaceRegion</name><argument_list>(<argument>mgr</argument>, <argument>GlobalImmutableSpaceRegionKind</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion *R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>GlobalImmutableSpaceRegionKind</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>GlobalInternalSpaceRegion</name> <operator>:</operator> <name>public</name> <name>NonStaticGlobalSpaceRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><call><name>GlobalInternalSpaceRegion</name><argument_list>(<argument><expr><name>MemRegionManager</name> <operator>&amp;</operator><name>mgr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>NonStaticGlobalSpaceRegion</name><argument_list>(<argument>mgr</argument>, <argument>GlobalInternalSpaceRegionKind</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion *R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>GlobalInternalSpaceRegionKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>HeapSpaceRegion</name> <operator>:</operator> <name>public</name> <name>MemSpaceRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><call><name>HeapSpaceRegion</name><argument_list>(<argument><expr><name>MemRegionManager</name> <operator>&amp;</operator><name>mgr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>MemSpaceRegion</name><argument_list>(<argument>mgr</argument>, <argument>HeapSpaceRegionKind</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion *R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>HeapSpaceRegionKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>UnknownSpaceRegion</name> <operator>:</operator> <name>public</name> <name>MemSpaceRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><call><name>UnknownSpaceRegion</name><argument_list>(<argument><expr><name>MemRegionManager</name> <operator>&amp;</operator><name>mgr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>MemSpaceRegion</name><argument_list>(<argument>mgr</argument>, <argument>UnknownSpaceRegionKind</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion *R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>UnknownSpaceRegionKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>StackSpaceRegion</name> <operator>:</operator> <name>public</name> <name>MemSpaceRegion</name> <block>{
<expr><name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;

<expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><name>SFC</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>StackSpaceRegion</name><argument_list>(<argument>MemRegionManager &amp;mgr</argument>, <argument>Kind k</argument>, <argument>const StackFrameContext *sfc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>MemSpaceRegion</name><argument_list>(<argument><expr><name>mgr</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>, <macro><name>SFC</name><argument_list>(<argument>sfc</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>classof</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>sfc</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><macro><name>getStackFrame</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SFC</name></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion *R</argument>)</argument_list></macro> <block>{
<expr><name>Kind</name> <name>k</name> <operator>=</operator> <call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>k</name> <operator>&gt;=</operator> <name>BEGIN_STACK_MEMSPACES</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;=</operator> <name>END_STACK_MEMSPACES</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>StackLocalsSpaceRegion</name> <operator>:</operator> <name>public</name> <name>StackSpaceRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><call><name>StackLocalsSpaceRegion</name><argument_list>(<argument><expr><name>MemRegionManager</name> <operator>&amp;</operator><name>mgr</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><name>sfc</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>StackSpaceRegion</name><argument_list>(<argument>mgr</argument>, <argument>StackLocalsSpaceRegionKind</argument>, <argument>sfc</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion *R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>StackLocalsSpaceRegionKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>StackArgumentsSpaceRegion</name> <operator>:</operator> <name>public</name> <name>StackSpaceRegion</name> <block>{
<expr><name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><call><name>StackArgumentsSpaceRegion</name><argument_list>(<argument><expr><name>MemRegionManager</name> <operator>&amp;</operator><name>mgr</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><name>sfc</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>StackSpaceRegion</name><argument_list>(<argument>mgr</argument>, <argument>StackArgumentsSpaceRegionKind</argument>, <argument>sfc</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion *R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>StackArgumentsSpaceRegionKind</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>SubRegion</name> <operator>:</operator> <name>public</name> <name>MemRegion</name> <block>{
<expr><name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;

<expr><name>protected</name><operator>:</operator>
<specifier>const</specifier> <name>MemRegion</name><operator>*</operator> <name>superRegion</name></expr>;

<macro><name>SubRegion</name><argument_list>(<argument>const MemRegion *sReg</argument>, <argument>Kind k</argument>)</argument_list></macro> <operator>:</operator> <expr><call><name>MemRegion</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>, <macro><name>superRegion</name><argument_list>(<argument>sReg</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>classof</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>sReg</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>MemRegion</name><operator>*</operator> <macro><name>getSuperRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>superRegion</name></expr>;</return>
}</block>

<name>MemRegionManager</name> <operator>&amp;</operator><macro><name>getMemRegionManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>bool</name> <macro><name>isSubRegionOf</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>END_MEMSPACES</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>AllocaRegion</name> <operator>:</operator> <name>public</name> <name>SubRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;



<expr><name>unsigned</name> <name>Cnt</name></expr>;

<expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>Ex</name></expr>;

<macro><name>AllocaRegion</name><argument_list>(<argument>const Expr *ex</argument>, <argument>unsigned cnt</argument>, <argument>const MemSpaceRegion *superRegion</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>SubRegion</name><argument_list>(<argument><expr><name>superRegion</name></expr></argument>, <argument><expr><name>AllocaRegionKind</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Cnt</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>, <macro><name>Ex</name><argument_list>(<argument>ex</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Ex</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>ProfileRegion</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; ID</argument>, <argument>const Expr *Ex</argument>,
<argument>unsigned Cnt</argument>, <argument>const MemRegion *superRegion</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Ex</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isBoundable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>AllocaRegionKind</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>TypedRegion</name> <operator>:</operator> <name>public</name> <name>SubRegion</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>TypedRegion</name><argument_list>(<argument>const MemRegion *sReg</argument>, <argument>Kind k</argument>)</argument_list></macro> <operator>:</operator> <macro><name>SubRegion</name><argument_list>(<argument>sReg</argument>, <argument>k</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>classof</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<name>virtual</name> <name>QualType</name> <macro><name>getLocationType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>QualType</name> <macro><name>getDesugaredLocationType</name><argument_list>(<argument>ASTContext &amp;Context</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocationType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getDesugaredType</name><argument_list>(<argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isBoundable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<expr><name>unsigned</name> <name>k</name> <operator>=</operator> <call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>k</name> <operator>&gt;=</operator> <name>BEGIN_TYPED_REGIONS</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;=</operator> <name>END_TYPED_REGIONS</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>TypedValueRegion</name> <operator>:</operator> <name>public</name> <name>TypedRegion</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>TypedValueRegion</name><argument_list>(<argument>const MemRegion* sReg</argument>, <argument>Kind k</argument>)</argument_list></macro> <operator>:</operator> <macro><name>TypedRegion</name><argument_list>(<argument>sReg</argument>, <argument>k</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>classof</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<name>virtual</name> <name>QualType</name> <macro><name>getValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>QualType</name> <macro><name>getLocationType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{

<expr><name>QualType</name> <name>T</name> <operator>=</operator> <call><name>getValueType</name><argument_list>()</argument_list></call></expr>;
<expr><name>ASTContext</name> <operator>&amp;</operator><name>ctx</name> <operator>=</operator> <call><name>getContext</name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name><name>T</name><operator>-&gt;</operator><name>getAs</name></name><operator>&lt;</operator><name>ObjCObjectType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>ctx</name><operator>.</operator><name>getObjCObjectPointerType</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>ctx</name><operator>.</operator><name>getPointerType</name></name><argument_list>(<argument><expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>QualType</name> <macro><name>getDesugaredValueType</name><argument_list>(<argument>ASTContext &amp;Context</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>QualType</name> <name>T</name> <operator>=</operator> <call><name>getValueType</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><ternary><condition><expr><call><name><name>T</name><operator>.</operator><name>getTypePtrOrNull</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>T</name><operator>.</operator><name>getDesugaredType</name></name><argument_list>(<argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>T</name></expr></else></ternary></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<expr><name>unsigned</name> <name>k</name> <operator>=</operator> <call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>k</name> <operator>&gt;=</operator> <name>BEGIN_TYPED_VALUE_REGIONS</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;=</operator> <name>END_TYPED_VALUE_REGIONS</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>CodeTextRegion</name> <operator>:</operator> <name>public</name> <name>TypedRegion</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>CodeTextRegion</name><argument_list>(<argument>const MemSpaceRegion *sreg</argument>, <argument>Kind k</argument>)</argument_list></macro> <operator>:</operator> <macro><name>TypedRegion</name><argument_list>(<argument>sreg</argument>, <argument>k</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>classof</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<name>bool</name> <macro><name>isBoundable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<expr><name>Kind</name> <name>k</name> <operator>=</operator> <call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>k</name> <operator>&gt;=</operator> <name>BEGIN_CODE_TEXT_REGIONS</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;=</operator> <name>END_CODE_TEXT_REGIONS</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>FunctionCodeRegion</name> <operator>:</operator> <name>public</name> <name>CodeTextRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>FD</name></expr>;

<expr><call><name>FunctionCodeRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>fd</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CodeSpaceRegion</name><operator>*</operator> <name>sreg</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>CodeTextRegion</name><argument_list>(<argument><expr><name>sreg</name></expr></argument>, <argument><expr><name>FunctionCodeRegionKind</name></expr></argument>)</argument_list></call></expr>, <macro><name>FD</name><argument_list>(<argument>fd</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <call><name>ProfileRegion</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name><operator>&amp;</operator> <name>ID</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>FD</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MemRegion</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getLocationType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name> <operator>=</operator> <call><name>getContext</name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>D</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>FD</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<return>return <expr><call><name><name>Ctx</name><operator>.</operator><name>getPointerType</name></name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>

assert(isa&lt;ObjCMethodDecl&gt;(FD</block></if></if_stmt>))</block></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>false</name> <operator>&amp;&amp;</operator> <literal type="string">"Getting the type of ObjCMethod is not supported yet"</literal></expr></argument>)</argument_list></call></expr>;



<return>return <expr><block>{}</block></expr>;</return>
}</block>

<specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>FD</name></expr>;</return>
}</block>

<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>FunctionCodeRegionKind</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>BlockCodeRegion</name> <operator>:</operator> <name>public</name> <name>CodeTextRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><specifier>const</specifier> <name>BlockDecl</name> <operator>*</operator><name>BD</name></expr>;
<expr><name>AnalysisDeclContext</name> <operator>*</operator><name>AC</name></expr>;
<expr><name>CanQualType</name> <name>locTy</name></expr>;

<macro><name>BlockCodeRegion</name><argument_list>(<argument>const BlockDecl *bd</argument>, <argument>CanQualType lTy</argument>,
<argument>AnalysisDeclContext *ac</argument>, <argument>const CodeSpaceRegion* sreg</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>CodeTextRegion</name><argument_list>(<argument><expr><name>sreg</name></expr></argument>, <argument><expr><name>BlockCodeRegionKind</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>BD</name><argument_list>(<argument><expr><name>bd</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>AC</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>, <macro><name>locTy</name><argument_list>(<argument>lTy</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>bd</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>lTy</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isBlockPointerType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <call><name>ProfileRegion</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name><operator>&amp;</operator> <name>ID</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>BlockDecl</name> <operator>*</operator><name>BD</name></expr></argument>,
<argument><expr><name>CanQualType</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>AnalysisDeclContext</name><operator>*</operator></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MemRegion</name><operator>*</operator></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getLocationType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><name>locTy</name></expr>;</return>
}</block>

<specifier>const</specifier> <name>BlockDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>BD</name></expr>;</return>
}</block>

<name>AnalysisDeclContext</name> <operator>*</operator><macro><name>getAnalysisDeclContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AC</name></expr>;</return> }</block>

<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>BlockCodeRegionKind</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>BlockDataRegion</name> <operator>:</operator> <name>public</name> <name>TypedRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><specifier>const</specifier> <name>BlockCodeRegion</name> <operator>*</operator><name>BC</name></expr>;
<expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LC</name></expr>;
<expr><name>unsigned</name> <name>BlockCount</name></expr>;
<expr><name>void</name> <operator>*</operator><name>ReferencedVars</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>void</name> <operator>*</operator><name>OriginalVars</name> <operator>=</operator> <name>nullptr</name></expr>;

<macro><name>BlockDataRegion</name><argument_list>(<argument>const BlockCodeRegion *bc</argument>, <argument>const LocationContext *lc</argument>,
<argument>unsigned count</argument>, <argument>const MemSpaceRegion *sreg</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>TypedRegion</name><argument_list>(<argument><expr><name>sreg</name></expr></argument>, <argument><expr><name>BlockDataRegionKind</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>BC</name><argument_list>(<argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LC</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>,
<macro><name>BlockCount</name><argument_list>(<argument>count</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>GlobalImmutableSpaceRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>sreg</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>StackLocalsSpaceRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>sreg</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>UnknownSpaceRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>sreg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <call><name>ProfileRegion</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name><operator>&amp;</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>BlockCodeRegion</name> <operator>*</operator></expr></argument>,
<argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>const</specifier> <name>BlockCodeRegion</name> <operator>*</operator><macro><name>getCodeRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BC</name></expr>;</return> }</block>

<specifier>const</specifier> <name>BlockDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>BC</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>QualType</name> <macro><name>getLocationType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><call><name><name>BC</name><operator>-&gt;</operator><name>getLocationType</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>class</name> <name>referenced_vars_iterator</name> <block>{
<expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><name>R</name></expr>;
<expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><name>OriginalR</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>referenced_vars_iterator</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><name>r</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><name>originalR</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>R</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>, <macro><name>OriginalR</name><argument_list>(<argument>originalR</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>const</specifier> <name>VarRegion</name> <operator>*</operator><macro><name>getCapturedRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>VarRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>R</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>VarRegion</name> <operator>*</operator><macro><name>getOriginalRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>VarRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>OriginalR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>referenced_vars_iterator</name> <operator>&amp;</operator><name>I</name><operator>)</operator> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>R</name> <operator>==</operator> <name>nullptr</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name><name>I</name><operator>.</operator><name>R</name></name> <operator>==</operator> <name>nullptr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>I</name><operator>.</operator><name>R</name></name> <operator>==</operator> <name>R</name></expr>;</return>
}</block>

<name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>referenced_vars_iterator</name> <operator>&amp;</operator><name>I</name><operator>)</operator> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>R</name> <operator>==</operator> <name>nullptr</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name><name>I</name><operator>.</operator><name>R</name></name> <operator>==</operator> <name>nullptr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>I</name><operator>.</operator><name>R</name></name> <operator>!=</operator> <name>R</name></expr>;</return>
}</block>

<name>referenced_vars_iterator</name> <operator>&amp;</operator><name>operator</name><operator>++</operator><operator>(</operator><operator>)</operator> <block>{
<expr><operator>++</operator><name>R</name></expr>;
<expr><operator>++</operator><name>OriginalR</name></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block>
}</expr>;



<expr><specifier>const</specifier> <name>VarRegion</name> <operator>*</operator><macro><name>getOriginalRegion</name><argument_list>(<argument>const VarRegion *VR</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>referenced_vars_iterator</name> <macro><name>referenced_vars_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>referenced_vars_iterator</name> <macro><name>referenced_vars_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>BlockDataRegionKind</name></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>void</name> <call><name>LazyInitializeReferencedVars</name><argument_list>()</argument_list></call></expr>;
<expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarRegion</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>VarRegion</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<call><name>getCaptureRegions</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;






<expr><name>class</name> <name>SymbolicRegion</name> <operator>:</operator> <name>public</name> <name>SubRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><specifier>const</specifier> <name>SymbolRef</name> <name>sym</name></expr>;

<macro><name>SymbolicRegion</name><argument_list>(<argument>const SymbolRef s</argument>, <argument>const MemSpaceRegion *sreg</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>SubRegion</name><argument_list>(<argument><expr><name>sreg</name></expr></argument>, <argument><expr><name>SymbolicRegionKind</name></expr></argument>)</argument_list></call></expr>, <macro><name>sym</name><argument_list>(<argument>s</argument>)</argument_list></macro> <expr><block>{


<expr><call><name>assert</name><argument_list>(<argument><expr><name>s</name> <operator>&amp;&amp;</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>SymbolData</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>s</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isAnyPointerType</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>s</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isReferenceType</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>s</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isBlockPointerType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>UnknownSpaceRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>sreg</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>HeapSpaceRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>sreg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<name>SymbolRef</name> <macro><name>getSymbol</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>sym</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isBoundable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>void</name> <macro><name>ProfileRegion</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; ID</argument>,
<argument>SymbolRef sym</argument>,
<argument>const MemRegion* superRegion</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SymbolicRegionKind</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>StringRegion</name> <operator>:</operator> <name>public</name> <name>TypedValueRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><specifier>const</specifier> <name>StringLiteral</name> <operator>*</operator><name>Str</name></expr>;

<expr><call><name>StringRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>StringLiteral</name> <operator>*</operator><name>str</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>GlobalInternalSpaceRegion</name> <operator>*</operator><name>sreg</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>TypedValueRegion</name><argument_list>(<argument><expr><name>sreg</name></expr></argument>, <argument><expr><name>StringRegionKind</name></expr></argument>)</argument_list></call></expr>, <macro><name>Str</name><argument_list>(<argument>str</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <call><name>ProfileRegion</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>StringLiteral</name> <operator>*</operator><name>Str</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><name>superRegion</name></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>const</specifier> <name>StringLiteral</name> <operator>*</operator><macro><name>getStringLiteral</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Str</name></expr>;</return> }</block>

<name>QualType</name> <macro><name>getValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><call><name><name>Str</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>isBoundable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<expr><call><name>ProfileRegion</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Str</name></expr></argument>, <argument><expr><name>superRegion</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>StringRegionKind</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>ObjCStringRegion</name> <operator>:</operator> <name>public</name> <name>TypedValueRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><specifier>const</specifier> <name>ObjCStringLiteral</name> <operator>*</operator><name>Str</name></expr>;

<expr><call><name>ObjCStringRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCStringLiteral</name> <operator>*</operator><name>str</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>GlobalInternalSpaceRegion</name> <operator>*</operator><name>sreg</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>TypedValueRegion</name><argument_list>(<argument><expr><name>sreg</name></expr></argument>, <argument><expr><name>ObjCStringRegionKind</name></expr></argument>)</argument_list></call></expr>, <macro><name>Str</name><argument_list>(<argument>str</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <call><name>ProfileRegion</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ObjCStringLiteral</name> <operator>*</operator><name>Str</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><name>superRegion</name></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>const</specifier> <name>ObjCStringLiteral</name> <operator>*</operator><macro><name>getObjCStringLiteral</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Str</name></expr>;</return> }</block>

<name>QualType</name> <macro><name>getValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><call><name><name>Str</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>isBoundable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<expr><call><name>ProfileRegion</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Str</name></expr></argument>, <argument><expr><name>superRegion</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCStringRegionKind</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>CompoundLiteralRegion</name> <operator>:</operator> <name>public</name> <name>TypedValueRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><specifier>const</specifier> <name>CompoundLiteralExpr</name> <operator>*</operator><name>CL</name></expr>;

<expr><call><name>CompoundLiteralRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CompoundLiteralExpr</name> <operator>*</operator><name>cl</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MemSpaceRegion</name> <operator>*</operator><name>sReg</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>TypedValueRegion</name><argument_list>(<argument><expr><name>sReg</name></expr></argument>, <argument><expr><name>CompoundLiteralRegionKind</name></expr></argument>)</argument_list></call></expr>, <macro><name>CL</name><argument_list>(<argument>cl</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>GlobalInternalSpaceRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>sReg</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>StackLocalsSpaceRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>sReg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <call><name>ProfileRegion</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name><operator>&amp;</operator> <name>ID</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CompoundLiteralExpr</name> <operator>*</operator><name>CL</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MemRegion</name><operator>*</operator> <name>superRegion</name></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><call><name><name>CL</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>isBoundable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><operator>!</operator><call><name><name>CL</name><operator>-&gt;</operator><name>isFileScope</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>const</specifier> <name>CompoundLiteralExpr</name> <operator>*</operator><macro><name>getLiteralExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CL</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CompoundLiteralRegionKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>DeclRegion</name> <operator>:</operator> <name>public</name> <name>TypedValueRegion</name> <block>{
<expr><name>protected</name><operator>:</operator>
<macro><name>DeclRegion</name><argument_list>(<argument>const MemRegion *sReg</argument>, <argument>Kind k</argument>)</argument_list></macro> <operator>:</operator> <macro><name>TypedValueRegion</name><argument_list>(<argument>sReg</argument>, <argument>k</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>classof</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<name>virtual</name> <specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<expr><name>unsigned</name> <name>k</name> <operator>=</operator> <call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>k</name> <operator>&gt;=</operator> <name>BEGIN_DECL_REGIONS</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;=</operator> <name>END_DECL_REGIONS</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>VarRegion</name> <operator>:</operator> <name>public</name> <name>DeclRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><name>protected</name><operator>:</operator>

<macro><name>VarRegion</name><argument_list>(<argument>const MemRegion *sReg</argument>, <argument>Kind k</argument>)</argument_list></macro> <operator>:</operator> <macro><name>DeclRegion</name><argument_list>(<argument>sReg</argument>, <argument>k</argument>)</argument_list></macro> <block>{




<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>GlobalsSpaceRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>sReg</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>StackSpaceRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>sReg</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>BlockDataRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>sReg</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>UnknownSpaceRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>sReg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><macro><name>getStackFrame</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>QualType</name> <macro><name>getValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{

<return>return <expr><call><name>getDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion *R</argument>)</argument_list></macro> <block>{
<expr><name>unsigned</name> <name>k</name> <operator>=</operator> <call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>k</name> <operator>&gt;=</operator> <name>BEGIN_VAR_REGIONS</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;=</operator> <name>END_VAR_REGIONS</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>NonParamVarRegion</name> <operator>:</operator> <name>public</name> <name>VarRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr>;


<expr><call><name>NonParamVarRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>vd</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><name>sReg</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>VarRegion</name><argument_list>(<argument><expr><name>sReg</name></expr></argument>, <argument><expr><name>NonParamVarRegionKind</name></expr></argument>)</argument_list></call></expr>, <macro><name>VD</name><argument_list>(<argument>vd</argument>)</argument_list></macro> <expr><block>{




<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>GlobalsSpaceRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>sReg</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>StackSpaceRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>sReg</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>BlockDataRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>sReg</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>UnknownSpaceRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>sReg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <call><name>ProfileRegion</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><name>superRegion</name></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>VD</name></expr>;</return> }</block>

<name>QualType</name> <macro><name>getValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{

<return>return <expr><call><name>getDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>bool</name> <macro><name>canPrintPrettyAsExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>printPrettyAsExpr</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NonParamVarRegionKind</name></expr>;</return>
}</block>
}</expr>;











<expr><name>class</name> <name>ParamVarRegion</name> <operator>:</operator> <name>public</name> <name>VarRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>OriginExpr</name></expr>;
<expr><name>unsigned</name> <name>Index</name></expr>;

<macro><name>ParamVarRegion</name><argument_list>(<argument>const Expr *OE</argument>, <argument>unsigned Idx</argument>, <argument>const MemRegion *SReg</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>VarRegion</name><argument_list>(<argument><expr><name>SReg</name></expr></argument>, <argument><expr><name>ParamVarRegionKind</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>OriginExpr</name><argument_list>(<argument><expr><name>OE</name></expr></argument>)</argument_list></call></expr>, <macro><name>Index</name><argument_list>(<argument>Idx</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>StackSpaceRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SReg</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getStackFrame</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>inTopFrame</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>ProfileRegion</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>const Expr *OE</argument>,
<argument>unsigned Idx</argument>, <argument>const MemRegion *SReg</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getOriginExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OriginExpr</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>getIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Index</name></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>QualType</name> <macro><name>getValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><specifier>const</specifier> <name>ParmVarDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>bool</name> <macro><name>canPrintPrettyAsExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <macro><name>printPrettyAsExpr</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion *R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ParamVarRegionKind</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>CXXThisRegion</name> <operator>:</operator> <name>public</name> <name>TypedValueRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><call><name>CXXThisRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>PointerType</name> <operator>*</operator><name>thisPointerTy</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>StackArgumentsSpaceRegion</name> <operator>*</operator><name>sReg</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>TypedValueRegion</name><argument_list>(<argument><expr><name>sReg</name></expr></argument>, <argument><expr><name>CXXThisRegionKind</name></expr></argument>)</argument_list></call></expr>,
<macro><name>ThisPointerTy</name><argument_list>(<argument>thisPointerTy</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>ThisPointerTy</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getAsCXXRecordDecl</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Invalid region type!"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <call><name>ProfileRegion</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PointerType</name> <operator>*</operator><name>PT</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><name>sReg</name></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>QualType</name> <macro><name>getValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>ThisPointerTy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXThisRegionKind</name></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>PointerType</name> <operator>*</operator><name>ThisPointerTy</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>FieldRegion</name> <operator>:</operator> <name>public</name> <name>DeclRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><name>FD</name></expr>;

<expr><call><name>FieldRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><name>fd</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>SubRegion</name> <operator>*</operator><name>sReg</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>DeclRegion</name><argument_list>(<argument><expr><name>sReg</name></expr></argument>, <argument><expr><name>FieldRegionKind</name></expr></argument>)</argument_list></call></expr>, <macro><name>FD</name><argument_list>(<argument>fd</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>void</name> <macro><name>ProfileRegion</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>const FieldDecl *FD</argument>,
<argument>const MemRegion* superRegion</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>FieldRegionKind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>FD</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>superRegion</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>FD</name></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>QualType</name> <macro><name>getValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{

<return>return <expr><call><name>getDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>bool</name> <macro><name>canPrintPretty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <macro><name>printPretty</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>canPrintPrettyAsExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <macro><name>printPrettyAsExpr</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>FieldRegionKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>ObjCIvarRegion</name> <operator>:</operator> <name>public</name> <name>DeclRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><specifier>const</specifier> <name>ObjCIvarDecl</name> <operator>*</operator><name>IVD</name></expr>;

<expr><call><name>ObjCIvarRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCIvarDecl</name> <operator>*</operator><name>ivd</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>SubRegion</name> <operator>*</operator><name>sReg</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>void</name> <call><name>ProfileRegion</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name><operator>&amp;</operator> <name>ID</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ObjCIvarDecl</name> <operator>*</operator><name>ivd</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MemRegion</name><operator>*</operator> <name>superRegion</name></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>const</specifier> <name>ObjCIvarDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>QualType</name> <macro><name>getValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>bool</name> <macro><name>canPrintPrettyAsExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <macro><name>printPrettyAsExpr</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCIvarRegionKind</name></expr>;</return>
}</block>
}</expr>;





<expr><name>class</name> <name>RegionRawOffset</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ElementRegion</name></expr>;

<expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><name>Region</name></expr>;
<expr><name>CharUnits</name> <name>Offset</name></expr>;

<macro><name>RegionRawOffset</name><argument_list>(<argument>const MemRegion* reg</argument>, <argument>CharUnits offset = CharUnits::Zero()</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Region</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>, <macro><name>Offset</name><argument_list>(<argument>offset</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>

<name>CharUnits</name> <macro><name>getOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Offset</name></expr>;</return> }</block>
<specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><macro><name>getRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Region</name></expr>;</return> }</block>

<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr>;


<expr><name>class</name> <name>ElementRegion</name> <operator>:</operator> <name>public</name> <name>TypedValueRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><name>QualType</name> <name>ElementType</name></expr>;
<expr><name>NonLoc</name> <name>Index</name></expr>;

<macro><name>ElementRegion</name><argument_list>(<argument>QualType elementType</argument>, <argument>NonLoc Idx</argument>, <argument>const SubRegion *sReg</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>TypedValueRegion</name><argument_list>(<argument><expr><name>sReg</name></expr></argument>, <argument><expr><name>ElementRegionKind</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ElementType</name><argument_list>(<argument><expr><name>elementType</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Index</name><argument_list>(<argument>Idx</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>!</operator><name><name>Idx</name><operator>.</operator><name>getAs</name></name><operator>&lt;</operator><name>nonloc</name><operator>::</operator><name>ConcreteInt</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>||</operator>
<name><name>Idx</name><operator>.</operator><name>castAs</name></name><operator>&lt;</operator><name>nonloc</name><operator>::</operator><name>ConcreteInt</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>.</operator><call><name>getValue</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isSigned</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"The index must be signed"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>elementType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>elementType</name><operator>-&gt;</operator><name>isVoidType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Invalid region type!"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>ProfileRegion</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; ID</argument>, <argument>QualType elementType</argument>,
<argument>SVal Idx</argument>, <argument>const MemRegion* superRegion</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<name>NonLoc</name> <macro><name>getIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Index</name></expr>;</return> }</block>

<name>QualType</name> <macro><name>getValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>ElementType</name></expr>;</return> }</block>

<name>QualType</name> <macro><name>getElementType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ElementType</name></expr>;</return> }</block>


<name>RegionRawOffset</name> <macro><name>getAsArrayOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ElementRegionKind</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>CXXTempObjectRegion</name> <operator>:</operator> <name>public</name> <name>TypedValueRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><name>Expr</name> <specifier>const</specifier> <operator>*</operator><name>Ex</name></expr>;

<expr><call><name>CXXTempObjectRegion</name><argument_list>(<argument><expr><name>Expr</name> <specifier>const</specifier> <operator>*</operator><name>E</name></expr></argument>, <argument><expr><name>MemSpaceRegion</name> <specifier>const</specifier> <operator>*</operator><name>sReg</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>TypedValueRegion</name><argument_list>(<argument><expr><name>sReg</name></expr></argument>, <argument><expr><name>CXXTempObjectRegionKind</name></expr></argument>)</argument_list></call></expr>, <macro><name>Ex</name><argument_list>(<argument>E</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>StackLocalsSpaceRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>sReg</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>GlobalInternalSpaceRegion</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>sReg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <call><name>ProfileRegion</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>,
<argument><expr><name>Expr</name> <specifier>const</specifier> <operator>*</operator><name>E</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><name>sReg</name></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Ex</name></expr>;</return> }</block>

<name>QualType</name> <macro><name>getValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><call><name><name>Ex</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion* R</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXTempObjectRegionKind</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>CXXBaseObjectRegion</name> <operator>:</operator> <name>public</name> <name>TypedValueRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>Data</name></expr>;

<macro><name>CXXBaseObjectRegion</name><argument_list>(<argument>const CXXRecordDecl *RD</argument>, <argument>bool IsVirtual</argument>,
<argument>const SubRegion *SReg</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>TypedValueRegion</name><argument_list>(<argument><expr><name>SReg</name></expr></argument>, <argument><expr><name>CXXBaseObjectRegionKind</name></expr></argument>)</argument_list></call></expr>, <macro><name>Data</name><argument_list>(<argument>RD</argument>, <argument>IsVirtual</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>RD</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>ProfileRegion</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>const CXXRecordDecl *RD</argument>,
<argument>bool IsVirtual</argument>, <argument>const MemRegion *SReg</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Data</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>isVirtual</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Data</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>QualType</name> <macro><name>getValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>bool</name> <macro><name>canPrintPrettyAsExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>printPrettyAsExpr</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion *region</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>region</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXBaseObjectRegionKind</name></expr>;</return>
}</block>
}</expr>;






<expr><name>class</name> <name>CXXDerivedObjectRegion</name> <operator>:</operator> <name>public</name> <name>TypedValueRegion</name> <block>{
<expr><name>friend</name> <name>class</name> <name>MemRegionManager</name></expr>;

<expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>DerivedD</name></expr>;

<expr><call><name>CXXDerivedObjectRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>DerivedD</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>SubRegion</name> <operator>*</operator><name>SReg</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>TypedValueRegion</name><argument_list>(<argument><expr><name>SReg</name></expr></argument>, <argument><expr><name>CXXDerivedObjectRegionKind</name></expr></argument>)</argument_list></call></expr>, <macro><name>DerivedD</name><argument_list>(<argument>DerivedD</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>DerivedD</name></expr></argument>)</argument_list></call></expr>;



<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>SReg</name><operator>-&gt;</operator><name>getSymbolicBase</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Should have unwrapped a base region instead!"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <call><name>ProfileRegion</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><name>SReg</name></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DerivedD</name></expr>;</return> }</block>

<name>QualType</name> <macro><name>getValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>bool</name> <macro><name>canPrintPrettyAsExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>printPrettyAsExpr</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const MemRegion *region</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>region</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXDerivedObjectRegionKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>RegionTy</name></expr></argument>&gt;</argument_list></name>
<specifier>const</specifier> <name>RegionTy</name><operator>*</operator> <name>MemRegion</name><operator>::</operator><macro><name>getAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>RT</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>RegionTy</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>RT</name></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><name>nullptr</name></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>RegionTy</name></expr></argument>&gt;</argument_list></name>
<specifier>const</specifier> <name>RegionTy</name><operator>*</operator> <name>MemRegion</name><operator>::</operator><macro><name>castAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>RegionTy</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name>class</name> <name>MemRegionManager</name> <block>{
<expr><name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr>;
<expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name><operator>&amp;</operator> <name>A</name></expr>;

<expr><name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>MemRegion</name></expr></argument>&gt;</argument_list></name> <name>Regions</name></expr>;

<expr><name>GlobalInternalSpaceRegion</name> <operator>*</operator><name>InternalGlobals</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>GlobalSystemSpaceRegion</name> <operator>*</operator><name>SystemGlobals</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>GlobalImmutableSpaceRegion</name> <operator>*</operator><name>ImmutableGlobals</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator></expr></argument>, <argument><expr><name>StackLocalsSpaceRegion</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>StackLocalsSpaceRegions</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator></expr></argument>, <argument><expr><name>StackArgumentsSpaceRegion</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>StackArgumentsSpaceRegions</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CodeTextRegion</name> <operator>*</operator></expr></argument>, <argument><expr><name>StaticGlobalSpaceRegion</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>StaticsGlobalSpaceRegions</name></expr>;

<expr><name>HeapSpaceRegion</name> <operator>*</operator><name>heap</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>UnknownSpaceRegion</name> <operator>*</operator><name>unknown</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>CodeSpaceRegion</name> <operator>*</operator><name>code</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>MemRegionManager</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name> <operator>&amp;</operator><name>a</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>Ctx</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>, <macro><name>A</name><argument_list>(<argument>a</argument>)</argument_list></macro> <expr><block>{}</block>
<operator>~</operator><call><name>MemRegionManager</name><argument_list>()</argument_list></call></expr>;

<expr><name>ASTContext</name> <operator>&amp;</operator><macro><name>getContext</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Ctx</name></expr>;</return> }</block>

<name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name> <operator>&amp;</operator><macro><name>getAllocator</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>A</name></expr>;</return> }</block>



<name>DefinedOrUnknownSVal</name> <macro><name>getStaticSize</name><argument_list>(<argument>const MemRegion *MR</argument>,
<argument>SValBuilder &amp;SVB</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><specifier>const</specifier> <name>StackLocalsSpaceRegion</name> <operator>*</operator>
<call><name>getStackLocalsRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><name>STC</name></expr></argument>)</argument_list></call></expr>;



<expr><specifier>const</specifier> <name>StackArgumentsSpaceRegion</name> <operator>*</operator>
<call><name>getStackArgumentsRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><name>STC</name></expr></argument>)</argument_list></call></expr>;



<expr><specifier>const</specifier> <name>GlobalsSpaceRegion</name> <operator>*</operator><macro><name>getGlobalsRegion</name><argument_list>(
<argument>MemRegion::Kind K = MemRegion::GlobalInternalSpaceRegionKind</argument>,
<argument>const CodeTextRegion *R = nullptr</argument>)</argument_list></macro></expr>;



<expr><specifier>const</specifier> <name>HeapSpaceRegion</name> <operator>*</operator><call><name>getHeapRegion</name><argument_list>()</argument_list></call></expr>;



<expr><specifier>const</specifier> <name>UnknownSpaceRegion</name> <operator>*</operator><call><name>getUnknownRegion</name><argument_list>()</argument_list></call></expr>;

<expr><specifier>const</specifier> <name>CodeSpaceRegion</name> <operator>*</operator><call><name>getCodeRegion</name><argument_list>()</argument_list></call></expr>;


<expr><specifier>const</specifier> <name>AllocaRegion</name> <operator>*</operator><macro><name>getAllocaRegion</name><argument_list>(<argument>const Expr *Ex</argument>, <argument>unsigned Cnt</argument>,
<argument>const LocationContext *LC</argument>)</argument_list></macro></expr>;



<expr><specifier>const</specifier> <name>CompoundLiteralRegion</name><operator>*</operator>
<call><name>getCompoundLiteralRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CompoundLiteralExpr</name> <operator>*</operator><name>CL</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LC</name></expr></argument>)</argument_list></call></expr>;



<expr><specifier>const</specifier> <name>CXXThisRegion</name> <operator>*</operator><macro><name>getCXXThisRegion</name><argument_list>(<argument>QualType thisPointerTy</argument>,
<argument>const LocationContext *LC</argument>)</argument_list></macro></expr>;


<expr><specifier>const</specifier> <name>SymbolicRegion</name><operator>*</operator> <macro><name>getSymbolicRegion</name><argument_list>(<argument>SymbolRef Sym</argument>)</argument_list></macro></expr>;


<expr><specifier>const</specifier> <name>SymbolicRegion</name> <operator>*</operator><macro><name>getSymbolicHeapRegion</name><argument_list>(<argument>SymbolRef sym</argument>)</argument_list></macro></expr>;

<expr><specifier>const</specifier> <name>StringRegion</name> <operator>*</operator><call><name>getStringRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>StringLiteral</name> <operator>*</operator><name>Str</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>const</specifier> <name>ObjCStringRegion</name> <operator>*</operator><call><name>getObjCStringRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCStringLiteral</name> <operator>*</operator><name>Str</name></expr></argument>)</argument_list></call></expr>;



<expr><specifier>const</specifier> <name>VarRegion</name> <operator>*</operator><call><name>getVarRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LC</name></expr></argument>)</argument_list></call></expr>;



<expr><specifier>const</specifier> <name>NonParamVarRegion</name> <operator>*</operator><call><name>getNonParamVarRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><name>superR</name></expr></argument>)</argument_list></call></expr>;



<expr><specifier>const</specifier> <name>ParamVarRegion</name> <operator>*</operator><macro><name>getParamVarRegion</name><argument_list>(<argument>const Expr *OriginExpr</argument>,
<argument>unsigned Index</argument>,
<argument>const LocationContext *LC</argument>)</argument_list></macro></expr>;



<expr><specifier>const</specifier> <name>ElementRegion</name> <operator>*</operator><macro><name>getElementRegion</name><argument_list>(<argument>QualType elementType</argument>, <argument>NonLoc Idx</argument>,
<argument>const SubRegion *superRegion</argument>,
<argument>ASTContext &amp;Ctx</argument>)</argument_list></macro></expr>;

<expr><specifier>const</specifier> <name>ElementRegion</name> <operator>*</operator><macro><name>getElementRegionWithSuper</name><argument_list>(<argument>const ElementRegion *ER</argument>,
<argument>const SubRegion *superRegion</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getElementRegion</name><argument_list>(<argument><expr><call><name><name>ER</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ER</name><operator>-&gt;</operator><name>getIndex</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>superRegion</name></expr></argument>, <argument><expr><call><name><name>ER</name><operator>-&gt;</operator><name>getContext</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<specifier>const</specifier> <name>FieldRegion</name> <operator>*</operator><call><name>getFieldRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><name>fd</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>SubRegion</name><operator>*</operator> <name>superRegion</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>const</specifier> <name>FieldRegion</name> <operator>*</operator><macro><name>getFieldRegionWithSuper</name><argument_list>(<argument>const FieldRegion *FR</argument>,
<argument>const SubRegion *superRegion</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getFieldRegion</name><argument_list>(<argument><expr><call><name><name>FR</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>superRegion</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<specifier>const</specifier> <name>ObjCIvarRegion</name> <operator>*</operator><call><name>getObjCIvarRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCIvarDecl</name> <operator>*</operator><name>ivd</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>SubRegion</name><operator>*</operator> <name>superRegion</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>const</specifier> <name>CXXTempObjectRegion</name> <operator>*</operator><call><name>getCXXTempObjectRegion</name><argument_list>(<argument><expr><name>Expr</name> <specifier>const</specifier> <operator>*</operator><name>Ex</name></expr></argument>,
<argument><expr><name>LocationContext</name> <specifier>const</specifier> <operator>*</operator><name>LC</name></expr></argument>)</argument_list></call></expr>;





<expr><specifier>const</specifier> <name>CXXBaseObjectRegion</name> <operator>*</operator>
<macro><name>getCXXBaseObjectRegion</name><argument_list>(<argument>const CXXRecordDecl *BaseClass</argument>, <argument>const SubRegion *Super</argument>,
<argument>bool IsVirtual</argument>)</argument_list></macro></expr>;



<expr><specifier>const</specifier> <name>CXXBaseObjectRegion</name> <operator>*</operator>
<macro><name>getCXXBaseObjectRegionWithSuper</name><argument_list>(<argument>const CXXBaseObjectRegion *baseReg</argument>,
<argument>const SubRegion *superRegion</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getCXXBaseObjectRegion</name><argument_list>(<argument><expr><call><name><name>baseReg</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>superRegion</name></expr></argument>,
<argument><expr><call><name><name>baseReg</name><operator>-&gt;</operator><name>isVirtual</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<specifier>const</specifier> <name>CXXDerivedObjectRegion</name> <operator>*</operator>
<call><name>getCXXDerivedObjectRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>BaseClass</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>SubRegion</name> <operator>*</operator><name>Super</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>const</specifier> <name>FunctionCodeRegion</name> <operator>*</operator><call><name>getFunctionCodeRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>FD</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>BlockCodeRegion</name> <operator>*</operator><macro><name>getBlockCodeRegion</name><argument_list>(<argument>const BlockDecl *BD</argument>,
<argument>CanQualType locTy</argument>,
<argument>AnalysisDeclContext *AC</argument>)</argument_list></macro></expr>;





<expr><specifier>const</specifier> <name>BlockDataRegion</name> <operator>*</operator><macro><name>getBlockDataRegion</name><argument_list>(<argument>const BlockCodeRegion *bc</argument>,
<argument>const LocationContext *lc</argument>,
<argument>unsigned blockCount</argument>)</argument_list></macro></expr>;




<expr><specifier>const</specifier> <name>CXXTempObjectRegion</name> <operator>*</operator><call><name>getCXXStaticTempObjectRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>Ex</name></expr></argument>)</argument_list></call></expr>;

<expr><name>private</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>RegionTy</name></expr></argument>, <argument><expr><name>typename</name> <name>SuperTy</name></expr></argument>,
<argument><expr><name>typename</name> <name>Arg1Ty</name></expr></argument>&gt;</argument_list></name>
<name>RegionTy</name><operator>*</operator> <macro><name>getSubRegion</name><argument_list>(<argument>const Arg1Ty arg1</argument>,
<argument>const SuperTy* superRegion</argument>)</argument_list></macro></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>RegionTy</name></expr></argument>, <argument><expr><name>typename</name> <name>SuperTy</name></expr></argument>,
<argument><expr><name>typename</name> <name>Arg1Ty</name></expr></argument>, <argument><expr><name>typename</name> <name>Arg2Ty</name></expr></argument>&gt;</argument_list></name>
<name>RegionTy</name><operator>*</operator> <macro><name>getSubRegion</name><argument_list>(<argument>const Arg1Ty arg1</argument>, <argument>const Arg2Ty arg2</argument>,
<argument>const SuperTy* superRegion</argument>)</argument_list></macro></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>RegionTy</name></expr></argument>, <argument><expr><name>typename</name> <name>SuperTy</name></expr></argument>,
<argument><expr><name>typename</name> <name>Arg1Ty</name></expr></argument>, <argument><expr><name>typename</name> <name>Arg2Ty</name></expr></argument>, <argument><expr><name>typename</name> <name>Arg3Ty</name></expr></argument>&gt;</argument_list></name>
<name>RegionTy</name><operator>*</operator> <macro><name>getSubRegion</name><argument_list>(<argument>const Arg1Ty arg1</argument>, <argument>const Arg2Ty arg2</argument>,
<argument>const Arg3Ty arg3</argument>,
<argument>const SuperTy* superRegion</argument>)</argument_list></macro></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>REG</name></expr></argument>&gt;</argument_list></name>
<specifier>const</specifier> <name>REG</name><operator>*</operator> <call><name>LazyAllocate</name><argument_list>(<argument><expr><name>REG</name><operator>*</operator><operator>&amp;</operator> <name>region</name></expr></argument>)</argument_list></call></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>REG</name></expr></argument>, <argument><expr><name>typename</name> <name>ARG</name></expr></argument>&gt;</argument_list></name>
<specifier>const</specifier> <name>REG</name><operator>*</operator> <macro><name>LazyAllocate</name><argument_list>(<argument>REG*&amp; region</argument>, <argument>ARG a</argument>)</argument_list></macro></expr>;
}</block></expr>;





<expr><specifier>inline</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>MemRegion</name><operator>::</operator><macro><name>getContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getMemRegionManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getContext</name><argument_list>()</argument_list></call></expr>;</return>
}</block>






<name>class</name> <name>RegionAndSymbolInvalidationTraits</name> <block>{
<expr><name>using</name> <name>StorageTypeForKinds</name> <operator>=</operator> <name>unsigned</name> <name>char</name></expr>;

<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator></expr></argument>, <argument><expr><name>StorageTypeForKinds</name></expr></argument>&gt;</argument_list></name> <name>MRTraitsMap</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>SymbolRef</name></expr></argument>, <argument><expr><name>StorageTypeForKinds</name></expr></argument>&gt;</argument_list></name> <name>SymTraitsMap</name></expr>;

<expr><name>using</name> <name>const_region_iterator</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator></expr></argument>, <argument><expr><name>StorageTypeForKinds</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name></expr>;
<expr><name>using</name> <name>const_symbol_iterator</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>SymbolRef</name></expr></argument>, <argument><expr><name>StorageTypeForKinds</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name></expr>;

<expr><name>public</name><operator>:</operator>

enum <name>InvalidationKinds</name> <block>{

<expr><name>TK_PreserveContents</name> <operator>=</operator> <literal type="number">0x1</literal></expr>,


<expr><name>TK_SuppressEscape</name> <operator>=</operator> <literal type="number">0x2</literal></expr>,


<expr><name>TK_DoNotInvalidateSuperRegion</name> <operator>=</operator> <literal type="number">0x4</literal></expr>,



<expr><name>TK_EntireMemSpace</name> <operator>=</operator> <literal type="number">0x8</literal></expr>



}</block></expr>;

<expr><name>void</name> <macro><name>setTrait</name><argument_list>(<argument>SymbolRef Sym</argument>, <argument>InvalidationKinds IK</argument>)</argument_list></macro></expr>;
<expr><name>void</name> <macro><name>setTrait</name><argument_list>(<argument>const MemRegion *MR</argument>, <argument>InvalidationKinds IK</argument>)</argument_list></macro></expr>;
<expr><name>bool</name> <macro><name>hasTrait</name><argument_list>(<argument>SymbolRef Sym</argument>, <argument>InvalidationKinds IK</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>hasTrait</name><argument_list>(<argument>const MemRegion *MR</argument>, <argument>InvalidationKinds IK</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr>;




<expr><specifier>inline</specifier> <name>raw_ostream</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><name>raw_ostream</name> <operator>&amp;</operator><name>os</name>, <specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><name>R</name><operator>)</operator> <block>{
<expr><call><name><name>R</name><operator>-&gt;</operator><name>dumpToStream</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>os</name></expr>;</return>
}</block>

}

}</expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></range></decl></decl_stmt></block_content></block></decl></decl_stmt></block_content></block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
