<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Format/Format.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_FORMAT_FORMAT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_FORMAT_FORMAT_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LangOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Tooling/Core/Replacement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Tooling/Inclusions/IncludeStyle.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Regex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/SourceMgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;system_error&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>vfs</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>FileSystem</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>Lexer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SourceManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DiagnosticConsumer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>format</name> <block>{<block_content>

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>ParseError</name> <block>{<block_content>
<expr_stmt><expr><name>Success</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator>
<expr><name>Error</name></expr><operator>,</operator>
<expr><name>Unsuitable</name></expr><operator>,</operator>
<expr><name>BinPackTrailingCommaConflict</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<decl_stmt><decl><type><name>class</name> <name>ParseErrorCategory</name></type> <name>final</name> <range>: <expr><name>public</name> <name>std</name><operator>::</operator><name>error_category</name> <block>{
<expr><name>public</name><operator>:</operator>
<specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>name</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>noexcept</name> <name>override</name></expr>;
<expr><name>std</name><operator>::</operator><name>string</name> <macro><name>message</name><argument_list>(<argument>int EV</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
}</block></expr></range></decl>;</decl_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>error_category</name> <operator>&amp;</operator><call><name>getParseCategory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>error_code</name> <macro><name>make_error_code</name><argument_list>(<argument>ParseError e</argument>)</argument_list></macro></expr>;</expr_stmt>



<struct>struct <name>FormatStyle</name> <block>{



<decl_stmt><decl><type><name>bool</name></type> <name>InheritsParentConfig</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>AccessModifierOffset</name></decl>;</decl_stmt>


<enum>enum <name>BracketAlignmentStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{





<decl><name>BAS_Align</name></decl>,





<decl><name>BAS_DontAlign</name></decl>,






<decl><name>BAS_AlwaysBreak</name></decl>,
}</block>;</enum>





<decl_stmt><decl><type><name>BracketAlignmentStyle</name></type> <name>AlignAfterOpenBracket</name></decl>;</decl_stmt>


<enum>enum <name>ArrayInitializerAlignmentStyle</name> <block>{









<decl><name>AIAS_Left</name></decl>,









<decl><name>AIAS_Right</name></decl>,

<decl><name>AIAS_None</name></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>ArrayInitializerAlignmentStyle</name></type> <name>AlignArrayOfStructures</name></decl>;</decl_stmt>







<enum>enum <name>AlignConsecutiveStyle</name> <block>{
<decl><name>ACS_None</name></decl>,
<decl><name>ACS_Consecutive</name></decl>,
<decl><name>ACS_AcrossEmptyLines</name></decl>,
<decl><name>ACS_AcrossComments</name></decl>,
<decl><name>ACS_AcrossEmptyLinesAndComments</name></decl>
}</block>;</enum>





































































<decl_stmt><decl><type><name>AlignConsecutiveStyle</name></type> <name>AlignConsecutiveMacros</name></decl>;</decl_stmt>



































































<decl_stmt><decl><type><name>AlignConsecutiveStyle</name></type> <name>AlignConsecutiveAssignments</name></decl>;</decl_stmt>




































































<decl_stmt><decl><type><name>AlignConsecutiveStyle</name></type> <name>AlignConsecutiveBitFields</name></decl>;</decl_stmt>




































































<decl_stmt><decl><type><name>AlignConsecutiveStyle</name></type> <name>AlignConsecutiveDeclarations</name></decl>;</decl_stmt>


<enum>enum <name>EscapedNewlineAlignmentStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{







<decl><name>ENAS_DontAlign</name></decl>,










<decl><name>ENAS_Left</name></decl>,







<decl><name>ENAS_Right</name></decl>,
}</block>;</enum>


<decl_stmt><decl><type><name>EscapedNewlineAlignmentStyle</name></type> <name>AlignEscapedNewlines</name></decl>;</decl_stmt>


<enum>enum <name>OperandAlignmentStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{



<decl><name>OAS_DontAlign</name></decl>,















<decl><name>OAS_Align</name></decl>,









<decl><name>OAS_AlignAfterOperator</name></decl>,
}</block>;</enum>



<decl_stmt><decl><type><name>OperandAlignmentStyle</name></type> <name>AlignOperands</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>bool</name></type> <name>AlignTrailingComments</name></decl>;</decl_stmt>















<decl_stmt><decl><type><name>bool</name></type> <name>AllowAllArgumentsOnNextLine</name></decl>;</decl_stmt>















<decl_stmt><decl><type><name>bool</name></type> <name>AllowAllConstructorInitializersOnNextLine</name></decl>;</decl_stmt>
















<decl_stmt><decl><type><name>bool</name></type> <name>AllowAllParametersOfDeclarationOnNextLine</name></decl>;</decl_stmt>













<decl_stmt><decl><type><name>bool</name></type> <name>AllowShortEnumsOnASingleLine</name></decl>;</decl_stmt>



<enum>enum <name>ShortBlockStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{








<decl><name>SBS_Never</name></decl>,







<decl><name>SBS_Empty</name></decl>,





<decl><name>SBS_Always</name></decl>,
}</block>;</enum>



<decl_stmt><decl><type><name>ShortBlockStyle</name></type> <name>AllowShortBlocksOnASingleLine</name></decl>;</decl_stmt>












<decl_stmt><decl><type><name>bool</name></type> <name>AllowShortCaseLabelsOnASingleLine</name></decl>;</decl_stmt>



<enum>enum <name>ShortFunctionStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{

<decl><name>SFS_None</name></decl>,













<decl><name>SFS_InlineOnly</name></decl>,







<decl><name>SFS_Empty</name></decl>,










<decl><name>SFS_Inline</name></decl>,







<decl><name>SFS_All</name></decl>,
}</block>;</enum>



<decl_stmt><decl><type><name>ShortFunctionStyle</name></type> <name>AllowShortFunctionsOnASingleLine</name></decl>;</decl_stmt>


<enum>enum <name>ShortIfStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{
















<decl><name>SIS_Never</name></decl>,















<decl><name>SIS_WithoutElse</name></decl>,















<decl><name>SIS_OnlyFirstIf</name></decl>,













<decl><name>SIS_AllIfsAndElse</name></decl>,
}</block>;</enum>


<decl_stmt><decl><type><name>ShortIfStyle</name></type> <name>AllowShortIfStatementsOnASingleLine</name></decl>;</decl_stmt>



<enum>enum <name>ShortLambdaStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{

<decl><name>SLS_None</name></decl>,







<decl><name>SLS_Empty</name></decl>,







<decl><name>SLS_Inline</name></decl>,





<decl><name>SLS_All</name></decl>,
}</block>;</enum>



<decl_stmt><decl><type><name>ShortLambdaStyle</name></type> <name>AllowShortLambdasOnASingleLine</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>AllowShortLoopsOnASingleLine</name></decl>;</decl_stmt>



<enum>enum <name>DefinitionReturnTypeBreakingStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{


<decl><name>DRTBS_None</name></decl>,

<decl><name>DRTBS_All</name></decl>,

<decl><name>DRTBS_TopLevel</name></decl>,
}</block>;</enum>



<enum>enum <name>ReturnTypeBreakingStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{









<decl><name>RTBS_None</name></decl>,















<decl><name>RTBS_All</name></decl>,












<decl><name>RTBS_TopLevel</name></decl>,














<decl><name>RTBS_AllDefinitions</name></decl>,











<decl><name>RTBS_TopLevelDefinitions</name></decl>,
}</block>;</enum>



<decl_stmt><decl><type><name>DefinitionReturnTypeBreakingStyle</name></type> <name>AlwaysBreakAfterDefinitionReturnType</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ReturnTypeBreakingStyle</name></type> <name>AlwaysBreakAfterReturnType</name></decl>;</decl_stmt>













<decl_stmt><decl><type><name>bool</name></type> <name>AlwaysBreakBeforeMultilineStrings</name></decl>;</decl_stmt>


<enum>enum <name>BreakTemplateDeclarationsStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{









<decl><name>BTDS_No</name></decl>,










<decl><name>BTDS_MultiLine</name></decl>,










<decl><name>BTDS_Yes</name></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>BreakTemplateDeclarationsStyle</name></type> <name>AlwaysBreakTemplateDeclarations</name></decl>;</decl_stmt>

















<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>AttributeMacros</name></expr>;</expr_stmt>

















<decl_stmt><decl><type><name>bool</name></type> <name>BinPackArguments</name></decl>;</decl_stmt>


<enum>enum <name>TrailingCommaStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{

<decl><name>TCS_None</name></decl>,





<decl><name>TCS_Wrapped</name></decl>,
}</block>;</enum>
















<decl_stmt><decl><type><name>TrailingCommaStyle</name></type> <name>InsertTrailingCommas</name></decl>;</decl_stmt>













<decl_stmt><decl><type><name>bool</name></type> <name>BinPackParameters</name></decl>;</decl_stmt>



<enum>enum <name>BinPackStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{

<decl><name>BPS_Auto</name></decl>,

<decl><name>BPS_Always</name></decl>,

<decl><name>BPS_Never</name></decl>,
}</block>;</enum>


<enum>enum <name>BinaryOperatorStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{











<decl><name>BOS_None</name></decl>,











<decl><name>BOS_NonAssignment</name></decl>,











<decl><name>BOS_All</name></decl>,
}</block>;</enum>


<decl_stmt><decl><type><name>BinaryOperatorStyle</name></type> <name>BreakBeforeBinaryOperators</name></decl>;</decl_stmt>


<enum>enum <name>BraceBreakingStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{












































<decl><name>BS_Attach</name></decl>,

















































<decl><name>BS_Linux</name></decl>,

















































<decl><name>BS_Mozilla</name></decl>,

















































<decl><name>BS_Stroustrup</name></decl>,



























































<decl><name>BS_Allman</name></decl>,



























































<decl><name>BS_Whitesmiths</name></decl>,






























































<decl><name>BS_GNU</name></decl>,














































<decl><name>BS_WebKit</name></decl>,

<decl><name>BS_Custom</name></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>BraceBreakingStyle</name></type> <name>BreakBeforeBraces</name></decl>;</decl_stmt>


<enum>enum <name>BraceWrappingAfterControlStatementStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{








<decl><name>BWACS_Never</name></decl>,










<decl><name>BWACS_MultiLine</name></decl>,









<decl><name>BWACS_Always</name></decl>
}</block>;</enum>








<struct>struct <name>BraceWrappingFlags</name> <block>{















<decl_stmt><decl><type><name>bool</name></type> <name>AfterCaseLabel</name></decl>;</decl_stmt>









<decl_stmt><decl><type><name>bool</name></type> <name>AfterClass</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>BraceWrappingAfterControlStatementStyle</name></type> <name>AfterControlStatement</name></decl>;</decl_stmt>











<decl_stmt><decl><type><name>bool</name></type> <name>AfterEnum</name></decl>;</decl_stmt>















<decl_stmt><decl><type><name>bool</name></type> <name>AfterFunction</name></decl>;</decl_stmt>















<decl_stmt><decl><type><name>bool</name></type> <name>AfterNamespace</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>AfterObjCDeclaration</name></decl>;</decl_stmt>













<decl_stmt><decl><type><name>bool</name></type> <name>AfterStruct</name></decl>;</decl_stmt>













<decl_stmt><decl><type><name>bool</name></type> <name>AfterUnion</name></decl>;</decl_stmt>













<decl_stmt><decl><type><name>bool</name></type> <name>AfterExternBlock</name></decl>;</decl_stmt>















<decl_stmt><decl><type><name>bool</name></type> <name>BeforeCatch</name></decl>;</decl_stmt>













<decl_stmt><decl><type><name>bool</name></type> <name>BeforeElse</name></decl>;</decl_stmt>
















<decl_stmt><decl><type><name>bool</name></type> <name>BeforeLambdaBody</name></decl>;</decl_stmt>













<decl_stmt><decl><type><name>bool</name></type> <name>BeforeWhile</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>IndentBraces</name></decl>;</decl_stmt>











<decl_stmt><decl><type><name>bool</name></type> <name>SplitEmptyFunction</name></decl>;</decl_stmt>










<decl_stmt><decl><type><name>bool</name></type> <name>SplitEmptyRecord</name></decl>;</decl_stmt>










<decl_stmt><decl><type><name>bool</name></type> <name>SplitEmptyNamespace</name></decl>;</decl_stmt>
}</block>;</struct>













<decl_stmt><decl><type><name>BraceWrappingFlags</name></type> <name>BraceWrapping</name></decl>;</decl_stmt>










<decl_stmt><decl><type><name>bool</name></type> <name>BreakBeforeConceptDeclarations</name></decl>;</decl_stmt>













<decl_stmt><decl><type><name>bool</name></type> <name>BreakBeforeTernaryOperators</name></decl>;</decl_stmt>


<enum>enum <name>BreakConstructorInitializersStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{






<decl><name>BCIS_BeforeColon</name></decl>,







<decl><name>BCIS_BeforeComma</name></decl>,






<decl><name>BCIS_AfterColon</name></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>BreakConstructorInitializersStyle</name></type> <name>BreakConstructorInitializers</name></decl>;</decl_stmt>








<decl_stmt><decl><type><name>bool</name></type> <name>BreakAfterJavaFieldAnnotations</name></decl>;</decl_stmt>












<decl_stmt><decl><type><name>bool</name></type> <name>BreakStringLiterals</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>unsigned</name></type> <name>ColumnLimit</name></decl>;</decl_stmt>








<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>CommentPragmas</name></expr>;</expr_stmt>


<enum>enum <name>BreakInheritanceListStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{







<decl><name>BILS_BeforeColon</name></decl>,








<decl><name>BILS_BeforeComma</name></decl>,







<decl><name>BILS_AfterColon</name></decl>,






<decl><name>BILS_AfterComma</name></decl>,
}</block>;</enum>


<decl_stmt><decl><type><name>BreakInheritanceListStyle</name></type> <name>BreakInheritanceList</name></decl>;</decl_stmt>






















<decl_stmt><decl><type><name>bool</name></type> <name>CompactNamespaces</name></decl>;</decl_stmt>


















<decl_stmt><decl><type><name>bool</name></type> <name>ConstructorInitializerAllOnOneLineOrOnePerLine</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>ConstructorInitializerIndentWidth</name></decl>;</decl_stmt>









<decl_stmt><decl><type><name>unsigned</name></type> <name>ContinuationIndentWidth</name></decl>;</decl_stmt>





















<decl_stmt><decl><type><name>bool</name></type> <name>Cpp11BracedListStyle</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>DeriveLineEnding</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>bool</name></type> <name>DerivePointerAlignment</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>DisableFormat</name></decl>;</decl_stmt>




<enum>enum <name>EmptyLineAfterAccessModifierStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{














<decl><name>ELAAMS_Never</name></decl>,


<decl><name>ELAAMS_Leave</name></decl>,




















<decl><name>ELAAMS_Always</name></decl>,
}</block>;</enum>




<decl_stmt><decl><type><name>EmptyLineAfterAccessModifierStyle</name></type> <name>EmptyLineAfterAccessModifier</name></decl>;</decl_stmt>


<enum>enum <name>EmptyLineBeforeAccessModifierStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{














<decl><name>ELBAMS_Never</name></decl>,

<decl><name>ELBAMS_Leave</name></decl>,

















<decl><name>ELBAMS_LogicalBlock</name></decl>,



















<decl><name>ELBAMS_Always</name></decl>,
}</block>;</enum>


<decl_stmt><decl><type><name>EmptyLineBeforeAccessModifierStyle</name></type> <name>EmptyLineBeforeAccessModifier</name></decl>;</decl_stmt>











<decl_stmt><decl><type><name>bool</name></type> <name>ExperimentalAutoDetectBinPacking</name></decl>;</decl_stmt>











<decl_stmt><decl><type><name>bool</name></type> <name>FixNamespaceComments</name></decl>;</decl_stmt>
















<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>ForEachMacros</name></expr>;</expr_stmt>



















<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>IfMacros</name></expr>;</expr_stmt>















<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>TypenameMacros</name></expr>;</expr_stmt>









<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>StatementMacros</name></expr>;</expr_stmt>











<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>NamespaceMacros</name></expr>;</expr_stmt>















<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>WhitespaceSensitiveMacros</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tooling</name><operator>::</operator><name>IncludeStyle</name> <name>IncludeStyle</name></expr>;</expr_stmt>

























<decl_stmt><decl><type><name>bool</name></type> <name>IndentAccessModifiers</name></decl>;</decl_stmt>

















<decl_stmt><decl><type><name>bool</name></type> <name>IndentCaseLabels</name></decl>;</decl_stmt>





















<decl_stmt><decl><type><name>bool</name></type> <name>IndentCaseBlocks</name></decl>;</decl_stmt>















<decl_stmt><decl><type><name>bool</name></type> <name>IndentGotoLabels</name></decl>;</decl_stmt>


<enum>enum <name>PPDirectiveIndentStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{








<decl><name>PPDIS_None</name></decl>,








<decl><name>PPDIS_AfterHash</name></decl>,








<decl><name>PPDIS_BeforeHash</name></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>PPDirectiveIndentStyle</name></type> <name>IndentPPDirectives</name></decl>;</decl_stmt>


<enum>enum <name>IndentExternBlockStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{

















<decl><name>IEBS_AfterExternBlock</name></decl>,






<decl><name>IEBS_NoIndent</name></decl>,






<decl><name>IEBS_Indent</name></decl>,
}</block>;</enum>


<decl_stmt><decl><type><name>IndentExternBlockStyle</name></type> <name>IndentExternBlock</name></decl>;</decl_stmt>

















<decl_stmt><decl><type><name>bool</name></type> <name>IndentRequires</name></decl>;</decl_stmt>












<decl_stmt><decl><type><name>unsigned</name></type> <name>IndentWidth</name></decl>;</decl_stmt>












<decl_stmt><decl><type><name>bool</name></type> <name>IndentWrappedFunctionNames</name></decl>;</decl_stmt>
































<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>JavaImportGroups</name></expr>;</expr_stmt>



<enum>enum <name>JavaScriptQuoteStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{





<decl><name>JSQS_Leave</name></decl>,





<decl><name>JSQS_Single</name></decl>,





<decl><name>JSQS_Double</name></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>JavaScriptQuoteStyle</name></type> <name>JavaScriptQuotes</name></decl>;</decl_stmt>














<decl_stmt><decl><type><name>bool</name></type> <name>JavaScriptWrapImports</name></decl>;</decl_stmt>










<decl_stmt><decl><type><name>bool</name></type> <name>KeepEmptyLinesAtTheStartOfBlocks</name></decl>;</decl_stmt>






<enum>enum <name>LanguageKind</name> : <type><name>unsigned</name> <name>char</name></type> <block>{

<decl><name>LK_None</name></decl>,

<decl><name>LK_Cpp</name></decl>,

<decl><name>LK_CSharp</name></decl>,

<decl><name>LK_Java</name></decl>,

<decl><name>LK_JavaScript</name></decl>,

<decl><name>LK_Json</name></decl>,

<decl><name>LK_ObjC</name></decl>,


<decl><name>LK_Proto</name></decl>,

<decl><name>LK_TableGen</name></decl>,


<decl><name>LK_TextProto</name></decl>
}</block>;</enum>
<expr_stmt><expr><name>bool</name> <macro><name>isCpp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Language</name> <operator>==</operator> <name>LK_Cpp</name> <operator>||</operator> <name>Language</name> <operator>==</operator> <name>LK_ObjC</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isCSharp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Language</name> <operator>==</operator> <name>LK_CSharp</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isJson</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Language</name> <operator>==</operator> <name>LK_Json</name></expr>;</return> }</block></expr></expr_stmt>


<decl_stmt><decl><type><name>LanguageKind</name></type> <name>Language</name></decl>;</decl_stmt>


<enum>enum <name>LambdaBodyIndentationKind</name> : <type><name>unsigned</name> <name>char</name></type> <block>{







<decl><name>LBI_Signature</name></decl>,








<decl><name>LBI_OuterScope</name></decl>,
}</block>;</enum>










<decl_stmt><decl><type><name>LambdaBodyIndentationKind</name></type> <name>LambdaBodyIndentation</name></decl>;</decl_stmt>



























<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>MacroBlockBegin</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>MacroBlockEnd</name></expr>;</expr_stmt>












<decl_stmt><decl><type><name>unsigned</name></type> <name>MaxEmptyLinesToKeep</name></decl>;</decl_stmt>


<enum>enum <name>NamespaceIndentationKind</name> : <type><name>unsigned</name> <name>char</name></type> <block>{









<decl><name>NI_None</name></decl>,









<decl><name>NI_Inner</name></decl>,









<decl><name>NI_All</name></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>NamespaceIndentationKind</name></type> <name>NamespaceIndentation</name></decl>;</decl_stmt>































<decl_stmt><decl><type><name>BinPackStyle</name></type> <name>ObjCBinPackProtocolList</name></decl>;</decl_stmt>









<decl_stmt><decl><type><name>unsigned</name></type> <name>ObjCBlockIndentWidth</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>ObjCSpaceAfterProperty</name></decl>;</decl_stmt>






















<decl_stmt><decl><type><name>bool</name></type> <name>ObjCBreakBeforeNestedBlockParam</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>ObjCSpaceBeforeProtocolList</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>PenaltyBreakAssignment</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>PenaltyBreakBeforeFirstCallParameter</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>PenaltyBreakComment</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>PenaltyBreakFirstLessLess</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>PenaltyBreakString</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>PenaltyBreakTemplateDeclaration</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>PenaltyExcessCharacter</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>PenaltyReturnTypeOnItsOwnLine</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>PenaltyIndentedWhitespace</name></decl>;</decl_stmt>


<enum>enum <name>PointerAlignmentStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{




<decl><name>PAS_Left</name></decl>,




<decl><name>PAS_Right</name></decl>,




<decl><name>PAS_Middle</name></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>PointerAlignmentStyle</name></type> <name>PointerAlignment</name></decl>;</decl_stmt>













<decl_stmt><decl><type><name>int</name></type> <name>PPIndentWidth</name></decl>;</decl_stmt>


<struct>struct <name>RawStringFormat</name> <block>{

<decl_stmt><decl><type><name>LanguageKind</name></type> <name>Language</name></decl>;</decl_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>Delimiters</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>EnclosingFunctions</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>CanonicalDelimiter</name></expr>;</expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>BasedOnStyle</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>RawStringFormat</name> <operator>&amp;</operator><name>Other</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>Language</name> <operator>==</operator> <name><name>Other</name><operator>.</operator><name>Language</name></name> <operator>&amp;&amp;</operator> <name>Delimiters</name> <operator>==</operator> <name><name>Other</name><operator>.</operator><name>Delimiters</name></name> <operator>&amp;&amp;</operator>
<name>EnclosingFunctions</name> <operator>==</operator> <name><name>Other</name><operator>.</operator><name>EnclosingFunctions</name></name> <operator>&amp;&amp;</operator>
<name>CanonicalDelimiter</name> <operator>==</operator> <name><name>Other</name><operator>.</operator><name>CanonicalDelimiter</name></name> <operator>&amp;&amp;</operator>
<name>BasedOnStyle</name> <operator>==</operator> <name><name>Other</name><operator>.</operator><name>BasedOnStyle</name></name></expr>;</return>
}</block></expr></expr_stmt>
}</block>;</struct>




































<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>RawStringFormat</name></expr></argument>&gt;</argument_list></name> <name>RawStringFormats</name></expr>;</expr_stmt>


<enum>enum <name>ReferenceAlignmentStyle</name> <block>{

<decl><name>RAS_Pointer</name></decl>,




<decl><name>RAS_Left</name></decl>,




<decl><name>RAS_Right</name></decl>,




<decl><name>RAS_Middle</name></decl>
}</block>;</enum>



<decl_stmt><decl><type><name>ReferenceAlignmentStyle</name></type> <name>ReferenceAlignment</name></decl>;</decl_stmt>














<decl_stmt><decl><type><name>bool</name></type> <name>ReflowComments</name></decl>;</decl_stmt>





















<decl_stmt><decl><type><name>unsigned</name></type> <name>ShortNamespaceLines</name></decl>;</decl_stmt>


<enum>enum <name>SortIncludesOptions</name> : <type><name>unsigned</name> <name>char</name></type> <block>{








<decl><name>SI_Never</name></decl>,








<decl><name>SI_CaseSensitive</name></decl>,








<decl><name>SI_CaseInsensitive</name></decl>,
}</block>;</enum>







<decl_stmt><decl><type><name>SortIncludesOptions</name></type> <name>SortIncludes</name></decl>;</decl_stmt>


<enum>enum <name>SortJavaStaticImportOptions</name> : <type><name>unsigned</name> <name>char</name></type> <block>{






<decl><name>SJSIO_Before</name></decl>,






<decl><name>SJSIO_After</name></decl>,
}</block>;</enum>




<decl_stmt><decl><type><name>SortJavaStaticImportOptions</name></type> <name>SortJavaStaticImport</name></decl>;</decl_stmt>















<decl_stmt><decl><type><name>bool</name></type> <name>SortUsingDeclarations</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>bool</name></type> <name>SpaceAfterCStyleCast</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>bool</name></type> <name>SpaceAfterLogicalNot</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>bool</name></type> <name>SpaceAfterTemplateKeyword</name></decl>;</decl_stmt>


<enum>enum <name>SpaceAroundPointerQualifiersStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{






<decl><name>SAPQ_Default</name></decl>,





<decl><name>SAPQ_Before</name></decl>,





<decl><name>SAPQ_After</name></decl>,





<decl><name>SAPQ_Both</name></decl>,
}</block>;</enum>


<decl_stmt><decl><type><name>SpaceAroundPointerQualifiersStyle</name></type> <name>SpaceAroundPointerQualifiers</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>bool</name></type> <name>SpaceBeforeAssignmentOperators</name></decl>;</decl_stmt>








<decl_stmt><decl><type><name>bool</name></type> <name>SpaceBeforeCaseColon</name></decl>;</decl_stmt>










<decl_stmt><decl><type><name>bool</name></type> <name>SpaceBeforeCpp11BracedList</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>bool</name></type> <name>SpaceBeforeCtorInitializerColon</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>bool</name></type> <name>SpaceBeforeInheritanceColon</name></decl>;</decl_stmt>


<enum>enum <name>SpaceBeforeParensOptions</name> : <type><name>unsigned</name> <name>char</name></type> <block>{








<decl><name>SBPO_Never</name></decl>,









<decl><name>SBPO_ControlStatements</name></decl>,












<decl><name>SBPO_ControlStatementsExceptControlMacros</name></decl>,










<decl><name>SBPO_NonEmptyParentheses</name></decl>,











<decl><name>SBPO_Always</name></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>SpaceBeforeParensOptions</name></type> <name>SpaceBeforeParens</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>bool</name></type> <name>SpaceBeforeRangeBasedForLoopColon</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>bool</name></type> <name>SpaceInEmptyBlock</name></decl>;</decl_stmt>











<decl_stmt><decl><type><name>bool</name></type> <name>SpaceInEmptyParentheses</name></decl>;</decl_stmt>















<decl_stmt><decl><type><name>unsigned</name></type> <name>SpacesBeforeTrailingComments</name></decl>;</decl_stmt>



<enum>enum <name>SpacesInAnglesStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{





<decl><name>SIAS_Never</name></decl>,





<decl><name>SIAS_Always</name></decl>,


<decl><name>SIAS_Leave</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><name>SpacesInAnglesStyle</name></type> <name>SpacesInAngles</name></decl>;</decl_stmt>








<decl_stmt><decl><type><name>bool</name></type> <name>SpacesInConditionalStatement</name></decl>;</decl_stmt>








<decl_stmt><decl><type><name>bool</name></type> <name>SpacesInContainerLiterals</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>bool</name></type> <name>SpacesInCStyleCastParentheses</name></decl>;</decl_stmt>


<struct>struct <name>SpacesInLineComment</name> <block>{

<decl_stmt><decl><type><name>unsigned</name></type> <name>Minimum</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>Maximum</name></decl>;</decl_stmt>
}</block>;</struct>




























<decl_stmt><decl><type><name>SpacesInLineComment</name></type> <name>SpacesInLineCommentPrefix</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>bool</name></type> <name>SpacesInParentheses</name></decl>;</decl_stmt>









<decl_stmt><decl><type><name>bool</name></type> <name>SpacesInSquareBrackets</name></decl>;</decl_stmt>








<decl_stmt><decl><type><name>bool</name></type> <name>SpaceBeforeSquareBrackets</name></decl>;</decl_stmt>


<enum>enum <name>BitFieldColonSpacingStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{




<decl><name>BFCS_Both</name></decl>,





<decl><name>BFCS_None</name></decl>,




<decl><name>BFCS_Before</name></decl>,





<decl><name>BFCS_After</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><name>BitFieldColonSpacingStyle</name></type> <name>BitFieldColonSpacing</name></decl>;</decl_stmt>









<enum>enum <name>LanguageStandard</name> : <type><name>unsigned</name> <name>char</name></type> <block>{


<decl><name>LS_Cpp03</name></decl>,

<decl><name>LS_Cpp11</name></decl>,

<decl><name>LS_Cpp14</name></decl>,

<decl><name>LS_Cpp17</name></decl>,

<decl><name>LS_Cpp20</name></decl>,


<decl><name>LS_Latest</name></decl>,

<decl><name>LS_Auto</name></decl>,
}</block>;</enum>






<decl_stmt><decl><type><name>LanguageStandard</name></type> <name>Standard</name></decl>;</decl_stmt>















<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>StatementAttributeLikeMacros</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>TabWidth</name></decl>;</decl_stmt>


<enum>enum <name>UseTabStyle</name> : <type><name>unsigned</name> <name>char</name></type> <block>{

<decl><name>UT_Never</name></decl>,

<decl><name>UT_ForIndentation</name></decl>,


<decl><name>UT_ForContinuationAndIndentation</name></decl>,


<decl><name>UT_AlignWithSpaces</name></decl>,


<decl><name>UT_Always</name></decl>
}</block>;</enum>



<decl_stmt><decl><type><name>bool</name></type> <name>UseCRLF</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>UseTabStyle</name></type> <name>UseTab</name></decl>;</decl_stmt>

<expr_stmt><expr><name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>FormatStyle</name> <operator>&amp;</operator><name>R</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>AccessModifierOffset</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>AccessModifierOffset</name></name> <operator>&amp;&amp;</operator>
<name>AlignAfterOpenBracket</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>AlignAfterOpenBracket</name></name> <operator>&amp;&amp;</operator>
<name>AlignArrayOfStructures</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>AlignArrayOfStructures</name></name> <operator>&amp;&amp;</operator>
<name>AlignConsecutiveAssignments</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>AlignConsecutiveAssignments</name></name> <operator>&amp;&amp;</operator>
<name>AlignConsecutiveBitFields</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>AlignConsecutiveBitFields</name></name> <operator>&amp;&amp;</operator>
<name>AlignConsecutiveDeclarations</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>AlignConsecutiveDeclarations</name></name> <operator>&amp;&amp;</operator>
<name>AlignConsecutiveMacros</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>AlignConsecutiveMacros</name></name> <operator>&amp;&amp;</operator>
<name>AlignEscapedNewlines</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>AlignEscapedNewlines</name></name> <operator>&amp;&amp;</operator>
<name>AlignOperands</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>AlignOperands</name></name> <operator>&amp;&amp;</operator>
<name>AlignTrailingComments</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>AlignTrailingComments</name></name> <operator>&amp;&amp;</operator>
<name>AllowAllArgumentsOnNextLine</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>AllowAllArgumentsOnNextLine</name></name> <operator>&amp;&amp;</operator>
<name>AllowAllConstructorInitializersOnNextLine</name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>AllowAllConstructorInitializersOnNextLine</name></name> <operator>&amp;&amp;</operator>
<name>AllowAllParametersOfDeclarationOnNextLine</name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>AllowAllParametersOfDeclarationOnNextLine</name></name> <operator>&amp;&amp;</operator>
<name>AllowShortEnumsOnASingleLine</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>AllowShortEnumsOnASingleLine</name></name> <operator>&amp;&amp;</operator>
<name>AllowShortBlocksOnASingleLine</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>AllowShortBlocksOnASingleLine</name></name> <operator>&amp;&amp;</operator>
<name>AllowShortCaseLabelsOnASingleLine</name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>AllowShortCaseLabelsOnASingleLine</name></name> <operator>&amp;&amp;</operator>
<name>AllowShortFunctionsOnASingleLine</name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>AllowShortFunctionsOnASingleLine</name></name> <operator>&amp;&amp;</operator>
<name>AllowShortIfStatementsOnASingleLine</name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>AllowShortIfStatementsOnASingleLine</name></name> <operator>&amp;&amp;</operator>
<name>AllowShortLambdasOnASingleLine</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>AllowShortLambdasOnASingleLine</name></name> <operator>&amp;&amp;</operator>
<name>AllowShortLoopsOnASingleLine</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>AllowShortLoopsOnASingleLine</name></name> <operator>&amp;&amp;</operator>
<name>AlwaysBreakAfterReturnType</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>AlwaysBreakAfterReturnType</name></name> <operator>&amp;&amp;</operator>
<name>AlwaysBreakBeforeMultilineStrings</name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>AlwaysBreakBeforeMultilineStrings</name></name> <operator>&amp;&amp;</operator>
<name>AlwaysBreakTemplateDeclarations</name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>AlwaysBreakTemplateDeclarations</name></name> <operator>&amp;&amp;</operator>
<name>AttributeMacros</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>AttributeMacros</name></name> <operator>&amp;&amp;</operator>
<name>BinPackArguments</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>BinPackArguments</name></name> <operator>&amp;&amp;</operator>
<name>BinPackParameters</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>BinPackParameters</name></name> <operator>&amp;&amp;</operator>
<name>BreakBeforeBinaryOperators</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>BreakBeforeBinaryOperators</name></name> <operator>&amp;&amp;</operator>
<name>BreakBeforeBraces</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>BreakBeforeBraces</name></name> <operator>&amp;&amp;</operator>
<name>BreakBeforeConceptDeclarations</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>BreakBeforeConceptDeclarations</name></name> <operator>&amp;&amp;</operator>
<name>BreakBeforeTernaryOperators</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>BreakBeforeTernaryOperators</name></name> <operator>&amp;&amp;</operator>
<name>BreakConstructorInitializers</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>BreakConstructorInitializers</name></name> <operator>&amp;&amp;</operator>
<name>CompactNamespaces</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>CompactNamespaces</name></name> <operator>&amp;&amp;</operator>
<name>BreakAfterJavaFieldAnnotations</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>BreakAfterJavaFieldAnnotations</name></name> <operator>&amp;&amp;</operator>
<name>BreakStringLiterals</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>BreakStringLiterals</name></name> <operator>&amp;&amp;</operator>
<name>ColumnLimit</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>ColumnLimit</name></name> <operator>&amp;&amp;</operator> <name>CommentPragmas</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>CommentPragmas</name></name> <operator>&amp;&amp;</operator>
<name>BreakInheritanceList</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>BreakInheritanceList</name></name> <operator>&amp;&amp;</operator>
<name>ConstructorInitializerAllOnOneLineOrOnePerLine</name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>ConstructorInitializerAllOnOneLineOrOnePerLine</name></name> <operator>&amp;&amp;</operator>
<name>ConstructorInitializerIndentWidth</name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>ConstructorInitializerIndentWidth</name></name> <operator>&amp;&amp;</operator>
<name>ContinuationIndentWidth</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>ContinuationIndentWidth</name></name> <operator>&amp;&amp;</operator>
<name>Cpp11BracedListStyle</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>Cpp11BracedListStyle</name></name> <operator>&amp;&amp;</operator>
<name>DeriveLineEnding</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>DeriveLineEnding</name></name> <operator>&amp;&amp;</operator>
<name>DerivePointerAlignment</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>DerivePointerAlignment</name></name> <operator>&amp;&amp;</operator>
<name>DisableFormat</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>DisableFormat</name></name> <operator>&amp;&amp;</operator>
<name>EmptyLineAfterAccessModifier</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>EmptyLineAfterAccessModifier</name></name> <operator>&amp;&amp;</operator>
<name>EmptyLineBeforeAccessModifier</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>EmptyLineBeforeAccessModifier</name></name> <operator>&amp;&amp;</operator>
<name>ExperimentalAutoDetectBinPacking</name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>ExperimentalAutoDetectBinPacking</name></name> <operator>&amp;&amp;</operator>
<name>FixNamespaceComments</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>FixNamespaceComments</name></name> <operator>&amp;&amp;</operator>
<name>ForEachMacros</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>ForEachMacros</name></name> <operator>&amp;&amp;</operator>
<name><name>IncludeStyle</name><operator>.</operator><name>IncludeBlocks</name></name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>IncludeStyle</name><operator>.</operator><name>IncludeBlocks</name></name> <operator>&amp;&amp;</operator>
<name><name>IncludeStyle</name><operator>.</operator><name>IncludeCategories</name></name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>IncludeStyle</name><operator>.</operator><name>IncludeCategories</name></name> <operator>&amp;&amp;</operator>
<name><name>IncludeStyle</name><operator>.</operator><name>IncludeIsMainRegex</name></name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>IncludeStyle</name><operator>.</operator><name>IncludeIsMainRegex</name></name> <operator>&amp;&amp;</operator>
<name><name>IncludeStyle</name><operator>.</operator><name>IncludeIsMainSourceRegex</name></name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>IncludeStyle</name><operator>.</operator><name>IncludeIsMainSourceRegex</name></name> <operator>&amp;&amp;</operator>
<name>IndentAccessModifiers</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>IndentAccessModifiers</name></name> <operator>&amp;&amp;</operator>
<name>IndentCaseLabels</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>IndentCaseLabels</name></name> <operator>&amp;&amp;</operator>
<name>IndentCaseBlocks</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>IndentCaseBlocks</name></name> <operator>&amp;&amp;</operator>
<name>IndentGotoLabels</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>IndentGotoLabels</name></name> <operator>&amp;&amp;</operator>
<name>IndentPPDirectives</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>IndentPPDirectives</name></name> <operator>&amp;&amp;</operator>
<name>IndentExternBlock</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>IndentExternBlock</name></name> <operator>&amp;&amp;</operator>
<name>IndentRequires</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>IndentRequires</name></name> <operator>&amp;&amp;</operator> <name>IndentWidth</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>IndentWidth</name></name> <operator>&amp;&amp;</operator>
<name>Language</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>Language</name></name> <operator>&amp;&amp;</operator>
<name>IndentWrappedFunctionNames</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>IndentWrappedFunctionNames</name></name> <operator>&amp;&amp;</operator>
<name>JavaImportGroups</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>JavaImportGroups</name></name> <operator>&amp;&amp;</operator>
<name>JavaScriptQuotes</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>JavaScriptQuotes</name></name> <operator>&amp;&amp;</operator>
<name>JavaScriptWrapImports</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>JavaScriptWrapImports</name></name> <operator>&amp;&amp;</operator>
<name>KeepEmptyLinesAtTheStartOfBlocks</name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>KeepEmptyLinesAtTheStartOfBlocks</name></name> <operator>&amp;&amp;</operator>
<name>LambdaBodyIndentation</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>LambdaBodyIndentation</name></name> <operator>&amp;&amp;</operator>
<name>MacroBlockBegin</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>MacroBlockBegin</name></name> <operator>&amp;&amp;</operator>
<name>MacroBlockEnd</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>MacroBlockEnd</name></name> <operator>&amp;&amp;</operator>
<name>MaxEmptyLinesToKeep</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>MaxEmptyLinesToKeep</name></name> <operator>&amp;&amp;</operator>
<name>NamespaceIndentation</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>NamespaceIndentation</name></name> <operator>&amp;&amp;</operator>
<name>NamespaceMacros</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>NamespaceMacros</name></name> <operator>&amp;&amp;</operator>
<name>ObjCBinPackProtocolList</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>ObjCBinPackProtocolList</name></name> <operator>&amp;&amp;</operator>
<name>ObjCBlockIndentWidth</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>ObjCBlockIndentWidth</name></name> <operator>&amp;&amp;</operator>
<name>ObjCBreakBeforeNestedBlockParam</name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>ObjCBreakBeforeNestedBlockParam</name></name> <operator>&amp;&amp;</operator>
<name>ObjCSpaceAfterProperty</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>ObjCSpaceAfterProperty</name></name> <operator>&amp;&amp;</operator>
<name>ObjCSpaceBeforeProtocolList</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>ObjCSpaceBeforeProtocolList</name></name> <operator>&amp;&amp;</operator>
<name>PenaltyBreakAssignment</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>PenaltyBreakAssignment</name></name> <operator>&amp;&amp;</operator>
<name>PenaltyBreakBeforeFirstCallParameter</name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>PenaltyBreakBeforeFirstCallParameter</name></name> <operator>&amp;&amp;</operator>
<name>PenaltyBreakComment</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>PenaltyBreakComment</name></name> <operator>&amp;&amp;</operator>
<name>PenaltyBreakFirstLessLess</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>PenaltyBreakFirstLessLess</name></name> <operator>&amp;&amp;</operator>
<name>PenaltyBreakString</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>PenaltyBreakString</name></name> <operator>&amp;&amp;</operator>
<name>PenaltyExcessCharacter</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>PenaltyExcessCharacter</name></name> <operator>&amp;&amp;</operator>
<name>PenaltyReturnTypeOnItsOwnLine</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>PenaltyReturnTypeOnItsOwnLine</name></name> <operator>&amp;&amp;</operator>
<name>PenaltyBreakTemplateDeclaration</name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>PenaltyBreakTemplateDeclaration</name></name> <operator>&amp;&amp;</operator>
<name>PointerAlignment</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>PointerAlignment</name></name> <operator>&amp;&amp;</operator>
<name>RawStringFormats</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>RawStringFormats</name></name> <operator>&amp;&amp;</operator>
<name>ReferenceAlignment</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>ReferenceAlignment</name></name> <operator>&amp;&amp;</operator>
<name>ShortNamespaceLines</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>ShortNamespaceLines</name></name> <operator>&amp;&amp;</operator>
<name>SortIncludes</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SortIncludes</name></name> <operator>&amp;&amp;</operator>
<name>SortJavaStaticImport</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SortJavaStaticImport</name></name> <operator>&amp;&amp;</operator>
<name>SpaceAfterCStyleCast</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpaceAfterCStyleCast</name></name> <operator>&amp;&amp;</operator>
<name>SpaceAfterLogicalNot</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpaceAfterLogicalNot</name></name> <operator>&amp;&amp;</operator>
<name>SpaceAfterTemplateKeyword</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpaceAfterTemplateKeyword</name></name> <operator>&amp;&amp;</operator>
<name>SpaceBeforeAssignmentOperators</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpaceBeforeAssignmentOperators</name></name> <operator>&amp;&amp;</operator>
<name>SpaceBeforeCaseColon</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpaceBeforeCaseColon</name></name> <operator>&amp;&amp;</operator>
<name>SpaceBeforeCpp11BracedList</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpaceBeforeCpp11BracedList</name></name> <operator>&amp;&amp;</operator>
<name>SpaceBeforeCtorInitializerColon</name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>SpaceBeforeCtorInitializerColon</name></name> <operator>&amp;&amp;</operator>
<name>SpaceBeforeInheritanceColon</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpaceBeforeInheritanceColon</name></name> <operator>&amp;&amp;</operator>
<name>SpaceBeforeParens</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpaceBeforeParens</name></name> <operator>&amp;&amp;</operator>
<name>SpaceAroundPointerQualifiers</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpaceAroundPointerQualifiers</name></name> <operator>&amp;&amp;</operator>
<name>SpaceBeforeRangeBasedForLoopColon</name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>SpaceBeforeRangeBasedForLoopColon</name></name> <operator>&amp;&amp;</operator>
<name>SpaceInEmptyBlock</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpaceInEmptyBlock</name></name> <operator>&amp;&amp;</operator>
<name>SpaceInEmptyParentheses</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpaceInEmptyParentheses</name></name> <operator>&amp;&amp;</operator>
<name>SpacesBeforeTrailingComments</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpacesBeforeTrailingComments</name></name> <operator>&amp;&amp;</operator>
<name>SpacesInAngles</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpacesInAngles</name></name> <operator>&amp;&amp;</operator>
<name>SpacesInConditionalStatement</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpacesInConditionalStatement</name></name> <operator>&amp;&amp;</operator>
<name>SpacesInContainerLiterals</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpacesInContainerLiterals</name></name> <operator>&amp;&amp;</operator>
<name>SpacesInCStyleCastParentheses</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpacesInCStyleCastParentheses</name></name> <operator>&amp;&amp;</operator>
<name><name>SpacesInLineCommentPrefix</name><operator>.</operator><name>Minimum</name></name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>SpacesInLineCommentPrefix</name><operator>.</operator><name>Minimum</name></name> <operator>&amp;&amp;</operator>
<name><name>SpacesInLineCommentPrefix</name><operator>.</operator><name>Maximum</name></name> <operator>==</operator>
<name><name>R</name><operator>.</operator><name>SpacesInLineCommentPrefix</name><operator>.</operator><name>Maximum</name></name> <operator>&amp;&amp;</operator>
<name>SpacesInParentheses</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpacesInParentheses</name></name> <operator>&amp;&amp;</operator>
<name>SpacesInSquareBrackets</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpacesInSquareBrackets</name></name> <operator>&amp;&amp;</operator>
<name>SpaceBeforeSquareBrackets</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>SpaceBeforeSquareBrackets</name></name> <operator>&amp;&amp;</operator>
<name>BitFieldColonSpacing</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>BitFieldColonSpacing</name></name> <operator>&amp;&amp;</operator>
<name>Standard</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>Standard</name></name> <operator>&amp;&amp;</operator>
<name>StatementAttributeLikeMacros</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>StatementAttributeLikeMacros</name></name> <operator>&amp;&amp;</operator>
<name>StatementMacros</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>StatementMacros</name></name> <operator>&amp;&amp;</operator> <name>TabWidth</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>TabWidth</name></name> <operator>&amp;&amp;</operator>
<name>UseTab</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>UseTab</name></name> <operator>&amp;&amp;</operator> <name>UseCRLF</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>UseCRLF</name></name> <operator>&amp;&amp;</operator>
<name>TypenameMacros</name> <operator>==</operator> <name><name>R</name><operator>.</operator><name>TypenameMacros</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>FormatStyle</name></expr></argument>&gt;</argument_list></name> <macro><name>GetLanguageStyle</name><argument_list>(<argument>LanguageKind Language</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>








<struct>struct <name>FormatStyleSet</name> <block>{
<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>FormatStyle</name><operator>::</operator><name>LanguageKind</name></expr></argument>, <argument><expr><name>FormatStyle</name></expr></argument>&gt;</argument_list></name> <name>MapType</name></expr>;</expr_stmt></typedef>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>FormatStyle</name></expr></argument>&gt;</argument_list></name> <macro><name>Get</name><argument_list>(<argument>FormatStyle::LanguageKind Language</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>






<function_decl><type><name>void</name></type> <name>Add</name><parameter_list>(<parameter><decl><type><name>FormatStyle</name></type> <name>Style</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>Clear</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>private</name>:</label>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MapType</name></expr></argument>&gt;</argument_list></name> <name>Styles</name></expr>;</expr_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>FormatStyleSet</name></type> <name>BuildStyleSetFromConfiguration</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>FormatStyle</name> <operator>&amp;</operator><name>MainStyle</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>FormatStyle</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>ConfigurationStyles</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>FormatStyleSet</name></type> <name>StyleSet</name></decl>;</decl_stmt>

<expr_stmt><expr><name>friend</name> <name>std</name><operator>::</operator><name>error_code</name>
<macro><name>parseConfiguration</name><argument_list>(<argument>llvm::MemoryBufferRef Config</argument>, <argument>FormatStyle *Style</argument>,
<argument>bool AllowUnknownOptions</argument>,
<argument>llvm::SourceMgr::DiagHandlerTy DiagHandler</argument>,
<argument>void *DiagHandlerCtxt</argument>)</argument_list></macro></expr>;</expr_stmt>
}</block>;</struct>



<decl_stmt><decl><type><name>FormatStyle</name></type> <name>getLLVMStyle</name><argument_list>(
<argument><expr><name>FormatStyle</name><operator>::</operator><name>LanguageKind</name> <name>Language</name> <operator>=</operator> <name>FormatStyle</name><operator>::</operator><name>LanguageKind</name><operator>::</operator><name>LK_Cpp</name></expr></argument>)</argument_list></decl>;</decl_stmt>





<decl_stmt><decl><type><name>FormatStyle</name></type> <name>getGoogleStyle</name><argument_list>(<argument><expr><name>FormatStyle</name><operator>::</operator><name>LanguageKind</name> <name>Language</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>FormatStyle</name></type> <name>getChromiumStyle</name><argument_list>(<argument><expr><name>FormatStyle</name><operator>::</operator><name>LanguageKind</name> <name>Language</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>FormatStyle</name></type> <name>getMozillaStyle</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>FormatStyle</name></type> <name>getWebKitStyle</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>FormatStyle</name></type> <name>getGNUStyle</name><parameter_list>()</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>FormatStyle</name></type> <name>getMicrosoftStyle</name><argument_list>(<argument><expr><name>FormatStyle</name><operator>::</operator><name>LanguageKind</name> <name>Language</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>FormatStyle</name></type> <name>getNoStyle</name><parameter_list>()</parameter_list>;</function_decl>







<decl_stmt><decl><type><name>bool</name></type> <name>getPredefinedStyle</name><argument_list>(<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>, <argument><expr><name>FormatStyle</name><operator>::</operator><name>LanguageKind</name> <name>Language</name></expr></argument>,
<argument><expr><name>FormatStyle</name> <operator>*</operator><name>Style</name></expr></argument>)</argument_list></decl>;</decl_stmt>















<expr_stmt><expr><name>std</name><operator>::</operator><name>error_code</name>
<macro><name>parseConfiguration</name><argument_list>(<argument>llvm::MemoryBufferRef Config</argument>, <argument>FormatStyle *Style</argument>,
<argument>bool AllowUnknownOptions = false</argument>,
<argument>llvm::SourceMgr::DiagHandlerTy DiagHandler = nullptr</argument>,
<argument>void *DiagHandlerCtx = nullptr</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><specifier>inline</specifier> <name>std</name><operator>::</operator><name>error_code</name> <macro><name>parseConfiguration</name><argument_list>(<argument>StringRef Config</argument>, <argument>FormatStyle *Style</argument>,
<argument>bool AllowUnknownOptions = false</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>parseConfiguration</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><call><name>MemoryBufferRef</name><argument_list>(<argument><expr><name>Config</name></expr></argument>, <argument><expr><literal type="string">"YAML"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Style</name></expr></argument>,
<argument><expr><name>AllowUnknownOptions</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <call><name>configurationAsText</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FormatStyle</name> <operator>&amp;</operator><name>Style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>tooling</name><operator>::</operator><name>Replacements</name> <macro><name>sortIncludes</name><argument_list>(<argument>const FormatStyle &amp;Style</argument>, <argument>StringRef Code</argument>,
<argument>ArrayRef&lt;tooling::Range&gt; Ranges</argument>,
<argument>StringRef FileName</argument>,
<argument>unsigned *Cursor = nullptr</argument>)</argument_list></macro></expr>;</expr_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Expected</name><argument_list type="generic">&lt;<argument><expr><name>tooling</name><operator>::</operator><name>Replacements</name></expr></argument>&gt;</argument_list></name>
<macro><name>formatReplacements</name><argument_list>(<argument>StringRef Code</argument>, <argument>const tooling::Replacements &amp;Replaces</argument>,
<argument>const FormatStyle &amp;Style</argument>)</argument_list></macro></expr>;</expr_stmt>














<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Expected</name><argument_list type="generic">&lt;<argument><expr><name>tooling</name><operator>::</operator><name>Replacements</name></expr></argument>&gt;</argument_list></name>
<macro><name>cleanupAroundReplacements</name><argument_list>(<argument>StringRef Code</argument>, <argument>const tooling::Replacements &amp;Replaces</argument>,
<argument>const FormatStyle &amp;Style</argument>)</argument_list></macro></expr>;</expr_stmt>


<struct>struct <name>FormattingAttemptStatus</name> <block>{


<decl_stmt><decl><type><name>bool</name></type> <name>FormatComplete</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>Line</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
}</block>;</struct>












<expr_stmt><expr><name>tooling</name><operator>::</operator><name>Replacements</name> <macro><name>reformat</name><argument_list>(<argument>const FormatStyle &amp;Style</argument>, <argument>StringRef Code</argument>,
<argument>ArrayRef&lt;tooling::Range&gt; Ranges</argument>,
<argument>StringRef FileName = <literal type="string">"&lt;stdin&gt;"</literal></argument>,
<argument>FormattingAttemptStatus *Status = nullptr</argument>)</argument_list></macro></expr>;</expr_stmt>




<expr_stmt><expr><name>tooling</name><operator>::</operator><name>Replacements</name> <macro><name>reformat</name><argument_list>(<argument>const FormatStyle &amp;Style</argument>, <argument>StringRef Code</argument>,
<argument>ArrayRef&lt;tooling::Range&gt; Ranges</argument>,
<argument>StringRef FileName</argument>, <argument>bool *IncompleteFormat</argument>)</argument_list></macro></expr>;</expr_stmt>





<expr_stmt><expr><name>tooling</name><operator>::</operator><name>Replacements</name> <macro><name>cleanup</name><argument_list>(<argument>const FormatStyle &amp;Style</argument>, <argument>StringRef Code</argument>,
<argument>ArrayRef&lt;tooling::Range&gt; Ranges</argument>,
<argument>StringRef FileName = <literal type="string">"&lt;stdin&gt;"</literal></argument>)</argument_list></macro></expr>;</expr_stmt>





<expr_stmt><expr><name>tooling</name><operator>::</operator><name>Replacements</name> <macro><name>fixNamespaceEndComments</name><argument_list>(<argument>const FormatStyle &amp;Style</argument>,
<argument>StringRef Code</argument>,
<argument>ArrayRef&lt;tooling::Range&gt; Ranges</argument>,
<argument>StringRef FileName = <literal type="string">"&lt;stdin&gt;"</literal></argument>)</argument_list></macro></expr>;</expr_stmt>






<expr_stmt><expr><name>tooling</name><operator>::</operator><name>Replacements</name> <macro><name>sortUsingDeclarations</name><argument_list>(<argument>const FormatStyle &amp;Style</argument>,
<argument>StringRef Code</argument>,
<argument>ArrayRef&lt;tooling::Range&gt; Ranges</argument>,
<argument>StringRef FileName = <literal type="string">"&lt;stdin&gt;"</literal></argument>)</argument_list></macro></expr>;</expr_stmt>




<function_decl><type><name>LangOptions</name></type> <name>getFormattingLangOpts</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FormatStyle</name> <modifier>&amp;</modifier></type><name>Style</name> <init>= <expr><call><name>getLLVMStyle</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>StyleOptionHelpDescription</name></decl>;</decl_stmt>




<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>DefaultFormatStyle</name></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>DefaultFallbackStyle</name></decl>;</decl_stmt>




























<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Expected</name><argument_list type="generic">&lt;<argument><expr><name>FormatStyle</name></expr></argument>&gt;</argument_list></name> <macro><name>getStyle</name><argument_list>(<argument>StringRef StyleName</argument>, <argument>StringRef FileName</argument>,
<argument>StringRef FallbackStyle</argument>,
<argument>StringRef Code = <literal type="string">""</literal></argument>,
<argument>llvm::vfs::FileSystem *FS = nullptr</argument>,
<argument>bool AllowUnknownOptions = false</argument>)</argument_list></macro></expr>;</expr_stmt>



<expr_stmt><expr><name>FormatStyle</name><operator>::</operator><name>LanguageKind</name> <macro><name>guessLanguage</name><argument_list>(<argument>StringRef FileName</argument>, <argument>StringRef Code</argument>)</argument_list></macro></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>inline</specifier> <name>StringRef</name></type> <name>getLanguageName</name><argument_list>(<argument><expr><name>FormatStyle</name><operator>::</operator><name>LanguageKind</name> <name>Language</name></expr></argument>)</argument_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>Language</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>FormatStyle</name><operator>::</operator><name>LK_Cpp</name></expr>:</case>
<return>return <expr><literal type="string">"C++"</literal></expr>;</return>
<case>case <expr><name>FormatStyle</name><operator>::</operator><name>LK_CSharp</name></expr>:</case>
<return>return <expr><literal type="string">"CSharp"</literal></expr>;</return>
<case>case <expr><name>FormatStyle</name><operator>::</operator><name>LK_ObjC</name></expr>:</case>
<return>return <expr><literal type="string">"Objective-C"</literal></expr>;</return>
<case>case <expr><name>FormatStyle</name><operator>::</operator><name>LK_Java</name></expr>:</case>
<return>return <expr><literal type="string">"Java"</literal></expr>;</return>
<case>case <expr><name>FormatStyle</name><operator>::</operator><name>LK_JavaScript</name></expr>:</case>
<return>return <expr><literal type="string">"JavaScript"</literal></expr>;</return>
<case>case <expr><name>FormatStyle</name><operator>::</operator><name>LK_Json</name></expr>:</case>
<return>return <expr><literal type="string">"Json"</literal></expr>;</return>
<case>case <expr><name>FormatStyle</name><operator>::</operator><name>LK_Proto</name></expr>:</case>
<return>return <expr><literal type="string">"Proto"</literal></expr>;</return>
<case>case <expr><name>FormatStyle</name><operator>::</operator><name>LK_TableGen</name></expr>:</case>
<return>return <expr><literal type="string">"TableGen"</literal></expr>;</return>
<case>case <expr><name>FormatStyle</name><operator>::</operator><name>LK_TextProto</name></expr>:</case>
<return>return <expr><literal type="string">"TextProto"</literal></expr>;</return>
<default>default:</default>
<return>return <expr><literal type="string">"Unknown"</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></decl></decl_stmt>

</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>std</name> <block>{<block_content>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
struct</type> <name><name>is_error_code_enum</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>format</name><operator>::</operator><name>ParseError</name></expr></argument>&gt;</argument_list></name> <range>: <expr><name>std</name><operator>::</operator><name>true_type</name> <block>{}</block></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
