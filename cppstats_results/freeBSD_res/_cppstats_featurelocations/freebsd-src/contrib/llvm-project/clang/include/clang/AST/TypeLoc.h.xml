<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/TypeLoc.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_TYPELOC_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_TYPELOC_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclarationName.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/NestedNameSpecifier.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TemplateBase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Specifiers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/MathExtras.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;algorithm&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstring&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>Attr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXRecordDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ConceptDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCInterfaceDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCProtocolDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCTypeParamDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ParmVarDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateTypeParmDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UnqualTypeLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UnresolvedUsingTypenameDecl</name></decl>;</decl_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_TYPELOC</name><parameter_list>(<parameter><type><name>Class</name></type></parameter>, <parameter><type><name>Base</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPELOC</name><parameter_list>(<parameter><type><name>Class</name></type></parameter>, <parameter><type><name>Base</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>class Class##TypeLoc;</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeLocNodes.def"</cpp:file></cpp:include>





<decl_stmt><decl><type><name>class</name></type> <name>TypeLoc</name> <block>{<block_content>
<label><name>protected</name>:</label>


<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>Ty</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>Data</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>TypeLoc</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<macro><name>TypeLoc</name><argument_list>(<argument>QualType ty</argument>, <argument>void *opaqueData</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Ty</name><argument_list>(<argument><expr><call><name><name>ty</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Data</name><argument_list>(<argument>opaqueData</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>TypeLoc</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>ty</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>opaqueData</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Ty</name><argument_list>(<argument><expr><name>ty</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Data</name><argument_list>(<argument>opaqueData</argument>)</argument_list></macro> <expr><block>{}</block>





<name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>T</name> <macro><name>castAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>T</name><operator>::</operator><call><name>isKind</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>T</name> <name>t</name></expr>;
<expr><name>TypeLoc</name><operator>&amp;</operator> <name>tl</name> <operator>=</operator> <name>t</name></expr>;
<expr><name>tl</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;
<return>return <expr><name>t</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>T</name> <macro><name>getAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>T</name><operator>::</operator><call><name>isKind</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><block>{}</block></expr>;</return></block_content></block></if></if_stmt>
<name>T</name> <name>t</name></block></expr>;</expr_stmt>
<decl_stmt><decl><type><name>TypeLoc</name><modifier>&amp;</modifier></type> <name>tl</name> <init>= <expr><name>t</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>tl</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;</expr_stmt>
<return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>T</name> <macro><name>getAsAdjusted</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<enum>enum <name>TypeLocClass</name> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_TYPE</name><parameter_list>(<parameter><type><name>Class</name></type></parameter>, <parameter><type><name>Base</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPE</name><parameter_list>(<parameter><type><name>Class</name></type></parameter>, <parameter><type><name>Base</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Class = Type::Class,</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeNodes.inc"</cpp:file></cpp:include>
<decl><name>Qualified</name></decl>
}</block>;</enum>

<expr_stmt><expr><name>TypeLocClass</name> <macro><name>getTypeLocClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasLocalQualifiers</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qualified</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><operator>(</operator><name>TypeLocClass</name><operator>)</operator> <call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTypeClass</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isNull</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><name>Ty</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>explicit</name> <name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Ty</name></expr>;</return> }</block></expr></expr_stmt>


<function_decl><type><specifier>static</specifier> <name>unsigned</name></type> <name>getFullDataSizeForType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><specifier>static</specifier> <name>unsigned</name></type> <name>getLocalAlignmentForType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>QualType</name><operator>::</operator><call><name>getFromOpaquePtr</name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><macro><name>getTypePtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>QualType</name><operator>::</operator><call><name>getFromOpaquePtr</name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>void</name> <operator>*</operator><macro><name>getOpaqueData</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Data</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalSourceRangeImpl</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getFullDataSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getFullDataSizeForType</name><argument_list>(<argument><expr><call><name>getType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>TypeLoc</name> <macro><name>getNextTypeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNextTypeLocImpl</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>UnqualTypeLoc</name> <macro><name>getUnqualifiedLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>TypeLoc</name> <macro><name>IgnoreParens</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>







<expr_stmt><expr><name>TypeLoc</name> <macro><name>findExplicitQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>AutoTypeLoc</name> <macro><name>getContainedAutoTypeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>






<decl_stmt><decl><type><name>void</name></type> <name>initialize</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>initializeImpl</name><argument_list>(<argument><expr><name>Context</name></expr></argument>, <argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>



<function><type><name>void</name></type> <name>initializeFullCopy</name><parameter_list>(<parameter><decl><type><name>TypeLoc</name></type> <name>Other</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getType</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>Other</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy</name><argument_list>(<argument><expr><name>Other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>initializeFullCopy</name><parameter_list>(<parameter><decl><type><name>TypeLoc</name></type> <name>Other</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getType</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>Other</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getFullDataSize</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy</name><argument_list>(<argument><expr><name>Other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>copy</name><parameter_list>(<parameter><decl><type><name>TypeLoc</name></type> <name>other</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>TypeLoc</name> <operator>&amp;</operator><name>LHS</name><operator>,</operator> <specifier>const</specifier> <name>TypeLoc</name> <operator>&amp;</operator><name>RHS</name><operator>)</operator> <block>{
<return>return <expr><name><name>LHS</name><operator>.</operator><name>Ty</name></name> <operator>==</operator> <name><name>RHS</name><operator>.</operator><name>Ty</name></name> <operator>&amp;&amp;</operator> <name><name>LHS</name><operator>.</operator><name>Data</name></name> <operator>==</operator> <name><name>RHS</name><operator>.</operator><name>Data</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>TypeLoc</name> <operator>&amp;</operator><name>LHS</name><operator>,</operator> <specifier>const</specifier> <name>TypeLoc</name> <operator>&amp;</operator><name>RHS</name><operator>)</operator> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><name>LHS</name> <operator>==</operator> <name>RHS</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>SourceLocation</name> <macro><name>findNullabilityLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<label><name>private</name>:</label>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>isKind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TypeLoc</name><modifier>&amp;</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initializeImpl</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name>TypeLoc</name></type> <name>TL</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TypeLoc</name></type> <name>getNextTypeLocImpl</name><parameter_list>(<parameter><decl><type><name>TypeLoc</name></type> <name>TL</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TypeLoc</name></type> <name>IgnoreParensImpl</name><parameter_list>(<parameter><decl><type><name>TypeLoc</name></type> <name>TL</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SourceRange</name></type> <name>getLocalSourceRangeImpl</name><parameter_list>(<parameter><decl><type><name>TypeLoc</name></type> <name>TL</name></decl></parameter>)</parameter_list>;</function_decl>
};


<expr_stmt><expr><specifier>inline</specifier> <name>TypeLoc</name> <name>TypeSourceInfo</name><operator>::</operator><macro><name>getTypeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{

<return>return <expr><call><name>TypeLoc</name><argument_list>(<argument><expr><name>Ty</name></expr></argument>, <argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>UnqualTypeLoc</name> <range>: <expr><name>public</name> <name>TypeLoc</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>UnqualTypeLoc</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><call><name>UnqualTypeLoc</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>Data</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>TypeLoc</name><argument_list>(<argument>Ty</argument>, <argument>Data</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>Type</name> <operator>*</operator><macro><name>getTypePtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Type</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>TypeLocClass</name> <macro><name>getTypeLocClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>TypeLocClass</name><operator>)</operator> <call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTypeClass</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>TypeLoc</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const TypeLoc &amp;TL</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>!</operator><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasLocalQualifiers</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;






<expr><name>class</name> <name>QualifiedTypeLoc</name> <operator>:</operator> <name>public</name> <name>TypeLoc</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><block>{}</block></expr>;</return> }</block>

<name>UnqualTypeLoc</name> <macro><name>getUnqualifiedLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>unsigned</name> <name>align</name> <operator>=</operator>
<name>TypeLoc</name><operator>::</operator><call><name>getLocalAlignmentForType</name><argument_list>(<argument><expr><call><name>QualType</name><argument_list>(<argument><expr><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>dataInt</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>uintptr_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Data</name></expr></argument>)</argument_list></call></expr>;
<expr><name>dataInt</name> <operator>=</operator> <name>llvm</name><operator>::</operator><call><name>alignTo</name><argument_list>(<argument><expr><name>dataInt</name></expr></argument>, <argument><expr><name>align</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>UnqualTypeLoc</name><argument_list>(<argument><expr><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>dataInt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{

}</block>

<name>void</name> <macro><name>copyLocal</name><argument_list>(<argument>TypeLoc other</argument>)</argument_list></macro> <block>{

}</block>

<name>TypeLoc</name> <macro><name>getNextTypeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getUnqualifiedLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>unsigned</name> <macro><name>getLocalDataSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{


<return>return <expr><literal type="number">0</literal></expr>;</return>
}</block>



<name>unsigned</name> <macro><name>getLocalDataAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{

<return>return <expr><literal type="number">1</literal></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>TypeLoc</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const TypeLoc &amp;TL</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasLocalQualifiers</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><specifier>inline</specifier> <name>UnqualTypeLoc</name> <name>TypeLoc</name><operator>::</operator><macro><name>getUnqualifiedLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><name>QualifiedTypeLoc</name></type> <name>Loc</name> <init>= <expr><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>QualifiedTypeLoc</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Loc</name><operator>.</operator><name>getUnqualifiedLoc</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>castAs</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>





























<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Base</name></expr></argument>, <argument><expr><name>class</name> <name>Derived</name></expr></argument>, <argument><expr><name>class</name> <name>TypeClass</name></expr></argument>, <argument><expr><name>class</name> <name>LocalData</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>ConcreteTypeLoc</name> <operator>:</operator> <name>public</name> <name>Base</name> <block>{
<expr><name>friend</name> <name>class</name> <name>TypeLoc</name></expr>;

<expr><specifier>const</specifier> <name>Derived</name> <operator>*</operator><macro><name>asDerived</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Derived</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const TypeLoc &amp;TL</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>!</operator><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasLocalQualifiers</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>Derived</name><operator>::</operator><call><name>classofType</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classofType</name><argument_list>(<argument>const Type *Ty</argument>)</argument_list></macro> <block>{
<return>return <expr><name>TypeClass</name><operator>::</operator><call><name>classof</name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>unsigned</name> <macro><name>getLocalDataAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>std</name><operator>::</operator><call><name>max</name><argument_list>(<argument><expr><call><name>unsigned</name><argument_list>(<argument><expr><call><name>alignof</name><argument_list>(<argument><expr><name>LocalData</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>asDerived</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getExtraLocalDataAlignment</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getLocalDataSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>unsigned</name> <name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LocalData</name></expr></argument>)</argument_list></sizeof></expr>;
<expr><name>unsigned</name> <name>extraAlign</name> <operator>=</operator> <call><name>asDerived</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getExtraLocalDataAlignment</name><argument_list>()</argument_list></call></expr>;
<expr><name>size</name> <operator>=</operator> <name>llvm</name><operator>::</operator><call><name>alignTo</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>extraAlign</name></expr></argument>)</argument_list></call></expr>;
<expr><name>size</name> <operator>+=</operator> <call><name>asDerived</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getExtraLocalDataSize</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>size</name></expr>;</return>
}</block>

<name>void</name> <macro><name>copyLocal</name><argument_list>(<argument>Derived other</argument>)</argument_list></macro> <block>{

<if_stmt><if>if <condition>(<expr><call><name>asDerived</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getLocalDataSize</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>


<call><name>memcpy</name><argument_list>(<argument><expr><call><name>getLocalData</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>other</name><operator>.</operator><name>getLocalData</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LocalData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></block></expr>;




<expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>getExtraLocalData</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>other</name><operator>.</operator><name>getExtraLocalData</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>asDerived</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getExtraLocalDataSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>TypeLoc</name> <macro><name>getNextTypeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNextTypeLoc</name><argument_list>(<argument><expr><call><name>asDerived</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getInnerType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>TypeClass</name> <operator>*</operator><macro><name>getTypePtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>TypeClass</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Base</name><operator>::</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>protected</name><operator>:</operator>
<name>unsigned</name> <macro><name>getExtraLocalDataSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><literal type="number">0</literal></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getExtraLocalDataAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><literal type="number">1</literal></expr>;</return>
}</block>

<name>LocalData</name> <operator>*</operator><macro><name>getLocalData</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>LocalData</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Base</name><operator>::</operator><name>Data</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>void</name> <operator>*</operator><macro><name>getExtraLocalData</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>unsigned</name> <name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LocalData</name></expr></argument>)</argument_list></sizeof></expr>;
<expr><name>unsigned</name> <name>extraAlign</name> <operator>=</operator> <call><name>asDerived</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getExtraLocalDataAlignment</name><argument_list>()</argument_list></call></expr>;
<expr><name>size</name> <operator>=</operator> <name>llvm</name><operator>::</operator><call><name>alignTo</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>extraAlign</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>char</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Base</name><operator>::</operator><name>Data</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>size</name></expr>;</return>
}</block>

<name>void</name> <operator>*</operator><macro><name>getNonLocalData</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>data</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>uintptr_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Base</name><operator>::</operator><name>Data</name></expr></argument>)</argument_list></call></expr>;
<expr><name>data</name> <operator>+=</operator> <call><name>asDerived</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getLocalDataSize</name><argument_list>()</argument_list></call></expr>;
<expr><name>data</name> <operator>=</operator> <name>llvm</name><operator>::</operator><call><name>alignTo</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>getNextTypeAlign</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

struct <name>HasNoInnerType</name> <block>{}</block></expr>;
<expr><name>HasNoInnerType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>HasNoInnerType</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>TypeLoc</name> <macro><name>getInnerTypeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>TypeLoc</name><argument_list>(<argument><expr><call><name>asDerived</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getInnerType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNonLocalData</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>unsigned</name> <macro><name>getInnerTypeSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getInnerTypeSize</name><argument_list>(<argument><expr><call><name>asDerived</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getInnerType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getInnerTypeSize</name><argument_list>(<argument>HasNoInnerType _</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><literal type="number">0</literal></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getInnerTypeSize</name><argument_list>(<argument>QualType _</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getInnerTypeLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getFullDataSize</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNextTypeAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNextTypeAlign</name><argument_list>(<argument><expr><call><name>asDerived</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getInnerType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNextTypeAlign</name><argument_list>(<argument>HasNoInnerType _</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><literal type="number">1</literal></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNextTypeAlign</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TypeLoc</name><operator>::</operator><call><name>getLocalAlignmentForType</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>TypeLoc</name> <macro><name>getNextTypeLoc</name><argument_list>(<argument>HasNoInnerType _</argument>)</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><block>{}</block></expr>;</return> }</block>

<name>TypeLoc</name> <macro><name>getNextTypeLoc</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>TypeLoc</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><call><name>getNonLocalData</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;




<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Base</name></expr></argument>, <argument><expr><name>class</name> <name>Derived</name></expr></argument>, <argument><expr><name>class</name> <name>TypeClass</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>InheritingConcreteTypeLoc</name> <operator>:</operator> <name>public</name> <name>Base</name> <block>{
<expr><name>friend</name> <name>class</name> <name>TypeLoc</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classofType</name><argument_list>(<argument>const Type *Ty</argument>)</argument_list></macro> <block>{
<return>return <expr><name>TypeClass</name><operator>::</operator><call><name>classof</name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const TypeLoc &amp;TL</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>!</operator><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasLocalQualifiers</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>Derived</name><operator>::</operator><call><name>classofType</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const UnqualTypeLoc &amp;TL</argument>)</argument_list></macro> <block>{
<return>return <expr><name>Derived</name><operator>::</operator><call><name>classofType</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>TypeClass</name> <operator>*</operator><macro><name>getTypePtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>TypeClass</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Base</name><operator>::</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

struct <expr><name>TypeSpecLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>NameLoc</name></expr>;
}</block></expr>;



<expr><name>class</name> <name>TypeSpecTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>,
<argument><expr><name>TypeSpecTypeLoc</name></expr></argument>,
<argument><expr><name>Type</name></expr></argument>,
<argument><expr><name>TypeSpecLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
enum <block>{
<expr><name>LocalDataSize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TypeSpecLocInfo</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><name>LocalDataAlignment</name> <operator>=</operator> <macro><name>alignof</name><argument_list>(<argument>TypeSpecLocInfo</argument>)</argument_list></macro></expr>
}</block></expr>;

<expr><name>SourceLocation</name> <macro><name>getNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setNameLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getNameLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNameLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setNameLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>TypeLoc</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <call><name>isKind</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TypeLoc</name> <operator>&amp;</operator><name>TL</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;

struct <expr><name>BuiltinLocInfo</name> <block>{
<expr><name>SourceRange</name> <name>BuiltinRange</name></expr>;
}</block></expr>;


<expr><name>class</name> <name>BuiltinTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>,
<argument><expr><name>BuiltinTypeLoc</name></expr></argument>,
<argument><expr><name>BuiltinType</name></expr></argument>,
<argument><expr><name>BuiltinLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getBuiltinLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>BuiltinRange</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setBuiltinLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>BuiltinRange</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>void</name> <macro><name>expandBuiltinRange</name><argument_list>(<argument>SourceRange Range</argument>)</argument_list></macro> <block>{
<expr><name>SourceRange</name> <operator>&amp;</operator><name>BuiltinRange</name> <operator>=</operator> <call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>BuiltinRange</name></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>BuiltinRange</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>BuiltinRange</name> <operator>=</operator> <name>Range</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content> else <block>{<block_content>
<expr_stmt><expr><call><name><name>BuiltinRange</name><operator>.</operator><name>setBegin</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>min</name><argument_list>(<argument><expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>BuiltinRange</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>BuiltinRange</name><operator>.</operator><name>setEnd</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>max</name><argument_list>(<argument><expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>BuiltinRange</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}

SourceLocation getNameLoc(</block></block></if></if_stmt>) <specifier>const</specifier> <block>{ <return>return <expr><call><name>getBuiltinLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block></block>

<name>WrittenBuiltinSpecs</name><operator>&amp;</operator> <macro><name>getWrittenBuiltinSpecs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><operator>*</operator><operator>(</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>WrittenBuiltinSpecs</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getExtraLocalData</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block>
<specifier>const</specifier> <name>WrittenBuiltinSpecs</name><operator>&amp;</operator> <macro><name>getWrittenBuiltinSpecs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>*</operator><operator>(</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>WrittenBuiltinSpecs</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getExtraLocalData</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block>

<name>bool</name> <macro><name>needsExtraLocalData</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>BuiltinType</name><operator>::</operator><name>Kind</name> <name>bk</name> <operator>=</operator> <call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getKind</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><operator>(</operator><name>bk</name> <operator>&gt;=</operator> <name>BuiltinType</name><operator>::</operator><name>UShort</name> <operator>&amp;&amp;</operator> <name>bk</name> <operator>&lt;=</operator> <name>BuiltinType</name><operator>::</operator><name>UInt128</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name>bk</name> <operator>&gt;=</operator> <name>BuiltinType</name><operator>::</operator><name>Short</name> <operator>&amp;&amp;</operator> <name>bk</name> <operator>&lt;=</operator> <name>BuiltinType</name><operator>::</operator><name>Float128</name><operator>)</operator>
<operator>||</operator> <name>bk</name> <operator>==</operator> <name>BuiltinType</name><operator>::</operator><name>UChar</name>
<operator>||</operator> <name>bk</name> <operator>==</operator> <name>BuiltinType</name><operator>::</operator><name>SChar</name></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getExtraLocalDataSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>needsExtraLocalData</name><argument_list>()</argument_list></call> <operator>?</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WrittenBuiltinSpecs</name></expr></argument>)</argument_list></sizeof> <operator>:</operator> <literal type="number">0</literal></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getExtraLocalDataAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>needsExtraLocalData</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>alignof</name><argument_list>(<argument><expr><name>WrittenBuiltinSpecs</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>BuiltinRange</name></expr>;</return>
}</block>

<name>TypeSpecifierSign</name> <macro><name>getWrittenSignSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>needsExtraLocalData</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TypeSpecifierSign</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getWrittenBuiltinSpecs</name><argument_list>()</argument_list></call><operator>.</operator><name>Sign</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>TypeSpecifierSign</name><operator>::</operator><name>Unspecified</name></expr>;</return></block_content></block></else></if_stmt>
}</block>

<name>bool</name> <macro><name>hasWrittenSignSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getWrittenSignSpec</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>TypeSpecifierSign</name><operator>::</operator><name>Unspecified</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setWrittenSignSpec</name><argument_list>(<argument>TypeSpecifierSign written</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>needsExtraLocalData</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>getWrittenBuiltinSpecs</name><argument_list>()</argument_list></call><operator>.</operator><name>Sign</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<name>TypeSpecifierWidth</name> <macro><name>getWrittenWidthSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>needsExtraLocalData</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TypeSpecifierWidth</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getWrittenBuiltinSpecs</name><argument_list>()</argument_list></call><operator>.</operator><name>Width</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>TypeSpecifierWidth</name><operator>::</operator><name>Unspecified</name></expr>;</return></block_content></block></else></if_stmt>
}</block>

<name>bool</name> <macro><name>hasWrittenWidthSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getWrittenWidthSpec</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>TypeSpecifierWidth</name><operator>::</operator><name>Unspecified</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setWrittenWidthSpec</name><argument_list>(<argument>TypeSpecifierWidth written</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>needsExtraLocalData</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>getWrittenBuiltinSpecs</name><argument_list>()</argument_list></call><operator>.</operator><name>Width</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<name>TypeSpecifierType</name> <macro><name>getWrittenTypeSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>hasWrittenTypeSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getWrittenTypeSpec</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>TST_unspecified</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setWrittenTypeSpec</name><argument_list>(<argument>TypeSpecifierType written</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>needsExtraLocalData</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>getWrittenBuiltinSpecs</name><argument_list>()</argument_list></call><operator>.</operator><name>Type</name> <operator>=</operator> <name>written</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<name>bool</name> <macro><name>hasModeAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>needsExtraLocalData</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getWrittenBuiltinSpecs</name><argument_list>()</argument_list></call><operator>.</operator><name>ModeAttr</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
}</block>

<name>void</name> <macro><name>setModeAttr</name><argument_list>(<argument>bool written</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>needsExtraLocalData</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>getWrittenBuiltinSpecs</name><argument_list>()</argument_list></call><operator>.</operator><name>ModeAttr</name> <operator>=</operator> <name>written</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setBuiltinLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name>needsExtraLocalData</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>WrittenBuiltinSpecs</name> <modifier>&amp;</modifier></type><name>wbs</name> <init>= <expr><call><name>getWrittenBuiltinSpecs</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>wbs</name><operator>.</operator><name>Sign</name></name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TypeSpecifierSign</name><operator>::</operator><name>Unspecified</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>wbs</name><operator>.</operator><name>Width</name></name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TypeSpecifierWidth</name><operator>::</operator><name>Unspecified</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>wbs</name><operator>.</operator><name>Type</name></name> <operator>=</operator> <name>TST_unspecified</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>wbs</name><operator>.</operator><name>ModeAttr</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}
}</block><empty_stmt>;</empty_stmt></if></if_stmt>


<name>class</name> <name>TypedefTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>TypeSpecTypeLoc</name></expr></argument>,
<argument><expr><name>TypedefTypeLoc</name></expr></argument>,
<argument><expr><name>TypedefType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>TypedefNameDecl</name> <operator>*</operator><macro><name>getTypedefNameDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>InjectedClassNameTypeLoc</name> <operator>:</operator>
<name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>TypeSpecTypeLoc</name></expr></argument>,
<argument><expr><name>InjectedClassNameTypeLoc</name></expr></argument>,
<argument><expr><name>InjectedClassNameType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>CXXRecordDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>UnresolvedUsingTypeLoc</name> <operator>:</operator>
<name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>TypeSpecTypeLoc</name></expr></argument>,
<argument><expr><name>UnresolvedUsingTypeLoc</name></expr></argument>,
<argument><expr><name>UnresolvedUsingType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>UnresolvedUsingTypenameDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;






<expr><name>class</name> <name>TagTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>TypeSpecTypeLoc</name></expr></argument>,
<argument><expr><name>TagTypeLoc</name></expr></argument>,
<argument><expr><name>TagType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>TagDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getDecl</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>bool</name> <macro><name>isDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr>;


<expr><name>class</name> <name>RecordTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>TagTypeLoc</name></expr></argument>,
<argument><expr><name>RecordTypeLoc</name></expr></argument>,
<argument><expr><name>RecordType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>RecordDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getDecl</name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;


<expr><name>class</name> <name>EnumTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>TagTypeLoc</name></expr></argument>,
<argument><expr><name>EnumTypeLoc</name></expr></argument>,
<argument><expr><name>EnumType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>EnumDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getDecl</name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;


<expr><name>class</name> <name>TemplateTypeParmTypeLoc</name> <operator>:</operator>
<name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>TypeSpecTypeLoc</name></expr></argument>,
<argument><expr><name>TemplateTypeParmTypeLoc</name></expr></argument>,
<argument><expr><name>TemplateTypeParmType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>TemplateTypeParmDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getDecl</name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;

struct <expr><name>ObjCTypeParamTypeLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>NameLoc</name></expr>;
}</block></expr>;



<expr><name>class</name> <name>ObjCTypeParamTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>,
<argument><expr><name>ObjCTypeParamTypeLoc</name></expr></argument>,
<argument><expr><name>ObjCTypeParamType</name></expr></argument>,
<argument><expr><name>ObjCTypeParamTypeLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{

<expr><name>SourceLocation</name> <operator>*</operator><macro><name>getProtocolLocArray</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>SourceLocation</name><operator>*</operator><operator>)</operator><call><name><name>this</name><operator>-&gt;</operator><name>getExtraLocalData</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>ObjCTypeParamDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getDecl</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setNameLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getProtocolLAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNumProtocols</name><argument_list>()</argument_list></call> <operator>?</operator>
<operator>*</operator><operator>(</operator><operator>(</operator><name>SourceLocation</name><operator>*</operator><operator>)</operator><call><name><name>this</name><operator>-&gt;</operator><name>getExtraLocalData</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>:</operator>
<call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setProtocolLAngleLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>SourceLocation</name><operator>*</operator><operator>)</operator><call><name><name>this</name><operator>-&gt;</operator><name>getExtraLocalData</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getProtocolRAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>getNumProtocols</name><argument_list>()</argument_list></call></expr> ?</condition><then>
<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>SourceLocation</name><operator>*</operator><operator>)</operator><call><name><name>this</name><operator>-&gt;</operator><name>getExtraLocalData</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>:
<expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>

<name>void</name> <macro><name>setProtocolRAngleLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>SourceLocation</name><operator>*</operator><operator>)</operator><call><name><name>this</name><operator>-&gt;</operator><name>getExtraLocalData</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>unsigned</name> <macro><name>getNumProtocols</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNumProtocols</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getProtocolLoc</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getNumProtocols</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Index is out of bounds!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getProtocolLocArray</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</return>
}</block>

<name>void</name> <macro><name>setProtocolLoc</name><argument_list>(<argument>unsigned i</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getNumProtocols</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Index is out of bounds!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getProtocolLocArray</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>ObjCProtocolDecl</name> <operator>*</operator><macro><name>getProtocol</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getNumProtocols</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Index is out of bounds!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><operator>(</operator><call><name><name>this</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>qual_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <name>i</name><operator>)</operator></expr>;</return>
}</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <macro><name>getProtocolLocs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getProtocolLocArray</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNumProtocols</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;

<expr><name>unsigned</name> <macro><name>getExtraLocalDataSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>this</name><operator>-&gt;</operator><name>getNumProtocols</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block></expr>


<return>return <expr><operator>(</operator><call><name><name>this</name><operator>-&gt;</operator><name>getNumProtocols</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SourceLocation</name></expr></argument>)</argument_list></sizeof></expr> ;</return>
}</block>

<name>unsigned</name> <macro><name>getExtraLocalDataAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>alignof</name><argument_list>(<argument><expr><name>SourceLocation</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>SourceLocation</name> <name>start</name> <operator>=</operator> <call><name>getNameLoc</name><argument_list>()</argument_list></call></expr>;
<expr><name>SourceLocation</name> <name>end</name> <operator>=</operator> <call><name>getProtocolRAngleLoc</name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>end</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>SubstTemplateTypeParmTypeLoc</name> <operator>:</operator>
<name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>TypeSpecTypeLoc</name></expr></argument>,
<argument><expr><name>SubstTemplateTypeParmTypeLoc</name></expr></argument>,
<argument><expr><name>SubstTemplateTypeParmType</name></expr></argument>&gt;</argument_list></name> <block>{
}</block></expr>;


<expr><name>class</name> <name>SubstTemplateTypeParmPackTypeLoc</name> <operator>:</operator>
<name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>TypeSpecTypeLoc</name></expr></argument>,
<argument><expr><name>SubstTemplateTypeParmPackTypeLoc</name></expr></argument>,
<argument><expr><name>SubstTemplateTypeParmPackType</name></expr></argument>&gt;</argument_list></name> <block>{
}</block></expr>;

struct <expr><name>AttributedLocInfo</name> <block>{
<expr><specifier>const</specifier> <name>Attr</name> <operator>*</operator><name>TypeAttr</name></expr>;
}</block></expr>;


<expr><name>class</name> <name>AttributedTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>,
<argument><expr><name>AttributedTypeLoc</name></expr></argument>,
<argument><expr><name>AttributedType</name></expr></argument>,
<argument><expr><name>AttributedLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>attr</name><operator>::</operator><name>Kind</name> <macro><name>getAttrKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getAttrKind</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isQualifier</name><argument_list>()</argument_list></call></expr>;</return>
}</block>





<name>TypeLoc</name> <macro><name>getModifiedLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getInnerTypeLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<specifier>const</specifier> <name>Attr</name> <operator>*</operator><macro><name>getAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TypeAttr</name></expr>;</return>
}</block>
<name>void</name> <macro><name>setAttr</name><argument_list>(<argument>const Attr *A</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TypeAttr</name> <operator>=</operator> <name>A</name></expr>;
}</block>

<name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier> <name>T</name> <operator>*</operator><macro><name>getAttrAs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getAttr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setAttr</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>QualType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getModifiedType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;

struct <expr><name>ObjCObjectTypeLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>TypeArgsLAngleLoc</name></expr>;
<expr><name>SourceLocation</name> <name>TypeArgsRAngleLoc</name></expr>;
<expr><name>SourceLocation</name> <name>ProtocolLAngleLoc</name></expr>;
<expr><name>SourceLocation</name> <name>ProtocolRAngleLoc</name></expr>;
<expr><name>bool</name> <name>HasBaseTypeAsWritten</name></expr>;
}</block></expr>;






<expr><name>class</name> <name>ObjCObjectTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>,
<argument><expr><name>ObjCObjectTypeLoc</name></expr></argument>,
<argument><expr><name>ObjCObjectType</name></expr></argument>,
<argument><expr><name>ObjCObjectTypeLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{

<expr><name>TypeSourceInfo</name> <operator>*</operator><operator>*</operator><macro><name>getTypeArgLocArray</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>TypeSourceInfo</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name><name>this</name><operator>-&gt;</operator><name>getExtraLocalData</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>SourceLocation</name> <operator>*</operator><macro><name>getProtocolLocArray</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>SourceLocation</name><operator>*</operator><operator>)</operator><operator>(</operator><call><name>getTypeArgLocArray</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumTypeArgs</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getTypeArgsLAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TypeArgsLAngleLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setTypeArgsLAngleLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TypeArgsLAngleLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getTypeArgsRAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TypeArgsRAngleLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setTypeArgsRAngleLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TypeArgsRAngleLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>unsigned</name> <macro><name>getNumTypeArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTypeArgsAsWritten</name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeArgTInfo</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getNumTypeArgs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Index is out of bounds!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getTypeArgLocArray</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</return>
}</block>

<name>void</name> <macro><name>setTypeArgTInfo</name><argument_list>(<argument>unsigned i</argument>, <argument>TypeSourceInfo *TInfo</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getNumTypeArgs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Index is out of bounds!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getTypeArgLocArray</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name>TInfo</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getProtocolLAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ProtocolLAngleLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setProtocolLAngleLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ProtocolLAngleLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getProtocolRAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ProtocolRAngleLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setProtocolRAngleLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ProtocolRAngleLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>unsigned</name> <macro><name>getNumProtocols</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNumProtocols</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getProtocolLoc</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getNumProtocols</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Index is out of bounds!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getProtocolLocArray</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</return>
}</block>

<name>void</name> <macro><name>setProtocolLoc</name><argument_list>(<argument>unsigned i</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getNumProtocols</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Index is out of bounds!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getProtocolLocArray</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>ObjCProtocolDecl</name> <operator>*</operator><macro><name>getProtocol</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getNumProtocols</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Index is out of bounds!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><operator>(</operator><call><name><name>this</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>qual_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <name>i</name><operator>)</operator></expr>;</return>
}</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <macro><name>getProtocolLocs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getProtocolLocArray</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNumProtocols</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasBaseTypeAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>HasBaseTypeAsWritten</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setHasBaseTypeAsWritten</name><argument_list>(<argument>bool HasBaseType</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>HasBaseTypeAsWritten</name> <operator>=</operator> <name>HasBaseType</name></expr>;
}</block>

<name>TypeLoc</name> <macro><name>getBaseLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getInnerTypeLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>SourceLocation</name> <name>start</name> <operator>=</operator> <call><name>getTypeArgsLAngleLoc</name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>start</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>getProtocolLAngleLoc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<name>SourceLocation</name> <name>end</name> <operator>=</operator> <call><name>getProtocolRAngleLoc</name><argument_list>()</argument_list></call></block></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>end</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>getTypeArgsRAngleLoc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;

<expr><name>unsigned</name> <macro><name>getExtraLocalDataSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getNumTypeArgs</name></name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof>
<operator>+</operator> <call><name><name>this</name><operator>-&gt;</operator><name>getNumProtocols</name></name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SourceLocation</name></expr></argument>)</argument_list></sizeof></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getExtraLocalDataAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><call><name>alignof</name><argument_list>(<argument><expr><name>ObjCObjectTypeLoc</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>alignof</name><argument_list>(<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="string">"not enough alignment for tail-allocated data"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>alignof</name><argument_list>(<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>QualType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBaseType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;

struct <expr><name>ObjCInterfaceLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>NameLoc</name></expr>;
<expr><name>SourceLocation</name> <name>NameEndLoc</name></expr>;
}</block></expr>;


<expr><name>class</name> <name>ObjCInterfaceTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectTypeLoc</name></expr></argument>,
<argument><expr><name>ObjCInterfaceTypeLoc</name></expr></argument>,
<argument><expr><name>ObjCInterfaceType</name></expr></argument>,
<argument><expr><name>ObjCInterfaceLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getIFaceDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setNameLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getNameLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNameEndLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getNameEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameEndLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setNameEndLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameEndLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setNameLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setNameEndLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;

struct <expr><name>MacroQualifiedLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>ExpansionLoc</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>MacroQualifiedTypeLoc</name>
<operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>, <argument><expr><name>MacroQualifiedTypeLoc</name></expr></argument>,
<argument><expr><name>MacroQualifiedType</name></expr></argument>, <argument><expr><name>MacroQualifiedLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setExpansionLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>TypeLoc</name> <macro><name>getInnerLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getInnerTypeLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><macro><name>getMacroIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getMacroIdentifier</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getExpansionLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ExpansionLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setExpansionLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ExpansionLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>QualType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getUnderlyingType</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getInnerLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLocalSourceRange</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;

struct <expr><name>ParenLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;
<expr><name>SourceLocation</name> <name>RParenLoc</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>ParenTypeLoc</name>
<operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>, <argument><expr><name>ParenTypeLoc</name></expr></argument>, <argument><expr><name>ParenType</name></expr></argument>,
<argument><expr><name>ParenLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LParenLoc</name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RParenLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RParenLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getLParenLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRParenLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setLParenLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setRParenLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>TypeLoc</name> <macro><name>getInnerLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getInnerTypeLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>QualType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getInnerType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><specifier>inline</specifier> <name>TypeLoc</name> <name>TypeLoc</name><operator>::</operator><macro><name>IgnoreParens</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>ParenTypeLoc</name><operator>::</operator><call><name>isKind</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>IgnoreParensImpl</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block>

struct <name>AdjustedLocInfo</name> <block>{}</block></expr>;

<expr><name>class</name> <name>AdjustedTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>, <argument><expr><name>AdjustedTypeLoc</name></expr></argument>,
<argument><expr><name>AdjustedType</name></expr></argument>, <argument><expr><name>AdjustedLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>TypeLoc</name> <macro><name>getOriginalLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getInnerTypeLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{

}</block>

<name>QualType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{


<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getOriginalType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><block>{}</block></expr>;</return> }</block>

<name>unsigned</name> <macro><name>getLocalDataSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{


<return>return <expr><literal type="number">0</literal></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>DecayedTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;
<argument><expr><name>AdjustedTypeLoc</name></expr></argument>, <argument><expr><name>DecayedTypeLoc</name></expr></argument>, <argument><expr><name>DecayedType</name></expr></argument>&gt;</argument_list></name> <block>{
}</block></expr>;

struct <expr><name>PointerLikeLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>StarLoc</name></expr>;
}</block></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Derived</name></expr></argument>, <argument><expr><name>class</name> <name>TypeClass</name></expr></argument>, <argument><expr><name>class</name> <name>LocalData</name> <operator>=</operator> <name>PointerLikeLocInfo</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>PointerLikeTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>, <argument><expr><name>Derived</name></expr></argument>,
<argument><expr><name>TypeClass</name></expr></argument>, <argument><expr><name>LocalData</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getSigilLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>StarLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setSigilLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>StarLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>TypeLoc</name> <macro><name>getPointeeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getInnerTypeLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getSigilLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getSigilLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setSigilLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>QualType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getPointeeType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>PointerTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>PointerLikeTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>PointerTypeLoc</name></expr></argument>,
<argument><expr><name>PointerType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getStarLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getSigilLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setStarLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setSigilLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;


<expr><name>class</name> <name>BlockPointerTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>PointerLikeTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>BlockPointerTypeLoc</name></expr></argument>,
<argument><expr><name>BlockPointerType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getCaretLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getSigilLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setCaretLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setSigilLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;

struct <expr><name>MemberPointerLocInfo</name> <operator>:</operator> <name>public</name> <name>PointerLikeLocInfo</name> <block>{
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>ClassTInfo</name></expr>;
}</block></expr>;


<expr><name>class</name> <name>MemberPointerTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>PointerLikeTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>MemberPointerTypeLoc</name></expr></argument>,
<argument><expr><name>MemberPointerType</name></expr></argument>,
<argument><expr><name>MemberPointerLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getStarLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getSigilLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setStarLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setSigilLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>const</specifier> <name>Type</name> <operator>*</operator><macro><name>getClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getClass</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getClassTInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ClassTInfo</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setClassTInfo</name><argument_list>(<argument>TypeSourceInfo* TI</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ClassTInfo</name> <operator>=</operator> <name>TI</name></expr>;
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setSigilLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setClassTInfo</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TI</name> <init>= <expr><call><name>getClassTInfo</name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name><name>TI</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getStarLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getStarLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block>
}</expr>;


<expr><name>class</name> <name>ObjCObjectPointerTypeLoc</name> <operator>:</operator>
<name>public</name> <name><name>PointerLikeTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectPointerTypeLoc</name></expr></argument>,
<argument><expr><name>ObjCObjectPointerType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getStarLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getSigilLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setStarLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setSigilLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;

<expr><name>class</name> <name>ReferenceTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>PointerLikeTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>ReferenceTypeLoc</name></expr></argument>,
<argument><expr><name>ReferenceType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getPointeeTypeAsWritten</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>LValueReferenceTypeLoc</name> <operator>:</operator>
<name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>ReferenceTypeLoc</name></expr></argument>,
<argument><expr><name>LValueReferenceTypeLoc</name></expr></argument>,
<argument><expr><name>LValueReferenceType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getAmpLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getSigilLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setAmpLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setSigilLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;

<expr><name>class</name> <name>RValueReferenceTypeLoc</name> <operator>:</operator>
<name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>ReferenceTypeLoc</name></expr></argument>,
<argument><expr><name>RValueReferenceTypeLoc</name></expr></argument>,
<argument><expr><name>RValueReferenceType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getAmpAmpLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getSigilLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setAmpAmpLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setSigilLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;

struct <expr><name>FunctionLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>LocalRangeBegin</name></expr>;
<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;
<expr><name>SourceLocation</name> <name>RParenLoc</name></expr>;
<expr><name>SourceLocation</name> <name>LocalRangeEnd</name></expr>;
}</block></expr>;


<expr><name>class</name> <name>FunctionTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>,
<argument><expr><name>FunctionTypeLoc</name></expr></argument>,
<argument><expr><name>FunctionType</name></expr></argument>,
<argument><expr><name>FunctionLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>bool</name> <macro><name>hasExceptionSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>FPT</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name><name>FPT</name><operator>-&gt;</operator><name>hasExceptionSpec</name></name><argument_list>()</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>
return false</block><empty_stmt>;</empty_stmt></if></if_stmt>
}</block>

<name>SourceRange</name> <operator>*</operator><macro><name>getExceptionSpecRangePtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasExceptionSpec</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"No exception spec range"</literal></expr></argument>)</argument_list></call></expr>;


<return>return <expr><operator>(</operator><name>SourceRange</name> <operator>*</operator><operator>)</operator><operator>(</operator><call><name>getParmArray</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumParams</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getLocalRangeBegin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LocalRangeBegin</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setLocalRangeBegin</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LocalRangeBegin</name> <operator>=</operator> <name>L</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getLocalRangeEnd</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LocalRangeEnd</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setLocalRangeEnd</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LocalRangeEnd</name> <operator>=</operator> <name>L</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LParenLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RParenLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RParenLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceRange</name> <macro><name>getParensRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getLParenLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRParenLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getExceptionSpecRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasExceptionSpec</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>*</operator><call><name>getExceptionSpecRangePtr</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><block>{}</block></expr>;</return>
}</block>

<name>void</name> <macro><name>setExceptionSpecRange</name><argument_list>(<argument>SourceRange R</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasExceptionSpec</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><call><name>getExceptionSpecRangePtr</name><argument_list>()</argument_list></call> <operator>=</operator> <name>R</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getParams</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getParmArray</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNumParams</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>ParmVarDecl</name> <operator>*</operator><operator>*</operator><macro><name>getParmArray</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>ParmVarDecl</name><operator>*</operator><operator>*</operator><operator>)</operator> <call><name>getExtraLocalData</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumParams</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>FunctionNoProtoType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getNumParams</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ParmVarDecl</name> <operator>*</operator><macro><name>getParam</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getParmArray</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</return> }</block>
<name>void</name> <macro><name>setParam</name><argument_list>(<argument>unsigned i</argument>, <argument>ParmVarDecl *VD</argument>)</argument_list></macro> <block>{ <expr><call><name>getParmArray</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name>VD</name></expr>; }</block>

<name>TypeLoc</name> <macro><name>getReturnLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getInnerTypeLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getLocalRangeBegin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getLocalRangeEnd</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setLocalRangeBegin</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setLParenLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setRParenLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setLocalRangeEnd</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>e</name> <init>= <expr><call><name>getNumParams</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>e</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setParam</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block></expr>
<if_stmt><if>if <condition>(<expr><call><name>hasExceptionSpec</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setExceptionSpecRange</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>



<name>unsigned</name> <macro><name>getExtraLocalDataSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>unsigned</name> <name>ExceptSpecSize</name> <operator>=</operator> <call><name>hasExceptionSpec</name><argument_list>()</argument_list></call> <operator>?</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SourceRange</name></expr></argument>)</argument_list></sizeof> <operator>:</operator> <literal type="number">0</literal></expr>;
<return>return <expr><operator>(</operator><call><name>getNumParams</name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>+</operator> <name>ExceptSpecSize</name></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getExtraLocalDataAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>alignof</name><argument_list>(<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>QualType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getReturnType</name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;

<expr><name>class</name> <name>FunctionProtoTypeLoc</name> <operator>:</operator>
<name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTypeLoc</name></expr></argument>,
<argument><expr><name>FunctionProtoTypeLoc</name></expr></argument>,
<argument><expr><name>FunctionProtoType</name></expr></argument>&gt;</argument_list></name> <block>{
}</block></expr>;

<expr><name>class</name> <name>FunctionNoProtoTypeLoc</name> <operator>:</operator>
<name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTypeLoc</name></expr></argument>,
<argument><expr><name>FunctionNoProtoTypeLoc</name></expr></argument>,
<argument><expr><name>FunctionNoProtoType</name></expr></argument>&gt;</argument_list></name> <block>{
}</block></expr>;

struct <expr><name>ArrayLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>LBracketLoc</name></expr>, <expr><name>RBracketLoc</name></expr>;
<expr><name>Expr</name> <operator>*</operator><name>Size</name></expr>;
}</block></expr>;


<expr><name>class</name> <name>ArrayTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>,
<argument><expr><name>ArrayTypeLoc</name></expr></argument>,
<argument><expr><name>ArrayType</name></expr></argument>,
<argument><expr><name>ArrayLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getLBracketLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LBracketLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setLBracketLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LBracketLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getRBracketLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RBracketLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setRBracketLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RBracketLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceRange</name> <macro><name>getBracketsRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getLBracketLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRBracketLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getSizeExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>Size</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setSizeExpr</name><argument_list>(<argument>Expr *Size</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>Size</name> <operator>=</operator> <name>Size</name></expr>;
}</block>

<name>TypeLoc</name> <macro><name>getElementLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getInnerTypeLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getLBracketLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRBracketLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setLBracketLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setRBracketLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setSizeExpr</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>QualType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getElementType</name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;

<expr><name>class</name> <name>ConstantArrayTypeLoc</name> <operator>:</operator>
<name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>ArrayTypeLoc</name></expr></argument>,
<argument><expr><name>ConstantArrayTypeLoc</name></expr></argument>,
<argument><expr><name>ConstantArrayType</name></expr></argument>&gt;</argument_list></name> <block>{
}</block></expr>;

<expr><name>class</name> <name>IncompleteArrayTypeLoc</name> <operator>:</operator>
<name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>ArrayTypeLoc</name></expr></argument>,
<argument><expr><name>IncompleteArrayTypeLoc</name></expr></argument>,
<argument><expr><name>IncompleteArrayType</name></expr></argument>&gt;</argument_list></name> <block>{
}</block></expr>;

<expr><name>class</name> <name>DependentSizedArrayTypeLoc</name> <operator>:</operator>
<name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>ArrayTypeLoc</name></expr></argument>,
<argument><expr><name>DependentSizedArrayTypeLoc</name></expr></argument>,
<argument><expr><name>DependentSizedArrayType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><name>ArrayTypeLoc</name><operator>::</operator><call><name>initializeLocal</name><argument_list>(<argument><expr><name>Context</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setSizeExpr</name><argument_list>(<argument><expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getSizeExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block></expr>
}</block></expr>;

<expr><name>class</name> <name>VariableArrayTypeLoc</name> <operator>:</operator>
<name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>ArrayTypeLoc</name></expr></argument>,
<argument><expr><name>VariableArrayTypeLoc</name></expr></argument>,
<argument><expr><name>VariableArrayType</name></expr></argument>&gt;</argument_list></name> <block>{
}</block></expr>;


struct <expr><name>TemplateNameLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>NameLoc</name></expr>;
}</block></expr>;

struct <expr><name>TemplateSpecializationLocInfo</name> <operator>:</operator> <name>TemplateNameLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>TemplateKWLoc</name></expr>;
<expr><name>SourceLocation</name> <name>LAngleLoc</name></expr>;
<expr><name>SourceLocation</name> <name>RAngleLoc</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>TemplateSpecializationTypeLoc</name> <operator>:</operator>
<name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>,
<argument><expr><name>TemplateSpecializationTypeLoc</name></expr></argument>,
<argument><expr><name>TemplateSpecializationType</name></expr></argument>,
<argument><expr><name>TemplateSpecializationLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TemplateKWLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setTemplateKeywordLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TemplateKWLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getLAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LAngleLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setLAngleLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LAngleLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getRAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RAngleLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setRAngleLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RAngleLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNumArgs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setArgLocInfo</name><argument_list>(<argument>unsigned i</argument>, <argument>TemplateArgumentLocInfo AI</argument>)</argument_list></macro> <block>{
<expr><call><name>getArgInfos</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name>AI</name></expr>;
}</block>

<name>TemplateArgumentLocInfo</name> <macro><name>getArgLocInfo</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getArgInfos</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</return>
}</block>

<name>TemplateArgumentLoc</name> <macro><name>getArgLoc</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>TemplateArgumentLoc</name><argument_list>(<argument><expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getArg</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getArgLocInfo</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getTemplateNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setTemplateNameLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>


<name>void</name> <macro><name>copy</name><argument_list>(<argument>TemplateSpecializationTypeLoc Loc</argument>)</argument_list></macro> <block>{
<expr><name>unsigned</name> <name>size</name> <operator>=</operator> <call><name>getFullDataSize</name><argument_list>()</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>==</operator> <call><name><name>Loc</name><operator>.</operator><name>getFullDataSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;





<expr><call><name>memcpy</name><argument_list>(<argument><expr><name>Data</name></expr></argument>, <argument><expr><name><name>Loc</name><operator>.</operator><name>Data</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRAngleLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getTemplateNameLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRAngleLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setTemplateKeywordLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setTemplateNameLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setLAngleLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setRAngleLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>initializeArgLocs</name><argument_list>(<argument><expr><name>Context</name></expr></argument>, <argument><expr><call><name>getNumArgs</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getArgs</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getArgInfos</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>initializeArgLocs</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>unsigned NumArgs</argument>,
<argument>const TemplateArgument *Args</argument>,
<argument>TemplateArgumentLocInfo *ArgInfos</argument>,
<argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;

<expr><name>unsigned</name> <macro><name>getExtraLocalDataSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TemplateArgumentLocInfo</name></expr></argument>)</argument_list></sizeof></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getExtraLocalDataAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>alignof</name><argument_list>(<argument><expr><name>TemplateArgumentLocInfo</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>TemplateArgumentLocInfo</name> <operator>*</operator><macro><name>getArgInfos</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLocInfo</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getExtraLocalData</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

struct <expr><name>DependentAddressSpaceLocInfo</name> <block>{
<expr><name>Expr</name> <operator>*</operator><name>ExprOperand</name></expr>;
<expr><name>SourceRange</name> <name>OperandParens</name></expr>;
<expr><name>SourceLocation</name> <name>AttrLoc</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>DependentAddressSpaceTypeLoc</name>
<operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>,
<argument><expr><name>DependentAddressSpaceTypeLoc</name></expr></argument>,
<argument><expr><name>DependentAddressSpaceType</name></expr></argument>,
<argument><expr><name>DependentAddressSpaceLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>



<name>SourceLocation</name> <macro><name>getAttrNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>AttrLoc</name></expr>;</return>
}</block>
<name>void</name> <macro><name>setAttrNameLoc</name><argument_list>(<argument>SourceLocation loc</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>AttrLoc</name> <operator>=</operator> <name>loc</name></expr>;
}</block>




<name>Expr</name> <operator>*</operator><macro><name>getAttrExprOperand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ExprOperand</name></expr>;</return>
}</block>
<name>void</name> <macro><name>setAttrExprOperand</name><argument_list>(<argument>Expr *e</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ExprOperand</name> <operator>=</operator> <name>e</name></expr>;
}</block>





<name>SourceRange</name> <macro><name>getAttrOperandParensRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>OperandParens</name></expr>;</return>
}</block>
<name>void</name> <macro><name>setAttrOperandParensRange</name><argument_list>(<argument>SourceRange range</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>OperandParens</name> <operator>=</operator> <name>range</name></expr>;
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>SourceRange</name> <call><name>range</name><argument_list>(<argument><expr><call><name>getAttrNameLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>range</name><operator>.</operator><name>setEnd</name></name><argument_list>(<argument><expr><call><name>getAttrOperandParensRange</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getEnd</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>range</name></expr>;</return>
}</block>





<name>QualType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getPointeeType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>TypeLoc</name> <macro><name>getPointeeTypeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getInnerTypeLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setAttrNameLoc</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setAttrOperandParensRange</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setAttrOperandParensRange</name><argument_list>(<argument><expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setAttrExprOperand</name><argument_list>(<argument><expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getAddrSpaceExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;









struct <expr><name>VectorTypeLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>NameLoc</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>VectorTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>, <argument><expr><name>VectorTypeLoc</name></expr></argument>,
<argument><expr><name>VectorType</name></expr></argument>, <argument><expr><name>VectorTypeLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameLoc</name></expr>;</return> }</block>

<name>void</name> <macro><name>setNameLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getNameLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNameLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setNameLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>TypeLoc</name> <macro><name>getElementLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getInnerTypeLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>QualType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getElementType</name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;



<expr><name>class</name> <name>DependentVectorTypeLoc</name>
<operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>, <argument><expr><name>DependentVectorTypeLoc</name></expr></argument>,
<argument><expr><name>DependentVectorType</name></expr></argument>, <argument><expr><name>VectorTypeLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameLoc</name></expr>;</return> }</block>

<name>void</name> <macro><name>setNameLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getNameLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNameLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setNameLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>TypeLoc</name> <macro><name>getElementLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getInnerTypeLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>QualType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getElementType</name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;


<expr><name>class</name> <name>ExtVectorTypeLoc</name>
<operator>:</operator> <name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>VectorTypeLoc</name></expr></argument>, <argument><expr><name>ExtVectorTypeLoc</name></expr></argument>,
<argument><expr><name>ExtVectorType</name></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;



<expr><name>class</name> <name>DependentSizedExtVectorTypeLoc</name>
<operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>, <argument><expr><name>DependentSizedExtVectorTypeLoc</name></expr></argument>,
<argument><expr><name>DependentSizedExtVectorType</name></expr></argument>, <argument><expr><name>VectorTypeLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameLoc</name></expr>;</return> }</block>

<name>void</name> <macro><name>setNameLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getNameLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNameLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setNameLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>TypeLoc</name> <macro><name>getElementLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getInnerTypeLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>QualType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getElementType</name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;

struct <expr><name>MatrixTypeLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>AttrLoc</name></expr>;
<expr><name>SourceRange</name> <name>OperandParens</name></expr>;
<expr><name>Expr</name> <operator>*</operator><name>RowOperand</name></expr>;
<expr><name>Expr</name> <operator>*</operator><name>ColumnOperand</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>MatrixTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>, <argument><expr><name>MatrixTypeLoc</name></expr></argument>,
<argument><expr><name>MatrixType</name></expr></argument>, <argument><expr><name>MatrixTypeLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>



<name>SourceLocation</name> <macro><name>getAttrNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>AttrLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setAttrNameLoc</name><argument_list>(<argument>SourceLocation loc</argument>)</argument_list></macro> <block>{ <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>AttrLoc</name> <operator>=</operator> <name>loc</name></expr>; }</block>




<name>Expr</name> <operator>*</operator><macro><name>getAttrRowOperand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RowOperand</name></expr>;</return> }</block>
<name>void</name> <macro><name>setAttrRowOperand</name><argument_list>(<argument>Expr *e</argument>)</argument_list></macro> <block>{ <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RowOperand</name> <operator>=</operator> <name>e</name></expr>; }</block>




<name>Expr</name> <operator>*</operator><macro><name>getAttrColumnOperand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ColumnOperand</name></expr>;</return> }</block>
<name>void</name> <macro><name>setAttrColumnOperand</name><argument_list>(<argument>Expr *e</argument>)</argument_list></macro> <block>{ <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ColumnOperand</name> <operator>=</operator> <name>e</name></expr>; }</block>





<name>SourceRange</name> <macro><name>getAttrOperandParensRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>OperandParens</name></expr>;</return>
}</block>
<name>void</name> <macro><name>setAttrOperandParensRange</name><argument_list>(<argument>SourceRange range</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>OperandParens</name> <operator>=</operator> <name>range</name></expr>;
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>SourceRange</name> <call><name>range</name><argument_list>(<argument><expr><call><name>getAttrNameLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>range</name><operator>.</operator><name>setEnd</name></name><argument_list>(<argument><expr><call><name>getAttrOperandParensRange</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getEnd</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>range</name></expr>;</return>
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setAttrNameLoc</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setAttrOperandParensRange</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setAttrRowOperand</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setAttrColumnOperand</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;

<expr><name>class</name> <name>ConstantMatrixTypeLoc</name>
<operator>:</operator> <name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>MatrixTypeLoc</name></expr></argument>, <argument><expr><name>ConstantMatrixTypeLoc</name></expr></argument>,
<argument><expr><name>ConstantMatrixType</name></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;

<expr><name>class</name> <name>DependentSizedMatrixTypeLoc</name>
<operator>:</operator> <name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>MatrixTypeLoc</name></expr></argument>,
<argument><expr><name>DependentSizedMatrixTypeLoc</name></expr></argument>,
<argument><expr><name>DependentSizedMatrixType</name></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;


<expr><name>class</name> <name>ComplexTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>TypeSpecTypeLoc</name></expr></argument>,
<argument><expr><name>ComplexTypeLoc</name></expr></argument>,
<argument><expr><name>ComplexType</name></expr></argument>&gt;</argument_list></name> <block>{
}</block></expr>;

struct <expr><name>TypeofLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>TypeofLoc</name></expr>;
<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;
<expr><name>SourceLocation</name> <name>RParenLoc</name></expr>;
}</block></expr>;

struct <expr><name>TypeOfExprTypeLocInfo</name> <operator>:</operator> <name>public</name> <name>TypeofLocInfo</name> <block>{
}</block></expr>;

struct <expr><name>TypeOfTypeLocInfo</name> <operator>:</operator> <name>public</name> <name>TypeofLocInfo</name> <block>{
<expr><name>TypeSourceInfo</name><operator>*</operator> <name>UnderlyingTInfo</name></expr>;
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Derived</name></expr></argument>, <argument><expr><name>class</name> <name>TypeClass</name></expr></argument>, <argument><expr><name>class</name> <name>LocalData</name> <operator>=</operator> <name>TypeofLocInfo</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>TypeofLikeTypeLoc</name>
<operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>, <argument><expr><name>Derived</name></expr></argument>, <argument><expr><name>TypeClass</name></expr></argument>, <argument><expr><name>LocalData</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getTypeofLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TypeofLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setTypeofLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TypeofLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LParenLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RParenLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RParenLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceRange</name> <macro><name>getParensRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getLParenLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRParenLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setParensRange</name><argument_list>(<argument>SourceRange range</argument>)</argument_list></macro> <block>{
<expr><call><name>setLParenLoc</name><argument_list>(<argument><expr><call><name><name>range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setRParenLoc</name><argument_list>(<argument><expr><call><name><name>range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getTypeofLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRParenLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setTypeofLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setLParenLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setRParenLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;

<expr><name>class</name> <name>TypeOfExprTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>TypeofLikeTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>TypeOfExprTypeLoc</name></expr></argument>,
<argument><expr><name>TypeOfExprType</name></expr></argument>,
<argument><expr><name>TypeOfExprTypeLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>Expr</name><operator>*</operator> <macro><name>getUnderlyingExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getUnderlyingExpr</name><argument_list>()</argument_list></call></expr>;</return>
}</block>




<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr>;

<expr><name>class</name> <name>TypeOfTypeLoc</name>
<operator>:</operator> <name>public</name> <name><name>TypeofLikeTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>TypeOfTypeLoc</name></expr></argument>, <argument><expr><name>TypeOfType</name></expr></argument>, <argument><expr><name>TypeOfTypeLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getUnderlyingType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getUnderlyingType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>TypeSourceInfo</name><operator>*</operator> <macro><name>getUnderlyingTInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>UnderlyingTInfo</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setUnderlyingTInfo</name><argument_list>(<argument>TypeSourceInfo* TI</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>UnderlyingTInfo</name> <operator>=</operator> <name>TI</name></expr>;
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;
}</block></expr>;


<expr><name>class</name> <name>DecltypeTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>TypeSpecTypeLoc</name></expr></argument>,
<argument><expr><name>DecltypeTypeLoc</name></expr></argument>,
<argument><expr><name>DecltypeType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>Expr</name> <operator>*</operator><macro><name>getUnderlyingExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getUnderlyingExpr</name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;

struct <expr><name>UnaryTransformTypeLocInfo</name> <block>{


<expr><name>SourceLocation</name> <name>KWLoc</name></expr>, <expr><name>LParenLoc</name></expr>, <expr><name>RParenLoc</name></expr>;
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>UnderlyingTInfo</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>UnaryTransformTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>,
<argument><expr><name>UnaryTransformTypeLoc</name></expr></argument>,
<argument><expr><name>UnaryTransformType</name></expr></argument>,
<argument><expr><name>UnaryTransformTypeLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getKWLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>KWLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setKWLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>KWLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>TypeSourceInfo</name><operator>*</operator> <macro><name>getUnderlyingTInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>UnderlyingTInfo</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setUnderlyingTInfo</name><argument_list>(<argument>TypeSourceInfo *TInfo</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>UnderlyingTInfo</name> <operator>=</operator> <name>TInfo</name></expr>;
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getKWLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRParenLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getParensRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getLParenLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRParenLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setParensRange</name><argument_list>(<argument>SourceRange Range</argument>)</argument_list></macro> <block>{
<expr><call><name>setLParenLoc</name><argument_list>(<argument><expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setRParenLoc</name><argument_list>(<argument><expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;
}</block></expr>;

<expr><name>class</name> <name>DeducedTypeLoc</name>
<operator>:</operator> <name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>TypeSpecTypeLoc</name></expr></argument>, <argument><expr><name>DeducedTypeLoc</name></expr></argument>,
<argument><expr><name>DeducedType</name></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;

struct <expr><name>AutoTypeLocInfo</name> <operator>:</operator> <name>TypeSpecLocInfo</name> <block>{
<expr><name>NestedNameSpecifierLoc</name> <name>NestedNameSpec</name></expr>;
<expr><name>SourceLocation</name> <name>TemplateKWLoc</name></expr>;
<expr><name>SourceLocation</name> <name>ConceptNameLoc</name></expr>;
<expr><name>NamedDecl</name> <operator>*</operator><name>FoundDecl</name></expr>;
<expr><name>SourceLocation</name> <name>LAngleLoc</name></expr>;
<expr><name>SourceLocation</name> <name>RAngleLoc</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>AutoTypeLoc</name>
<operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>DeducedTypeLoc</name></expr></argument>,
<argument><expr><name>AutoTypeLoc</name></expr></argument>,
<argument><expr><name>AutoType</name></expr></argument>,
<argument><expr><name>AutoTypeLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>AutoTypeKeyword</name> <macro><name>getAutoKeyword</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getKeyword</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isConstrained</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isConstrained</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>NestedNameSpecifierLoc</name> <operator>&amp;</operator><macro><name>getNestedNameSpecifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NestedNameSpec</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setNestedNameSpecifierLoc</name><argument_list>(<argument>NestedNameSpecifierLoc NNS</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NestedNameSpec</name> <operator>=</operator> <name>NNS</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getTemplateKWLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TemplateKWLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setTemplateKWLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TemplateKWLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getConceptNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ConceptNameLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setConceptNameLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ConceptNameLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>NamedDecl</name> <operator>*</operator><macro><name>getFoundDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>FoundDecl</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setFoundDecl</name><argument_list>(<argument>NamedDecl *D</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>FoundDecl</name> <operator>=</operator> <name>D</name></expr>;
}</block>

<name>ConceptDecl</name> <operator>*</operator><macro><name>getNamedConcept</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTypeConstraintConcept</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>DeclarationNameInfo</name> <macro><name>getConceptNameInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>LAngleLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getLAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LAngleLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setLAngleLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LAngleLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getRAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RAngleLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setRAngleLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RAngleLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNumArgs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setArgLocInfo</name><argument_list>(<argument>unsigned i</argument>, <argument>TemplateArgumentLocInfo AI</argument>)</argument_list></macro> <block>{
<expr><call><name>getArgInfos</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name>AI</name></expr>;
}</block>

<name>TemplateArgumentLocInfo</name> <macro><name>getArgLocInfo</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getArgInfos</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</return>
}</block>

<name>TemplateArgumentLoc</name> <macro><name>getArgLoc</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>TemplateArgumentLoc</name><argument_list>(<argument><expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTypeConstraintArguments</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr></argument>,
<argument><expr><call><name>getArgLocInfo</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return<expr><block>{
<expr><call><name>isConstrained</name><argument_list>()</argument_list></call>
<operator>?</operator> <operator>(</operator><call><name>getNestedNameSpecifierLoc</name><argument_list>()</argument_list></call>
<operator>?</operator> <call><name>getNestedNameSpecifierLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call>
<operator>:</operator> <operator>(</operator><call><name>getTemplateKWLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call>
<operator>?</operator> <call><name>getTemplateKWLoc</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>getConceptNameLoc</name><argument_list>()</argument_list></call><operator>)</operator><operator>)</operator>
<operator>:</operator> <call><name>getNameLoc</name><argument_list>()</argument_list></call></expr>,
<macro><name>getNameLoc</name><argument_list>()</argument_list></macro>
}</block></expr>;</return>
}</block>

<name>void</name> <macro><name>copy</name><argument_list>(<argument>AutoTypeLoc Loc</argument>)</argument_list></macro> <block>{
<expr><name>unsigned</name> <name>size</name> <operator>=</operator> <call><name>getFullDataSize</name><argument_list>()</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>==</operator> <call><name><name>Loc</name><operator>.</operator><name>getFullDataSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>memcpy</name><argument_list>(<argument><expr><name>Data</name></expr></argument>, <argument><expr><name><name>Loc</name><operator>.</operator><name>Data</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;

<expr><name>unsigned</name> <macro><name>getExtraLocalDataSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TemplateArgumentLocInfo</name></expr></argument>)</argument_list></sizeof></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getExtraLocalDataAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>alignof</name><argument_list>(<argument><expr><name>TemplateArgumentLocInfo</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>TemplateArgumentLocInfo</name> <operator>*</operator><macro><name>getArgInfos</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLocInfo</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getExtraLocalData</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>DeducedTemplateSpecializationTypeLoc</name>
<operator>:</operator> <name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>DeducedTypeLoc</name></expr></argument>,
<argument><expr><name>DeducedTemplateSpecializationTypeLoc</name></expr></argument>,
<argument><expr><name>DeducedTemplateSpecializationType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getTemplateNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNameLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setTemplateNameLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setNameLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;

struct <expr><name>ElaboratedLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>ElaboratedKWLoc</name></expr>;


<expr><name>void</name> <operator>*</operator><name>QualifierData</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>ElaboratedTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>,
<argument><expr><name>ElaboratedTypeLoc</name></expr></argument>,
<argument><expr><name>ElaboratedType</name></expr></argument>,
<argument><expr><name>ElaboratedLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getElaboratedKeywordLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ElaboratedKWLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setElaboratedKeywordLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ElaboratedKWLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>NestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getQualifier</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>QualifierData</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setQualifierLoc</name><argument_list>(<argument>NestedNameSpecifierLoc QualifierLoc</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call>
<operator>==</operator> <call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getQualifier</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Inconsistent nested-name-specifier pointer"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>QualifierData</name> <operator>=</operator> <call><name><name>QualifierLoc</name><operator>.</operator><name>getOpaqueData</name></name><argument_list>()</argument_list></call></expr>;
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getElaboratedKeywordLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>getQualifierLoc</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getElaboratedKeywordLoc</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getQualifierLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getElaboratedKeywordLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>getQualifierLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSourceRange</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;

<expr><name>TypeLoc</name> <macro><name>getNamedTypeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getInnerTypeLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>QualType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNamedType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>copy</name><argument_list>(<argument>ElaboratedTypeLoc Loc</argument>)</argument_list></macro> <block>{
<expr><name>unsigned</name> <name>size</name> <operator>=</operator> <call><name>getFullDataSize</name><argument_list>()</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>==</operator> <call><name><name>Loc</name><operator>.</operator><name>getFullDataSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>memcpy</name><argument_list>(<argument><expr><name>Data</name></expr></argument>, <argument><expr><name><name>Loc</name><operator>.</operator><name>Data</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;



struct <expr><name>DependentNameLocInfo</name> <operator>:</operator> <name>ElaboratedLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>NameLoc</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>DependentNameTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>,
<argument><expr><name>DependentNameTypeLoc</name></expr></argument>,
<argument><expr><name>DependentNameType</name></expr></argument>,
<argument><expr><name>DependentNameLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getElaboratedKeywordLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ElaboratedKWLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setElaboratedKeywordLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ElaboratedKWLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>NestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getQualifier</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>QualifierData</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setQualifierLoc</name><argument_list>(<argument>NestedNameSpecifierLoc QualifierLoc</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call>
<operator>==</operator> <call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getQualifier</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Inconsistent nested-name-specifier pointer"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>QualifierData</name> <operator>=</operator> <call><name><name>QualifierLoc</name><operator>.</operator><name>getOpaqueData</name></name><argument_list>()</argument_list></call></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setNameLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getElaboratedKeywordLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getElaboratedKeywordLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNameLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getQualifierLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNameLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block>

<name>void</name> <macro><name>copy</name><argument_list>(<argument>DependentNameTypeLoc Loc</argument>)</argument_list></macro> <block>{
<expr><name>unsigned</name> <name>size</name> <operator>=</operator> <call><name>getFullDataSize</name><argument_list>()</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>==</operator> <call><name><name>Loc</name><operator>.</operator><name>getFullDataSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>memcpy</name><argument_list>(<argument><expr><name>Data</name></expr></argument>, <argument><expr><name><name>Loc</name><operator>.</operator><name>Data</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;
}</block></expr>;

struct <expr><name>DependentTemplateSpecializationLocInfo</name> <operator>:</operator> <name>DependentNameLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>TemplateKWLoc</name></expr>;
<expr><name>SourceLocation</name> <name>LAngleLoc</name></expr>;
<expr><name>SourceLocation</name> <name>RAngleLoc</name></expr>;

}</block></expr>;

<expr><name>class</name> <name>DependentTemplateSpecializationTypeLoc</name> <operator>:</operator>
<name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>,
<argument><expr><name>DependentTemplateSpecializationTypeLoc</name></expr></argument>,
<argument><expr><name>DependentTemplateSpecializationType</name></expr></argument>,
<argument><expr><name>DependentTemplateSpecializationLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getElaboratedKeywordLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ElaboratedKWLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setElaboratedKeywordLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ElaboratedKWLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>QualifierData</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>NestedNameSpecifierLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name>NestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getQualifier</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>QualifierData</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setQualifierLoc</name><argument_list>(<argument>NestedNameSpecifierLoc QualifierLoc</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>QualifierLoc</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>QualifierData</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<return>return;</return>
<expr_stmt/>}</block_content>

assert(QualifierLoc.getNestedNameSpecifier(</block></if></if_stmt>)
<operator>==</operator> <call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getQualifier</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Inconsistent nested-name-specifier pointer"</literal>)</block></expr>;
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>QualifierData</name> <operator>=</operator> <call><name><name>QualifierLoc</name><operator>.</operator><name>getOpaqueData</name></name><argument_list>()</argument_list></call></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TemplateKWLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setTemplateKeywordLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>getLocalData</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TemplateKWLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getTemplateNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setTemplateNameLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NameLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getLAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LAngleLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setLAngleLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LAngleLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getRAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RAngleLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setRAngleLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RAngleLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNumArgs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setArgLocInfo</name><argument_list>(<argument>unsigned i</argument>, <argument>TemplateArgumentLocInfo AI</argument>)</argument_list></macro> <block>{
<expr><call><name>getArgInfos</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name>AI</name></expr>;
}</block>

<name>TemplateArgumentLocInfo</name> <macro><name>getArgLocInfo</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getArgInfos</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</return>
}</block>

<name>TemplateArgumentLoc</name> <macro><name>getArgLoc</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>TemplateArgumentLoc</name><argument_list>(<argument><expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getArg</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getArgLocInfo</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getElaboratedKeywordLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getElaboratedKeywordLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRAngleLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>getQualifierLoc</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getQualifierLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRAngleLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRAngleLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getTemplateNameLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRAngleLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block>

<name>void</name> <macro><name>copy</name><argument_list>(<argument>DependentTemplateSpecializationTypeLoc Loc</argument>)</argument_list></macro> <block>{
<expr><name>unsigned</name> <name>size</name> <operator>=</operator> <call><name>getFullDataSize</name><argument_list>()</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>==</operator> <call><name><name>Loc</name><operator>.</operator><name>getFullDataSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>memcpy</name><argument_list>(<argument><expr><name>Data</name></expr></argument>, <argument><expr><name><name>Loc</name><operator>.</operator><name>Data</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;

<expr><name>unsigned</name> <macro><name>getExtraLocalDataSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TemplateArgumentLocInfo</name></expr></argument>)</argument_list></sizeof></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getExtraLocalDataAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>alignof</name><argument_list>(<argument><expr><name>TemplateArgumentLocInfo</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>TemplateArgumentLocInfo</name> <operator>*</operator><macro><name>getArgInfos</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLocInfo</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getExtraLocalData</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

struct <expr><name>PackExpansionTypeLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>EllipsisLoc</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>PackExpansionTypeLoc</name>
<operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>, <argument><expr><name>PackExpansionTypeLoc</name></expr></argument>,
<argument><expr><name>PackExpansionType</name></expr></argument>, <argument><expr><name>PackExpansionTypeLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getEllipsisLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>EllipsisLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setEllipsisLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>EllipsisLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getEllipsisLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getEllipsisLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setEllipsisLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>TypeLoc</name> <macro><name>getPatternLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getInnerTypeLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>QualType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getPattern</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;

struct <expr><name>AtomicTypeLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>KWLoc</name></expr>, <expr><name>LParenLoc</name></expr>, <expr><name>RParenLoc</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>AtomicTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>, <argument><expr><name>AtomicTypeLoc</name></expr></argument>,
<argument><expr><name>AtomicType</name></expr></argument>, <argument><expr><name>AtomicTypeLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>TypeLoc</name> <macro><name>getValueLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getInnerTypeLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getKWLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRParenLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getKWLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>KWLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setKWLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>KWLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LParenLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RParenLoc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RParenLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>SourceRange</name> <macro><name>getParensRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getLParenLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRParenLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setParensRange</name><argument_list>(<argument>SourceRange Range</argument>)</argument_list></macro> <block>{
<expr><call><name>setLParenLoc</name><argument_list>(<argument><expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setRParenLoc</name><argument_list>(<argument><expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setKWLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setLParenLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setRParenLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>QualType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;

struct <expr><name>PipeTypeLocInfo</name> <block>{
<expr><name>SourceLocation</name> <name>KWLoc</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>PipeTypeLoc</name> <operator>:</operator> <name>public</name> <name><name>ConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>UnqualTypeLoc</name></expr></argument>, <argument><expr><name>PipeTypeLoc</name></expr></argument>, <argument><expr><name>PipeType</name></expr></argument>,
<argument><expr><name>PipeTypeLocInfo</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>TypeLoc</name> <macro><name>getValueLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getInnerTypeLoc</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceRange</name> <macro><name>getLocalSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getKWLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getKWLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>KWLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setKWLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><call><name><name>this</name><operator>-&gt;</operator><name>getLocalData</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>KWLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>void</name> <macro><name>initializeLocal</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>setKWLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>QualType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getElementType</name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>T</name> <name>TypeLoc</name><operator>::</operator><macro><name>getAsAdjusted</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>TypeLoc</name> <name>Cur</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;
<while>while <condition>(<expr><operator>!</operator><name>T</name><operator>::</operator><call><name>isKind</name><argument_list>(<argument><expr><name>Cur</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><name>auto</name></type> <name>PTL</name> <init>= <expr><name><name>Cur</name><operator>.</operator><name>getAs</name></name><operator>&lt;</operator><name>ParenTypeLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Cur</name> <operator>=</operator> <call><name><name>PTL</name><operator>.</operator><name>getInnerLoc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<decl><type><name>auto</name></type> <name>ATL</name> <init>= <expr><name><name>Cur</name><operator>.</operator><name>getAs</name></name><operator>&lt;</operator><name>AttributedTypeLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Cur</name> <operator>=</operator> <call><name><name>ATL</name><operator>.</operator><name>getModifiedLoc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<decl><type><name>auto</name></type> <name>ETL</name> <init>= <expr><name><name>Cur</name><operator>.</operator><name>getAs</name></name><operator>&lt;</operator><name>ElaboratedTypeLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Cur</name> <operator>=</operator> <call><name><name>ETL</name><operator>.</operator><name>getNamedTypeLoc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<decl><type><name>auto</name></type> <name>ATL</name> <init>= <expr><name><name>Cur</name><operator>.</operator><name>getAs</name></name><operator>&lt;</operator><name>AdjustedTypeLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Cur</name> <operator>=</operator> <call><name><name>ATL</name><operator>.</operator><name>getOriginalLoc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<decl><type><name>auto</name></type> <name>MQL</name> <init>= <expr><name><name>Cur</name><operator>.</operator><name>getAs</name></name><operator>&lt;</operator><name>MacroQualifiedTypeLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Cur</name> <operator>=</operator> <call><name><name>MQL</name><operator>.</operator><name>getInnerLoc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<break>break;</break></block_content></block></else></if_stmt>
<expr_stmt/>}</block_content>
return Cur.getAs&lt;T&gt;(</block></while>)</block></expr>;
}</block>
<name>class</name> <name>ExtIntTypeLoc</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>TypeSpecTypeLoc</name></expr></argument>, <argument><expr><name>ExtIntTypeLoc</name></expr></argument>,
<argument><expr><name>ExtIntType</name></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;
<expr><name>class</name> <name>DependentExtIntTypeLoc</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>InheritingConcreteTypeLoc</name><argument_list type="generic">&lt;<argument><expr><name>TypeSpecTypeLoc</name></expr></argument>, <argument><expr><name>DependentExtIntTypeLoc</name></expr></argument>,
<argument><expr><name>DependentExtIntType</name></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;

}</block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></block></expr></block></expr></block></expr></block></expr></range></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
