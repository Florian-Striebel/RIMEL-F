<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Basic/LangOptions.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_BASIC_LANGOPTIONS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_BASIC_LANGOPTIONS_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/CommentOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LangStandard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/ObjCRuntime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Sanitizers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TargetCXXABI.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Visibility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/FloatingPointMode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Triple.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>



<decl_stmt><decl><type><name>class</name></type> <name>LangOptionsBase</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CompilerInvocation</name></decl>;</decl_stmt>

<label><name>public</name>:</label>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LANGOPT</name><parameter_list>(<parameter><type><name>Name</name></type></parameter>, <parameter><type><name>Bits</name></type></parameter>, <parameter><type><name>Default</name></type></parameter>, <parameter><type><name>Description</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>unsigned Name : Bits;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENUM_LANGOPT</name><parameter_list>(<parameter><type><name>Name</name></type></parameter>, <parameter><type><name>Type</name></type></parameter>, <parameter><type><name>Bits</name></type></parameter>, <parameter><type><name>Default</name></type></parameter>, <parameter><type><name>Description</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LangOptions.def"</cpp:file></cpp:include>

<label><name>protected</name>:</label>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LANGOPT</name><parameter_list>(<parameter><type><name>Name</name></type></parameter>, <parameter><type><name>Bits</name></type></parameter>, <parameter><type><name>Default</name></type></parameter>, <parameter><type><name>Description</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENUM_LANGOPT</name><parameter_list>(<parameter><type><name>Name</name></type></parameter>, <parameter><type><name>Type</name></type></parameter>, <parameter><type><name>Bits</name></type></parameter>, <parameter><type><name>Default</name></type></parameter>, <parameter><type><name>Description</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>unsigned Name : Bits;</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LangOptions.def"</cpp:file></cpp:include>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>MSVtorDispMode</name> <block>{<block_content> <expr_stmt><expr><name>Never</name></expr><operator>,</operator> <expr><name>ForVBaseOverride</name></expr><operator>,</operator> <expr><name>ForVFTable</name></expr></expr_stmt> </block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>LangOptions</name> <range>: <expr><name>public</name> <name>LangOptionsBase</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>using</name> <name>Visibility</name> <operator>=</operator> <name>clang</name><operator>::</operator><name>Visibility</name></expr>;
<expr><name>using</name> <name>RoundingMode</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name>RoundingMode</name></expr>;

enum <expr><name>GCMode</name> <block>{ <expr><name>NonGC</name></expr>, <expr><name>GCOnly</name></expr>, <expr><name>HybridGC</name></expr> }</block></expr>;
enum <expr><name>StackProtectorMode</name> <block>{ <expr><name>SSPOff</name></expr>, <expr><name>SSPOn</name></expr>, <expr><name>SSPStrong</name></expr>, <expr><name>SSPReq</name></expr> }</block></expr>;




enum <expr><name>class</name> <name>TrivialAutoVarInitKind</name> <block>{ <expr><name>Uninitialized</name></expr>, <expr><name>Zero</name></expr>, <expr><name>Pattern</name></expr> }</block></expr>;

enum <expr><name>SignedOverflowBehaviorTy</name> <block>{

<expr><name>SOB_Undefined</name></expr>,


<expr><name>SOB_Defined</name></expr>,


<expr><name>SOB_Trapping</name></expr>
}</block></expr>;


enum <expr><name>CompilingModuleKind</name> <block>{

<expr><name>CMK_None</name></expr>,


<expr><name>CMK_ModuleMap</name></expr>,


<expr><name>CMK_HeaderModule</name></expr>,


<expr><name>CMK_ModuleInterface</name></expr>,
}</block></expr>;

enum <expr><name>PragmaMSPointersToMembersKind</name> <block>{
<expr><name>PPTMK_BestCase</name></expr>,
<expr><name>PPTMK_FullGeneralitySingleInheritance</name></expr>,
<expr><name>PPTMK_FullGeneralityMultipleInheritance</name></expr>,
<expr><name>PPTMK_FullGeneralityVirtualInheritance</name></expr>
}</block></expr>;

<expr><name>using</name> <name>MSVtorDispMode</name> <operator>=</operator> <name>clang</name><operator>::</operator><name>MSVtorDispMode</name></expr>;

enum <expr><name>DefaultCallingConvention</name> <block>{
<expr><name>DCC_None</name></expr>,
<expr><name>DCC_CDecl</name></expr>,
<expr><name>DCC_FastCall</name></expr>,
<expr><name>DCC_StdCall</name></expr>,
<expr><name>DCC_VectorCall</name></expr>,
<expr><name>DCC_RegCall</name></expr>
}</block></expr>;

enum <expr><name>AddrSpaceMapMangling</name> <block>{ <expr><name>ASMM_Target</name></expr>, <expr><name>ASMM_On</name></expr>, <expr><name>ASMM_Off</name></expr> }</block></expr>;


enum <expr><name>MSVCMajorVersion</name> <block>{
<expr><name>MSVC2010</name> <operator>=</operator> <literal type="number">1600</literal></expr>,
<expr><name>MSVC2012</name> <operator>=</operator> <literal type="number">1700</literal></expr>,
<expr><name>MSVC2013</name> <operator>=</operator> <literal type="number">1800</literal></expr>,
<expr><name>MSVC2015</name> <operator>=</operator> <literal type="number">1900</literal></expr>,
<expr><name>MSVC2017</name> <operator>=</operator> <literal type="number">1910</literal></expr>,
<expr><name>MSVC2017_5</name> <operator>=</operator> <literal type="number">1912</literal></expr>,
<expr><name>MSVC2017_7</name> <operator>=</operator> <literal type="number">1914</literal></expr>,
<expr><name>MSVC2019</name> <operator>=</operator> <literal type="number">1920</literal></expr>,
<expr><name>MSVC2019_8</name> <operator>=</operator> <literal type="number">1928</literal></expr>,
}</block></expr>;

enum <expr><name>SYCLMajorVersion</name> <block>{
<expr><name>SYCL_None</name></expr>,
<expr><name>SYCL_2017</name></expr>,
<expr><name>SYCL_2020</name></expr>,


<expr><name>SYCL_Default</name> <operator>=</operator> <name>SYCL_2020</name></expr>
}</block></expr>;


enum <expr><name>class</name> <name>ClangABI</name> <block>{



<expr><name>Ver3_8</name></expr>,




<expr><name>Ver4</name></expr>,






<expr><name>Ver6</name></expr>,





<expr><name>Ver7</name></expr>,





<expr><name>Ver9</name></expr>,







<expr><name>Ver11</name></expr>,




<expr><name>Ver12</name></expr>,



<expr><name>Latest</name></expr>
}</block></expr>;

enum <expr><name>class</name> <name>CoreFoundationABI</name> <block>{

<expr><name>Unspecified</name></expr>,

<expr><name>Standalone</name></expr>,

<expr><name>ObjectiveC</name></expr>,

<expr><name>Swift</name></expr>,

<expr><name>Swift5_0</name></expr>,

<expr><name>Swift4_2</name></expr>,

<expr><name>Swift4_1</name></expr>,
}</block></expr>;

enum <expr><name>FPModeKind</name> <block>{

<expr><name>FPM_Off</name></expr>,


<expr><name>FPM_On</name></expr>,


<expr><name>FPM_Fast</name></expr>,


<expr><name>FPM_FastHonorPragmas</name></expr>
}</block></expr>;


<expr><specifier>static</specifier> <name>constexpr</name> <name>unsigned</name> <name>FPR_ToNearest</name> <operator>=</operator>
<call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>RoundingMode</name><operator>::</operator><name>NearestTiesToEven</name></expr></argument>)</argument_list></call></expr>;


enum <expr><name>FPExceptionModeKind</name> <block>{

<expr><name>FPE_Ignore</name></expr>,

<expr><name>FPE_MayTrap</name></expr>,

<expr><name>FPE_Strict</name></expr>
}</block></expr>;


enum <expr><name>class</name> <name>ExceptionHandlingKind</name> <block>{ <expr><name>None</name></expr>, <expr><name>SjLj</name></expr>, <expr><name>WinEH</name></expr>, <expr><name>DwarfCFI</name></expr>, <expr><name>Wasm</name></expr> }</block></expr>;

enum <expr><name>class</name> <name>LaxVectorConversionKind</name> <block>{

<expr><name>None</name></expr>,


<expr><name>Integer</name></expr>,


<expr><name>All</name></expr>,
}</block></expr>;

enum <expr><name>class</name> <name>AltivecSrcCompatKind</name> <block>{


<expr><name>Mixed</name></expr>,

<expr><name>GCC</name></expr>,

<expr><name>XL</name></expr>,

<expr><name>Default</name> <operator>=</operator> <name>Mixed</name></expr>,
}</block></expr>;

enum <expr><name>class</name> <name>SignReturnAddressScopeKind</name> <block>{

<expr><name>None</name></expr>,

<expr><name>NonLeaf</name></expr>,

<expr><name>All</name></expr>
}</block></expr>;

enum <expr><name>class</name> <name>SignReturnAddressKeyKind</name> <block>{

<expr><name>AKey</name></expr>,

<expr><name>BKey</name></expr>
}</block></expr>;

enum <expr><name>class</name> <name>ThreadModelKind</name> <block>{

<expr><name>POSIX</name></expr>,

<expr><name>Single</name></expr>
}</block></expr>;

enum <expr><name>class</name> <name>ExtendArgsKind</name> <block>{


<expr><name>ExtendTo32</name></expr>,
<expr><name>ExtendTo64</name></expr>
}</block></expr>;

<expr><name>public</name><operator>:</operator>

<name>LangStandard</name><operator>::</operator><name>Kind</name> <name>LangStd</name></expr>;


<expr><name>SanitizerSet</name> <name>Sanitize</name></expr>;

<expr><name>bool</name> <name>SanitizeCoverage</name> <operator>=</operator> <name>false</name></expr>;



<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>NoSanitizeFiles</name></expr>;





<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>XRayAlwaysInstrumentFiles</name></expr>;





<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>XRayNeverInstrumentFiles</name></expr>;




<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>XRayAttrListFiles</name></expr>;



<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>ProfileListFiles</name></expr>;

<expr><name>clang</name><operator>::</operator><name>ObjCRuntime</name> <name>ObjCRuntime</name></expr>;

<expr><name>CoreFoundationABI</name> <name>CFRuntime</name> <operator>=</operator> <name>CoreFoundationABI</name><operator>::</operator><name>Unspecified</name></expr>;

<expr><name>std</name><operator>::</operator><name>string</name> <name>ObjCConstantStringClass</name></expr>;





<expr><name>std</name><operator>::</operator><name>string</name> <name>OverflowHandler</name></expr>;


<expr><name>std</name><operator>::</operator><name>string</name> <name>ModuleName</name></expr>;






<expr><name>std</name><operator>::</operator><name>string</name> <name>CurrentModule</name></expr>;





<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>ModuleFeatures</name></expr>;


<expr><name>CommentOptions</name> <name>CommentOpts</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>NoBuiltinFuncs</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>greater</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>MacroPrefixMap</name></expr>;



<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Triple</name></expr></argument>&gt;</argument_list></name> <name>OMPTargetTriples</name></expr>;



<expr><name>std</name><operator>::</operator><name>string</name> <name>OMPHostIRFile</name></expr>;





<expr><name>std</name><operator>::</operator><name>string</name> <name>CUID</name></expr>;



<expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>TargetCXXABI</name><operator>::</operator><name>Kind</name></expr></argument>&gt;</argument_list></name> <name>CXXABI</name></expr>;



<expr><name>bool</name> <name>IsHeaderFile</name> <operator>=</operator> <name>false</name></expr>;

<expr><call><name>LangOptions</name><argument_list>()</argument_list></call></expr>;


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LANGOPT</name><parameter_list>(<parameter><type><name>Name</name></type></parameter>, <parameter><type><name>Bits</name></type></parameter>, <parameter><type><name>Default</name></type></parameter>, <parameter><type><name>Description</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENUM_LANGOPT</name><parameter_list>(<parameter><type><name>Name</name></type></parameter>, <parameter><type><name>Type</name></type></parameter>, <parameter><type><name>Bits</name></type></parameter>, <parameter><type><name>Default</name></type></parameter>, <parameter><type><name>Description</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Type get##Name() const { return static_cast&lt;Type&gt;(Name); } void set##Name(Type Value) { Name = static_cast&lt;unsigned&gt;(Value); }</cpp:value></cpp:define>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LangOptions.def"</cpp:file></cpp:include>


<expr><name>bool</name> <macro><name>isCompilingModule</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCompilingModule</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>CMK_None</name></expr>;</return>
}</block>


<name>bool</name> <macro><name>trackLocalOwningModule</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isCompilingModule</name><argument_list>()</argument_list></call> <operator>||</operator> <name>ModulesLocalVisibility</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isSignedOverflowDefined</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getSignedOverflowBehavior</name><argument_list>()</argument_list></call> <operator>==</operator> <name>SOB_Defined</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isSubscriptPointerArithmetic</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>ObjCRuntime</name><operator>.</operator><name>isSubscriptPointerArithmetic</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name>ObjCSubscriptingLegacyRuntime</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isCompatibleWithMSVC</name><argument_list>(<argument>MSVCMajorVersion MajorVersion</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>MSCompatibilityVersion</name> <operator>&gt;=</operator> <name>MajorVersion</name> <operator>*</operator> <literal type="number">100000U</literal></expr>;</return>
}</block>



<name>void</name> <call><name>resetNonModularOptions</name><argument_list>()</argument_list></call></expr>;



<expr><name>bool</name> <macro><name>isNoBuiltinFunc</name><argument_list>(<argument>StringRef Name</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>allowsNonTrivialObjCLifetimeQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ObjCAutoRefCount</name> <operator>||</operator> <name>ObjCWeak</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>assumeFunctionsAreConvergent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ConvergentFunctions</name></expr>;</return>
}</block>


<name>VersionTuple</name> <macro><name>getOpenCLVersionTuple</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>hasSignReturnAddress</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getSignReturnAddressScope</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SignReturnAddressScopeKind</name><operator>::</operator><name>None</name></expr>;</return>
}</block>


<name>bool</name> <macro><name>isSignReturnAddressWithAKey</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getSignReturnAddressKey</name><argument_list>()</argument_list></call> <operator>==</operator> <name>SignReturnAddressKeyKind</name><operator>::</operator><name>AKey</name></expr>;</return>
}</block>


<name>bool</name> <macro><name>isSignReturnAddressScopeAll</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getSignReturnAddressScope</name><argument_list>()</argument_list></call> <operator>==</operator> <name>SignReturnAddressScopeKind</name><operator>::</operator><name>All</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasSjLjExceptions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getExceptionHandling</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ExceptionHandlingKind</name><operator>::</operator><name>SjLj</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasSEHExceptions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getExceptionHandling</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ExceptionHandlingKind</name><operator>::</operator><name>WinEH</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasDWARFExceptions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getExceptionHandling</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ExceptionHandlingKind</name><operator>::</operator><name>DwarfCFI</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasWasmExceptions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getExceptionHandling</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ExceptionHandlingKind</name><operator>::</operator><name>Wasm</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isSYCL</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SYCLIsDevice</name> <operator>||</operator> <name>SYCLIsHost</name></expr>;</return> }</block>


<name>void</name> <macro><name>remapPathPrefix</name><argument_list>(<argument>SmallString&lt;<literal type="number">256</literal>&gt; &amp;Path</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>FPOptionsOverride</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FPOptions</name> <block>{<block_content>
<label><name>public</name>:</label>

<decl_stmt><decl><type><name>using</name></type> <name>storage_type</name> <init>= <expr><name>uint16_t</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>RoundingMode</name> <init>= <expr><name>llvm</name><operator>::</operator><name>RoundingMode</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>constexpr</name> <name>unsigned</name></type> <name>StorageBitSize</name> <init>= <expr><literal type="number">8</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>storage_type</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>static</specifier> <name>constexpr</name> <name>storage_type</name></type> <name>FirstShift</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>FirstWidth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION</name><parameter_list>(<parameter><type><name>NAME</name></type></parameter>, <parameter><type><name>TYPE</name></type></parameter>, <parameter><type><name>WIDTH</name></type></parameter>, <parameter><type><name>PREVIOUS</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static constexpr storage_type NAME##Shift = PREVIOUS##Shift + PREVIOUS##Width; static constexpr storage_type NAME##Width = WIDTH; static constexpr storage_type NAME##Mask = ((1 &lt;&lt; NAME##Width) - 1) &lt;&lt; NAME##Shift;</cpp:value></cpp:define>





<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/FPOptions.def"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>constexpr</name> <name>storage_type</name></type> <name>TotalWidth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION</name><parameter_list>(<parameter><type><name>NAME</name></type></parameter>, <parameter><type><name>TYPE</name></type></parameter>, <parameter><type><name>WIDTH</name></type></parameter>, <parameter><type><name>PREVIOUS</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>+WIDTH</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/FPOptions.def"</cpp:file></cpp:include>
;</decl_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><name>TotalWidth</name> <operator>&lt;=</operator> <name>StorageBitSize</name></expr></argument>, <argument><expr><literal type="string">"Too short type for FPOptions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>storage_type</name></type> <name>Value</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>FPOptions</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Value</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro> <block>{
<expr><call><name>setFPContractMode</name><argument_list>(<argument><expr><name>LangOptions</name><operator>::</operator><name>FPM_Off</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setRoundingMode</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>RoundingMode</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>LangOptions</name><operator>::</operator><name>FPR_ToNearest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setFPExceptionMode</name><argument_list>(<argument><expr><name>LangOptions</name><operator>::</operator><name>FPE_Ignore</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>explicit</name> <macro><name>FPOptions</name><argument_list>(<argument>const LangOptions &amp;LO</argument>)</argument_list></macro> <block>{
<expr><name>Value</name> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name>auto</name> <name>LangOptContractMode</name> <operator>=</operator> <call><name><name>LO</name><operator>.</operator><name>getDefaultFPContractMode</name></name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>LangOptContractMode</name> <operator>==</operator> <name>LangOptions</name><operator>::</operator><name>FPM_FastHonorPragmas</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>LangOptContractMode</name> <operator>=</operator> <name>LangOptions</name><operator>::</operator><name>FPM_Fast</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<call><name>setFPContractMode</name><argument_list>(<argument><expr><name>LangOptContractMode</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setRoundingMode</name><argument_list>(<argument><expr><call><name><name>LO</name><operator>.</operator><name>getFPRoundingMode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setFPExceptionMode</name><argument_list>(<argument><expr><call><name><name>LO</name><operator>.</operator><name>getFPExceptionMode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setAllowFPReassociate</name><argument_list>(<argument><expr><name><name>LO</name><operator>.</operator><name>AllowFPReassoc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setNoHonorNaNs</name><argument_list>(<argument><expr><name><name>LO</name><operator>.</operator><name>NoHonorNaNs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setNoHonorInfs</name><argument_list>(<argument><expr><name><name>LO</name><operator>.</operator><name>NoHonorInfs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setNoSignedZero</name><argument_list>(<argument><expr><name><name>LO</name><operator>.</operator><name>NoSignedZero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setAllowReciprocal</name><argument_list>(<argument><expr><name><name>LO</name><operator>.</operator><name>AllowRecip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setAllowApproxFunc</name><argument_list>(<argument><expr><name><name>LO</name><operator>.</operator><name>ApproxFunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getFPContractMode</name><argument_list>()</argument_list></call> <operator>==</operator> <name>LangOptions</name><operator>::</operator><name>FPM_On</name> <operator>&amp;&amp;</operator>
<call><name>getRoundingMode</name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator><name>RoundingMode</name><operator>::</operator><name>Dynamic</name> <operator>&amp;&amp;</operator>
<call><name>getFPExceptionMode</name><argument_list>()</argument_list></call> <operator>==</operator> <name>LangOptions</name><operator>::</operator><name>FPE_Strict</name></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><call><name>setAllowFEnvAccess</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setAllowFEnvAccess</name><argument_list>(<argument><expr><name>LangOptions</name><operator>::</operator><name>FPM_Off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>allowFPContractWithinStatement</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getFPContractMode</name><argument_list>()</argument_list></call> <operator>==</operator> <name>LangOptions</name><operator>::</operator><name>FPM_On</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setAllowFPContractWithinStatement</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>setFPContractMode</name><argument_list>(<argument><expr><name>LangOptions</name><operator>::</operator><name>FPM_On</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>allowFPContractAcrossStatement</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getFPContractMode</name><argument_list>()</argument_list></call> <operator>==</operator> <name>LangOptions</name><operator>::</operator><name>FPM_Fast</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setAllowFPContractAcrossStatement</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>setFPContractMode</name><argument_list>(<argument><expr><name>LangOptions</name><operator>::</operator><name>FPM_Fast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>isFPConstrained</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getRoundingMode</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>llvm</name><operator>::</operator><name>RoundingMode</name><operator>::</operator><name>NearestTiesToEven</name> <operator>||</operator>
<call><name>getFPExceptionMode</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>LangOptions</name><operator>::</operator><name>FPE_Ignore</name> <operator>||</operator>
<call><name>getAllowFEnvAccess</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><name>FPOptions</name> <name>other</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>Value</name> <operator>==</operator> <name><name>other</name><operator>.</operator><name>Value</name></name></expr>;</return> }</block></expr></expr_stmt>



<function_decl><type><specifier>static</specifier> <name>FPOptions</name></type> <name>defaultWithoutTrailingStorage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LangOptions</name> <modifier>&amp;</modifier></type><name>LO</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>storage_type</name> <macro><name>getAsOpaqueInt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Value</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><specifier>static</specifier> <name>FPOptions</name></type> <name>getFromOpaqueInt</name><parameter_list>(<parameter><decl><type><name>storage_type</name></type> <name>Value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>FPOptions</name></type> <name>Opts</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Opts</name><operator>.</operator><name>Value</name></name> <operator>=</operator> <name>Value</name></expr>;</expr_stmt>
<return>return <expr><name>Opts</name></expr>;</return>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION</name><parameter_list>(<parameter><type><name>NAME</name></type></parameter>, <parameter><type><name>TYPE</name></type></parameter>, <parameter><type><name>WIDTH</name></type></parameter>, <parameter><type><name>PREVIOUS</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TYPE get##NAME() const { return static_cast&lt;TYPE&gt;((Value &amp; NAME##Mask) &gt;&gt; NAME##Shift); } void set##NAME(TYPE value) { Value = (Value &amp; ~NAME##Mask) | (storage_type(value) &lt;&lt; NAME##Shift); }</cpp:value></cpp:define>






<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/FPOptions.def"</cpp:file></cpp:include>
<function_decl><type><name>LLVM_DUMP_METHOD</name> <name>void</name></type> <name>dump</name><parameter_list>()</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>














<decl_stmt><decl><type><name>class</name></type> <name>FPOptionsOverride</name> <block>{<block_content>
<decl_stmt><decl><type><name>FPOptions</name></type> <name>Options</name> <init>= <expr><name>FPOptions</name><operator>::</operator><call><name>getFromOpaqueInt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>FPOptions</name><operator>::</operator><name>storage_type</name> <name>OverrideMask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>using</name></type> <name>RoundingMode</name> <init>= <expr><name>llvm</name><operator>::</operator><name>RoundingMode</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>using</name></type> <name>storage_type</name> <init>= <expr><name>uint32_t</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>storage_type</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FPOptions</name><operator>::</operator><name>storage_type</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"Too short type for FPOptionsOverride"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<decl_stmt><decl><type><specifier>static</specifier> <name>constexpr</name> <name>storage_type</name></type> <name>OverrideMaskBits</name> <init>=
<expr><operator>(</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>storage_type</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>FPOptions</name><operator>::</operator><name>StorageBitSize</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<macro><name>FPOptionsOverride</name><argument_list>()</argument_list></macro> <block>{<block_content/>}</block>
<expr_stmt><expr><call><name>FPOptionsOverride</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><name>LO</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Options</name><argument_list>(<argument><expr><name>LO</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>OverrideMask</name><argument_list>(<argument>OverrideMaskBits</argument>)</argument_list></macro> <expr><block>{}</block>
<macro><name>FPOptionsOverride</name><argument_list>(<argument>FPOptions FPO</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Options</name><argument_list>(<argument><expr><name>FPO</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>OverrideMask</name><argument_list>(<argument>OverrideMaskBits</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>requiresTrailingStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OverrideMask</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setAllowFPContractWithinStatement</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>setFPContractModeOverride</name><argument_list>(<argument><expr><name>LangOptions</name><operator>::</operator><name>FPM_On</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setAllowFPContractAcrossStatement</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>setFPContractModeOverride</name><argument_list>(<argument><expr><name>LangOptions</name><operator>::</operator><name>FPM_Fast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setDisallowFPContract</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>setFPContractModeOverride</name><argument_list>(<argument><expr><name>LangOptions</name><operator>::</operator><name>FPM_Off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setFPPreciseEnabled</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>setAllowFPReassociateOverride</name><argument_list>(<argument><expr><operator>!</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setNoHonorNaNsOverride</name><argument_list>(<argument><expr><operator>!</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setNoHonorInfsOverride</name><argument_list>(<argument><expr><operator>!</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setNoSignedZeroOverride</name><argument_list>(<argument><expr><operator>!</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setAllowReciprocalOverride</name><argument_list>(<argument><expr><operator>!</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setAllowApproxFuncOverride</name><argument_list>(<argument><expr><operator>!</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>Value</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>setAllowFPContractWithinStatement</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>setAllowFPContractAcrossStatement</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>storage_type</name> <macro><name>getAsOpaqueInt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>storage_type</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Options</name><operator>.</operator><name>getAsOpaqueInt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <name>FPOptions</name><operator>::</operator><name>StorageBitSize</name><operator>)</operator> <operator>|</operator>
<name>OverrideMask</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><specifier>static</specifier> <name>FPOptionsOverride</name></type> <name>getFromOpaqueInt</name><parameter_list>(<parameter><decl><type><name>storage_type</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>FPOptionsOverride</name></type> <name>Opts</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Opts</name><operator>.</operator><name>OverrideMask</name></name> <operator>=</operator> <name>I</name> <operator>&amp;</operator> <name>OverrideMaskBits</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><operator>.</operator><name>Options</name></name> <operator>=</operator> <name>FPOptions</name><operator>::</operator><call><name>getFromOpaqueInt</name><argument_list>(<argument><expr><name>I</name> <operator>&gt;&gt;</operator> <name>FPOptions</name><operator>::</operator><name>StorageBitSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Opts</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>FPOptions</name></type> <name>applyOverrides</name><parameter_list>(<parameter><decl><type><name>FPOptions</name></type> <name>Base</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>FPOptions</name></type> <name>Result</name> <init>=
<expr><name>FPOptions</name><operator>::</operator><call><name>getFromOpaqueInt</name><argument_list>(<argument><expr><operator>(</operator><call><name><name>Base</name><operator>.</operator><name>getAsOpaqueInt</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>OverrideMask</name><operator>)</operator> <operator>|</operator>
<operator>(</operator><call><name><name>Options</name><operator>.</operator><name>getAsOpaqueInt</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>OverrideMask</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>FPOptions</name></type> <name>applyOverrides</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LangOptions</name> <modifier>&amp;</modifier></type><name>LO</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>applyOverrides</name><argument_list>(<argument><expr><call><name>FPOptions</name><argument_list>(<argument><expr><name>LO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><name>FPOptionsOverride</name> <name>other</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>Options</name> <operator>==</operator> <name><name>other</name><operator>.</operator><name>Options</name></name> <operator>&amp;&amp;</operator> <name>OverrideMask</name> <operator>==</operator> <name><name>other</name><operator>.</operator><name>OverrideMask</name></name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><name>FPOptionsOverride</name> <name>other</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><operator>(</operator><operator>*</operator><name>this</name> <operator>==</operator> <name>other</name><operator>)</operator></expr>;</return> }</block></expr></expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION</name><parameter_list>(<parameter><type><name>NAME</name></type></parameter>, <parameter><type><name>TYPE</name></type></parameter>, <parameter><type><name>WIDTH</name></type></parameter>, <parameter><type><name>PREVIOUS</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bool has##NAME##Override() const { return OverrideMask &amp; FPOptions::NAME##Mask; } TYPE get##NAME##Override() const { assert(has##NAME##Override()); return Options.get##NAME(); } void clear##NAME##Override() { Options.set##NAME(TYPE(0)); OverrideMask &amp;= ~FPOptions::NAME##Mask; } void set##NAME##Override(TYPE value) { Options.set##NAME(value); OverrideMask |= FPOptions::NAME##Mask; }</cpp:value></cpp:define>

















<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/FPOptions.def"</cpp:file></cpp:include>
<function_decl><type><name>LLVM_DUMP_METHOD</name> <name>void</name></type> <name>dump</name><parameter_list>()</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<enum>enum <name>TranslationUnitKind</name> <block>{

<decl><name>TU_Complete</name></decl>,



<decl><name>TU_Prefix</name></decl>,


<decl><name>TU_Module</name></decl>,



<decl><name>TU_Incremental</name></decl>
}</block>;</enum>

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
