<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_LEX_PREPROCESSINGRECORD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_LEX_PREPROCESSINGRECORD_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/IdentifierTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/PPCallbacks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/None.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerUnion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Allocator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iterator&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>PreprocessingRecord</name></decl>;</decl_stmt>

</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><name>operator</name></type> <name>new</name><argument_list>(<argument><expr><name>size_t</name> <name>bytes</name></expr></argument>, <argument><expr><name>clang</name><operator>::</operator><name>PreprocessingRecord</name> <operator>&amp;</operator><name>PR</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>alignment</name> <operator>=</operator> <literal type="number">8</literal></expr></argument>)</argument_list> <name>noexcept</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name> <name>operator</name></type> <name>delete</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>clang</name><operator>::</operator><name>PreprocessingRecord</name> <operator>&amp;</operator><name>PR</name></expr></argument>,
<argument><expr><name>unsigned</name></expr></argument>)</argument_list> <name>noexcept</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>FileEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>IdentifierInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MacroInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SourceManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Token</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>PreprocessedEntity</name> <block>{<block_content>
<label><name>public</name>:</label>

<enum>enum <name>EntityKind</name> <block>{

<decl><name>InvalidKind</name></decl>,


<decl><name>MacroExpansionKind</name></decl>,





<decl><name>MacroDefinitionKind</name></decl>,



<decl><name>InclusionDirectiveKind</name></decl>,



<decl><name>FirstPreprocessingDirective</name> <init>= <expr><name>MacroDefinitionKind</name></expr></init></decl>,
<decl><name>LastPreprocessingDirective</name> <init>= <expr><name>InclusionDirectiveKind</name></expr></init></decl>
}</block>;</enum>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>EntityKind</name></type> <name>Kind</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceRange</name></type> <name>Range</name></decl>;</decl_stmt>

<label><name>protected</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>PreprocessingRecord</name></decl>;</decl_stmt>

<macro><name>PreprocessedEntity</name><argument_list>(<argument>EntityKind Kind</argument>, <argument>SourceRange Range</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Kind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Range</name><argument_list>(<argument>Range</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>

<name>EntityKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Range</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isInvalid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>InvalidKind</name></expr>;</return> }</block></expr></expr_stmt>



<function><type><name>void</name> <modifier>*</modifier><name>operator</name></type> <name>new</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>, <parameter><decl><type><name>PreprocessingRecord</name> <modifier>&amp;</modifier></type><name>PR</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>alignment</name> <init>= <expr><literal type="number">8</literal></expr></init></decl></parameter>)</parameter_list> noexcept <block>{<block_content>
<return>return <expr><operator>::</operator><name>operator</name> <call><name>new</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>PR</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier><name>operator</name></type> <name>new</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>mem</name></decl></parameter>)</parameter_list> noexcept <block>{<block_content> <return>return <expr><name>mem</name></expr>;</return> </block_content>}</block></function>

<function><type><name>void</name> <name>operator</name></type> <name>delete</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>PreprocessingRecord</name> <modifier>&amp;</modifier></type><name>PR</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>alignment</name></decl></parameter>)</parameter_list> noexcept <block>{<block_content>
<return>return <expr><operator>::</operator><name>operator</name> <call><name>delete</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>PR</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>void</name> <name>operator</name></type> <name>delete</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>size_t</name></expr></argument>)</argument_list> <name>noexcept</name> <block>{<block_content/>}</block></decl></decl_stmt>
<function><type><name>void</name> <name>operator</name></type> <name>delete</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list> noexcept <block>{<block_content/>}</block></function>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><name>operator</name></type> <name>new</name><argument_list>(<argument><expr><name>size_t</name> <name>bytes</name></expr></argument>)</argument_list> <name>noexcept</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <name>operator</name></type> <name>delete</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>data</name></expr></argument>)</argument_list> <name>noexcept</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>PreprocessingDirective</name> <range>: <expr><name>public</name> <name>PreprocessedEntity</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>PreprocessingDirective</name><argument_list>(<argument>EntityKind Kind</argument>, <argument>SourceRange Range</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>PreprocessedEntity</name><argument_list>(<argument>Kind</argument>, <argument>Range</argument>)</argument_list></macro> <block>{}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const PreprocessedEntity *PD</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>PD</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>FirstPreprocessingDirective</name> <operator>&amp;&amp;</operator>
<call><name><name>PD</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>LastPreprocessingDirective</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>MacroDefinitionRecord</name> <operator>:</operator> <name>public</name> <name>PreprocessingDirective</name> <block>{

<expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>Name</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <macro><name>MacroDefinitionRecord</name><argument_list>(<argument>const IdentifierInfo *Name</argument>,
<argument>SourceRange Range</argument>)</argument_list></macro>
<operator>:</operator> <call><name>PreprocessingDirective</name><argument_list>(<argument><expr><name>MacroDefinitionKind</name></expr></argument>, <argument><expr><name>Range</name></expr></argument>)</argument_list></call></expr>, <macro><name>Name</name><argument_list>(<argument>Name</argument>)</argument_list></macro> <expr><block>{}</block>


<specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><macro><name>getName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Name</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getSourceRange</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBegin</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const PreprocessedEntity *PE</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>PE</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>MacroDefinitionKind</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>MacroExpansion</name> <operator>:</operator> <name>public</name> <name>PreprocessedEntity</name> <block>{


<expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>MacroDefinitionRecord</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>NameOrDef</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>MacroExpansion</name><argument_list>(<argument>IdentifierInfo *BuiltinName</argument>, <argument>SourceRange Range</argument>)</argument_list></macro>
<operator>:</operator> <call><name>PreprocessedEntity</name><argument_list>(<argument><expr><name>MacroExpansionKind</name></expr></argument>, <argument><expr><name>Range</name></expr></argument>)</argument_list></call></expr>,
<macro><name>NameOrDef</name><argument_list>(<argument>BuiltinName</argument>)</argument_list></macro> <expr><block>{}</block>

<macro><name>MacroExpansion</name><argument_list>(<argument>MacroDefinitionRecord *Definition</argument>, <argument>SourceRange Range</argument>)</argument_list></macro>
<operator>:</operator> <call><name>PreprocessedEntity</name><argument_list>(<argument><expr><name>MacroExpansionKind</name></expr></argument>, <argument><expr><name>Range</name></expr></argument>)</argument_list></call></expr>, <macro><name>NameOrDef</name><argument_list>(<argument>Definition</argument>)</argument_list></macro> <expr><block>{
}</block>


<name>bool</name> <macro><name>isBuiltinMacro</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>NameOrDef</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>IdentifierInfo</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block>


<specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><macro><name>getName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><name>MacroDefinitionRecord</name> <modifier>*</modifier></type><name>Def</name> <init>= <expr><call><name>getDefinition</name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Def</name><operator>-&gt;</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name><name>NameOrDef</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>IdentifierInfo</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>



<name>MacroDefinitionRecord</name> <operator>*</operator><macro><name>getDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>NameOrDef</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>MacroDefinitionRecord</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const PreprocessedEntity *PE</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>PE</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>MacroExpansionKind</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>InclusionDirective</name> <operator>:</operator> <name>public</name> <name>PreprocessingDirective</name> <block>{
<expr><name>public</name><operator>:</operator>


enum <name>InclusionKind</name> <block>{

<expr><name>Include</name></expr>,


<expr><name>Import</name></expr>,


<expr><name>IncludeNext</name></expr>,


<expr><name>IncludeMacros</name></expr>
}</block></expr>;

<expr><name>private</name><operator>:</operator>


<name>StringRef</name> <name>FileName</name></expr>;



<expr><name>unsigned</name> <name>InQuotes</name> <operator>:</operator> <literal type="number">1</literal></expr>;




<expr><name>unsigned</name> <name>Kind</name> <operator>:</operator> <literal type="number">2</literal></expr>;



<expr><name>unsigned</name> <name>ImportedModule</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator><name>File</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>InclusionDirective</name><argument_list>(<argument>PreprocessingRecord &amp;PPRec</argument>,
<argument>InclusionKind Kind</argument>, <argument>StringRef FileName</argument>,
<argument>bool InQuotes</argument>, <argument>bool ImportedModule</argument>,
<argument>const FileEntry *File</argument>, <argument>SourceRange Range</argument>)</argument_list></macro></expr>;


<expr><name>InclusionKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>InclusionKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>;</return> }</block>


<name>StringRef</name> <macro><name>getFileName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FileName</name></expr>;</return> }</block>



<name>bool</name> <macro><name>wasInQuotes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>InQuotes</name></expr>;</return> }</block>



<name>bool</name> <macro><name>importedModule</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ImportedModule</name></expr>;</return> }</block>



<specifier>const</specifier> <name>FileEntry</name> <operator>*</operator><macro><name>getFile</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>File</name></expr>;</return> }</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const PreprocessedEntity *PE</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>PE</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>InclusionDirectiveKind</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>ExternalPreprocessingRecordSource</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>virtual</name> <operator>~</operator><call><name>ExternalPreprocessingRecordSource</name><argument_list>()</argument_list></call></expr>;





<expr><name>virtual</name> <name>PreprocessedEntity</name> <operator>*</operator><macro><name>ReadPreprocessedEntity</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name>virtual</name> <name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name>
<macro><name>findPreprocessedEntitiesInRange</name><argument_list>(<argument>SourceRange Range</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name>virtual</name> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <macro><name>isPreprocessedEntityInFileID</name><argument_list>(<argument>unsigned Index</argument>,
<argument>FileID FID</argument>)</argument_list></macro> <block>{
<return>return <expr><name>None</name></expr>;</return>
}</block>


<name>virtual</name> <name>SourceRange</name> <macro><name>ReadSkippedRange</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;
}</block></expr>;




<expr><name>class</name> <name>PreprocessingRecord</name> <operator>:</operator> <name>public</name> <name>PPCallbacks</name> <block>{
<expr><name>SourceManager</name> <operator>&amp;</operator><name>SourceMgr</name></expr>;


<expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name> <name>BumpAlloc</name></expr>;



<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>PreprocessedEntity</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>PreprocessedEntities</name></expr>;






<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>PreprocessedEntity</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>LoadedPreprocessedEntities</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>SourceRange</name></expr></argument>&gt;</argument_list></name> <name>SkippedRanges</name></expr>;

<expr><name>bool</name> <name>SkippedRangesAllLoaded</name> <operator>=</operator> <name>true</name></expr>;










<expr><name>class</name> <name>PPEntityID</name> <block>{
<expr><name>friend</name> <name>class</name> <name>PreprocessingRecord</name></expr>;

<expr><name>int</name> <name>ID</name> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>explicit</name> <macro><name>PPEntityID</name><argument_list>(<argument>int ID</argument>)</argument_list></macro> <operator>:</operator> <macro><name>ID</name><argument_list>(<argument>ID</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<call><name>PPEntityID</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
}</block></expr>;

<expr><specifier>static</specifier> <name>PPEntityID</name> <macro><name>getPPEntityID</name><argument_list>(<argument>unsigned Index</argument>, <argument>bool isLoaded</argument>)</argument_list></macro> <block>{
<return>return <expr><name>isLoaded</name> <operator>?</operator> <call><name>PPEntityID</name><argument_list>(<argument><expr><operator>-</operator><call><name>int</name><argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>PPEntityID</name><argument_list>(<argument><expr><name>Index</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>MacroInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>MacroDefinitionRecord</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>MacroDefinitions</name></expr>;


<expr><name>ExternalPreprocessingRecordSource</name> <operator>*</operator><name>ExternalSource</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>PreprocessedEntity</name> <operator>*</operator><macro><name>getPreprocessedEntity</name><argument_list>(<argument>PPEntityID PPID</argument>)</argument_list></macro></expr>;


<expr><name>PreprocessedEntity</name> <operator>*</operator><macro><name>getLoadedPreprocessedEntity</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro></expr>;



<expr><name>unsigned</name> <macro><name>getNumLoadedPreprocessedEntities</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>LoadedPreprocessedEntities</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name>
<macro><name>findLocalPreprocessedEntitiesInRange</name><argument_list>(<argument>SourceRange Range</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>unsigned</name> <macro><name>findBeginLocalPreprocessedEntity</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>unsigned</name> <macro><name>findEndLocalPreprocessedEntity</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <specifier>const</specifier></expr>;





<expr><name>unsigned</name> <macro><name>allocateLoadedEntities</name><argument_list>(<argument>unsigned NumEntities</argument>)</argument_list></macro></expr>;






<expr><name>unsigned</name> <macro><name>allocateSkippedRanges</name><argument_list>(<argument>unsigned NumRanges</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <call><name>ensureSkippedRangesLoaded</name><argument_list>()</argument_list></call></expr>;


<expr><name>void</name> <call><name>RegisterMacroDefinition</name><argument_list>(<argument><expr><name>MacroInfo</name> <operator>*</operator><name>Macro</name></expr></argument>, <argument><expr><name>MacroDefinitionRecord</name> <operator>*</operator><name>Def</name></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>

<name>explicit</name> <call><name>PreprocessingRecord</name><argument_list>(<argument><expr><name>SourceManager</name> <operator>&amp;</operator><name>SM</name></expr></argument>)</argument_list></call></expr>;


<expr><name>void</name> <operator>*</operator><macro><name>Allocate</name><argument_list>(<argument>unsigned Size</argument>, <argument>unsigned Align = <literal type="number">8</literal></argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>BumpAlloc</name><operator>.</operator><name>Allocate</name></name><argument_list>(<argument><expr><name>Size</name></expr></argument>, <argument><expr><name>Align</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>void</name> <macro><name>Deallocate</name><argument_list>(<argument>void *Ptr</argument>)</argument_list></macro> <block>{}</block>

<name>size_t</name> <macro><name>getTotalMemory</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>SourceManager</name> <operator>&amp;</operator><macro><name>getSourceManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SourceMgr</name></expr>;</return> }</block>

















<name>class</name> <name>iterator</name> <operator>:</operator> <name>public</name> <name>llvm</name><operator>::</operator><name><name>iterator_adaptor_base</name><argument_list type="generic">&lt;
<argument><expr><name>iterator</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>random_access_iterator_tag</name></expr></argument>,
<argument><expr><name>PreprocessedEntity</name> <operator>*</operator></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PreprocessedEntity</name> <operator>*</operator></expr></argument>,
<argument><expr><name>PreprocessedEntity</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>PreprocessingRecord</name></expr>;

<expr><name>PreprocessingRecord</name> <operator>*</operator><name>Self</name></expr>;

<macro><name>iterator</name><argument_list>(<argument>PreprocessingRecord *Self</argument>, <argument>int Position</argument>)</argument_list></macro>
<operator>:</operator> <expr><name>iterator</name><operator>::</operator><call><name>iterator_adaptor_base</name><argument_list>(<argument><expr><name>Position</name></expr></argument>)</argument_list></call></expr>, <macro><name>Self</name><argument_list>(<argument>Self</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<call><name>iterator</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>iterator</name><argument_list>(<argument>nullptr</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro> <block>{}</block>

<name>PreprocessedEntity</name> <operator>*</operator><name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<expr><name>bool</name> <name>isLoaded</name> <operator>=</operator> <name><name>this</name><operator>-&gt;</operator><name>I</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;
<expr><name>unsigned</name> <name>Index</name> <operator>=</operator> <ternary><condition><expr><name>isLoaded</name></expr> ?</condition><then>
<expr><call><name><name>Self</name><operator>-&gt;</operator><name>LoadedPreprocessedEntities</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name><name>this</name><operator>-&gt;</operator><name>I</name></name></expr> </then><else>: <expr><name><name>this</name><operator>-&gt;</operator><name>I</name></name></expr></else></ternary></expr>;
<expr><name>PPEntityID</name> <name>ID</name> <operator>=</operator> <call><name><name>Self</name><operator>-&gt;</operator><name>getPPEntityID</name></name><argument_list>(<argument><expr><name>Index</name></expr></argument>, <argument><expr><name>isLoaded</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Self</name><operator>-&gt;</operator><name>getPreprocessedEntity</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>PreprocessedEntity</name> <operator>*</operator><name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr>) <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><operator>*</operator><name>this</name></expr>;</return> }</block></block>
}</expr>;


<expr><name>iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>iterator</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><call><name><name>LoadedPreprocessedEntities</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>iterator</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name><name>PreprocessedEntities</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>iterator</name> <macro><name>local_begin</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>iterator</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>iterator</name> <macro><name>local_end</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>iterator</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name><name>PreprocessedEntities</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>iterator</name></expr></argument>&gt;</argument_list></name> <macro><name>getIteratorsForLoadedRange</name><argument_list>(<argument>unsigned start</argument>,
<argument>unsigned count</argument>)</argument_list></macro> <block>{
<expr><name>unsigned</name> <name>end</name> <operator>=</operator> <name>start</name> <operator>+</operator> <name>count</name></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>end</name> <operator>&lt;=</operator> <call><name><name>LoadedPreprocessedEntities</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>llvm</name><operator>::</operator><call><name>make_range</name><argument_list>(
<argument><expr><call><name>iterator</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>int</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name><name>LoadedPreprocessedEntities</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>iterator</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name>int</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name><name>LoadedPreprocessedEntities</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>iterator</name></expr></argument>&gt;</argument_list></name>
<macro><name>getPreprocessedEntitiesInRange</name><argument_list>(<argument>SourceRange R</argument>)</argument_list></macro></expr>;








<expr><name>bool</name> <macro><name>isEntityInFileID</name><argument_list>(<argument>iterator PPEI</argument>, <argument>FileID FID</argument>)</argument_list></macro></expr>;


<expr><name>PPEntityID</name> <call><name>addPreprocessedEntity</name><argument_list>(<argument><expr><name>PreprocessedEntity</name> <operator>*</operator><name>Entity</name></expr></argument>)</argument_list></call></expr>;


<expr><name>void</name> <call><name>SetExternalSource</name><argument_list>(<argument><expr><name>ExternalPreprocessingRecordSource</name> <operator>&amp;</operator><name>Source</name></expr></argument>)</argument_list></call></expr>;


<expr><name>ExternalPreprocessingRecordSource</name> <operator>*</operator><macro><name>getExternalSource</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ExternalSource</name></expr>;</return>
}</block>



<name>MacroDefinitionRecord</name> <operator>*</operator><call><name>findMacroDefinition</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MacroInfo</name> <operator>*</operator><name>MI</name></expr></argument>)</argument_list></call></expr>;


<expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>SourceRange</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><macro><name>getSkippedRanges</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>ensureSkippedRangesLoaded</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>SkippedRanges</name></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTWriter</name></expr>;

<expr><name>void</name> <macro><name>MacroExpands</name><argument_list>(<argument>const Token &amp;Id</argument>, <argument>const MacroDefinition &amp;MD</argument>,
<argument>SourceRange Range</argument>, <argument>const MacroArgs *Args</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>MacroDefined</name><argument_list>(<argument>const Token &amp;Id</argument>, <argument>const MacroDirective *MD</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>MacroUndefined</name><argument_list>(<argument>const Token &amp;Id</argument>, <argument>const MacroDefinition &amp;MD</argument>,
<argument>const MacroDirective *Undef</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>InclusionDirective</name><argument_list>(<argument>SourceLocation HashLoc</argument>, <argument>const Token &amp;IncludeTok</argument>,
<argument>StringRef FileName</argument>, <argument>bool IsAngled</argument>,
<argument>CharSourceRange FilenameRange</argument>,
<argument>const FileEntry *File</argument>, <argument>StringRef SearchPath</argument>,
<argument>StringRef RelativePath</argument>, <argument>const Module *Imported</argument>,
<argument>SrcMgr::CharacteristicKind FileType</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>Ifdef</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>const Token &amp;MacroNameTok</argument>,
<argument>const MacroDefinition &amp;MD</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>Ifndef</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>const Token &amp;MacroNameTok</argument>,
<argument>const MacroDefinition &amp;MD</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>using</name> <name>PPCallbacks</name><operator>::</operator><name>Elifdef</name></expr>;
<expr><name>using</name> <name>PPCallbacks</name><operator>::</operator><name>Elifndef</name></expr>;
<expr><name>void</name> <macro><name>Elifdef</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>const Token &amp;MacroNameTok</argument>,
<argument>const MacroDefinition &amp;MD</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>Elifndef</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>const Token &amp;MacroNameTok</argument>,
<argument>const MacroDefinition &amp;MD</argument>)</argument_list></macro> <name>override</name></expr>;


<expr><name>void</name> <macro><name>Defined</name><argument_list>(<argument>const Token &amp;MacroNameTok</argument>, <argument>const MacroDefinition &amp;MD</argument>,
<argument>SourceRange Range</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>void</name> <macro><name>SourceRangeSkipped</name><argument_list>(<argument>SourceRange Range</argument>,
<argument>SourceLocation EndifLoc</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>void</name> <macro><name>addMacroExpansion</name><argument_list>(<argument>const Token &amp;Id</argument>, <argument>const MacroInfo *MI</argument>,
<argument>SourceRange Range</argument>)</argument_list></macro></expr>;



struct <expr><block>{
<expr><name>SourceRange</name> <name>Range</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>, <argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <name>Result</name></expr>;
}</block> <name>CachedRangeQuery</name></expr>;

<expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>, <argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <macro><name>getPreprocessedEntitiesInRangeSlow</name><argument_list>(<argument>SourceRange R</argument>)</argument_list></macro></expr>;
}</block></expr>;

}</block>

<specifier>inline</specifier> <name>void</name> <operator>*</operator><name>operator</name> <macro><name>new</name><argument_list>(<argument>size_t bytes</argument>, <argument>clang::PreprocessingRecord &amp;PR</argument>,
<argument>unsigned alignment</argument>)</argument_list></macro> <name>noexcept</name> <block>{
<return>return <expr><call><name><name>PR</name><operator>.</operator><name>Allocate</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>void</name> <name>operator</name> <macro><name>delete</name><argument_list>(<argument>void *ptr</argument>, <argument>clang::PreprocessingRecord &amp;PR</argument>,
<argument>unsigned</argument>)</argument_list></macro> <name>noexcept</name> <block>{
<expr><call><name><name>PR</name><operator>.</operator><name>Deallocate</name></name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></block></expr></block></expr></range></decl></decl_stmt></block_content></block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
