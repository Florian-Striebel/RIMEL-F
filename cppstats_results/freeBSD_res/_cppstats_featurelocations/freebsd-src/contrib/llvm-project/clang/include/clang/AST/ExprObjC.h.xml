<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/ExprObjC.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_EXPROBJC_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_EXPROBJC_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ComputeDependence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DependenceFlags.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/OperationKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/SelectorLocationsKind.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Stmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/IdentifierTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Specifiers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/None.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerIntPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerUnion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/TrailingObjects.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/VersionTuple.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/type_traits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXBaseSpecifier</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>ObjCStringLiteral</name> <range>: <expr><name>public</name> <name>Expr</name> <block>{
<expr><name>Stmt</name> <operator>*</operator><name>String</name></expr>;
<expr><name>SourceLocation</name> <name>AtLoc</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>ObjCStringLiteral</name><argument_list>(<argument>StringLiteral *SL</argument>, <argument>QualType T</argument>, <argument>SourceLocation L</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ObjCStringLiteralClass</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>String</name><argument_list>(<argument><expr><name>SL</name></expr></argument>)</argument_list></call></expr>,
<macro><name>AtLoc</name><argument_list>(<argument>L</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><name>ExprDependence</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>explicit</name> <macro><name>ObjCStringLiteral</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ObjCStringLiteralClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>StringLiteral</name> <operator>*</operator><macro><name>getString</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>StringLiteral</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>StringLiteral</name> <operator>*</operator><macro><name>getString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>StringLiteral</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setString</name><argument_list>(<argument>StringLiteral *S</argument>)</argument_list></macro> <block>{ <expr><name>String</name> <operator>=</operator> <name>S</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getAtLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AtLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setAtLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>AtLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>AtLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>String</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>String</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>String</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>String</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>String</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCStringLiteralClass</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>ObjCBoolLiteralExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>bool</name> <name>Value</name></expr>;
<expr><name>SourceLocation</name> <name>Loc</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>ObjCBoolLiteralExpr</name><argument_list>(<argument>bool val</argument>, <argument>QualType Ty</argument>, <argument>SourceLocation l</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ObjCBoolLiteralExprClass</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Value</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Loc</name><argument_list>(<argument>l</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><name>ExprDependence</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>explicit</name> <macro><name>ObjCBoolLiteralExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ObjCBoolLiteralExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <macro><name>getValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Value</name></expr>;</return> }</block>
<name>void</name> <macro><name>setValue</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{ <expr><name>Value</name> <operator>=</operator> <name>V</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLocation</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>Loc</name> <operator>=</operator> <name>L</name></expr>; }</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCBoolLiteralExprClass</name></expr>;</return>
}</block>
}</expr>;





<expr><name>class</name> <name>ObjCBoxedExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>Stmt</name> <operator>*</operator><name>SubExpr</name></expr>;
<expr><name>ObjCMethodDecl</name> <operator>*</operator><name>BoxingMethod</name></expr>;
<expr><name>SourceRange</name> <name>Range</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<macro><name>ObjCBoxedExpr</name><argument_list>(<argument>Expr *E</argument>, <argument>QualType T</argument>, <argument>ObjCMethodDecl *method</argument>, <argument>SourceRange R</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Expr</name><argument_list>(<argument><expr><name>ObjCBoxedExprClass</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>SubExpr</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>BoxingMethod</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>, <macro><name>Range</name><argument_list>(<argument>R</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>
<name>explicit</name> <macro><name>ObjCBoxedExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ObjCBoxedExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SubExpr</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SubExpr</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>ObjCMethodDecl</name> <operator>*</operator><macro><name>getBoxingMethod</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>BoxingMethod</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>isExpressibleAsConstantInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><name>BoxingMethod</name> <operator>&amp;&amp;</operator> <name>SubExpr</name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getAtLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><name>Range</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubExpr</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubExpr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>const_arg_iterator</name> <operator>=</operator> <name>ConstExprIterator</name></expr>;

<expr><name>const_arg_iterator</name> <macro><name>arg_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <specifier>const</specifier> <operator>*</operator> <specifier>const</specifier><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubExpr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_arg_iterator</name> <macro><name>arg_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <specifier>const</specifier> <operator>*</operator> <specifier>const</specifier><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubExpr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCBoxedExprClass</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>ObjCArrayLiteral</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ObjCArrayLiteral</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>unsigned</name> <name>NumElements</name></expr>;
<expr><name>SourceRange</name> <name>Range</name></expr>;
<expr><name>ObjCMethodDecl</name> <operator>*</operator><name>ArrayWithObjectsMethod</name></expr>;

<macro><name>ObjCArrayLiteral</name><argument_list>(<argument>ArrayRef&lt;Expr *&gt; Elements</argument>,
<argument>QualType T</argument>, <argument>ObjCMethodDecl * Method</argument>,
<argument>SourceRange SR</argument>)</argument_list></macro>;

<expr><name>explicit</name> <macro><name>ObjCArrayLiteral</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>unsigned NumElements</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ObjCArrayLiteralClass</name></expr></argument>, <argument><expr><name>Empty</name></expr></argument>)</argument_list></call></expr>, <macro><name>NumElements</name><argument_list>(<argument>NumElements</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;

<expr><specifier>static</specifier> <name>ObjCArrayLiteral</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>ArrayRef&lt;Expr *&gt; Elements</argument>,
<argument>QualType T</argument>, <argument>ObjCMethodDecl * Method</argument>,
<argument>SourceRange SR</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>ObjCArrayLiteral</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumElements</argument>)</argument_list></macro></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Range</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><operator>*</operator><macro><name>getElements</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<specifier>const</specifier> <name>Expr</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><macro><name>getElements</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>unsigned</name> <macro><name>getNumElements</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumElements</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getElement</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>Index</name> <operator>&lt;</operator> <name>NumElements</name><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Arg access out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getElements</name><argument_list>()</argument_list></call><index>[<expr><name>Index</name></expr>]</index></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getElement</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>Index</name> <operator>&lt;</operator> <name>NumElements</name><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Arg access out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getElements</name><argument_list>()</argument_list></call><index>[<expr><name>Index</name></expr>]</index></expr>;</return>
}</block>

<name>ObjCMethodDecl</name> <operator>*</operator><macro><name>getArrayWithObjectsMethod</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ArrayWithObjectsMethod</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getElements</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getElements</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <name>NumElements</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCArrayLiteral</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCArrayLiteralClass</name></expr>;</return>
}</block>
}</expr>;



struct <expr><name>ObjCDictionaryElement</name> <block>{

<expr><name>Expr</name> <operator>*</operator><name>Key</name></expr>;


<expr><name>Expr</name> <operator>*</operator><name>Value</name></expr>;


<expr><name>SourceLocation</name> <name>EllipsisLoc</name></expr>;



<expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>NumExpansions</name></expr>;


<expr><name>bool</name> <macro><name>isPackExpansion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>EllipsisLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;

}</block>

<name>namespace</name> <name>clang</name> <block>{


struct <expr><name>ObjCDictionaryLiteral_KeyValuePair</name> <block>{
<expr><name>Expr</name> <operator>*</operator><name>Key</name></expr>;
<expr><name>Expr</name> <operator>*</operator><name>Value</name></expr>;
}</block></expr>;




struct <expr><name>ObjCDictionaryLiteral_ExpansionData</name> <block>{


<expr><name>SourceLocation</name> <name>EllipsisLoc</name></expr>;



<expr><name>unsigned</name> <name>NumExpansionsPlusOne</name></expr>;
}</block></expr>;



<expr><name>class</name> <name>ObjCDictionaryLiteral</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ObjCDictionaryLiteral</name></expr></argument>,
<argument><expr><name>ObjCDictionaryLiteral_KeyValuePair</name></expr></argument>,
<argument><expr><name>ObjCDictionaryLiteral_ExpansionData</name></expr></argument>&gt;</argument_list></name> <block>{

<expr><name>unsigned</name> <name>NumElements</name> <operator>:</operator> <literal type="number">31</literal></expr>;








<expr><name>unsigned</name> <name>HasPackExpansions</name> <operator>:</operator> <literal type="number">1</literal></expr>;

<expr><name>SourceRange</name> <name>Range</name></expr>;
<expr><name>ObjCMethodDecl</name> <operator>*</operator><name>DictWithObjectsMethod</name></expr>;

<expr><name>using</name> <name>KeyValuePair</name> <operator>=</operator> <name>ObjCDictionaryLiteral_KeyValuePair</name></expr>;
<expr><name>using</name> <name>ExpansionData</name> <operator>=</operator> <name>ObjCDictionaryLiteral_ExpansionData</name></expr>;

<macro><name>ObjCDictionaryLiteral</name><argument_list>(<argument>ArrayRef&lt;ObjCDictionaryElement&gt; VK</argument>,
<argument>bool HasPackExpansions</argument>,
<argument>QualType T</argument>, <argument>ObjCMethodDecl *method</argument>,
<argument>SourceRange SR</argument>)</argument_list></macro>;

<expr><name>explicit</name> <macro><name>ObjCDictionaryLiteral</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>unsigned NumElements</argument>,
<argument>bool HasPackExpansions</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ObjCDictionaryLiteralClass</name></expr></argument>, <argument><expr><name>Empty</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NumElements</name><argument_list>(<argument><expr><name>NumElements</name></expr></argument>)</argument_list></call></expr>,
<macro><name>HasPackExpansions</name><argument_list>(<argument>HasPackExpansions</argument>)</argument_list></macro> <expr><block>{}</block>

<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;KeyValuePair&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumElements</name></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;

<expr><specifier>static</specifier> <name>ObjCDictionaryLiteral</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>ArrayRef&lt;ObjCDictionaryElement&gt; VK</argument>,
<argument>bool HasPackExpansions</argument>,
<argument>QualType T</argument>, <argument>ObjCMethodDecl *method</argument>,
<argument>SourceRange SR</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>ObjCDictionaryLiteral</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumElements</argument>,
<argument>bool HasPackExpansions</argument>)</argument_list></macro></expr>;



<expr><name>unsigned</name> <macro><name>getNumElements</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumElements</name></expr>;</return> }</block>

<name>ObjCDictionaryElement</name> <macro><name>getKeyValueElement</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>Index</name> <operator>&lt;</operator> <name>NumElements</name><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Arg access out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>KeyValuePair</name> <operator>&amp;</operator><name>KV</name> <operator>=</operator> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>KeyValuePair</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>Index</name></expr>]</index></expr>;
<expr><name>ObjCDictionaryElement</name> <name>Result</name> <operator>=</operator> <block>{ <expr><name><name>KV</name><operator>.</operator><name>Key</name></name></expr>, <expr><name><name>KV</name><operator>.</operator><name>Value</name></name></expr>, <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>, <expr><name>None</name></expr> }</block></expr>;
<if_stmt><if>if <condition>(<expr><name>HasPackExpansions</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ExpansionData</name> <modifier>&amp;</modifier></type><name>Expansion</name> <init>=
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ExpansionData</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>Index</name></expr>]</index></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>EllipsisLoc</name></name> <operator>=</operator> <name><name>Expansion</name><operator>.</operator><name>EllipsisLoc</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>Expansion</name><operator>.</operator><name>NumExpansionsPlusOne</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>NumExpansions</name></name> <operator>=</operator> <name><name>Expansion</name><operator>.</operator><name>NumExpansionsPlusOne</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt/>}</block_content>
return Result</block><empty_stmt>;</empty_stmt></if></if_stmt>
}</block>

<name>ObjCMethodDecl</name> <operator>*</operator><macro><name>getDictWithObjectsMethod</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>DictWithObjectsMethod</name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Range</name></expr>;</return> }</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{


<expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>KeyValuePair</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>,
<argument><expr><literal type="string">"KeyValuePair is expected size"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>child_range</name><argument_list>(
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>KeyValuePair</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>KeyValuePair</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator>
<name>NumElements</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCDictionaryLiteral</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCDictionaryLiteralClass</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>ObjCEncodeExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>EncodedType</name></expr>;
<expr><name>SourceLocation</name> <name>AtLoc</name></expr>, <expr><name>RParenLoc</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>ObjCEncodeExpr</name><argument_list>(<argument>QualType T</argument>, <argument>TypeSourceInfo *EncodedType</argument>, <argument>SourceLocation at</argument>,
<argument>SourceLocation rp</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ObjCEncodeExprClass</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK_LValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>EncodedType</name><argument_list>(<argument><expr><name>EncodedType</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>AtLoc</name><argument_list>(<argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>, <macro><name>RParenLoc</name><argument_list>(<argument>rp</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>explicit</name> <macro><name>ObjCEncodeExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ObjCEncodeExprClass</argument>, <argument>Empty</argument>)</argument_list></macro><block>{}</block>

<name>SourceLocation</name> <macro><name>getAtLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AtLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setAtLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>AtLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>QualType</name> <macro><name>getEncodedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>EncodedType</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getEncodedTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>EncodedType</name></expr>;</return> }</block>

<name>void</name> <macro><name>setEncodedTypeSourceInfo</name><argument_list>(<argument>TypeSourceInfo *EncType</argument>)</argument_list></macro> <block>{
<expr><name>EncodedType</name> <operator>=</operator> <name>EncType</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>AtLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCEncodeExprClass</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>ObjCSelectorExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>Selector</name> <name>SelName</name></expr>;
<expr><name>SourceLocation</name> <name>AtLoc</name></expr>, <expr><name>RParenLoc</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>ObjCSelectorExpr</name><argument_list>(<argument>QualType T</argument>, <argument>Selector selInfo</argument>, <argument>SourceLocation at</argument>,
<argument>SourceLocation rp</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ObjCSelectorExprClass</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SelName</name><argument_list>(<argument><expr><name>selInfo</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>AtLoc</name><argument_list>(<argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>, <macro><name>RParenLoc</name><argument_list>(<argument>rp</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><name>ExprDependence</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>explicit</name> <macro><name>ObjCSelectorExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ObjCSelectorExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>Selector</name> <macro><name>getSelector</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SelName</name></expr>;</return> }</block>
<name>void</name> <macro><name>setSelector</name><argument_list>(<argument>Selector S</argument>)</argument_list></macro> <block>{ <expr><name>SelName</name> <operator>=</operator> <name>S</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getAtLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AtLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setAtLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>AtLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>AtLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>


<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>SelName</name><operator>.</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCSelectorExprClass</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>ObjCProtocolExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>ObjCProtocolDecl</name> <operator>*</operator><name>TheProtocol</name></expr>;
<expr><name>SourceLocation</name> <name>AtLoc</name></expr>, <expr><name>ProtoLoc</name></expr>, <expr><name>RParenLoc</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;

<macro><name>ObjCProtocolExpr</name><argument_list>(<argument>QualType T</argument>, <argument>ObjCProtocolDecl *protocol</argument>, <argument>SourceLocation at</argument>,
<argument>SourceLocation protoLoc</argument>, <argument>SourceLocation rp</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Expr</name><argument_list>(<argument><expr><name>ObjCProtocolExprClass</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TheProtocol</name><argument_list>(<argument><expr><name>protocol</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>AtLoc</name><argument_list>(<argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ProtoLoc</name><argument_list>(<argument><expr><name>protoLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>RParenLoc</name><argument_list>(<argument>rp</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><name>ExprDependence</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>explicit</name> <macro><name>ObjCProtocolExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ObjCProtocolExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>ObjCProtocolDecl</name> <operator>*</operator><macro><name>getProtocol</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TheProtocol</name></expr>;</return> }</block>
<name>void</name> <macro><name>setProtocol</name><argument_list>(<argument>ObjCProtocolDecl *P</argument>)</argument_list></macro> <block>{ <expr><name>TheProtocol</name> <operator>=</operator> <name>P</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getProtocolIdLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ProtoLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getAtLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AtLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setAtLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>AtLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>AtLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCProtocolExprClass</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>ObjCIvarRefExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>ObjCIvarDecl</name> <operator>*</operator><name>D</name></expr>;
<expr><name>Stmt</name> <operator>*</operator><name>Base</name></expr>;
<expr><name>SourceLocation</name> <name>Loc</name></expr>;


<expr><name>SourceLocation</name> <name>OpLoc</name></expr>;


<expr><name>bool</name> <name>IsArrow</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>bool</name> <name>IsFreeIvar</name> <operator>:</operator> <literal type="number">1</literal></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>ObjCIvarRefExpr</name><argument_list>(<argument>ObjCIvarDecl *d</argument>, <argument>QualType t</argument>, <argument>SourceLocation l</argument>,
<argument>SourceLocation oploc</argument>, <argument>Expr *base</argument>, <argument>bool arrow = false</argument>,
<argument>bool freeIvar = false</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ObjCIvarRefExprClass</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>VK_LValue</name></expr></argument>,
<argument><expr><ternary><condition><expr><call><name><name>d</name><operator>-&gt;</operator><name>isBitField</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>OK_BitField</name></expr> </then><else>: <expr><name>OK_Ordinary</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>,
<expr><call><name>D</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Base</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Loc</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>OpLoc</name><argument_list>(<argument><expr><name>oploc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>IsArrow</name><argument_list>(<argument><expr><name>arrow</name></expr></argument>)</argument_list></call></expr>,
<macro><name>IsFreeIvar</name><argument_list>(<argument>freeIvar</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>explicit</name> <macro><name>ObjCIvarRefExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ObjCIvarRefExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>ObjCIvarDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>D</name></expr>;</return> }</block>
<specifier>const</specifier> <name>ObjCIvarDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>D</name></expr>;</return> }</block>
<name>void</name> <macro><name>setDecl</name><argument_list>(<argument>ObjCIvarDecl *d</argument>)</argument_list></macro> <block>{ <expr><name>D</name> <operator>=</operator> <name>d</name></expr>; }</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Base</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Base</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setBase</name><argument_list>(<argument>Expr * base</argument>)</argument_list></macro> <block>{ <expr><name>Base</name> <operator>=</operator> <name>base</name></expr>; }</block>

<name>bool</name> <macro><name>isArrow</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsArrow</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isFreeIvar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsFreeIvar</name></expr>;</return> }</block>
<name>void</name> <macro><name>setIsArrow</name><argument_list>(<argument>bool A</argument>)</argument_list></macro> <block>{ <expr><name>IsArrow</name> <operator>=</operator> <name>A</name></expr>; }</block>
<name>void</name> <macro><name>setIsFreeIvar</name><argument_list>(<argument>bool A</argument>)</argument_list></macro> <block>{ <expr><name>IsFreeIvar</name> <operator>=</operator> <name>A</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLocation</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>Loc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><ternary><condition><expr><call><name>isFreeIvar</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>Loc</name></expr> </then><else>: <expr><call><name>getBase</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getOpLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OpLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setOpLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>OpLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Base</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Base</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCIvarRefExprClass</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>ObjCPropertyRefExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>private</name><operator>:</operator>




<name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>PropertyOrGetter</name></expr>;




enum <expr><name>MethodRefFlags</name> <block>{
<expr><name>MethodRef_None</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><name>MethodRef_Getter</name> <operator>=</operator> <literal type="number">0x1</literal></expr>,
<expr><name>MethodRef_Setter</name> <operator>=</operator> <literal type="number">0x2</literal></expr>
}</block></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>SetterAndMethodRefFlags</name></expr>;






<expr><name>SourceLocation</name> <name>IdLoc</name></expr>;




<expr><name>SourceLocation</name> <name>ReceiverLoc</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator></expr></argument>, <argument><expr><name>ObjCInterfaceDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Receiver</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>ObjCPropertyRefExpr</name><argument_list>(<argument>ObjCPropertyDecl *PD</argument>, <argument>QualType t</argument>, <argument>ExprValueKind VK</argument>,
<argument>ExprObjectKind OK</argument>, <argument>SourceLocation l</argument>, <argument>Expr *base</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ObjCPropertyRefExprClass</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>OK</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>PropertyOrGetter</name><argument_list>(<argument><expr><name>PD</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>IdLoc</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>, <macro><name>Receiver</name><argument_list>(<argument>base</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>t</name><operator>-&gt;</operator><name>isSpecificPlaceholderType</name></name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>PseudoObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>ObjCPropertyRefExpr</name><argument_list>(<argument>ObjCPropertyDecl *PD</argument>, <argument>QualType t</argument>, <argument>ExprValueKind VK</argument>,
<argument>ExprObjectKind OK</argument>, <argument>SourceLocation l</argument>, <argument>SourceLocation sl</argument>,
<argument>QualType st</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ObjCPropertyRefExprClass</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>OK</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>PropertyOrGetter</name><argument_list>(<argument><expr><name>PD</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>IdLoc</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ReceiverLoc</name><argument_list>(<argument><expr><name>sl</name></expr></argument>)</argument_list></call></expr>, <macro><name>Receiver</name><argument_list>(<argument>st.getTypePtr()</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>t</name><operator>-&gt;</operator><name>isSpecificPlaceholderType</name></name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>PseudoObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>ObjCPropertyRefExpr</name><argument_list>(<argument>ObjCMethodDecl *Getter</argument>, <argument>ObjCMethodDecl *Setter</argument>,
<argument>QualType T</argument>, <argument>ExprValueKind VK</argument>, <argument>ExprObjectKind OK</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>Expr *Base</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ObjCPropertyRefExprClass</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>OK</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>PropertyOrGetter</name><argument_list>(<argument><expr><name>Getter</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>SetterAndMethodRefFlags</name><argument_list>(<argument><expr><name>Setter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>IdLoc</name><argument_list>(<argument><expr><name>IdLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>Receiver</name><argument_list>(<argument>Base</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>isSpecificPlaceholderType</name></name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>PseudoObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>ObjCPropertyRefExpr</name><argument_list>(<argument>ObjCMethodDecl *Getter</argument>, <argument>ObjCMethodDecl *Setter</argument>,
<argument>QualType T</argument>, <argument>ExprValueKind VK</argument>, <argument>ExprObjectKind OK</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>SourceLocation SuperLoc</argument>,
<argument>QualType SuperTy</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ObjCPropertyRefExprClass</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>OK</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>PropertyOrGetter</name><argument_list>(<argument><expr><name>Getter</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>SetterAndMethodRefFlags</name><argument_list>(<argument><expr><name>Setter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>IdLoc</name><argument_list>(<argument><expr><name>IdLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ReceiverLoc</name><argument_list>(<argument><expr><name>SuperLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>Receiver</name><argument_list>(<argument>SuperTy.getTypePtr()</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>isSpecificPlaceholderType</name></name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>PseudoObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>ObjCPropertyRefExpr</name><argument_list>(<argument>ObjCMethodDecl *Getter</argument>, <argument>ObjCMethodDecl *Setter</argument>,
<argument>QualType T</argument>, <argument>ExprValueKind VK</argument>, <argument>ExprObjectKind OK</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>SourceLocation ReceiverLoc</argument>,
<argument>ObjCInterfaceDecl *Receiver</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ObjCPropertyRefExprClass</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>OK</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>PropertyOrGetter</name><argument_list>(<argument><expr><name>Getter</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>SetterAndMethodRefFlags</name><argument_list>(<argument><expr><name>Setter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>IdLoc</name><argument_list>(<argument><expr><name>IdLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ReceiverLoc</name><argument_list>(<argument><expr><name>ReceiverLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>Receiver</name><argument_list>(<argument>Receiver</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>isSpecificPlaceholderType</name></name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>PseudoObject</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>explicit</name> <macro><name>ObjCPropertyRefExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ObjCPropertyRefExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <macro><name>isImplicitProperty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>PropertyOrGetter</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>isExplicitProperty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name><name>PropertyOrGetter</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>ObjCPropertyDecl</name> <operator>*</operator><macro><name>getExplicitProperty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isImplicitProperty</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCPropertyDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>PropertyOrGetter</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>ObjCMethodDecl</name> <operator>*</operator><macro><name>getImplicitPropertyGetter</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isImplicitProperty</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>PropertyOrGetter</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>ObjCMethodDecl</name> <operator>*</operator><macro><name>getImplicitPropertySetter</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isImplicitProperty</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>SetterAndMethodRefFlags</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>Selector</name> <macro><name>getGetterSelector</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isImplicitProperty</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getImplicitPropertyGetter</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getSelector</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getExplicitProperty</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getGetterName</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>Selector</name> <macro><name>getSetterSelector</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isImplicitProperty</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getImplicitPropertySetter</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getSelector</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getExplicitProperty</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getSetterName</name><argument_list>()</argument_list></call></expr>;</return>
}</block>




<name>bool</name> <macro><name>isMessagingGetter</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>SetterAndMethodRefFlags</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>MethodRef_Getter</name></expr>;</return>
}</block>




<name>bool</name> <macro><name>isMessagingSetter</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>SetterAndMethodRefFlags</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>MethodRef_Setter</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setIsMessagingGetter</name><argument_list>(<argument>bool val = true</argument>)</argument_list></macro> <block>{
<expr><call><name>setMethodRefFlag</name><argument_list>(<argument><expr><name>MethodRef_Getter</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>setIsMessagingSetter</name><argument_list>(<argument>bool val = true</argument>)</argument_list></macro> <block>{
<expr><call><name>setMethodRefFlag</name><argument_list>(<argument><expr><name>MethodRef_Setter</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>Receiver</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>Stmt</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>Receiver</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>Stmt</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IdLoc</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getReceiverLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ReceiverLoc</name></expr>;</return> }</block>

<name>QualType</name> <macro><name>getSuperReceiverType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name><name>Receiver</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><specifier>const</specifier> <name>Type</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getClassReceiver</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Receiver</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>ObjCInterfaceDecl</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>

<name>bool</name> <macro><name>isObjectReceiver</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Receiver</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>Stmt</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block>
<name>bool</name> <macro><name>isSuperReceiver</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Receiver</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><specifier>const</specifier> <name>Type</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block>
<name>bool</name> <macro><name>isClassReceiver</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Receiver</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>ObjCInterfaceDecl</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block>


<name>QualType</name> <macro><name>getReceiverType</name><argument_list>(<argument>const ASTContext &amp;ctx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>isObjectReceiver</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name>getBase</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>getReceiverLocation</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>IdLoc</name></expr>;</return> }</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name><name>Receiver</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>Stmt</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>begin</name> <init>= <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name><operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Receiver</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>begin</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>
return child_range(child_iterator(</block></if></if_stmt>), <call><name>child_iterator</name><argument_list>()</argument_list></call>)</block></expr>;
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCPropertyRefExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCPropertyRefExprClass</name></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;

<expr><name>void</name> <macro><name>setExplicitProperty</name><argument_list>(<argument>ObjCPropertyDecl *D</argument>, <argument>unsigned methRefFlags</argument>)</argument_list></macro> <block>{
<expr><call><name><name>PropertyOrGetter</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>PropertyOrGetter</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>SetterAndMethodRefFlags</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>SetterAndMethodRefFlags</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>methRefFlags</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>setImplicitProperty</name><argument_list>(<argument>ObjCMethodDecl *Getter</argument>, <argument>ObjCMethodDecl *Setter</argument>,
<argument>unsigned methRefFlags</argument>)</argument_list></macro> <block>{
<expr><call><name><name>PropertyOrGetter</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><name>Getter</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>PropertyOrGetter</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>SetterAndMethodRefFlags</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><name>Setter</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>SetterAndMethodRefFlags</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>methRefFlags</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>setBase</name><argument_list>(<argument>Expr *Base</argument>)</argument_list></macro> <block>{ <expr><name>Receiver</name> <operator>=</operator> <name>Base</name></expr>; }</block>
<name>void</name> <macro><name>setSuperReceiver</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <block>{ <expr><name>Receiver</name> <operator>=</operator> <call><name><name>T</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>; }</block>
<name>void</name> <macro><name>setClassReceiver</name><argument_list>(<argument>ObjCInterfaceDecl *D</argument>)</argument_list></macro> <block>{ <expr><name>Receiver</name> <operator>=</operator> <name>D</name></expr>; }</block>

<name>void</name> <macro><name>setLocation</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>IdLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>void</name> <macro><name>setReceiverLocation</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>ReceiverLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>void</name> <macro><name>setMethodRefFlag</name><argument_list>(<argument>MethodRefFlags flag</argument>, <argument>bool val</argument>)</argument_list></macro> <block>{
<expr><name>unsigned</name> <name>f</name> <operator>=</operator> <call><name><name>SetterAndMethodRefFlags</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>f</name> <operator>|=</operator> <name>flag</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>f</name> <operator>&amp;=</operator> <operator>~</operator><name>flag</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<call><name><name>SetterAndMethodRefFlags</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></block></expr>;
}</block></expr>
}</block></expr>;



<expr><name>class</name> <name>ObjCSubscriptRefExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{

<expr><name>SourceLocation</name> <name>RBracket</name></expr>;




enum <expr><block>{ <expr><name>BASE</name></expr>, <expr><name>KEY</name></expr>, <expr><name>END_EXPR</name></expr> }</block></expr>;
<expr><name>Stmt</name><operator>*</operator> <name><name>SubExprs</name><index>[<expr><name>END_EXPR</name></expr>]</index></name></expr>;

<expr><name>ObjCMethodDecl</name> <operator>*</operator><name>GetAtIndexMethodDecl</name></expr>;



<expr><name>ObjCMethodDecl</name> <operator>*</operator><name>SetAtIndexMethodDecl</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>ObjCSubscriptRefExpr</name><argument_list>(<argument>Expr *base</argument>, <argument>Expr *key</argument>, <argument>QualType T</argument>, <argument>ExprValueKind VK</argument>,
<argument>ExprObjectKind OK</argument>, <argument>ObjCMethodDecl *getMethod</argument>,
<argument>ObjCMethodDecl *setMethod</argument>, <argument>SourceLocation RB</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ObjCSubscriptRefExprClass</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>OK</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>RBracket</name><argument_list>(<argument><expr><name>RB</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>GetAtIndexMethodDecl</name><argument_list>(<argument><expr><name>getMethod</name></expr></argument>)</argument_list></call></expr>, <macro><name>SetAtIndexMethodDecl</name><argument_list>(<argument>setMethod</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>SubExprs</name><index>[<expr><name>BASE</name></expr>]</index></name> <operator>=</operator> <name>base</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>KEY</name></expr>]</index></name> <operator>=</operator> <name>key</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>explicit</name> <macro><name>ObjCSubscriptRefExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ObjCSubscriptRefExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>SourceLocation</name> <macro><name>getRBracket</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RBracket</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRBracket</name><argument_list>(<argument>SourceLocation RB</argument>)</argument_list></macro> <block>{ <expr><name>RBracket</name> <operator>=</operator> <name>RB</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><name><name>SubExprs</name><index>[<expr><name>BASE</name></expr>]</index></name><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RBracket</name></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getBaseExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>BASE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setBaseExpr</name><argument_list>(<argument>Stmt *S</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>BASE</name></expr>]</index></name> <operator>=</operator> <name>S</name></expr>; }</block>

<name>Expr</name> <operator>*</operator><macro><name>getKeyExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>KEY</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setKeyExpr</name><argument_list>(<argument>Stmt *S</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>KEY</name></expr>]</index></name> <operator>=</operator> <name>S</name></expr>; }</block>

<name>ObjCMethodDecl</name> <operator>*</operator><macro><name>getAtIndexMethodDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>GetAtIndexMethodDecl</name></expr>;</return>
}</block>

<name>ObjCMethodDecl</name> <operator>*</operator><macro><name>setAtIndexMethodDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>SetAtIndexMethodDecl</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isArraySubscriptRefExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getKeyExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isIntegralOrEnumerationType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><name>SubExprs</name><operator>+</operator><name>END_EXPR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><name>SubExprs</name> <operator>+</operator> <name>END_EXPR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCSubscriptRefExprClass</name></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
}</block></expr>;



























<expr><name>class</name> <name>ObjCMessageExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMessageExpr</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <block>{



<expr><name>uintptr_t</name> <name>SelectorOrMethod</name> <operator>=</operator> <literal type="number">0</literal></expr>;

enum <expr><block>{ <expr><name>NumArgsBitWidth</name> <operator>=</operator> <literal type="number">16</literal></expr> }</block></expr>;



<expr><name>unsigned</name> <name>NumArgs</name> <operator>:</operator> <name>NumArgsBitWidth</name></expr>;





<expr><name>unsigned</name> <name>Kind</name> <operator>:</operator> <literal type="number">8</literal></expr>;






<expr><name>unsigned</name> <name>HasMethod</name> <operator>:</operator> <literal type="number">1</literal></expr>;



<expr><name>unsigned</name> <name>IsDelegateInitCall</name> <operator>:</operator> <literal type="number">1</literal></expr>;



<expr><name>unsigned</name> <name>IsImplicit</name> <operator>:</operator> <literal type="number">1</literal></expr>;



<expr><name>unsigned</name> <name>SelLocsKind</name> <operator>:</operator> <literal type="number">2</literal></expr>;



<expr><name>SourceLocation</name> <name>SuperLoc</name></expr>;



<expr><name>SourceLocation</name> <name>LBracLoc</name></expr>, <expr><name>RBracLoc</name></expr>;

<macro><name>ObjCMessageExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>unsigned NumArgs</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Expr</name><argument_list>(<argument><expr><name>ObjCMessageExprClass</name></expr></argument>, <argument><expr><name>Empty</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Kind</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>HasMethod</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>IsDelegateInitCall</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>IsImplicit</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>, <macro><name>SelLocsKind</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setNumArgs</name><argument_list>(<argument><expr><name>NumArgs</name></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>ObjCMessageExpr</name><argument_list>(<argument>QualType T</argument>, <argument>ExprValueKind VK</argument>,
<argument>SourceLocation LBracLoc</argument>,
<argument>SourceLocation SuperLoc</argument>,
<argument>bool IsInstanceSuper</argument>,
<argument>QualType SuperType</argument>,
<argument>Selector Sel</argument>,
<argument>ArrayRef&lt;SourceLocation&gt; SelLocs</argument>,
<argument>SelectorLocationsKind SelLocsK</argument>,
<argument>ObjCMethodDecl *Method</argument>,
<argument>ArrayRef&lt;Expr *&gt; Args</argument>,
<argument>SourceLocation RBracLoc</argument>,
<argument>bool isImplicit</argument>)</argument_list></macro></expr>;
<macro><name>ObjCMessageExpr</name><argument_list>(<argument>QualType T</argument>, <argument>ExprValueKind VK</argument>,
<argument>SourceLocation LBracLoc</argument>,
<argument>TypeSourceInfo *Receiver</argument>,
<argument>Selector Sel</argument>,
<argument>ArrayRef&lt;SourceLocation&gt; SelLocs</argument>,
<argument>SelectorLocationsKind SelLocsK</argument>,
<argument>ObjCMethodDecl *Method</argument>,
<argument>ArrayRef&lt;Expr *&gt; Args</argument>,
<argument>SourceLocation RBracLoc</argument>,
<argument>bool isImplicit</argument>)</argument_list></macro>;
<macro><name>ObjCMessageExpr</name><argument_list>(<argument>QualType T</argument>, <argument>ExprValueKind VK</argument>,
<argument>SourceLocation LBracLoc</argument>,
<argument>Expr *Receiver</argument>,
<argument>Selector Sel</argument>,
<argument>ArrayRef&lt;SourceLocation&gt; SelLocs</argument>,
<argument>SelectorLocationsKind SelLocsK</argument>,
<argument>ObjCMethodDecl *Method</argument>,
<argument>ArrayRef&lt;Expr *&gt; Args</argument>,
<argument>SourceLocation RBracLoc</argument>,
<argument>bool isImplicit</argument>)</argument_list></macro>;

<expr><name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;void *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumArgs</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return> }</block>

<name>void</name> <macro><name>setNumArgs</name><argument_list>(<argument>unsigned Num</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>Num</name> <operator>&gt;&gt;</operator> <name>NumArgsBitWidth</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="string">"Num of args is out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>NumArgs</name> <operator>=</operator> <name>Num</name></expr>;
}</block>

<name>void</name> <macro><name>initArgsAndSelLocs</name><argument_list>(<argument>ArrayRef&lt;Expr *&gt; Args</argument>,
<argument>ArrayRef&lt;SourceLocation&gt; SelLocs</argument>,
<argument>SelectorLocationsKind SelLocsK</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <operator>*</operator><macro><name>getReceiverPointer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>void</name> <macro><name>setReceiverPointer</name><argument_list>(<argument>void *Value</argument>)</argument_list></macro> <block>{
<expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>=</operator> <name>Value</name></expr>;
}</block>

<name>SelectorLocationsKind</name> <macro><name>getSelLocsKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>SelectorLocationsKind</name><operator>)</operator><name>SelLocsKind</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasStandardSelLocs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getSelLocsKind</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SelLoc_NonStandard</name></expr>;</return>
}</block>



<name>SourceLocation</name> <operator>*</operator><macro><name>getStoredSelLocs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>SourceLocation</name> <operator>*</operator><macro><name>getStoredSelLocs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>unsigned</name> <macro><name>getNumStoredSelLocs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasStandardSelLocs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getNumSelectorLocs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>ObjCMessageExpr</name> <operator>*</operator><macro><name>alloc</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>ArrayRef&lt;Expr *&gt; Args</argument>,
<argument>SourceLocation RBraceLoc</argument>,
<argument>ArrayRef&lt;SourceLocation&gt; SelLocs</argument>,
<argument>Selector Sel</argument>,
<argument>SelectorLocationsKind &amp;SelLocsK</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>ObjCMessageExpr</name> <operator>*</operator><macro><name>alloc</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumArgs</argument>,
<argument>unsigned NumStoredSelLocs</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


enum <expr><name>ReceiverKind</name> <block>{

<expr><name>Class</name> <operator>=</operator> <literal type="number">0</literal></expr>,


<expr><name>Instance</name></expr>,


<expr><name>SuperClass</name></expr>,


<expr><name>SuperInstance</name></expr>
}</block></expr>;


























<expr><specifier>static</specifier> <name>ObjCMessageExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>QualType T</argument>,
<argument>ExprValueKind VK</argument>,
<argument>SourceLocation LBracLoc</argument>,
<argument>SourceLocation SuperLoc</argument>,
<argument>bool IsInstanceSuper</argument>,
<argument>QualType SuperType</argument>,
<argument>Selector Sel</argument>,
<argument>ArrayRef&lt;SourceLocation&gt; SelLocs</argument>,
<argument>ObjCMethodDecl *Method</argument>,
<argument>ArrayRef&lt;Expr *&gt; Args</argument>,
<argument>SourceLocation RBracLoc</argument>,
<argument>bool isImplicit</argument>)</argument_list></macro></expr>;
























<expr><specifier>static</specifier> <name>ObjCMessageExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>QualType T</argument>,
<argument>ExprValueKind VK</argument>,
<argument>SourceLocation LBracLoc</argument>,
<argument>TypeSourceInfo *Receiver</argument>,
<argument>Selector Sel</argument>,
<argument>ArrayRef&lt;SourceLocation&gt; SelLocs</argument>,
<argument>ObjCMethodDecl *Method</argument>,
<argument>ArrayRef&lt;Expr *&gt; Args</argument>,
<argument>SourceLocation RBracLoc</argument>,
<argument>bool isImplicit</argument>)</argument_list></macro></expr>;
























<expr><specifier>static</specifier> <name>ObjCMessageExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>QualType T</argument>,
<argument>ExprValueKind VK</argument>,
<argument>SourceLocation LBracLoc</argument>,
<argument>Expr *Receiver</argument>,
<argument>Selector Sel</argument>,
<argument>ArrayRef&lt;SourceLocation&gt; SeLocs</argument>,
<argument>ObjCMethodDecl *Method</argument>,
<argument>ArrayRef&lt;Expr *&gt; Args</argument>,
<argument>SourceLocation RBracLoc</argument>,
<argument>bool isImplicit</argument>)</argument_list></macro></expr>;








<expr><specifier>static</specifier> <name>ObjCMessageExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Context</argument>,
<argument>unsigned NumArgs</argument>,
<argument>unsigned NumStoredSelLocs</argument>)</argument_list></macro></expr>;




<expr><name>bool</name> <macro><name>isImplicit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsImplicit</name></expr>;</return> }</block>



<name>ReceiverKind</name> <macro><name>getReceiverKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>ReceiverKind</name><operator>)</operator><name>Kind</name></expr>;</return> }</block>






<name>QualType</name> <macro><name>getCallReturnType</name><argument_list>(<argument>ASTContext &amp;Ctx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>SourceRange</name> <macro><name>getReceiverRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isInstanceMessage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getReceiverKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Instance</name> <operator>||</operator> <call><name>getReceiverKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>SuperInstance</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>isClassMessage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getReceiverKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Class</name> <operator>||</operator> <call><name>getReceiverKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>SuperClass</name></expr>;</return>
}</block>



<name>Expr</name> <operator>*</operator><macro><name>getInstanceReceiver</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getReceiverKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Instance</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getReceiverPointer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><name>nullptr</name></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getInstanceReceiver</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMessageExpr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getInstanceReceiver</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>void</name> <macro><name>setInstanceReceiver</name><argument_list>(<argument>Expr *rec</argument>)</argument_list></macro> <block>{
<expr><name>Kind</name> <operator>=</operator> <name>Instance</name></expr>;
<expr><call><name>setReceiverPointer</name><argument_list>(<argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;
}</block>



<name>QualType</name> <macro><name>getClassReceiver</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSInfo</name> <init>= <expr><call><name>getClassReceiverTypeInfo</name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>TSInfo</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><block>{}</block></expr>;</return>
}</block>



<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getClassReceiverTypeInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getReceiverKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Class</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getReceiverPointer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>nullptr</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setClassReceiver</name><argument_list>(<argument>TypeSourceInfo *TSInfo</argument>)</argument_list></macro> <block>{
<expr><name>Kind</name> <operator>=</operator> <name>Class</name></expr>;
<expr><call><name>setReceiverPointer</name><argument_list>(<argument><expr><name>TSInfo</name></expr></argument>)</argument_list></call></expr>;
}</block>



<name>SourceLocation</name> <macro><name>getSuperLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getReceiverKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>SuperInstance</name> <operator>||</operator> <call><name>getReceiverKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>SuperClass</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SuperLoc</name></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return>
}</block>










<name>QualType</name> <macro><name>getReceiverType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;











<expr><name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getReceiverInterface</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;






<expr><name>QualType</name> <macro><name>getSuperType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getReceiverKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>SuperInstance</name> <operator>||</operator> <call><name>getReceiverKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>SuperClass</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>QualType</name><operator>::</operator><call><name>getFromOpaquePtr</name><argument_list>(<argument><expr><call><name>getReceiverPointer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setSuper</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>QualType T</argument>, <argument>bool IsInstanceSuper</argument>)</argument_list></macro> <block>{
<expr><name>Kind</name> <operator>=</operator> <name>IsInstanceSuper</name><operator>?</operator> <name>SuperInstance</name> <operator>:</operator> <name>SuperClass</name></expr>;
<expr><name>SuperLoc</name> <operator>=</operator> <name>Loc</name></expr>;
<expr><call><name>setReceiverPointer</name><argument_list>(<argument><expr><call><name><name>T</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>Selector</name> <macro><name>getSelector</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>void</name> <macro><name>setSelector</name><argument_list>(<argument>Selector S</argument>)</argument_list></macro> <block>{
<expr><name>HasMethod</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>SelectorOrMethod</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>uintptr_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>S</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>const</specifier> <name>ObjCMethodDecl</name> <operator>*</operator><macro><name>getMethodDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>HasMethod</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ObjCMethodDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SelectorOrMethod</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><name>nullptr</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<function><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>getMethodDecl</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>HasMethod</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SelectorOrMethod</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>nullptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setMethodDecl</name><parameter_list>(<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>HasMethod</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>SelectorOrMethod</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>uintptr_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>MD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>ObjCMethodFamily</name> <macro><name>getMethodFamily</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>HasMethod</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>getMethodDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getMethodFamily</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getSelector</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getMethodFamily</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumArgs</name></expr>;</return> }</block></expr></expr_stmt>



<function><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>getArgs</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><macro><name>getArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>Expr</name> <modifier>*</modifier></type><name>getArg</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>Arg</name> <operator>&lt;</operator> <name>NumArgs</name> <operator>&amp;&amp;</operator> <literal type="string">"Arg access out of range!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>getArgs</name><argument_list>()</argument_list></call><index>[<expr><name>Arg</name></expr>]</index></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>getArg</name><argument_list>(<argument><expr><name>unsigned</name> <name>Arg</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>Arg</name> <operator>&lt;</operator> <name>NumArgs</name> <operator>&amp;&amp;</operator> <literal type="string">"Arg access out of range!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>getArgs</name><argument_list>()</argument_list></call><index>[<expr><name>Arg</name></expr>]</index></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<function><type><name>void</name></type> <name>setArg</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Arg</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ArgExpr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>Arg</name> <operator>&lt;</operator> <name>NumArgs</name> <operator>&amp;&amp;</operator> <literal type="string">"Arg access out of range!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>getArgs</name><argument_list>()</argument_list></call><index>[<expr><name>Arg</name></expr>]</index> <operator>=</operator> <name>ArgExpr</name></expr>;</expr_stmt>
</block_content>}</block></function>




<expr_stmt><expr><name>bool</name> <macro><name>isDelegateInitCall</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsDelegateInitCall</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setDelegateInitCall</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isDelegate</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>IsDelegateInitCall</name> <operator>=</operator> <name>isDelegate</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getLeftLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LBracLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getRightLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RBracLoc</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getSelectorStartLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isImplicit</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getSelectorLoc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}

SourceLocation <macro><name>getSelectorLoc</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Index</name> <operator>&lt;</operator> <call><name>getNumSelectorLocs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Index out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name>hasStandardSelLocs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getStandardSelectorLoc</name><argument_list>(<argument><expr><name>Index</name></expr></argument>, <argument><expr><call><name>getSelector</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getSelLocsKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>SelLoc_StandardWithSpace</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getArgs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>getNumArgs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>RBracLoc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getStoredSelLocs</name><argument_list>()</argument_list></call><index>[<expr><name>Index</name></expr>]</index></expr>;</return>
}

void <macro><name>getSelectorLocs</name><argument_list>(<argument>SmallVectorImpl&lt;SourceLocation&gt; &amp;SelLocs</argument>)</argument_list></macro> <decl_stmt><decl><type><specifier>const</specifier></type></decl>;</decl_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>getNumSelectorLocs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isImplicit</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<name>Selector</name> <name>Sel</name> <operator>=</operator> <call><name>getSelector</name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Sel</name><operator>.</operator><name>isUnarySelector</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>Sel</name><operator>.</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr>;</return>
}

void <macro><name>setSourceRange</name><argument_list>(<argument>SourceRange R</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>LBracLoc</name> <operator>=</operator> <call><name><name>R</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>RBracLoc</name> <operator>=</operator> <call><name><name>R</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>LBracLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RBracLoc</name></expr>;</return> }</block></expr></expr_stmt>


<function_decl><type><name>child_range</name></type> <name>children</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>arg_iterator</name> <init>= <expr><name>ExprIterator</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>const_arg_iterator</name> <init>= <expr><name>ConstExprIterator</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>arg_iterator</name></expr></argument>&gt;</argument_list></name> <macro><name>arguments</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>make_range</name><argument_list>(<argument><expr><call><name>arg_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>arg_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_arg_iterator</name></expr></argument>&gt;</argument_list></name> <macro><name>arguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>make_range</name><argument_list>(<argument><expr><call><name>arg_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>arg_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>arg_iterator</name></type> <name>arg_begin</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getArgs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>arg_iterator</name></type> <name>arg_end</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getArgs</name><argument_list>()</argument_list></call> <operator>+</operator> <name>NumArgs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>const_arg_iterator</name> <macro><name>arg_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <specifier>const</specifier> <operator>*</operator> <specifier>const</specifier><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getArgs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>const_arg_iterator</name> <macro><name>arg_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <specifier>const</specifier> <operator>*</operator> <specifier>const</specifier><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getArgs</name><argument_list>()</argument_list></call> <operator>+</operator> <name>NumArgs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCMessageExprClass</name></expr>;</return>
</block_content>}</block></function>
};



<decl_stmt><decl><type><name>class</name></type> <name>ObjCIsaExpr</name> <range>: <expr><name>public</name> <name>Expr</name> <block>{

<expr><name>Stmt</name> <operator>*</operator><name>Base</name></expr>;


<expr><name>SourceLocation</name> <name>IsaMemberLoc</name></expr>;


<expr><name>SourceLocation</name> <name>OpLoc</name></expr>;


<expr><name>bool</name> <name>IsArrow</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>ObjCIsaExpr</name><argument_list>(<argument>Expr *base</argument>, <argument>bool isarrow</argument>, <argument>SourceLocation l</argument>, <argument>SourceLocation oploc</argument>,
<argument>QualType ty</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ObjCIsaExprClass</name></expr></argument>, <argument><expr><name>ty</name></expr></argument>, <argument><expr><name>VK_LValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Base</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>IsaMemberLoc</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>OpLoc</name><argument_list>(<argument><expr><name>oploc</name></expr></argument>)</argument_list></call></expr>, <macro><name>IsArrow</name><argument_list>(<argument>isarrow</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>ObjCIsaExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ObjCIsaExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>void</name> <macro><name>setBase</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>Base</name> <operator>=</operator> <name>E</name></expr>; }</block>
<name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Base</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>isArrow</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsArrow</name></expr>;</return> }</block>
<name>void</name> <macro><name>setArrow</name><argument_list>(<argument>bool A</argument>)</argument_list></macro> <block>{ <expr><name>IsArrow</name> <operator>=</operator> <name>A</name></expr>; }</block>



<name>SourceLocation</name> <macro><name>getIsaMemberLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsaMemberLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setIsaMemberLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>IsaMemberLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getOpLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OpLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setOpLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>OpLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getBase</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBaseLocEnd</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getBase</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>IsaMemberLoc</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getExprLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>IsaMemberLoc</name></expr>;</return> }</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Base</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Base</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCIsaExprClass</name></expr>;</return>
}</block>
}</expr>;























<expr><name>class</name> <name>ObjCIndirectCopyRestoreExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>Stmt</name> <operator>*</operator><name>Operand</name></expr>;



<expr><name>explicit</name> <macro><name>ObjCIndirectCopyRestoreExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ObjCIndirectCopyRestoreExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>void</name> <macro><name>setShouldCopy</name><argument_list>(<argument>bool shouldCopy</argument>)</argument_list></macro> <block>{
<expr><name><name>ObjCIndirectCopyRestoreExprBits</name><operator>.</operator><name>ShouldCopy</name></name> <operator>=</operator> <name>shouldCopy</name></expr>;
}</block>

<name>public</name><operator>:</operator>
<macro><name>ObjCIndirectCopyRestoreExpr</name><argument_list>(<argument>Expr *operand</argument>, <argument>QualType type</argument>, <argument>bool shouldCopy</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ObjCIndirectCopyRestoreExprClass</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>VK_LValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Operand</name><argument_list>(<argument>operand</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setShouldCopy</name><argument_list>(<argument><expr><name>shouldCopy</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Operand</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Operand</name></expr></argument>)</argument_list></call></expr>;</return> }</block>



<name>bool</name> <macro><name>shouldCopy</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ObjCIndirectCopyRestoreExprBits</name><operator>.</operator><name>ShouldCopy</name></name></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Operand</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Operand</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Operand</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Operand</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>Operand</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>Operand</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getExprLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getSubExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getExprLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *s</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>s</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCIndirectCopyRestoreExprClass</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>ObjCBridgedCastExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>ExplicitCastExpr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ObjCBridgedCastExpr</name></expr></argument>, <argument><expr><name>CXXBaseSpecifier</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;
<expr><name>friend</name> <name>class</name> <name>CastExpr</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;

<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;
<expr><name>SourceLocation</name> <name>BridgeKeywordLoc</name></expr>;
<expr><name>unsigned</name> <name>Kind</name> <operator>:</operator> <literal type="number">2</literal></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>ObjCBridgedCastExpr</name><argument_list>(<argument>SourceLocation LParenLoc</argument>, <argument>ObjCBridgeCastKind Kind</argument>,
<argument>CastKind CK</argument>, <argument>SourceLocation BridgeKeywordLoc</argument>,
<argument>TypeSourceInfo *TSInfo</argument>, <argument>Expr *Operand</argument>)</argument_list></macro>
<operator>:</operator> <call><name>ExplicitCastExpr</name><argument_list>(<argument><expr><name>ObjCBridgedCastExprClass</name></expr></argument>, <argument><expr><call><name><name>TSInfo</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>CK</name></expr></argument>, <argument><expr><name>Operand</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TSInfo</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>BridgeKeywordLoc</name><argument_list>(<argument><expr><name>BridgeKeywordLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>Kind</name><argument_list>(<argument>Kind</argument>)</argument_list></macro> <expr><block>{}</block>


<name>explicit</name> <macro><name>ObjCBridgedCastExpr</name><argument_list>(<argument>EmptyShell Shell</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>ExplicitCastExpr</name><argument_list>(<argument>ObjCBridgedCastExprClass</argument>, <argument>Shell</argument>, <argument><literal type="number">0</literal></argument>, <argument>false</argument>)</argument_list></macro> <block>{}</block>

<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>ObjCBridgeCastKind</name> <macro><name>getBridgeKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCBridgeCastKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>StringRef</name> <macro><name>getBridgeKindName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>SourceLocation</name> <macro><name>getBridgeKeywordLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BridgeKeywordLoc</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getSubExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCBridgedCastExprClass</name></expr>;</return>
}</block>
}</expr>;














<expr><name>class</name> <name>ObjCAvailabilityCheckExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>VersionTuple</name> <name>VersionToCheck</name></expr>;
<expr><name>SourceLocation</name> <name>AtLoc</name></expr>, <expr><name>RParen</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>ObjCAvailabilityCheckExpr</name><argument_list>(<argument>VersionTuple VersionToCheck</argument>, <argument>SourceLocation AtLoc</argument>,
<argument>SourceLocation RParen</argument>, <argument>QualType Ty</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ObjCAvailabilityCheckExprClass</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>VersionToCheck</name><argument_list>(<argument><expr><name>VersionToCheck</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>AtLoc</name><argument_list>(<argument><expr><name>AtLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>RParen</name><argument_list>(<argument>RParen</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><name>ExprDependence</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>explicit</name> <macro><name>ObjCAvailabilityCheckExpr</name><argument_list>(<argument>EmptyShell Shell</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ObjCAvailabilityCheckExprClass</argument>, <argument>Shell</argument>)</argument_list></macro> <block>{}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AtLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParen</name></expr>;</return> }</block>
<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><block>{<expr><name>AtLoc</name></expr>, <expr><name>RParen</name></expr>}</block></expr>;</return> }</block>


<name>bool</name> <macro><name>hasVersion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name><name>VersionToCheck</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>VersionTuple</name> <macro><name>getVersion</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>VersionToCheck</name></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCAvailabilityCheckExprClass</name></expr>;</return>
}</block>
}</expr>;

}</block></expr></block></expr></block></expr></block></expr></range></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
