<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/DeclarationName.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_DECLARATIONNAME_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_DECLARATIONNAME_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Diagnostic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/IdentifierTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OperatorKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/PartialDiagnostic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMapInfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/FoldingSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/type_traits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstring&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>CanQual</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DeclarationName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DeclarationNameTable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MultiKeywordSelector</name></decl>;</decl_stmt>
<struct_decl>struct <name>PrintingPolicy</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TypeSourceInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UsingDirectiveDecl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CanQualType</name> <init>= <expr><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>Type</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>detail</name> <block>{<block_content>







<decl_stmt><decl><type><name>class</name></type> <name>alignas</name><argument_list>(<argument><expr><name>IdentifierInfoAlignment</name></expr></argument>)</argument_list> <name>CXXSpecialNameExtra</name>
<range>: <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>clang</name><operator>::</operator><name>DeclarationName</name></expr>;
<expr><name>friend</name> <name>class</name> <name>clang</name><operator>::</operator><name>DeclarationNameTable</name></expr>;


<expr><name>QualType</name> <name>Type</name></expr>;




<expr><name>void</name> <operator>*</operator><name>FETokenInfo</name></expr>;

<macro><name>CXXSpecialNameExtra</name><argument_list>(<argument>QualType QT</argument>)</argument_list></macro> <operator>:</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>QT</name></expr></argument>)</argument_list></call></expr>, <macro><name>FETokenInfo</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>Type</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block></expr>
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>alignas</name><argument_list>(<argument><expr><name>IdentifierInfoAlignment</name></expr></argument>)</argument_list> <name>CXXDeductionGuideNameExtra</name>
<range>: <expr><name>public</name> <name>detail</name><operator>::</operator><name>DeclarationNameExtra</name></expr></range></decl>,
<decl><type ref="prev"/><name>public</name> <name>llvm</name>::<name>FoldingSetNode</name> <block>{<block_content>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>clang</name><operator>::</operator><name>DeclarationName</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>clang</name><operator>::</operator><name>DeclarationNameTable</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>TemplateDecl</name> <modifier>*</modifier></type><name>Template</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>FETokenInfo</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CXXDeductionGuideNameExtra</name><argument_list>(<argument><expr><name>TemplateDecl</name> <operator>*</operator><name>TD</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>DeclarationNameExtra</name><argument_list>(<argument><expr><name>CXXDeductionGuideName</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Template</name><argument_list>(<argument><expr><name>TD</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>FETokenInfo</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{ <expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>Template</name></expr></argument>)</argument_list></call></expr>; }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>





<function><type><name>class</name></type> <name>alignas</name><parameter_list>(<parameter><decl><type><name>IdentifierInfoAlignment</name></type></decl></parameter>)</parameter_list> CXXOperatorIdName <block>{<block_content>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>clang</name><operator>::</operator><name>DeclarationName</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>clang</name><operator>::</operator><name>DeclarationNameTable</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>OverloadedOperatorKind</name></type> <name>Kind</name> <init>= <expr><name>OO_None</name></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>FETokenInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></function><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>alignas</name><argument_list>(<argument><expr><name>IdentifierInfoAlignment</name></expr></argument>)</argument_list> <name>CXXLiteralOperatorIdName</name>
<range>: <expr><name>public</name> <name>detail</name><operator>::</operator><name>DeclarationNameExtra</name></expr></range></decl>,
<decl><type ref="prev"/><name>public</name> <name>llvm</name>::<name>FoldingSetNode</name> <block>{<block_content>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>clang</name><operator>::</operator><name>DeclarationName</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>clang</name><operator>::</operator><name>DeclarationNameTable</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ID</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>FETokenInfo</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CXXLiteralOperatorIdName</name><argument_list>(<argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>II</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>DeclarationNameExtra</name><argument_list>(<argument><expr><name>CXXLiteralOperatorName</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ID</name><argument_list>(<argument><expr><name>II</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>FETokenInfo</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;FSID</argument>)</argument_list></macro> <block>{ <expr><call><name><name>FSID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>; }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

</block_content>}</block></decl></decl_stmt>







<decl_stmt><decl><type><name>class</name></type> <name>DeclarationName</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>DeclarationNameTable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>NamedDecl</name></decl>;</decl_stmt>



























<enum>enum <name>StoredNameKind</name> <block>{
<decl><name>StoredIdentifier</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>StoredObjCZeroArgSelector</name> <init>= <expr><name>Selector</name><operator>::</operator><name>ZeroArg</name></expr></init></decl>,
<decl><name>StoredObjCOneArgSelector</name> <init>= <expr><name>Selector</name><operator>::</operator><name>OneArg</name></expr></init></decl>,
<decl><name>StoredCXXConstructorName</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,
<decl><name>StoredCXXDestructorName</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,
<decl><name>StoredCXXConversionFunctionName</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>,
<decl><name>StoredCXXOperatorName</name> <init>= <expr><literal type="number">6</literal></expr></init></decl>,
<decl><name>StoredDeclarationNameExtra</name> <init>= <expr><name>Selector</name><operator>::</operator><name>MultiArg</name></expr></init></decl>,
<decl><name>PtrMask</name> <init>= <expr><literal type="number">7</literal></expr></init></decl>,
<decl><name>UncommonNameKindOffset</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>
}</block>;</enum>

<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><call><name>alignof</name><argument_list>(<argument><expr><name>IdentifierInfo</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator>
<call><name>alignof</name><argument_list>(<argument><expr><name>detail</name><operator>::</operator><name>DeclarationNameExtra</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator>
<call><name>alignof</name><argument_list>(<argument><expr><name>detail</name><operator>::</operator><name>CXXSpecialNameExtra</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator>
<call><name>alignof</name><argument_list>(<argument><expr><name>detail</name><operator>::</operator><name>CXXOperatorIdName</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator>
<call><name>alignof</name><argument_list>(<argument><expr><name>detail</name><operator>::</operator><name>CXXDeductionGuideNameExtra</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator>
<call><name>alignof</name><argument_list>(<argument><expr><name>detail</name><operator>::</operator><name>CXXLiteralOperatorIdName</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">8</literal></expr></argument>,
<argument><expr><literal type="string">"The various classes that DeclarationName::Ptr can point to"</literal>
<literal type="string">" must be at least aligned to 8 bytes!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>public</name>:</label>




<enum>enum <name>NameKind</name> <block>{
<decl><name>Identifier</name> <init>= <expr><name>StoredIdentifier</name></expr></init></decl>,
<decl><name>ObjCZeroArgSelector</name> <init>= <expr><name>StoredObjCZeroArgSelector</name></expr></init></decl>,
<decl><name>ObjCOneArgSelector</name> <init>= <expr><name>StoredObjCOneArgSelector</name></expr></init></decl>,
<decl><name>CXXConstructorName</name> <init>= <expr><name>StoredCXXConstructorName</name></expr></init></decl>,
<decl><name>CXXDestructorName</name> <init>= <expr><name>StoredCXXDestructorName</name></expr></init></decl>,
<decl><name>CXXConversionFunctionName</name> <init>= <expr><name>StoredCXXConversionFunctionName</name></expr></init></decl>,
<decl><name>CXXOperatorName</name> <init>= <expr><name>StoredCXXOperatorName</name></expr></init></decl>,
<decl><name>CXXDeductionGuideName</name> <init>= <expr><name>UncommonNameKindOffset</name> <operator>+</operator>
<name>detail</name><operator>::</operator><name>DeclarationNameExtra</name><operator>::</operator><name>CXXDeductionGuideName</name></expr></init></decl>,
<decl><name>CXXLiteralOperatorName</name> <init>=
<expr><name>UncommonNameKindOffset</name> <operator>+</operator>
<name>detail</name><operator>::</operator><name>DeclarationNameExtra</name><operator>::</operator><name>CXXLiteralOperatorName</name></expr></init></decl>,
<decl><name>CXXUsingDirective</name> <init>= <expr><name>UncommonNameKindOffset</name> <operator>+</operator>
<name>detail</name><operator>::</operator><name>DeclarationNameExtra</name><operator>::</operator><name>CXXUsingDirective</name></expr></init></decl>,
<decl><name>ObjCMultiArgSelector</name> <init>= <expr><name>UncommonNameKindOffset</name> <operator>+</operator>
<name>detail</name><operator>::</operator><name>DeclarationNameExtra</name><operator>::</operator><name>ObjCMultiArgSelector</name></expr></init></decl>
}</block>;</enum>

<label><name>private</name>:</label>
































<decl_stmt><decl><type><name>uintptr_t</name></type> <name>Ptr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>StoredNameKind</name> <macro><name>getStoredNameKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>StoredNameKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Ptr</name> <operator>&amp;</operator> <name>PtrMask</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>void</name> <operator>*</operator><macro><name>getPtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Ptr</name> <operator>&amp;</operator> <operator>~</operator><name>PtrMask</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setPtrAndKind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><name>StoredNameKind</name></type> <name>Kind</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>PAsInteger</name> <init>= <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>uintptr_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>Kind</name> <operator>&amp;</operator> <operator>~</operator><name>PtrMask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<literal type="string">"Invalid StoredNameKind in setPtrAndKind!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>PAsInteger</name> <operator>&amp;</operator> <name>PtrMask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<literal type="string">"Improperly aligned pointer in setPtrAndKind!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Ptr</name> <operator>=</operator> <name>PAsInteger</name> <operator>|</operator> <name>Kind</name></expr>;</expr_stmt>
</block_content>}</block></function>


<macro><name>DeclarationName</name><argument_list>(<argument>detail::DeclarationNameExtra *Name</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>setPtrAndKind</name><argument_list>(<argument><expr><name>Name</name></expr></argument>, <argument><expr><name>StoredDeclarationNameExtra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<macro><name>DeclarationName</name><argument_list>(<argument>detail::CXXSpecialNameExtra *Name</argument>,
<argument>StoredNameKind StoredKind</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>StoredKind</name> <operator>==</operator> <name>StoredCXXConstructorName</name> <operator>||</operator>
<name>StoredKind</name> <operator>==</operator> <name>StoredCXXDestructorName</name> <operator>||</operator>
<name>StoredKind</name> <operator>==</operator> <name>StoredCXXConversionFunctionName</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Invalid StoredNameKind when constructing a DeclarationName"</literal>
<literal type="string">" from a CXXSpecialNameExtra!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setPtrAndKind</name><argument_list>(<argument><expr><name>Name</name></expr></argument>, <argument><expr><name>StoredKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<macro><name>DeclarationName</name><argument_list>(<argument>detail::CXXOperatorIdName *Name</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>setPtrAndKind</name><argument_list>(<argument><expr><name>Name</name></expr></argument>, <argument><expr><name>StoredCXXOperatorName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<expr_stmt><expr><name>IdentifierInfo</name> <operator>*</operator><macro><name>castAsIdentifierInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>getStoredNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>StoredIdentifier</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"DeclarationName does not store an IdentifierInfo!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>detail</name><operator>::</operator><name>DeclarationNameExtra</name> <operator>*</operator><macro><name>castAsExtra</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>getStoredNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>StoredDeclarationNameExtra</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"DeclarationName does not store an Extra structure!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>detail</name><operator>::</operator><name>DeclarationNameExtra</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>detail</name><operator>::</operator><name>CXXSpecialNameExtra</name> <operator>*</operator><macro><name>castAsCXXSpecialNameExtra</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>getStoredNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>StoredCXXConstructorName</name> <operator>||</operator>
<call><name>getStoredNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>StoredCXXDestructorName</name> <operator>||</operator>
<call><name>getStoredNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>StoredCXXConversionFunctionName</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"DeclarationName does not store a CXXSpecialNameExtra!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>detail</name><operator>::</operator><name>CXXSpecialNameExtra</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>detail</name><operator>::</operator><name>CXXOperatorIdName</name> <operator>*</operator><macro><name>castAsCXXOperatorIdName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>getStoredNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>StoredCXXOperatorName</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"DeclarationName does not store a CXXOperatorIdName!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>detail</name><operator>::</operator><name>CXXOperatorIdName</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>detail</name><operator>::</operator><name>CXXDeductionGuideNameExtra</name> <operator>*</operator><macro><name>castAsCXXDeductionGuideNameExtra</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXDeductionGuideName</name> <operator>&amp;&amp;</operator>
<literal type="string">"DeclarationName does not store a CXXDeductionGuideNameExtra!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>detail</name><operator>::</operator><name>CXXDeductionGuideNameExtra</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>detail</name><operator>::</operator><name>CXXLiteralOperatorIdName</name> <operator>*</operator><macro><name>castAsCXXLiteralOperatorIdName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXLiteralOperatorName</name> <operator>&amp;&amp;</operator>
<literal type="string">"DeclarationName does not store a CXXLiteralOperatorIdName!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>detail</name><operator>::</operator><name>CXXLiteralOperatorIdName</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>void</name> <operator>*</operator><macro><name>getFETokenInfoSlow</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<function_decl><type><name>void</name></type> <name>setFETokenInfoSlow</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>

<macro><name>DeclarationName</name><argument_list>()</argument_list></macro> <block>{<block_content> <expr_stmt><expr><call><name>setPtrAndKind</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>StoredIdentifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>


<macro><name>DeclarationName</name><argument_list>(<argument>const IdentifierInfo *II</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>setPtrAndKind</name><argument_list>(<argument><expr><name>II</name></expr></argument>, <argument><expr><name>StoredIdentifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<macro><name>DeclarationName</name><argument_list>(<argument>Selector Sel</argument>)</argument_list></macro> : <macro><name>Ptr</name><argument_list>(<argument>Sel.InfoPtr</argument>)</argument_list></macro> <block>{<block_content/>}</block>


<function><type><specifier>static</specifier> <name>DeclarationName</name></type> <name>getUsingDirectiveName</name><parameter_list>()</parameter_list> <block>{<block_content>

<expr_stmt><expr><specifier>static</specifier> <name>detail</name><operator>::</operator><name>DeclarationNameExtra</name> <call><name>UDirExtra</name><argument_list>(
<argument><expr><name>detail</name><operator>::</operator><name>DeclarationNameExtra</name><operator>::</operator><name>CXXUsingDirective</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>DeclarationName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UDirExtra</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<expr_stmt><expr><name>explicit</name> <name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getPtr</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>getStoredNameKind</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>StoredIdentifier</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isEmpty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><operator>*</operator><name>this</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getStoredNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>StoredIdentifier</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isObjCZeroArgSelector</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStoredNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>StoredObjCZeroArgSelector</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isObjCOneArgSelector</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStoredNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>StoredObjCOneArgSelector</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>NameKind</name> <macro><name>getNameKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{


<expr><name>StoredNameKind</name> <name>StoredKind</name> <operator>=</operator> <call><name>getStoredNameKind</name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>StoredKind</name> <operator>!=</operator> <name>StoredDeclarationNameExtra</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>NameKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>StoredKind</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>



<name>unsigned</name> <name>ExtraKind</name> <operator>=</operator> <call><name>castAsExtra</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getKind</name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>NameKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>UncommonNameKindOffset</name> <operator>+</operator> <name>ExtraKind</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>







<expr_stmt><expr><name>bool</name> <macro><name>isDependentName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>IdentifierInfo</name> <operator>*</operator><macro><name>getAsIdentifierInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isIdentifier</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>castAsIdentifierInfo</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>nullptr</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name>uintptr_t</name> <macro><name>getAsOpaqueInteger</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Ptr</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>void</name> <operator>*</operator><macro><name>getAsOpaquePtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<function><type><specifier>static</specifier> <name>DeclarationName</name></type> <name>getFromOpaquePtr</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>P</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DeclarationName</name></type> <name>N</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>N</name><operator>.</operator><name>Ptr</name></name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>uintptr_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>N</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>DeclarationName</name></type> <name>getFromOpaqueInteger</name><parameter_list>(<parameter><decl><type><name>uintptr_t</name></type> <name>P</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DeclarationName</name></type> <name>N</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>N</name><operator>.</operator><name>Ptr</name></name> <operator>=</operator> <name>P</name></expr>;</expr_stmt>
<return>return <expr><name>N</name></expr>;</return>
</block_content>}</block></function>



<expr_stmt><expr><name>QualType</name> <macro><name>getCXXNameType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getStoredNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>StoredCXXConstructorName</name> <operator>||</operator>
<call><name>getStoredNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>StoredCXXDestructorName</name> <operator>||</operator>
<call><name>getStoredNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>StoredCXXConversionFunctionName</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getPtr</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"getCXXNameType on a null DeclarationName!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>castAsCXXSpecialNameExtra</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>Type</name></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return>
}



TemplateDecl <expr_stmt><expr><operator>*</operator><macro><name>getCXXDeductionGuideTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXDeductionGuideName</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getPtr</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"getCXXDeductionGuideTemplate on a null DeclarationName!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>castAsCXXDeductionGuideNameExtra</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>Template</name></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
<return>return <expr><name>nullptr</name></expr>;</return>
}



OverloadedOperatorKind <macro><name>getCXXOverloadedOperator</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getStoredNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>StoredCXXOperatorName</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getPtr</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"getCXXOverloadedOperator on a null DeclarationName!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>castAsCXXOperatorIdName</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>Kind</name></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
<return>return <expr><name>OO_None</name></expr>;</return>
}



IdentifierInfo <expr_stmt><expr><operator>*</operator><macro><name>getCXXLiteralIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXLiteralOperatorName</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getPtr</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"getCXXLiteralIdentifier on a null DeclarationName!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>castAsCXXLiteralOperatorIdName</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ID</name></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
<return>return <expr><name>nullptr</name></expr>;</return>
}


Selector <macro><name>getObjCSelector</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>getNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCZeroArgSelector</name> <operator>||</operator>
<call><name>getNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCOneArgSelector</name> <operator>||</operator>
<call><name>getNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCMultiArgSelector</name> <operator>||</operator> <operator>!</operator><call><name>getPtr</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Not a selector!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>Selector</name><argument_list>(<argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>void</name> <operator>*</operator><macro><name>getFETokenInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getPtr</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"getFETokenInfo on an empty DeclarationName!"</literal></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name>getStoredNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>StoredIdentifier</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>castAsIdentifierInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getFETokenInfo</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getFETokenInfoSlow</name><argument_list>()</argument_list></call></expr>;</return>
}

void <macro><name>setFETokenInfo</name><argument_list>(<argument>void *T</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getPtr</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"setFETokenInfo on an empty DeclarationName!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getStoredNameKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>StoredIdentifier</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>castAsIdentifierInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>setFETokenInfo</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setFETokenInfoSlow</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block>


<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><name>DeclarationName</name> <name>LHS</name><operator>,</operator> <name>DeclarationName</name> <name>RHS</name><operator>)</operator> <block>{
<return>return <expr><name><name>LHS</name><operator>.</operator><name>Ptr</name></name> <operator>==</operator> <name><name>RHS</name><operator>.</operator><name>Ptr</name></name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><name>DeclarationName</name> <name>LHS</name><operator>,</operator> <name>DeclarationName</name> <name>RHS</name><operator>)</operator> <block>{
<return>return <expr><name><name>LHS</name><operator>.</operator><name>Ptr</name></name> <operator>!=</operator> <name><name>RHS</name><operator>.</operator><name>Ptr</name></name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>DeclarationName</name></type> <name>getEmptyMarker</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DeclarationName</name></type> <name>Name</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Name</name><operator>.</operator><name>Ptr</name></name> <operator>=</operator> <call><name>uintptr_t</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Name</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DeclarationName</name></type> <name>getTombstoneMarker</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DeclarationName</name></type> <name>Name</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Name</name><operator>.</operator><name>Ptr</name></name> <operator>=</operator> <call><name>uintptr_t</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Name</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compare</name><parameter_list>(<parameter><decl><type><name>DeclarationName</name></type> <name>LHS</name></decl></parameter>, <parameter><decl><type><name>DeclarationName</name></type> <name>RHS</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>print</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>Policy</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
};

<expr_stmt><expr><name>raw_ostream</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name><operator>,</operator> <name>DeclarationName</name> <name>N</name><operator>)</operator></expr>;</expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>bool</name> <name>operator</name><operator>&lt;</operator><operator>(</operator><name>DeclarationName</name> <name>LHS</name><operator>,</operator> <name>DeclarationName</name> <name>RHS</name><operator>)</operator> <block>{
<return>return <expr><name>DeclarationName</name><operator>::</operator><call><name>compare</name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>bool</name> <name>operator</name><operator>&gt;</operator><operator>(</operator><name>DeclarationName</name> <name>LHS</name><operator>,</operator> <name>DeclarationName</name> <name>RHS</name><operator>)</operator> <block>{
<return>return <expr><name>DeclarationName</name><operator>::</operator><call><name>compare</name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>bool</name> <name>operator</name><operator>&lt;=</operator><operator>(</operator><name>DeclarationName</name> <name>LHS</name><operator>,</operator> <name>DeclarationName</name> <name>RHS</name><operator>)</operator> <block>{
<return>return <expr><name>DeclarationName</name><operator>::</operator><call><name>compare</name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>bool</name> <name>operator</name><operator>&gt;=</operator><operator>(</operator><name>DeclarationName</name> <name>LHS</name><operator>,</operator> <name>DeclarationName</name> <name>RHS</name><operator>)</operator> <block>{
<return>return <expr><name>DeclarationName</name><operator>::</operator><call><name>compare</name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return>
}</block></expr></expr_stmt>






<decl_stmt><decl><type><name>class</name></type> <name>DeclarationNameTable</name> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>ASTContext</name> <modifier>&amp;</modifier></type><name>Ctx</name></decl>;</decl_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>detail</name><operator>::</operator><name>CXXSpecialNameExtra</name></expr></argument>&gt;</argument_list></name> <name>CXXConstructorNames</name></expr>;</expr_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>detail</name><operator>::</operator><name>CXXSpecialNameExtra</name></expr></argument>&gt;</argument_list></name> <name>CXXDestructorNames</name></expr>;</expr_stmt>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>detail</name><operator>::</operator><name>CXXSpecialNameExtra</name></expr></argument>&gt;</argument_list></name> <name>CXXConversionFunctionNames</name></expr>;</expr_stmt>




<expr_stmt><expr><name>detail</name><operator>::</operator><name>CXXOperatorIdName</name> <name><name>CXXOperatorNames</name><index>[<expr><name>NUM_OVERLOADED_OPERATORS</name></expr>]</index></name></expr>;</expr_stmt>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>detail</name><operator>::</operator><name>CXXLiteralOperatorIdName</name></expr></argument>&gt;</argument_list></name> <name>CXXLiteralOperatorNames</name></expr>;</expr_stmt>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>detail</name><operator>::</operator><name>CXXDeductionGuideNameExtra</name></expr></argument>&gt;</argument_list></name> <name>CXXDeductionGuideNames</name></expr>;</expr_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>DeclarationNameTable</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DeclarationNameTable</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclarationNameTable</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>DeclarationNameTable</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>DeclarationNameTable</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>DeclarationNameTable</name><argument_list>(<argument><expr><name>DeclarationNameTable</name> <operator>&amp;&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>DeclarationNameTable</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><name>DeclarationNameTable</name> <operator>&amp;&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>~</operator><call><name>DeclarationNameTable</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>


<function><type><name>DeclarationName</name></type> <name>getIdentifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>ID</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>DeclarationName</name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name>DeclarationName</name></type> <name>getCXXConstructorName</name><parameter_list>(<parameter><decl><type><name>CanQualType</name></type> <name>Ty</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>DeclarationName</name></type> <name>getCXXDestructorName</name><parameter_list>(<parameter><decl><type><name>CanQualType</name></type> <name>Ty</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>DeclarationName</name></type> <name>getCXXDeductionGuideName</name><parameter_list>(<parameter><decl><type><name>TemplateDecl</name> <modifier>*</modifier></type><name>TD</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>DeclarationName</name></type> <name>getCXXConversionFunctionName</name><parameter_list>(<parameter><decl><type><name>CanQualType</name></type> <name>Ty</name></decl></parameter>)</parameter_list>;</function_decl>







<decl_stmt><decl><type><name>DeclarationName</name></type> <name>getCXXSpecialName</name><argument_list>(<argument><expr><name>DeclarationName</name><operator>::</operator><name>NameKind</name> <name>Kind</name></expr></argument>,
<argument><expr><name>CanQualType</name> <name>Ty</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function><type><name>DeclarationName</name></type> <name>getCXXOperatorName</name><parameter_list>(<parameter><decl><type><name>OverloadedOperatorKind</name></type> <name>Op</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>DeclarationName</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CXXOperatorNames</name><index>[<expr><name>Op</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name>DeclarationName</name></type> <name>getCXXLiteralOperatorName</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>)</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>DeclarationNameLoc</name> <block>{<block_content>






<struct>struct <name>NT</name> <block>{
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl>;</decl_stmt>
}</block>;</struct>


<struct>struct <name>CXXOpName</name> <block>{
<expr_stmt><expr><name>SourceLocation</name><operator>::</operator><name>UIntTy</name> <name>BeginOpNameLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>SourceLocation</name><operator>::</operator><name>UIntTy</name> <name>EndOpNameLoc</name></expr>;</expr_stmt>
}</block>;</struct>


<struct>struct <name>CXXLitOpName</name> <block>{
<expr_stmt><expr><name>SourceLocation</name><operator>::</operator><name>UIntTy</name> <name>OpNameLoc</name></expr>;</expr_stmt>
}</block>;</struct>





<union>union <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>NT</name></name></type> <name>NamedType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>CXXOpName</name></name></type> <name>CXXOperatorName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>CXXLitOpName</name></name></type> <name>CXXLiteralOperatorName</name></decl>;</decl_stmt>
}</block>;</union>

<function><type><name>void</name></type> <name>setNamedTypeLoc</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>NamedType</name><operator>.</operator><name>TInfo</name></name> <operator>=</operator> <name>TInfo</name></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>void</name></type> <name>setCXXOperatorNameRange</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>CXXOperatorName</name><operator>.</operator><name>BeginOpNameLoc</name></name> <operator>=</operator> <call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getRawEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>CXXOperatorName</name><operator>.</operator><name>EndOpNameLoc</name></name> <operator>=</operator> <call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getRawEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setCXXLiteralOperatorNameLoc</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>CXXLiteralOperatorName</name><operator>.</operator><name>OpNameLoc</name></name> <operator>=</operator> <call><name><name>Loc</name><operator>.</operator><name>getRawEncoding</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<label><name>public</name>:</label>
<macro><name>DeclarationNameLoc</name><argument_list>(<argument>DeclarationName Name</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>DeclarationNameLoc</name><argument_list>()</argument_list></macro> <block>{<block_content> <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>



<expr_stmt><expr><name>TypeSourceInfo</name> <operator>*</operator><macro><name>getNamedTypeInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>NamedType</name><operator>.</operator><name>TInfo</name></name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getCXXOperatorNameBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>SourceLocation</name><operator>::</operator><call><name>getFromRawEncoding</name><argument_list>(<argument><expr><name><name>CXXOperatorName</name><operator>.</operator><name>BeginOpNameLoc</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getCXXOperatorNameEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>SourceLocation</name><operator>::</operator><call><name>getFromRawEncoding</name><argument_list>(<argument><expr><name><name>CXXOperatorName</name><operator>.</operator><name>EndOpNameLoc</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>SourceRange</name> <macro><name>getCXXOperatorNameRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getCXXOperatorNameBeginLoc</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getCXXOperatorNameEndLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>SourceLocation</name> <macro><name>getCXXLiteralOperatorNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>SourceLocation</name><operator>::</operator><call><name>getFromRawEncoding</name><argument_list>(<argument><expr><name><name>CXXLiteralOperatorName</name><operator>.</operator><name>OpNameLoc</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<function><type><specifier>static</specifier> <name>DeclarationNameLoc</name></type> <name>makeNamedTypeLoc</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DeclarationNameLoc</name></type> <name>DNL</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>DNL</name><operator>.</operator><name>setNamedTypeLoc</name></name><argument_list>(<argument><expr><name>TInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>DNL</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>DeclarationNameLoc</name></type> <name>makeCXXOperatorNameLoc</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>BeginLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>makeCXXOperatorNameLoc</name><argument_list>(<argument><expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>BeginLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>DeclarationNameLoc</name></type> <name>makeCXXOperatorNameLoc</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DeclarationNameLoc</name></type> <name>DNL</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>DNL</name><operator>.</operator><name>setCXXOperatorNameRange</name></name><argument_list>(<argument><expr><name>Range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>DNL</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>DeclarationNameLoc</name></type> <name>makeCXXLiteralOperatorNameLoc</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DeclarationNameLoc</name></type> <name>DNL</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>DNL</name><operator>.</operator><name>setCXXLiteralOperatorNameLoc</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>DNL</name></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<struct>struct <name>DeclarationNameInfo</name> <block>{
<label><name>private</name>:</label>

<decl_stmt><decl><type><name>DeclarationName</name></type> <name>Name</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>DeclarationNameLoc</name></type> <name>LocInfo</name></decl>;</decl_stmt>

<label><name>public</name>:</label>

<expr_stmt><expr><call><name>DeclarationNameInfo</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>

<macro><name>DeclarationNameInfo</name><argument_list>(<argument>DeclarationName Name</argument>, <argument>SourceLocation NameLoc</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Name</name><argument_list>(<argument><expr><name>Name</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>NameLoc</name><argument_list>(<argument><expr><name>NameLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>LocInfo</name><argument_list>(<argument>Name</argument>)</argument_list></macro> <expr><block>{}</block>

<macro><name>DeclarationNameInfo</name><argument_list>(<argument>DeclarationName Name</argument>, <argument>SourceLocation NameLoc</argument>,
<argument>DeclarationNameLoc LocInfo</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Name</name><argument_list>(<argument><expr><name>Name</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>NameLoc</name><argument_list>(<argument><expr><name>NameLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>LocInfo</name><argument_list>(<argument>LocInfo</argument>)</argument_list></macro> <expr><block>{}</block>


<name>DeclarationName</name> <macro><name>getName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Name</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setName</name><parameter_list>(<parameter><decl><type><name>DeclarationName</name></type> <name>N</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Name</name> <operator>=</operator> <name>N</name></expr>;</expr_stmt> </block_content>}</block></function>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NameLoc</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setLoc</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>L</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>NameLoc</name> <operator>=</operator> <name>L</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>DeclarationNameLoc</name> <operator>&amp;</operator><macro><name>getInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LocInfo</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameLoc</name> <modifier>&amp;</modifier></type><name>Info</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>LocInfo</name> <operator>=</operator> <name>Info</name></expr>;</expr_stmt> </block_content>}</block></function>



<expr_stmt><expr><name>TypeSourceInfo</name> <operator>*</operator><macro><name>getNamedTypeInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Name</name><operator>.</operator><name>getNameKind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>DeclarationName</name><operator>::</operator><name>CXXConstructorName</name> <operator>&amp;&amp;</operator>
<call><name><name>Name</name><operator>.</operator><name>getNameKind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>DeclarationName</name><operator>::</operator><name>CXXDestructorName</name> <operator>&amp;&amp;</operator>
<call><name><name>Name</name><operator>.</operator><name>getNameKind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>DeclarationName</name><operator>::</operator><name>CXXConversionFunctionName</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name><name>LocInfo</name><operator>.</operator><name>getNamedTypeInfo</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<decl><name>void</name> <name>setNamedTypeInfo</name><argument_list>(<argument><expr><name>TypeSourceInfo</name> <operator>*</operator><name>TInfo</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Name</name><operator>.</operator><name>getNameKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DeclarationName</name><operator>::</operator><name>CXXConstructorName</name> <operator>||</operator>
<call><name><name>Name</name><operator>.</operator><name>getNameKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DeclarationName</name><operator>::</operator><name>CXXDestructorName</name> <operator>||</operator>
<call><name><name>Name</name><operator>.</operator><name>getNameKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DeclarationName</name><operator>::</operator><name>CXXConversionFunctionName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>LocInfo</name> <operator>=</operator> <name>DeclarationNameLoc</name><operator>::</operator><call><name>makeNamedTypeLoc</name><argument_list>(<argument><expr><name>TInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl>



<decl><name>SourceRange</name> <name>getCXXOperatorNameRange</name><argument_list>()</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Name</name><operator>.</operator><name>getNameKind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>DeclarationName</name><operator>::</operator><name>CXXOperatorName</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceRange</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>LocInfo</name><operator>.</operator><name>getCXXOperatorNameRange</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl>



<decl><name>void</name> <name>setCXXOperatorNameRange</name><argument_list>(<argument><expr><name>SourceRange</name> <name>R</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Name</name><operator>.</operator><name>getNameKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DeclarationName</name><operator>::</operator><name>CXXOperatorName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>LocInfo</name> <operator>=</operator> <name>DeclarationNameLoc</name><operator>::</operator><call><name>makeCXXOperatorNameLoc</name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl>




<decl><name>SourceLocation</name> <name>getCXXLiteralOperatorNameLoc</name><argument_list>()</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Name</name><operator>.</operator><name>getNameKind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>DeclarationName</name><operator>::</operator><name>CXXLiteralOperatorName</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>LocInfo</name><operator>.</operator><name>getCXXLiteralOperatorNameLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl>




<decl><name>void</name> <name>setCXXLiteralOperatorNameLoc</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Name</name><operator>.</operator><name>getNameKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DeclarationName</name><operator>::</operator><name>CXXLiteralOperatorName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>LocInfo</name> <operator>=</operator> <name>DeclarationNameLoc</name><operator>::</operator><call><name>makeCXXLiteralOperatorNameLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl>


<decl><name>bool</name> <name>isInstantiationDependent</name><argument_list>()</argument_list> const</decl>;</struct>



<expr_stmt><expr><name>bool</name> <macro><name>containsUnexpandedParameterPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>printName</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>, <argument><expr><name>PrintingPolicy</name> <name>Policy</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NameLoc</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<expr><name>SourceLocation</name> <name>EndLoc</name> <operator>=</operator> <call><name>getEndLocPrivate</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><ternary><condition><expr><call><name><name>EndLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>EndLoc</name></expr> </then><else>: <expr><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndLocPrivate</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
};



<expr_stmt><expr><specifier>inline</specifier> <specifier>const</specifier> <name>StreamingDiagnostic</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><specifier>const</specifier> <name>StreamingDiagnostic</name> <operator>&amp;</operator><name>PD</name><operator>,</operator>
<name>DeclarationName</name> <name>N</name><operator>)</operator> <block>{
<expr><call><name><name>PD</name><operator>.</operator><name>AddTaggedVal</name></name><argument_list>(<argument><expr><call><name><name>N</name><operator>.</operator><name>getAsOpaqueInteger</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>DiagnosticsEngine</name><operator>::</operator><name>ak_declarationname</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>PD</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>raw_ostream</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name><operator>,</operator> <name>DeclarationNameInfo</name> <name>DNInfo</name><operator>)</operator></expr>;</expr_stmt>

}

namespace <macro><name>llvm</name></macro> <block>{<block_content>



<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator>
struct <name><name>DenseMapInfo</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>DeclarationName</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <specifier>inline</specifier> <name>clang</name><operator>::</operator><name>DeclarationName</name> <macro><name>getEmptyKey</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>clang</name><operator>::</operator><name>DeclarationName</name><operator>::</operator><call><name>getEmptyMarker</name><argument_list>()</argument_list></call></expr>;</return></block></expr>
}</block>

<specifier>static</specifier> <specifier>inline</specifier> <name>clang</name><operator>::</operator><name>DeclarationName</name> <macro><name>getTombstoneKey</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>clang</name><operator>::</operator><name>DeclarationName</name><operator>::</operator><call><name>getTombstoneMarker</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name></type> <name>getHashValue</name><argument_list>(<argument><expr><name>clang</name><operator>::</operator><name>DeclarationName</name> <name>Name</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><name><name>DenseMapInfo</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>getHashValue</name><argument_list>(<argument><expr><call><name><name>Name</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>isEqual</name><argument_list>(<argument><expr><name>clang</name><operator>::</operator><name>DeclarationName</name> <name>LHS</name></expr></argument>, <argument><expr><name>clang</name><operator>::</operator><name>DeclarationName</name> <name>RHS</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><name>LHS</name> <operator>==</operator> <name>RHS</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>PointerLikeTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>DeclarationName</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <operator>*</operator><macro><name>getAsVoidPointer</name><argument_list>(<argument>clang::DeclarationName P</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>P</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr>;</return></block></expr>
}</block>
<specifier>static</specifier> <specifier>inline</specifier> <name>clang</name><operator>::</operator><name>DeclarationName</name> <macro><name>getFromVoidPointer</name><argument_list>(<argument>void *P</argument>)</argument_list></macro> <block>{
<return>return <expr><name>clang</name><operator>::</operator><name>DeclarationName</name><operator>::</operator><call><name>getFromOpaquePtr</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>constexpr</name> <name>int</name></type> <name>NumLowBitsAvailable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
};

}



namespace <macro><name>clang</name></macro> <block>{<block_content>



<decl_stmt><decl><type><name>class</name></type> <name>AssumedTemplateStorage</name> <range>: <expr><name>public</name> <name>UncommonTemplateNameStorage</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<macro><name>AssumedTemplateStorage</name><argument_list>(<argument>DeclarationName Name</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>UncommonTemplateNameStorage</name><argument_list>(<argument><expr><name>Assumed</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>, <macro><name>Name</name><argument_list>(<argument>Name</argument>)</argument_list></macro> <expr><block>{}</block>
<name>DeclarationName</name> <name>Name</name></expr>;

<expr><name>public</name><operator>:</operator>

<name>DeclarationName</name> <macro><name>getDeclName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Name</name></expr>;</return> }</block>
}</expr>;

}</block></expr></range></decl></decl_stmt></block_content></block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
