<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/CodeGen/CGFunctionInfo.h">













<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_CODEGEN_CGFUNCTIONINFO_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_CODEGEN_CGFUNCTIONINFO_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/CanonicalType.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/CharUnits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/IR/DerivedTypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/FoldingSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/TrailingObjects.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>CodeGen</name> <block>{<block_content>



<decl_stmt><decl><type><name>class</name></type> <name>ABIArgInfo</name> <block>{<block_content>
<label><name>public</name>:</label>
<enum>enum <name>Kind</name> : <type><name>uint8_t</name></type> <block>{






<decl><name>Direct</name></decl>,



<decl><name>Extend</name></decl>,



<decl><name>Indirect</name></decl>,












<decl><name>IndirectAliased</name></decl>,



<decl><name>Ignore</name></decl>,





<decl><name>Expand</name></decl>,





<decl><name>CoerceAndExpand</name></decl>,






<decl><name>InAlloca</name></decl>,
<decl><name>KindFirst</name> <init>= <expr><name>Direct</name></expr></init></decl>,
<decl><name>KindLast</name> <init>= <expr><name>InAlloca</name></expr></init></decl>
}</block>;</enum>

<label><name>private</name>:</label>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>TypeData</name></expr>;</expr_stmt>
<union>union <block>{
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>PaddingType</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>UnpaddedCoerceAndExpandType</name></expr>;</expr_stmt>
}</block>;</union>
<struct>struct <name>DirectAttrInfo</name> <block>{
<decl_stmt><decl><type><name>unsigned</name></type> <name>Offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>Align</name></decl>;</decl_stmt>
}</block>;</struct>
<struct>struct <name>IndirectAttrInfo</name> <block>{
<decl_stmt><decl><type><name>unsigned</name></type> <name>Align</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>AddrSpace</name></decl>;</decl_stmt>
}</block>;</struct>
<union>union <block>{
<decl_stmt><decl><type><name>DirectAttrInfo</name></type> <name>DirectAttr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IndirectAttrInfo</name></type> <name>IndirectAttr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>AllocaFieldIndex</name></decl>;</decl_stmt>
}</block>;</union>
<decl_stmt><decl><type><name>Kind</name></type> <name>TheKind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>PaddingInReg</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>InAllocaSRet</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>InAllocaIndirect</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>IndirectByVal</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>IndirectRealign</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>SRetAfterThis</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>InReg</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>CanBeFlattened</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>SignExt</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>canHavePaddingType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isDirect</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isExtend</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isIndirect</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isIndirectAliased</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name>isExpand</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>setPaddingType</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>canHavePaddingType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>PaddingType</name> <operator>=</operator> <name>T</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>setUnpaddedCoerceToType</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isCoerceAndExpand</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>UnpaddedCoerceAndExpandType</name> <operator>=</operator> <name>T</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<label><name>public</name>:</label>
<macro><name>ABIArgInfo</name><argument_list>(<argument>Kind K = Direct</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>TypeData</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>PaddingType</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>DirectAttr</name><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr><operator>,</operator> <expr><call><name>TheKind</name><argument_list>(<argument><expr><name>K</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>PaddingInReg</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>InAllocaSRet</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>InAllocaIndirect</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IndirectByVal</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IndirectRealign</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>SRetAfterThis</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>InReg</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>CanBeFlattened</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>SignExt</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>ABIArgInfo</name> <macro><name>getDirect</name><argument_list>(<argument>llvm::Type *T = nullptr</argument>, <argument>unsigned Offset = <literal type="number">0</literal></argument>,
<argument>llvm::Type *Padding = nullptr</argument>,
<argument>bool CanBeFlattened = true</argument>, <argument>unsigned Align = <literal type="number">0</literal></argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>AI</name> <operator>=</operator> <call><name>ABIArgInfo</name><argument_list>(<argument><expr><name>Direct</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>AI</name><operator>.</operator><name>setCoerceToType</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>AI</name><operator>.</operator><name>setPaddingType</name></name><argument_list>(<argument><expr><name>Padding</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>AI</name><operator>.</operator><name>setDirectOffset</name></name><argument_list>(<argument><expr><name>Offset</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>AI</name><operator>.</operator><name>setDirectAlign</name></name><argument_list>(<argument><expr><name>Align</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>AI</name><operator>.</operator><name>setCanBeFlattened</name></name><argument_list>(<argument><expr><name>CanBeFlattened</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>AI</name></expr>;</return>
}</block></expr></expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ABIArgInfo</name></type> <name>getDirectInReg</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>T</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>AI</name> <init>= <expr><call><name>getDirect</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setInReg</name></name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AI</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ABIArgInfo</name></type> <name>getSignExtend</name><argument_list>(<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>T</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Ty</name><operator>-&gt;</operator><name>isIntegralOrEnumerationType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Unexpected QualType"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>auto</name></type> <name>AI</name> <init>= <expr><call><name>ABIArgInfo</name><argument_list>(<argument><expr><name>Extend</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setCoerceToType</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setPaddingType</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setDirectOffset</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setDirectAlign</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setSignExt</name></name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AI</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ABIArgInfo</name></type> <name>getZeroExtend</name><argument_list>(<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>T</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Ty</name><operator>-&gt;</operator><name>isIntegralOrEnumerationType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Unexpected QualType"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>auto</name></type> <name>AI</name> <init>= <expr><call><name>ABIArgInfo</name><argument_list>(<argument><expr><name>Extend</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setCoerceToType</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setPaddingType</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setDirectOffset</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setDirectAlign</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setSignExt</name></name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AI</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><specifier>static</specifier> <name>ABIArgInfo</name></type> <name>getExtend</name><argument_list>(<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>T</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Ty</name><operator>-&gt;</operator><name>isIntegralOrEnumerationType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Unexpected QualType"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Ty</name><operator>-&gt;</operator><name>hasSignedIntegerRepresentation</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getSignExtend</name><argument_list>(<argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getZeroExtend</name><argument_list>(<argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ABIArgInfo</name></type> <name>getExtendInReg</name><argument_list>(<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>T</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>AI</name> <init>= <expr><call><name>getExtend</name><argument_list>(<argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setInReg</name></name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AI</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<function><type><specifier>static</specifier> <name>ABIArgInfo</name></type> <name>getIgnore</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>ABIArgInfo</name><argument_list>(<argument><expr><name>Ignore</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>ABIArgInfo</name></type> <name>getIndirect</name><argument_list>(<argument><expr><name>CharUnits</name> <name>Alignment</name></expr></argument>, <argument><expr><name>bool</name> <name>ByVal</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>bool</name> <name>Realign</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>Padding</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>AI</name> <init>= <expr><call><name>ABIArgInfo</name><argument_list>(<argument><expr><name>Indirect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setIndirectAlign</name></name><argument_list>(<argument><expr><name>Alignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setIndirectByVal</name></name><argument_list>(<argument><expr><name>ByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setIndirectRealign</name></name><argument_list>(<argument><expr><name>Realign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setSRetAfterThis</name></name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setPaddingType</name></name><argument_list>(<argument><expr><name>Padding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AI</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>ABIArgInfo</name></type> <name>getIndirectAliased</name><argument_list>(<argument><expr><name>CharUnits</name> <name>Alignment</name></expr></argument>, <argument><expr><name>unsigned</name> <name>AddrSpace</name></expr></argument>,
<argument><expr><name>bool</name> <name>Realign</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>Padding</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>AI</name> <init>= <expr><call><name>ABIArgInfo</name><argument_list>(<argument><expr><name>IndirectAliased</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setIndirectAlign</name></name><argument_list>(<argument><expr><name>Alignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setIndirectRealign</name></name><argument_list>(<argument><expr><name>Realign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setPaddingType</name></name><argument_list>(<argument><expr><name>Padding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setIndirectAddrSpace</name></name><argument_list>(<argument><expr><name>AddrSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AI</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>ABIArgInfo</name></type> <name>getIndirectInReg</name><parameter_list>(<parameter><decl><type><name>CharUnits</name></type> <name>Alignment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ByVal</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Realign</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>AI</name> <init>= <expr><call><name>getIndirect</name><argument_list>(<argument><expr><name>Alignment</name></expr></argument>, <argument><expr><name>ByVal</name></expr></argument>, <argument><expr><name>Realign</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setInReg</name></name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AI</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>ABIArgInfo</name></type> <name>getInAlloca</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>FieldIndex</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Indirect</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>AI</name> <init>= <expr><call><name>ABIArgInfo</name><argument_list>(<argument><expr><name>InAlloca</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setInAllocaFieldIndex</name></name><argument_list>(<argument><expr><name>FieldIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setInAllocaIndirect</name></name><argument_list>(<argument><expr><name>Indirect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AI</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>ABIArgInfo</name></type> <name>getExpand</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>AI</name> <init>= <expr><call><name>ABIArgInfo</name><argument_list>(<argument><expr><name>Expand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setPaddingType</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AI</name></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>ABIArgInfo</name></type> <name>getExpandWithPadding</name><argument_list>(<argument><expr><name>bool</name> <name>PaddingInReg</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>Padding</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>AI</name> <init>= <expr><call><name>getExpand</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setPaddingInReg</name></name><argument_list>(<argument><expr><name>PaddingInReg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setPaddingType</name></name><argument_list>(<argument><expr><name>Padding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AI</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><specifier>static</specifier> <name>ABIArgInfo</name></type> <name>getCoerceAndExpand</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>StructType</name> <operator>*</operator><name>coerceToType</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>unpaddedCoerceToType</name></expr></argument>)</argument_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>



<decl_stmt><decl><type><name>auto</name></type> <name>unpaddedStruct</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>StructType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>unpaddedCoerceToType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>unpaddedStruct</name> <operator>||</operator> <call><name><name>unpaddedStruct</name><operator>-&gt;</operator><name>getNumElements</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>unpaddedIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>auto</name></type> <name>eltType</name> <range>: <expr><call><name><name>coerceToType</name><operator>-&gt;</operator><name>elements</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>isPaddingForCoerceAndExpand</name><argument_list>(<argument><expr><name>eltType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>unpaddedStruct</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>unpaddedStruct</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>(<argument><expr><name>unpaddedIndex</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>eltType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>unpaddedIndex</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>unpaddedCoerceToType</name> <operator>==</operator> <name>eltType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>unpaddedIndex</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name>unpaddedStruct</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>unpaddedStruct</name><operator>-&gt;</operator><name>getNumElements</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>unpaddedIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>unpaddedIndex</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>auto</name></type> <name>AI</name> <init>= <expr><call><name>ABIArgInfo</name><argument_list>(<argument><expr><name>CoerceAndExpand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setCoerceToType</name></name><argument_list>(<argument><expr><name>coerceToType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>AI</name><operator>.</operator><name>setUnpaddedCoerceToType</name></name><argument_list>(<argument><expr><name>unpaddedCoerceToType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AI</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>isPaddingForCoerceAndExpand</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>eltType</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>eltType</name><operator>-&gt;</operator><name>isArrayTy</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>eltType</name><operator>-&gt;</operator><name>getArrayElementType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isIntegerTy</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TheKind</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isDirect</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TheKind</name> <operator>==</operator> <name>Direct</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isInAlloca</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TheKind</name> <operator>==</operator> <name>InAlloca</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isExtend</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TheKind</name> <operator>==</operator> <name>Extend</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isIgnore</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TheKind</name> <operator>==</operator> <name>Ignore</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isIndirect</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TheKind</name> <operator>==</operator> <name>Indirect</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isIndirectAliased</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TheKind</name> <operator>==</operator> <name>IndirectAliased</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isExpand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TheKind</name> <operator>==</operator> <name>Expand</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isCoerceAndExpand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TheKind</name> <operator>==</operator> <name>CoerceAndExpand</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>canHaveCoerceToType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isDirect</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isExtend</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isCoerceAndExpand</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getDirectOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isDirect</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isExtend</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Not a direct or extend kind"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>DirectAttr</name><operator>.</operator><name>Offset</name></name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setDirectOffset</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Offset</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isDirect</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isExtend</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Not a direct or extend kind"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>DirectAttr</name><operator>.</operator><name>Offset</name></name> <operator>=</operator> <name>Offset</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>unsigned</name> <macro><name>getDirectAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isDirect</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isExtend</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Not a direct or extend kind"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>DirectAttr</name><operator>.</operator><name>Align</name></name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setDirectAlign</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Align</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isDirect</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isExtend</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Not a direct or extend kind"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>DirectAttr</name><operator>.</operator><name>Align</name></name> <operator>=</operator> <name>Align</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>isSignExt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isExtend</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>SignExt</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setSignExt</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>SExt</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isExtend</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SignExt</name> <operator>=</operator> <name>SExt</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><macro><name>getPaddingType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>canHavePaddingType</name><argument_list>()</argument_list></call> <operator>?</operator> <name>PaddingType</name> <operator>:</operator> <name>nullptr</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>getPaddingInReg</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PaddingInReg</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setPaddingInReg</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>PIR</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>PaddingInReg</name> <operator>=</operator> <name>PIR</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><macro><name>getCoerceToType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>canHaveCoerceToType</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>TypeData</name></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>setCoerceToType</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>canHaveCoerceToType</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>TypeData</name> <operator>=</operator> <name>T</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>StructType</name> <operator>*</operator><macro><name>getCoerceAndExpandType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isCoerceAndExpand</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>StructType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TypeData</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><macro><name>getUnpaddedCoerceAndExpandType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isCoerceAndExpand</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>UnpaddedCoerceAndExpandType</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><macro><name>getCoerceAndExpandTypeSequence</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isCoerceAndExpand</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<decl><type><name>auto</name></type> <name>structTy</name> <init>=
<expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>StructType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>UnpaddedCoerceAndExpandType</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<return>return <expr><call><name><name>structTy</name><operator>-&gt;</operator><name>elements</name></name><argument_list>()</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content> else <block>{<block_content>
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnpaddedCoerceAndExpandType</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>
}

bool getInReg(</block></block></if></if_stmt>) <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isDirect</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isExtend</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isIndirect</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>InReg</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setInReg</name><argument_list>(<argument>bool IR</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isDirect</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isExtend</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isIndirect</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>InReg</name> <operator>=</operator> <name>IR</name></expr>;
}</block></block>


<name>CharUnits</name> <macro><name>getIndirectAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isIndirect</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isIndirectAliased</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>CharUnits</name><operator>::</operator><call><name>fromQuantity</name><argument_list>(<argument><expr><name><name>IndirectAttr</name><operator>.</operator><name>Align</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setIndirectAlign</name><parameter_list>(<parameter><decl><type><name>CharUnits</name></type> <name>IA</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isIndirect</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isIndirectAliased</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>IndirectAttr</name><operator>.</operator><name>Align</name></name> <operator>=</operator> <call><name><name>IA</name><operator>.</operator><name>getQuantity</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>getIndirectByVal</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isIndirect</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>IndirectByVal</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setIndirectByVal</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IBV</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isIndirect</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>IndirectByVal</name> <operator>=</operator> <name>IBV</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>unsigned</name> <macro><name>getIndirectAddrSpace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isIndirectAliased</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>IndirectAttr</name><operator>.</operator><name>AddrSpace</name></name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setIndirectAddrSpace</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>AddrSpace</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isIndirectAliased</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>IndirectAttr</name><operator>.</operator><name>AddrSpace</name></name> <operator>=</operator> <name>AddrSpace</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>getIndirectRealign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isIndirect</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isIndirectAliased</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>IndirectRealign</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setIndirectRealign</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IR</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isIndirect</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isIndirectAliased</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>IndirectRealign</name> <operator>=</operator> <name>IR</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>isSRetAfterThis</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isIndirect</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>SRetAfterThis</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setSRetAfterThis</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>AfterThis</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isIndirect</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SRetAfterThis</name> <operator>=</operator> <name>AfterThis</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>unsigned</name> <macro><name>getInAllocaFieldIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isInAlloca</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>AllocaFieldIndex</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setInAllocaFieldIndex</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>FieldIndex</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isInAlloca</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>AllocaFieldIndex</name> <operator>=</operator> <name>FieldIndex</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>unsigned</name> <macro><name>getInAllocaIndirect</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isInAlloca</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>InAllocaIndirect</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setInAllocaIndirect</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Indirect</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isInAlloca</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>InAllocaIndirect</name> <operator>=</operator> <name>Indirect</name></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>getInAllocaSRet</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isInAlloca</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>InAllocaSRet</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setInAllocaSRet</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>SRet</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isInAlloca</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>InAllocaSRet</name> <operator>=</operator> <name>SRet</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>getCanBeFlattened</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isDirect</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>CanBeFlattened</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setCanBeFlattened</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Flatten</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isDirect</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid kind!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>CanBeFlattened</name> <operator>=</operator> <name>Flatten</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>RequiredArgs</name> <block>{<block_content>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumRequired</name></decl>;</decl_stmt>
<label><name>public</name>:</label>
<enum>enum <name>All_t</name> <block>{ <decl><name>All</name></decl> }</block>;</enum>

<macro><name>RequiredArgs</name><argument_list>(<argument>All_t _</argument>)</argument_list></macro> : <macro><name>NumRequired</name><argument_list>(<argument>~<literal type="number">0U</literal></argument>)</argument_list></macro> <block>{<block_content/>}</block>
<macro><name>explicit</name></macro> <macro><name>RequiredArgs</name><argument_list>(<argument>unsigned n</argument>)</argument_list></macro> : <macro><name>NumRequired</name><argument_list>(<argument>n</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>!=</operator> <operator>~</operator><literal type="number">0U</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>






<function><type><specifier>static</specifier> <name>RequiredArgs</name></type> <name>forPrototypePlus</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>prototype</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>additional</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>prototype</name><operator>-&gt;</operator><name>isVariadic</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>All</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>prototype</name><operator>-&gt;</operator><name>hasExtParameterInfos</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>additional</name> <operator>+=</operator> <name>llvm</name><operator>::</operator><call><name>count_if</name><argument_list>(
<argument><expr><call><name><name>prototype</name><operator>-&gt;</operator><name>getExtParameterInfos</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><index>[]</index><operator>(</operator><specifier>const</specifier> <name>FunctionProtoType</name><operator>::</operator><name>ExtParameterInfo</name> <operator>&amp;</operator><name>ExtInfo</name><operator>)</operator> <block>{
<return>return <expr><call><name><name>ExtInfo</name><operator>.</operator><name>hasPassObjectSize</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></argument></argument_list></call></expr></expr_stmt></block_content></block></if></if_stmt>)</block_content></block>;</function>

<return>return <expr><call><name>RequiredArgs</name><argument_list>(<argument><expr><call><name><name>prototype</name><operator>-&gt;</operator><name>getNumParams</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>additional</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>RequiredArgs</name></type> <name>forPrototypePlus</name><parameter_list>(<parameter><decl><type><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name></expr></argument>&gt;</argument_list></name></type> <name>prototype</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>additional</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>forPrototypePlus</name><argument_list>(<argument><expr><call><name><name>prototype</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>additional</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RequiredArgs</name></type> <name>forPrototype</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>prototype</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>forPrototypePlus</name><argument_list>(<argument><expr><name>prototype</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RequiredArgs</name></type> <name>forPrototype</name><parameter_list>(<parameter><decl><type><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name></expr></argument>&gt;</argument_list></name></type> <name>prototype</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>forPrototypePlus</name><argument_list>(<argument><expr><call><name><name>prototype</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>allowsOptionalArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumRequired</name> <operator>!=</operator> <operator>~</operator><literal type="number">0U</literal></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getNumRequiredArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>allowsOptionalArgs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>NumRequired</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>getOpaqueData</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumRequired</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><specifier>static</specifier> <name>RequiredArgs</name></type> <name>getFromOpaqueData</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <operator>~</operator><literal type="number">0U</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>All</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>RequiredArgs</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<struct>struct <name>CGFunctionInfoArgInfo</name> <block>{
<decl_stmt><decl><type><name>CanQualType</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ABIArgInfo</name></type> <name>info</name></decl>;</decl_stmt>
}</block>;</struct>



<decl_stmt><decl><type><name>class</name> <name>CGFunctionInfo</name></type> <name>final</name>
<range>: <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name></expr></range></decl>,
<decl><type ref="prev"/><name>private</name> <name>llvm</name>::<name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>CGFunctionInfo</name></expr></argument>, <argument><expr><name>CGFunctionInfoArgInfo</name></expr></argument>,
<argument><expr><name>FunctionProtoType</name><operator>::</operator><name>ExtParameterInfo</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<typedef>typedef <type><name>CGFunctionInfoArgInfo</name></type> <name>ArgInfo</name>;</typedef>
<typedef>typedef <expr_stmt><expr><name>FunctionProtoType</name><operator>::</operator><name>ExtParameterInfo</name> <name>ExtParameterInfo</name></expr>;</expr_stmt></typedef>



<decl_stmt><decl><type><name>unsigned</name></type> <name>CallingConvention</name> <range>: <expr><literal type="number">8</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>EffectiveCallingConvention</name> <range>: <expr><literal type="number">8</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>ASTCallingConvention</name> <range>: <expr><literal type="number">6</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>InstanceMethod</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>ChainCall</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>CmseNSCall</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NoReturn</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>ReturnsRetained</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NoCallerSavedRegs</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>HasRegParm</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>RegParm</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NoCfCheck</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RequiredArgs</name></type> <name>Required</name></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>StructType</name> <operator>*</operator><name>ArgStruct</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ArgStructAlign</name> <range>: <expr><literal type="number">31</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>HasExtParameterInfos</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>NumArgs</name></decl>;</decl_stmt>

<function><type><name>ArgInfo</name> <modifier>*</modifier></type><name>getArgsBuffer</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ArgInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>ArgInfo</name> <operator>*</operator><macro><name>getArgsBuffer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ArgInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>ExtParameterInfo</name> <modifier>*</modifier></type><name>getExtParameterInfosBuffer</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ExtParameterInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>ExtParameterInfo</name> <operator>*</operator><macro><name>getExtParameterInfosBuffer</name><argument_list>()</argument_list></macro> <specifier>const</specifier><block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ExtParameterInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><call><name>CGFunctionInfo</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Required</name><argument_list>(<argument>RequiredArgs::All</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>CGFunctionInfo</name> <operator>*</operator><macro><name>create</name><argument_list>(<argument>unsigned llvmCC</argument>,
<argument>bool instanceMethod</argument>,
<argument>bool chainCall</argument>,
<argument>const FunctionType::ExtInfo &amp;extInfo</argument>,
<argument>ArrayRef&lt;ExtParameterInfo&gt; paramInfos</argument>,
<argument>CanQualType resultType</argument>,
<argument>ArrayRef&lt;CanQualType&gt; argTypes</argument>,
<argument>RequiredArgs required</argument>)</argument_list></macro></expr>;</expr_stmt>
<function><type><name>void</name> <name>operator</name></type> <name>delete</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><operator>::</operator><name>operator</name> <call><name>delete</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>



<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>TrailingObjects</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>numTrailingObjects</name><argument_list>(<argument><expr><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>ArgInfo</name></expr></argument>&gt;</argument_list></name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>NumArgs</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>numTrailingObjects</name><argument_list>(<argument><expr><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>ExtParameterInfo</name></expr></argument>&gt;</argument_list></name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><operator>(</operator><ternary><condition><expr><name>HasExtParameterInfos</name></expr> ?</condition><then> <expr><name>NumArgs</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<typedef>typedef <type><specifier>const</specifier> <name>ArgInfo</name> <modifier>*</modifier></type><name>const_arg_iterator</name>;</typedef>
<typedef>typedef <type><name>ArgInfo</name> <modifier>*</modifier></type><name>arg_iterator</name>;</typedef>

<function><type><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ArgInfo</name></expr></argument>&gt;</argument_list></name></type> <name>arguments</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ArgInfo</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>arg_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NumArgs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ArgInfo</name></expr></argument>&gt;</argument_list></name> <macro><name>arguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ArgInfo</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>arg_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NumArgs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>const_arg_iterator</name> <macro><name>arg_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getArgsBuffer</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>const_arg_iterator</name> <macro><name>arg_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getArgsBuffer</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>NumArgs</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>arg_iterator</name></type> <name>arg_begin</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>getArgsBuffer</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</return> </block_content>}</block></function>
<function><type><name>arg_iterator</name></type> <name>arg_end</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>getArgsBuffer</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>NumArgs</name></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name>unsigned</name> <macro><name>arg_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumArgs</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isVariadic</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Required</name><operator>.</operator><name>allowsOptionalArgs</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>RequiredArgs</name> <macro><name>getRequiredArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Required</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getNumRequiredArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isVariadic</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name>getRequiredArgs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getNumRequiredArgs</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>arg_size</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isInstanceMethod</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>InstanceMethod</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isChainCall</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ChainCall</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isCmseNSCall</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CmseNSCall</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isNoReturn</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NoReturn</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isReturnsRetained</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ReturnsRetained</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isNoCallerSavedRegs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NoCallerSavedRegs</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isNoCfCheck</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NoCfCheck</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>CallingConv</name> <macro><name>getASTCallingConvention</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>CallingConv</name><argument_list>(<argument><expr><name>ASTCallingConvention</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getCallingConvention</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CallingConvention</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getEffectiveCallingConvention</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>EffectiveCallingConvention</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setEffectiveCallingConvention</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>EffectiveCallingConvention</name> <operator>=</operator> <name>Value</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>getHasRegParm</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasRegParm</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getRegParm</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RegParm</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>FunctionType</name><operator>::</operator><name>ExtInfo</name> <macro><name>getExtInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>FunctionType</name><operator>::</operator><call><name>ExtInfo</name><argument_list>(<argument><expr><call><name>isNoReturn</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getHasRegParm</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRegParm</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getASTCallingConvention</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>isReturnsRetained</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>isNoCallerSavedRegs</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>isNoCfCheck</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>isCmseNSCall</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>CanQualType</name> <macro><name>getReturnType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getArgsBuffer</name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index><operator>.</operator><name>type</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>ABIArgInfo</name> <modifier>&amp;</modifier></type><name>getReturnInfo</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>getArgsBuffer</name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index><operator>.</operator><name>info</name></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>ABIArgInfo</name> <operator>&amp;</operator><macro><name>getReturnInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getArgsBuffer</name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index><operator>.</operator><name>info</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ExtParameterInfo</name></expr></argument>&gt;</argument_list></name> <macro><name>getExtParameterInfos</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HasExtParameterInfos</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><block>{}</block></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getExtParameterInfosBuffer</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NumArgs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>ExtParameterInfo</name></type> <name>getExtParameterInfo</name><argument_list>(<argument><expr><name>unsigned</name> <name>argIndex</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>argIndex</name> <operator>&lt;=</operator> <name>NumArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HasExtParameterInfos</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ExtParameterInfo</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getExtParameterInfos</name><argument_list>()</argument_list></call><index>[<expr><name>argIndex</name></expr>]</index></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>usesInAlloca</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ArgStruct</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>StructType</name> <operator>*</operator><macro><name>getArgStruct</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ArgStruct</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>CharUnits</name> <macro><name>getArgStructAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>CharUnits</name><operator>::</operator><call><name>fromQuantity</name><argument_list>(<argument><expr><name>ArgStructAlign</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>setArgStruct</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>StructType</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>CharUnits</name> <name>Align</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name>ArgStruct</name> <operator>=</operator> <name>Ty</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ArgStructAlign</name> <operator>=</operator> <call><name><name>Align</name><operator>.</operator><name>getQuantity</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><call><name>getASTCallingConvention</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><name>InstanceMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><name>ChainCall</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><name>NoReturn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><name>ReturnsRetained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><name>NoCallerSavedRegs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><name>HasRegParm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>RegParm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><name>NoCfCheck</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><name>CmseNSCall</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><call><name><name>Required</name><operator>.</operator><name>getOpaqueData</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><name>HasExtParameterInfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>HasExtParameterInfos</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>auto</name></type> <name>paramInfo</name> <range>: <expr><call><name>getExtParameterInfos</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><call><name><name>paramInfo</name><operator>.</operator><name>getOpaqueValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>getReturnType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>I</name> <range>: <expr><call><name>arguments</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>I</name><operator>.</operator><name>type</name><operator>.</operator><name>Profile</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>,
<argument><expr><name>bool</name> <name>InstanceMethod</name></expr></argument>,
<argument><expr><name>bool</name> <name>ChainCall</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionType</name><operator>::</operator><name>ExtInfo</name> <operator>&amp;</operator><name>info</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ExtParameterInfo</name></expr></argument>&gt;</argument_list></name> <name>paramInfos</name></expr></argument>,
<argument><expr><name>RequiredArgs</name> <name>required</name></expr></argument>,
<argument><expr><name>CanQualType</name> <name>resultType</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>CanQualType</name></expr></argument>&gt;</argument_list></name> <name>argTypes</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><call><name><name>info</name><operator>.</operator><name>getCC</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><name>InstanceMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><name>ChainCall</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><call><name><name>info</name><operator>.</operator><name>getNoReturn</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><call><name><name>info</name><operator>.</operator><name>getProducesResult</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><call><name><name>info</name><operator>.</operator><name>getNoCallerSavedRegs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><call><name><name>info</name><operator>.</operator><name>getHasRegParm</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><call><name><name>info</name><operator>.</operator><name>getRegParm</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><call><name><name>info</name><operator>.</operator><name>getNoCfCheck</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><call><name><name>info</name><operator>.</operator><name>getCmseNSCall</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><call><name><name>required</name><operator>.</operator><name>getOpaqueData</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><operator>!</operator><call><name><name>paramInfos</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>paramInfos</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>auto</name></type> <name>paramInfo</name> <range>: <expr><name>paramInfos</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><call><name><name>paramInfo</name><operator>.</operator><name>getOpaqueValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name><name>resultType</name><operator>.</operator><name>Profile</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>CanQualType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name>
<name>i</name> <operator>=</operator> <call><name><name>argTypes</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr><operator>,</operator> <expr><name>e</name> <operator>=</operator> <call><name><name>argTypes</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>e</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name><name>i</name><operator>-&gt;</operator><name>Profile</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

}
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
