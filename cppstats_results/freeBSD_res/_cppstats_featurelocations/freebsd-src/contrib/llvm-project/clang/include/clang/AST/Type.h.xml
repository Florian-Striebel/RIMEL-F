<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/Type.h">















<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_TYPE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_TYPE_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DependenceFlags.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/NestedNameSpecifier.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TemplateName.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/AddressSpaces.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/AttrKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Diagnostic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/ExceptionSpecificationType.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Linkage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/PartialDiagnostic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Specifiers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Visibility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/APInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/APSInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/FoldingSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/None.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerIntPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerUnion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Twine.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/ErrorHandling.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/PointerLikeTypeTraits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/TrailingObjects.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/type_traits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstring&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;type_traits&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ExtQuals</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>QualType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ConceptDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TagDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateParameterList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Type</name></decl>;</decl_stmt>

<enum>enum <block>{
<decl><name>TypeAlignmentInBits</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,
<decl><name>TypeAlignment</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>TypeAlignmentInBits</name></expr></init></decl>
}</block>;</enum>

<decl_stmt><decl><type><name>namespace</name></type> <name>serialization</name> <block>{<block_content>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>AbstractTypeReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>AbstractTypeWriter</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator>
struct <name>PointerLikeTypeTraits</name></expr>;</expr_stmt>
<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator>
struct <name><name>PointerLikeTypeTraits</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>Type</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <operator>*</operator><macro><name>getAsVoidPointer</name><argument_list>(<argument>::clang::Type *P</argument>)</argument_list></macro> <block>{ <return>return <expr><name>P</name></expr>;</return> }</block>

<specifier>static</specifier> <specifier>inline</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>Type</name> <operator>*</operator><macro><name>getFromVoidPointer</name><argument_list>(<argument>void *P</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>Type</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>constexpr</name> <name>int</name> <name>NumLowBitsAvailable</name> <operator>=</operator> <name>clang</name><operator>::</operator><name>TypeAlignmentInBits</name></expr>;
}</block></expr>;</expr_stmt>

<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator>
struct <name><name>PointerLikeTypeTraits</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>ExtQuals</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <operator>*</operator><macro><name>getAsVoidPointer</name><argument_list>(<argument>::clang::ExtQuals *P</argument>)</argument_list></macro> <block>{ <return>return <expr><name>P</name></expr>;</return> }</block>

<specifier>static</specifier> <specifier>inline</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>ExtQuals</name> <operator>*</operator><macro><name>getFromVoidPointer</name><argument_list>(<argument>void *P</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>ExtQuals</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>constexpr</name> <name>int</name> <name>NumLowBitsAvailable</name> <operator>=</operator> <name>clang</name><operator>::</operator><name>TypeAlignmentInBits</name></expr>;
}</block></expr>;</expr_stmt>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>CanQual</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXRecordDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DeclContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>EnumDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ExtQualsTypeCommonBase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>IdentifierInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>NamedDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCInterfaceDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCProtocolDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCTypeParamDecl</name></decl>;</decl_stmt>
<struct_decl>struct <name>PrintingPolicy</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>RecordDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Stmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TagDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateArgument</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateArgumentListInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateArgumentLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateTypeParmDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TypedefNameDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UnresolvedUsingTypenameDecl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CanQualType</name> <init>= <expr><name><name>CanQual</name><argument_list type="generic">&lt;<argument><expr><name>Type</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPE</name><parameter_list>(<parameter><type><name>Class</name></type></parameter>, <parameter><type><name>Base</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>class Class##Type;</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeNodes.inc"</cpp:file></cpp:include>







<decl_stmt><decl><type><name>class</name></type> <name>Qualifiers</name> <block>{<block_content>
<label><name>public</name>:</label>
<enum>enum <name>TQ</name> <block>{
<decl><name>Const</name> <init>= <expr><literal type="number">0x1</literal></expr></init></decl>,
<decl><name>Restrict</name> <init>= <expr><literal type="number">0x2</literal></expr></init></decl>,
<decl><name>Volatile</name> <init>= <expr><literal type="number">0x4</literal></expr></init></decl>,
<decl><name>CVRMask</name> <init>= <expr><name>Const</name> <operator>|</operator> <name>Volatile</name> <operator>|</operator> <name>Restrict</name></expr></init></decl>
}</block>;</enum>

<enum>enum <name>GC</name> <block>{
<decl><name>GCNone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>Weak</name></decl>,
<decl><name>Strong</name></decl>
}</block>;</enum>

<enum>enum <name>ObjCLifetime</name> <block>{

<decl><name>OCL_None</name></decl>,



<decl><name>OCL_ExplicitNone</name></decl>,






<decl><name>OCL_Strong</name></decl>,


<decl><name>OCL_Weak</name></decl>,


<decl><name>OCL_Autoreleasing</name></decl>
}</block>;</enum>

<enum>enum <block>{


<decl><name>MaxAddressSpace</name> <init>= <expr><literal type="number">0x7fffffu</literal></expr></init></decl>,


<decl><name>FastWidth</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,


<decl><name>FastMask</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>FastWidth</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>
}</block>;</enum>



<function><type><specifier>static</specifier> <name>Qualifiers</name></type> <name>removeCommonQualifiers</name><parameter_list>(<parameter><decl><type><name>Qualifiers</name> <modifier>&amp;</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Qualifiers</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>L</name><operator>.</operator><name>Mask</name></name> <operator>&amp;</operator> <operator>~</operator><name>CVRMask</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>R</name><operator>.</operator><name>Mask</name></name> <operator>&amp;</operator> <operator>~</operator><name>CVRMask</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Qualifiers</name></type> <name>Q</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Q</name><operator>.</operator><name>Mask</name></name> <operator>=</operator> <name><name>L</name><operator>.</operator><name>Mask</name></name> <operator>&amp;</operator> <name><name>R</name><operator>.</operator><name>Mask</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>.</operator><name>Mask</name></name> <operator>&amp;=</operator> <operator>~</operator><name><name>Q</name><operator>.</operator><name>Mask</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>R</name><operator>.</operator><name>Mask</name></name> <operator>&amp;=</operator> <operator>~</operator><name><name>Q</name><operator>.</operator><name>Mask</name></name></expr>;</expr_stmt>
<return>return <expr><name>Q</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>Qualifiers</name></type> <name>Q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>CommonCRV</name> <init>= <expr><call><name><name>L</name><operator>.</operator><name>getCVRQualifiers</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <call><name><name>R</name><operator>.</operator><name>getCVRQualifiers</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Q</name><operator>.</operator><name>addCVRQualifiers</name></name><argument_list>(<argument><expr><name>CommonCRV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>L</name><operator>.</operator><name>removeCVRQualifiers</name></name><argument_list>(<argument><expr><name>CommonCRV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>R</name><operator>.</operator><name>removeCVRQualifiers</name></name><argument_list>(<argument><expr><name>CommonCRV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>L</name><operator>.</operator><name>getObjCGCAttr</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>R</name><operator>.</operator><name>getObjCGCAttr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Q</name><operator>.</operator><name>setObjCGCAttr</name></name><argument_list>(<argument><expr><call><name><name>L</name><operator>.</operator><name>getObjCGCAttr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>L</name><operator>.</operator><name>removeObjCGCAttr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>R</name><operator>.</operator><name>removeObjCGCAttr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>L</name><operator>.</operator><name>getObjCLifetime</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>R</name><operator>.</operator><name>getObjCLifetime</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Q</name><operator>.</operator><name>setObjCLifetime</name></name><argument_list>(<argument><expr><call><name><name>L</name><operator>.</operator><name>getObjCLifetime</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>L</name><operator>.</operator><name>removeObjCLifetime</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>R</name><operator>.</operator><name>removeObjCLifetime</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>L</name><operator>.</operator><name>getAddressSpace</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>R</name><operator>.</operator><name>getAddressSpace</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Q</name><operator>.</operator><name>setAddressSpace</name></name><argument_list>(<argument><expr><call><name><name>L</name><operator>.</operator><name>getAddressSpace</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>L</name><operator>.</operator><name>removeAddressSpace</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>R</name><operator>.</operator><name>removeAddressSpace</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>Q</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Qualifiers</name></type> <name>fromFastMask</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>Qualifiers</name></type> <name>Qs</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Qs</name><operator>.</operator><name>addFastQualifiers</name></name><argument_list>(<argument><expr><name>Mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Qs</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Qualifiers</name></type> <name>fromCVRMask</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>CVR</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>Qualifiers</name></type> <name>Qs</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Qs</name><operator>.</operator><name>addCVRQualifiers</name></name><argument_list>(<argument><expr><name>CVR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Qs</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Qualifiers</name></type> <name>fromCVRUMask</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>CVRU</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>Qualifiers</name></type> <name>Qs</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Qs</name><operator>.</operator><name>addCVRUQualifiers</name></name><argument_list>(<argument><expr><name>CVRU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Qs</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Qualifiers</name></type> <name>fromOpaqueValue</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>opaque</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>Qualifiers</name></type> <name>Qs</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Qs</name><operator>.</operator><name>Mask</name></name> <operator>=</operator> <name>opaque</name></expr>;</expr_stmt>
<return>return <expr><name>Qs</name></expr>;</return>
</block_content>}</block></function>


<expr_stmt><expr><name>unsigned</name> <macro><name>getAsOpaqueValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Mask</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasConst</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Mask</name> <operator>&amp;</operator> <name>Const</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>hasOnlyConst</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Mask</name> <operator>==</operator> <name>Const</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>removeConst</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Mask</name> <operator>&amp;=</operator> <operator>~</operator><name>Const</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>addConst</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Mask</name> <operator>|=</operator> <name>Const</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>hasVolatile</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Mask</name> <operator>&amp;</operator> <name>Volatile</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>hasOnlyVolatile</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Mask</name> <operator>==</operator> <name>Volatile</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>removeVolatile</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Mask</name> <operator>&amp;=</operator> <operator>~</operator><name>Volatile</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>addVolatile</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Mask</name> <operator>|=</operator> <name>Volatile</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>hasRestrict</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Mask</name> <operator>&amp;</operator> <name>Restrict</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>hasOnlyRestrict</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Mask</name> <operator>==</operator> <name>Restrict</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>removeRestrict</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Mask</name> <operator>&amp;=</operator> <operator>~</operator><name>Restrict</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>addRestrict</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Mask</name> <operator>|=</operator> <name>Restrict</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>hasCVRQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getCVRQualifiers</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getCVRQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Mask</name> <operator>&amp;</operator> <name>CVRMask</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getCVRUQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Mask</name> <operator>&amp;</operator> <operator>(</operator><name>CVRMask</name> <operator>|</operator> <name>UMask</name><operator>)</operator></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setCVRQualifiers</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>mask</name> <operator>&amp;</operator> <operator>~</operator><name>CVRMask</name><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"bitmask contains non-CVR bits"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Mask</name> <operator>=</operator> <operator>(</operator><name>Mask</name> <operator>&amp;</operator> <operator>~</operator><name>CVRMask</name><operator>)</operator> <operator>|</operator> <name>mask</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>removeCVRQualifiers</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>mask</name> <operator>&amp;</operator> <operator>~</operator><name>CVRMask</name><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"bitmask contains non-CVR bits"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Mask</name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>removeCVRQualifiers</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>removeCVRQualifiers</name><argument_list>(<argument><expr><name>CVRMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>addCVRQualifiers</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>mask</name> <operator>&amp;</operator> <operator>~</operator><name>CVRMask</name><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"bitmask contains non-CVR bits"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Mask</name> <operator>|=</operator> <name>mask</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>addCVRUQualifiers</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>mask</name> <operator>&amp;</operator> <operator>~</operator><name>CVRMask</name> <operator>&amp;</operator> <operator>~</operator><name>UMask</name><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"bitmask contains non-CVRU bits"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Mask</name> <operator>|=</operator> <name>mask</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>hasUnaligned</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Mask</name> <operator>&amp;</operator> <name>UMask</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setUnaligned</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>flag</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Mask</name> <operator>=</operator> <operator>(</operator><name>Mask</name> <operator>&amp;</operator> <operator>~</operator><name>UMask</name><operator>)</operator> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>flag</name></expr> ?</condition><then> <expr><name>UMask</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>removeUnaligned</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Mask</name> <operator>&amp;=</operator> <operator>~</operator><name>UMask</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>addUnaligned</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Mask</name> <operator>|=</operator> <name>UMask</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>hasObjCGCAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Mask</name> <operator>&amp;</operator> <name>GCAttrMask</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>GC</name> <macro><name>getObjCGCAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>GC</name><argument_list>(<argument><expr><operator>(</operator><name>Mask</name> <operator>&amp;</operator> <name>GCAttrMask</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>GCAttrShift</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setObjCGCAttr</name><parameter_list>(<parameter><decl><type><name>GC</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Mask</name> <operator>=</operator> <operator>(</operator><name>Mask</name> <operator>&amp;</operator> <operator>~</operator><name>GCAttrMask</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>type</name> <operator>&lt;&lt;</operator> <name>GCAttrShift</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>removeObjCGCAttr</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>setObjCGCAttr</name><argument_list>(<argument><expr><name>GCNone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>addObjCGCAttr</name><parameter_list>(<parameter><decl><type><name>GC</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setObjCGCAttr</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><name>Qualifiers</name> <macro><name>withoutObjCGCAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>Qualifiers</name> <name>qs</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;
<expr><call><name><name>qs</name><operator>.</operator><name>removeObjCGCAttr</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>qs</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Qualifiers</name> <macro><name>withoutObjCLifetime</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>Qualifiers</name> <name>qs</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;
<expr><call><name><name>qs</name><operator>.</operator><name>removeObjCLifetime</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>qs</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Qualifiers</name> <macro><name>withoutAddressSpace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>Qualifiers</name> <name>qs</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;
<expr><call><name><name>qs</name><operator>.</operator><name>removeAddressSpace</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>qs</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasObjCLifetime</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Mask</name> <operator>&amp;</operator> <name>LifetimeMask</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>ObjCLifetime</name> <macro><name>getObjCLifetime</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>ObjCLifetime</name><argument_list>(<argument><expr><operator>(</operator><name>Mask</name> <operator>&amp;</operator> <name>LifetimeMask</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>LifetimeShift</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setObjCLifetime</name><parameter_list>(<parameter><decl><type><name>ObjCLifetime</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Mask</name> <operator>=</operator> <operator>(</operator><name>Mask</name> <operator>&amp;</operator> <operator>~</operator><name>LifetimeMask</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>type</name> <operator>&lt;&lt;</operator> <name>LifetimeShift</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>removeObjCLifetime</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>setObjCLifetime</name><argument_list>(<argument><expr><name>OCL_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>addObjCLifetime</name><parameter_list>(<parameter><decl><type><name>ObjCLifetime</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>hasObjCLifetime</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Mask</name> <operator>|=</operator> <operator>(</operator><name>type</name> <operator>&lt;&lt;</operator> <name>LifetimeShift</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>hasNonTrivialObjCLifetime</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>ObjCLifetime</name> <name>lifetime</name> <operator>=</operator> <call><name>getObjCLifetime</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><operator>(</operator><name>lifetime</name> <operator>&gt;</operator> <name>OCL_ExplicitNone</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasStrongOrWeakObjCLifetime</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>ObjCLifetime</name> <name>lifetime</name> <operator>=</operator> <call><name>getObjCLifetime</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><operator>(</operator><name>lifetime</name> <operator>==</operator> <name>OCL_Strong</name> <operator>||</operator> <name>lifetime</name> <operator>==</operator> <name>OCL_Weak</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasAddressSpace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Mask</name> <operator>&amp;</operator> <name>AddressSpaceMask</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>LangAS</name> <macro><name>getAddressSpace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>LangAS</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Mask</name> <operator>&gt;&gt;</operator> <name>AddressSpaceShift</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>hasTargetSpecificAddressSpace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isTargetAddressSpace</name><argument_list>(<argument><expr><call><name>getAddressSpace</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>getAddressSpaceAttributePrintValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Addr</name> <operator>=</operator> <call><name>getAddressSpace</name><argument_list>()</argument_list></call></expr>;



<expr><call><name>assert</name><argument_list>(<argument><expr><name>Addr</name> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>Default</name> <operator>||</operator> <call><name>hasTargetSpecificAddressSpace</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>Addr</name> <operator>!=</operator> <name>LangAS</name><operator>::</operator><name>Default</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>toTargetAddressSpace</name><argument_list>(<argument><expr><name>Addr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>



<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<function><type><name>void</name></type> <name>setAddressSpace</name><parameter_list>(<parameter><decl><type><name>LangAS</name></type> <name>space</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>space</name> <operator>&lt;=</operator> <name>MaxAddressSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Mask</name> <operator>=</operator> <operator>(</operator><name>Mask</name> <operator>&amp;</operator> <operator>~</operator><name>AddressSpaceMask</name><operator>)</operator>
<operator>|</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator> <name>space</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>AddressSpaceShift</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>removeAddressSpace</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>setAddressSpace</name><argument_list>(<argument><expr><name>LangAS</name><operator>::</operator><name>Default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>addAddressSpace</name><parameter_list>(<parameter><decl><type><name>LangAS</name></type> <name>space</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>space</name> <operator>!=</operator> <name>LangAS</name><operator>::</operator><name>Default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setAddressSpace</name><argument_list>(<argument><expr><name>space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>hasFastQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getFastQualifiers</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getFastQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Mask</name> <operator>&amp;</operator> <name>FastMask</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setFastQualifiers</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>mask</name> <operator>&amp;</operator> <operator>~</operator><name>FastMask</name><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"bitmask contains non-fast qualifier bits"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Mask</name> <operator>=</operator> <operator>(</operator><name>Mask</name> <operator>&amp;</operator> <operator>~</operator><name>FastMask</name><operator>)</operator> <operator>|</operator> <name>mask</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>removeFastQualifiers</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>mask</name> <operator>&amp;</operator> <operator>~</operator><name>FastMask</name><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"bitmask contains non-fast qualifier bits"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Mask</name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>removeFastQualifiers</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>removeFastQualifiers</name><argument_list>(<argument><expr><name>FastMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>addFastQualifiers</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>mask</name> <operator>&amp;</operator> <operator>~</operator><name>FastMask</name><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"bitmask contains non-fast qualifier bits"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Mask</name> <operator>|=</operator> <name>mask</name></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>hasNonFastQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Mask</name> <operator>&amp;</operator> <operator>~</operator><name>FastMask</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>Qualifiers</name> <macro><name>getNonFastQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>Qualifiers</name> <name>Quals</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;
<expr><call><name><name>Quals</name><operator>.</operator><name>setFastQualifiers</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Quals</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Mask</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><name>Mask</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>addQualifiers</name><parameter_list>(<parameter><decl><type><name>Qualifiers</name></type> <name>Q</name></decl></parameter>)</parameter_list> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>Q</name><operator>.</operator><name>Mask</name></name> <operator>&amp;</operator> <operator>~</operator><name>CVRMask</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Mask</name> <operator>|=</operator> <name><name>Q</name><operator>.</operator><name>Mask</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>Mask</name> <operator>|=</operator> <operator>(</operator><name><name>Q</name><operator>.</operator><name>Mask</name></name> <operator>&amp;</operator> <name>CVRMask</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Q</name><operator>.</operator><name>hasAddressSpace</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addAddressSpace</name><argument_list>(<argument><expr><call><name><name>Q</name><operator>.</operator><name>getAddressSpace</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Q</name><operator>.</operator><name>hasObjCGCAttr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addObjCGCAttr</name><argument_list>(<argument><expr><call><name><name>Q</name><operator>.</operator><name>getObjCGCAttr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Q</name><operator>.</operator><name>hasObjCLifetime</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addObjCLifetime</name><argument_list>(<argument><expr><call><name><name>Q</name><operator>.</operator><name>getObjCLifetime</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>removeQualifiers</name><parameter_list>(<parameter><decl><type><name>Qualifiers</name></type> <name>Q</name></decl></parameter>)</parameter_list> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>Q</name><operator>.</operator><name>Mask</name></name> <operator>&amp;</operator> <operator>~</operator><name>CVRMask</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Mask</name> <operator>&amp;=</operator> <operator>~</operator><name><name>Q</name><operator>.</operator><name>Mask</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>Mask</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name><name>Q</name><operator>.</operator><name>Mask</name></name> <operator>&amp;</operator> <name>CVRMask</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getObjCGCAttr</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>Q</name><operator>.</operator><name>getObjCGCAttr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>removeObjCGCAttr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getObjCLifetime</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>Q</name><operator>.</operator><name>getObjCLifetime</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>removeObjCLifetime</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getAddressSpace</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>Q</name><operator>.</operator><name>getAddressSpace</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>removeAddressSpace</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>addConsistentQualifiers</name><parameter_list>(<parameter><decl><type><name>Qualifiers</name></type> <name>qs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getAddressSpace</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>qs</name><operator>.</operator><name>getAddressSpace</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<operator>!</operator><call><name>hasAddressSpace</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>qs</name><operator>.</operator><name>hasAddressSpace</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getObjCGCAttr</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>qs</name><operator>.</operator><name>getObjCGCAttr</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<operator>!</operator><call><name>hasObjCGCAttr</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>qs</name><operator>.</operator><name>hasObjCGCAttr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getObjCLifetime</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>qs</name><operator>.</operator><name>getObjCLifetime</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<operator>!</operator><call><name>hasObjCLifetime</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>qs</name><operator>.</operator><name>hasObjCLifetime</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Mask</name> <operator>|=</operator> <name><name>qs</name><operator>.</operator><name>Mask</name></name></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>bool</name></type> <name>isAddressSpaceSupersetOf</name><parameter_list>(<parameter><decl><type><name>LangAS</name></type> <name>A</name></decl></parameter>, <parameter><decl><type><name>LangAS</name></type> <name>B</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><name>A</name> <operator>==</operator> <name>B</name> <operator>||</operator>


<operator>(</operator><name>A</name> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>opencl_generic</name> <operator>&amp;&amp;</operator> <name>B</name> <operator>!=</operator> <name>LangAS</name><operator>::</operator><name>opencl_constant</name><operator>)</operator> <operator>||</operator>



<operator>(</operator><name>A</name> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>opencl_global</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>B</name> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>opencl_global_device</name> <operator>||</operator>
<name>B</name> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>opencl_global_host</name><operator>)</operator><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>A</name> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>sycl_global</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>B</name> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>sycl_global_device</name> <operator>||</operator>
<name>B</name> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>sycl_global_host</name><operator>)</operator><operator>)</operator> <operator>||</operator>

<operator>(</operator><operator>(</operator><call><name>isPtrSizeAddressSpace</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>A</name> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>Default</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>isPtrSizeAddressSpace</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>B</name> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>Default</name><operator>)</operator><operator>)</operator> <operator>||</operator>

<operator>(</operator><name>A</name> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>Default</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>B</name> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>sycl_private</name> <operator>||</operator> <name>B</name> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>sycl_local</name> <operator>||</operator>
<name>B</name> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>sycl_global</name> <operator>||</operator> <name>B</name> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>sycl_global_device</name> <operator>||</operator>
<name>B</name> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>sycl_global_host</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<decl_stmt><decl><type><name>bool</name></type> <name>isAddressSpaceSupersetOf</name><argument_list>(<argument><expr><name>Qualifiers</name> <name>other</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>isAddressSpaceSupersetOf</name><argument_list>(<argument><expr><call><name>getAddressSpace</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>other</name><operator>.</operator><name>getAddressSpace</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>compatiblyIncludes</name><argument_list>(<argument><expr><name>Qualifiers</name> <name>other</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>isAddressSpaceSupersetOf</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>


<operator>(</operator><call><name>getObjCGCAttr</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>other</name><operator>.</operator><name>getObjCGCAttr</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>hasObjCGCAttr</name><argument_list>()</argument_list></call> <operator>||</operator>
<operator>!</operator><call><name><name>other</name><operator>.</operator><name>hasObjCGCAttr</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>

<call><name>getObjCLifetime</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>other</name><operator>.</operator><name>getObjCLifetime</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>

<operator>(</operator><operator>(</operator><operator>(</operator><name>Mask</name> <operator>&amp;</operator> <name>CVRMask</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>other</name><operator>.</operator><name>Mask</name></name> <operator>&amp;</operator> <name>CVRMask</name><operator>)</operator><operator>)</operator> <operator>==</operator> <operator>(</operator><name>Mask</name> <operator>&amp;</operator> <name>CVRMask</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>(</operator><operator>!</operator><call><name><name>other</name><operator>.</operator><name>hasUnaligned</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>hasUnaligned</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>








<decl_stmt><decl><type><name>bool</name></type> <name>compatiblyIncludesObjCLifetime</name><argument_list>(<argument><expr><name>Qualifiers</name> <name>other</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getObjCLifetime</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>other</name><operator>.</operator><name>getObjCLifetime</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getObjCLifetime</name><argument_list>()</argument_list></call> <operator>==</operator> <name>OCL_Weak</name> <operator>||</operator> <call><name><name>other</name><operator>.</operator><name>getObjCLifetime</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OCL_Weak</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getObjCLifetime</name><argument_list>()</argument_list></call> <operator>==</operator> <name>OCL_None</name> <operator>||</operator> <call><name><name>other</name><operator>.</operator><name>getObjCLifetime</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OCL_None</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>hasConst</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isStrictSupersetOf</name><argument_list>(<argument><expr><name>Qualifiers</name> <name>Other</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><name>Qualifiers</name> <name>Other</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>Mask</name> <operator>==</operator> <name><name>Other</name><operator>.</operator><name>Mask</name></name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><name>Qualifiers</name> <name>Other</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>Mask</name> <operator>!=</operator> <name><name>Other</name><operator>.</operator><name>Mask</name></name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>explicit</name> <name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>hasQualifiers</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>Qualifiers</name> <operator>&amp;</operator><name>operator</name><operator>+=</operator><operator>(</operator><name>Qualifiers</name> <name>R</name><operator>)</operator> <block>{
<expr><call><name>addQualifiers</name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>friend</name> <name>Qualifiers</name> <name>operator</name><operator>+</operator><operator>(</operator><name>Qualifiers</name> <name>L</name><operator>,</operator> <name>Qualifiers</name> <name>R</name><operator>)</operator> <block>{
<expr><name>L</name> <operator>+=</operator> <name>R</name></expr>;
<return>return <expr><name>L</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>Qualifiers</name> <operator>&amp;</operator><name>operator</name><operator>-=</operator><operator>(</operator><name>Qualifiers</name> <name>R</name><operator>)</operator> <block>{
<expr><call><name>removeQualifiers</name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>friend</name> <name>Qualifiers</name> <name>operator</name><operator>-</operator><operator>(</operator><name>Qualifiers</name> <name>L</name><operator>,</operator> <name>Qualifiers</name> <name>R</name><operator>)</operator> <block>{
<expr><name>L</name> <operator>-=</operator> <name>R</name></expr>;
<return>return <expr><name>L</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getAsString</name><argument_list>(<argument>const PrintingPolicy &amp;Policy</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name> <macro><name>getAddrSpaceAsString</name><argument_list>(<argument>LangAS AS</argument>)</argument_list></macro></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isEmptyWhenPrinted</name><argument_list>(<argument><expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>Policy</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>print</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>Policy</name></expr></argument>,
<argument><expr><name>bool</name> <name>appendSpaceIfNonEmpty</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>Mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>


<decl_stmt><decl><type><name>uint32_t</name></type> <name>Mask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name>UMask</name> <init>= <expr><literal type="number">0x8</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name>UShift</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name>GCAttrMask</name> <init>= <expr><literal type="number">0x30</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name>GCAttrShift</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name>LifetimeMask</name> <init>= <expr><literal type="number">0x1C0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name>LifetimeShift</name> <init>= <expr><literal type="number">6</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name>AddressSpaceMask</name> <init>=
<expr><operator>~</operator><operator>(</operator><name>CVRMask</name> <operator>|</operator> <name>UMask</name> <operator>|</operator> <name>GCAttrMask</name> <operator>|</operator> <name>LifetimeMask</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name>AddressSpaceShift</name> <init>= <expr><literal type="number">9</literal></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<struct>struct <name>SplitQualType</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>Type</name> <modifier>*</modifier></type><name>Ty</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Qualifiers</name></type> <name>Quals</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SplitQualType</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<macro><name>SplitQualType</name><argument_list>(<argument>const Type *ty</argument>, <argument>Qualifiers qs</argument>)</argument_list></macro> : <expr_stmt><expr><call><name>Ty</name><argument_list>(<argument><expr><name>ty</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Quals</name><argument_list>(<argument>qs</argument>)</argument_list></macro> <expr><block>{}</block>

<name>SplitQualType</name> <macro><name>getSingleStepDesugaredType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator></expr></argument>,<argument><expr><name>Qualifiers</name></expr></argument>&gt;</argument_list></name> <macro><name>asPair</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>std</name><operator>::</operator><call><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator></expr></argument>, <argument><expr><name>Qualifiers</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>Quals</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><name>SplitQualType</name> <name>a</name><operator>,</operator> <name>SplitQualType</name> <name>b</name><operator>)</operator> <block>{
<return>return <expr><name><name>a</name><operator>.</operator><name>Ty</name></name> <operator>==</operator> <name><name>b</name><operator>.</operator><name>Ty</name></name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>.</operator><name>Quals</name></name> <operator>==</operator> <name><name>b</name><operator>.</operator><name>Quals</name></name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><name>SplitQualType</name> <name>a</name><operator>,</operator> <name>SplitQualType</name> <name>b</name><operator>)</operator> <block>{
<return>return <expr><name><name>a</name><operator>.</operator><name>Ty</name></name> <operator>!=</operator> <name><name>b</name><operator>.</operator><name>Ty</name></name> <operator>||</operator> <name><name>a</name><operator>.</operator><name>Quals</name></name> <operator>!=</operator> <name><name>b</name><operator>.</operator><name>Quals</name></name></expr>;</return>
}</block></expr></expr_stmt>
}</block>;</struct>






<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>ObjCSubstitutionContext</name> <block>{<block_content>

<expr_stmt><expr><name>Ordinary</name></expr><operator>,</operator>


<expr><name>Result</name></expr><operator>,</operator>


<expr><name>Parameter</name></expr><operator>,</operator>


<expr><name>Property</name></expr><operator>,</operator>


<expr><name>Superclass</name></expr><operator>,</operator></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>















<decl_stmt><decl><type><name>class</name></type> <name>QualType</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>QualifierCollector</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>ExtQuals</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>Qualifiers</name><operator>::</operator><name>FastWidth</name></expr></argument>&gt;</argument_list></name> <name>Value</name></expr>;</expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>ExtQuals</name> <operator>*</operator><macro><name>getExtQualsUnsafe</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ExtQuals</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><macro><name>getTypePtrUnsafe</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Type</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>ExtQualsTypeCommonBase</name> <operator>*</operator><macro><name>getCommonPtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isNull</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Cannot retrieve a NULL type pointer"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>CommonPtrVal</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>uintptr_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Value</name><operator>.</operator><name>getOpaqueValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>CommonPtrVal</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>TypeAlignmentInBits</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExtQualsTypeCommonBase</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CommonPtrVal</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>QualType</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<macro><name>QualType</name><argument_list>(<argument>const Type *Ptr</argument>, <argument>unsigned Quals</argument>)</argument_list></macro> : <macro><name>Value</name><argument_list>(<argument>Ptr</argument>, <argument>Quals</argument>)</argument_list></macro> <block>{<block_content/>}</block>
<macro><name>QualType</name><argument_list>(<argument>const ExtQuals *Ptr</argument>, <argument>unsigned Quals</argument>)</argument_list></macro> : <macro><name>Value</name><argument_list>(<argument>Ptr</argument>, <argument>Quals</argument>)</argument_list></macro> <block>{<block_content/>}</block>

<expr_stmt><expr><name>unsigned</name> <macro><name>getLocalFastQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Value</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setLocalFastQualifiers</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Quals</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>Value</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>Quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>





<expr_stmt><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><macro><name>getTypePtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><macro><name>getTypePtrOrNull</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><macro><name>getBaseTypeIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>SplitQualType</name> <macro><name>split</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>void</name> <operator>*</operator><macro><name>getAsOpaquePtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Value</name><operator>.</operator><name>getOpaqueValue</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>QualType</name></type> <name>getFromOpaquePtr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>Ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>QualType</name></type> <name>T</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>T</name><operator>.</operator><name>Value</name><operator>.</operator><name>setFromOpaqueValue</name></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>Type</name> <operator>&amp;</operator><name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><operator>*</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>)</block_content> const <block>{<block_content>
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>

bool isCanonical(</block></decl>) const;</decl_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isCanonicalAsParam</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isNull</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>isLocalConstQualified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>getLocalFastQualifiers</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>Qualifiers</name><operator>::</operator><name>Const</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isConstQualified</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>isLocalRestrictQualified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>getLocalFastQualifiers</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>Qualifiers</name><operator>::</operator><name>Restrict</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isRestrictQualified</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>isLocalVolatileQualified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>getLocalFastQualifiers</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>Qualifiers</name><operator>::</operator><name>Volatile</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isVolatileQualified</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>hasLocalQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalFastQualifiers</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>hasLocalNonFastQualifiers</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>hasLocalNonFastQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>is</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ExtQuals</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>Qualifiers</name> <macro><name>getLocalQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>Qualifiers</name> <macro><name>getQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>unsigned</name> <macro><name>getLocalCVRQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocalFastQualifiers</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getCVRQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isConstant</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name><operator>&amp;</operator> <name>Ctx</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>QualType</name><operator>::</operator><call><name>isConstant</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>isPODType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isCXX98PODType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>isCXX11PODType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>isTrivialType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>isTriviallyCopyableType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>mayBeDynamicClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>mayBeNotDynamicClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>





<function><type><name>void</name></type> <name>addConst</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>addFastQualifiers</name><argument_list>(<argument><expr><name>Qualifiers</name><operator>::</operator><name>Const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><name>QualType</name> <macro><name>withConst</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>withFastQualifiers</name><argument_list>(<argument><expr><name>Qualifiers</name><operator>::</operator><name>Const</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>addVolatile</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>addFastQualifiers</name><argument_list>(<argument><expr><name>Qualifiers</name><operator>::</operator><name>Volatile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><name>QualType</name> <macro><name>withVolatile</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>withFastQualifiers</name><argument_list>(<argument><expr><name>Qualifiers</name><operator>::</operator><name>Volatile</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>addRestrict</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>addFastQualifiers</name><argument_list>(<argument><expr><name>Qualifiers</name><operator>::</operator><name>Restrict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><name>QualType</name> <macro><name>withRestrict</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>withFastQualifiers</name><argument_list>(<argument><expr><name>Qualifiers</name><operator>::</operator><name>Restrict</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>withCVRQualifiers</name><argument_list>(<argument><expr><name>unsigned</name> <name>CVR</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>withFastQualifiers</name><argument_list>(<argument><expr><name>CVR</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type> <name>addFastQualifiers</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>TQs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>TQs</name> <operator>&amp;</operator> <operator>~</operator><name>Qualifiers</name><operator>::</operator><name>FastMask</name><operator>)</operator>
<operator>&amp;&amp;</operator> <literal type="string">"non-fast qualifier bits set in mask!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Value</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><call><name><name>Value</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call> <operator>|</operator> <name>TQs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>removeLocalConst</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>removeLocalVolatile</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>removeLocalRestrict</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>removeLocalCVRQualifiers</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Mask</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type> <name>removeLocalFastQualifiers</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>Value</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>removeLocalFastQualifiers</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Mask</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>Mask</name> <operator>&amp;</operator> <operator>~</operator><name>Qualifiers</name><operator>::</operator><name>FastMask</name><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"mask has non-fast qualifiers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Value</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><call><name><name>Value</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>Mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<decl_stmt><decl><type><name>QualType</name></type> <name>withFastQualifiers</name><argument_list>(<argument><expr><name>unsigned</name> <name>TQs</name></expr></argument>)</argument_list> const <block>{<block_content>
<decl_stmt><decl><type><name>QualType</name></type> <name>T</name> <init>= <expr><operator>*</operator><name>this</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>T</name><operator>.</operator><name>addFastQualifiers</name></name><argument_list>(<argument><expr><name>TQs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>withExactLocalFastQualifiers</name><argument_list>(<argument><expr><name>unsigned</name> <name>TQs</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>withoutLocalFastQualifiers</name><argument_list>()</argument_list></call><operator>.</operator><call><name>withFastQualifiers</name><argument_list>(<argument><expr><name>TQs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name>QualType</name> <macro><name>withoutLocalFastQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>QualType</name> <name>T</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;
<expr><call><name><name>T</name><operator>.</operator><name>removeLocalFastQualifiers</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>T</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>QualType</name> <macro><name>getCanonicalType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>QualType</name> <macro><name>getLocalUnqualifiedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



















<expr_stmt><expr><specifier>inline</specifier> <name>QualType</name> <macro><name>getUnqualifiedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>










<expr_stmt><expr><specifier>inline</specifier> <name>SplitQualType</name> <macro><name>getSplitUnqualifiedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isMoreQualifiedThan</name><argument_list>(<argument><expr><name>QualType</name> <name>Other</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isAtLeastAsQualifiedAs</name><argument_list>(<argument><expr><name>QualType</name> <name>Other</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>QualType</name> <macro><name>getNonReferenceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>









<decl_stmt><decl><type><name>QualType</name></type> <name>getNonLValueExprType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<expr_stmt><expr><name>QualType</name> <macro><name>getNonPackExpansionType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>









<decl_stmt><decl><type><name>QualType</name></type> <name>getDesugaredType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getDesugaredType</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>SplitQualType</name> <macro><name>getSplitDesugaredType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getSplitDesugaredType</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>






<decl_stmt><decl><type><name>QualType</name></type> <name>getSingleStepDesugaredType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getSingleStepDesugaredTypeImpl</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name>QualType</name> <macro><name>IgnoreParens</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParenType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>QualType</name><operator>::</operator><call><name>IgnoreParens</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}


friend <expr_stmt><expr><name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>QualType</name> <operator>&amp;</operator><name>LHS</name><operator>,</operator> <specifier>const</specifier> <name>QualType</name> <operator>&amp;</operator><name>RHS</name><operator>)</operator> <block>{
<return>return <expr><name><name>LHS</name><operator>.</operator><name>Value</name></name> <operator>==</operator> <name><name>RHS</name><operator>.</operator><name>Value</name></name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>QualType</name> <operator>&amp;</operator><name>LHS</name><operator>,</operator> <specifier>const</specifier> <name>QualType</name> <operator>&amp;</operator><name>RHS</name><operator>)</operator> <block>{
<return>return <expr><name><name>LHS</name><operator>.</operator><name>Value</name></name> <operator>!=</operator> <name><name>RHS</name><operator>.</operator><name>Value</name></name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>&lt;</operator><operator>(</operator><specifier>const</specifier> <name>QualType</name> <operator>&amp;</operator><name>LHS</name><operator>,</operator> <specifier>const</specifier> <name>QualType</name> <operator>&amp;</operator><name>RHS</name><operator>)</operator> <block>{
<return>return <expr><name><name>LHS</name><operator>.</operator><name>Value</name></name> <operator>&lt;</operator> <name><name>RHS</name><operator>.</operator><name>Value</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name> <macro><name>getAsString</name><argument_list>(<argument>SplitQualType split</argument>,
<argument>const PrintingPolicy &amp;Policy</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getAsString</name><argument_list>(<argument><expr><name><name>split</name><operator>.</operator><name>Ty</name></name></expr></argument>, <argument><expr><name><name>split</name><operator>.</operator><name>Quals</name></name></expr></argument>, <argument><expr><name>Policy</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name> <macro><name>getAsString</name><argument_list>(<argument>const Type *ty</argument>, <argument>Qualifiers qs</argument>,
<argument>const PrintingPolicy &amp;Policy</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getAsString</name><argument_list>(<argument>const PrintingPolicy &amp;Policy</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>print</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>Policy</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Twine</name> <operator>&amp;</operator><name>PlaceHolder</name> <operator>=</operator> <call><name>Twine</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>unsigned</name> <name>Indentation</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print</name><parameter_list>(<parameter><decl><type><name>SplitQualType</name></type> <name>split</name></decl></parameter>, <parameter><decl><type><name>raw_ostream</name> <modifier>&amp;</modifier></type><name>OS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>policy</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Twine</name> <modifier>&amp;</modifier></type><name>PlaceHolder</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Indentation</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>print</name><argument_list>(<argument><expr><name><name>split</name><operator>.</operator><name>Ty</name></name></expr></argument>, <argument><expr><name><name>split</name><operator>.</operator><name>Quals</name></name></expr></argument>, <argument><expr><name>OS</name></expr></argument>, <argument><expr><name>policy</name></expr></argument>, <argument><expr><name>PlaceHolder</name></expr></argument>, <argument><expr><name>Indentation</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Type</name> <modifier>*</modifier></type><name>ty</name></decl></parameter>, <parameter><decl><type><name>Qualifiers</name></type> <name>qs</name></decl></parameter>,
<parameter><decl><type><name>raw_ostream</name> <modifier>&amp;</modifier></type><name>OS</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>policy</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Twine</name> <modifier>&amp;</modifier></type><name>PlaceHolder</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Indentation</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>getAsStringInternal</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>Str</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>Policy</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>getAsStringInternal</name><argument_list>(<argument><expr><name>SplitQualType</name> <name>split</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>out</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>policy</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>getAsStringInternal</name><argument_list>(<argument><expr><name><name>split</name><operator>.</operator><name>Ty</name></name></expr></argument>, <argument><expr><name><name>split</name><operator>.</operator><name>Quals</name></name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>getAsStringInternal</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>ty</name></expr></argument>, <argument><expr><name>Qualifiers</name> <name>qs</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>out</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>policy</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>StreamedQualTypeHelper</name> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>QualType</name> <modifier>&amp;</modifier></type><name>T</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Twine</name> <modifier>&amp;</modifier></type><name>PlaceHolder</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>Indentation</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>StreamedQualTypeHelper</name><argument_list>(<argument>const QualType &amp;T</argument>, <argument>const PrintingPolicy &amp;Policy</argument>,
<argument>const Twine &amp;PlaceHolder</argument>, <argument>unsigned Indentation</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>T</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Policy</name><argument_list>(<argument><expr><name>Policy</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>PlaceHolder</name><argument_list>(<argument><expr><name>PlaceHolder</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>Indentation</name><argument_list>(<argument>Indentation</argument>)</argument_list></macro> <expr><block>{}</block>

<name>friend</name> <name>raw_ostream</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name><operator>,</operator>
<specifier>const</specifier> <name>StreamedQualTypeHelper</name> <operator>&amp;</operator><name>SQT</name><operator>)</operator> <block>{
<expr><call><name><name>SQT</name><operator>.</operator><name>T</name><operator>.</operator><name>print</name></name><argument_list>(<argument><expr><name>OS</name></expr></argument>, <argument><expr><name><name>SQT</name><operator>.</operator><name>Policy</name></name></expr></argument>, <argument><expr><name><name>SQT</name><operator>.</operator><name>PlaceHolder</name></name></expr></argument>, <argument><expr><name><name>SQT</name><operator>.</operator><name>Indentation</name></name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>OS</name></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>StreamedQualTypeHelper</name></type> <name>stream</name><argument_list>(<argument><expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>Policy</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Twine</name> <operator>&amp;</operator><name>PlaceHolder</name> <operator>=</operator> <call><name>Twine</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>unsigned</name> <name>Indentation</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>StreamedQualTypeHelper</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>Policy</name></expr></argument>, <argument><expr><name>PlaceHolder</name></expr></argument>, <argument><expr><name>Indentation</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>dump</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>s</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<expr_stmt><expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>dump</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name>getAsOpaquePtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><specifier>inline</specifier> <name>bool</name> <macro><name>hasAddressSpace</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><specifier>inline</specifier> <name>LangAS</name> <macro><name>getAddressSpace</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>









<decl_stmt><decl><type><name>bool</name></type> <name>isAddressSpaceOverlapping</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<decl_stmt><decl><type><name>Qualifiers</name></type> <name>Q</name> <init>= <expr><call><name>getQualifiers</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Qualifiers</name></type> <name>TQ</name> <init>= <expr><call><name><name>T</name><operator>.</operator><name>getQualifiers</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name><name>Q</name><operator>.</operator><name>isAddressSpaceSupersetOf</name></name><argument_list>(<argument><expr><name>TQ</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>TQ</name><operator>.</operator><name>isAddressSpaceSupersetOf</name></name><argument_list>(<argument><expr><name>Q</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><specifier>inline</specifier> <name>Qualifiers</name><operator>::</operator><name>GC</name> <macro><name>getObjCGCAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isObjCGCWeak</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getObjCGCAttr</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Qualifiers</name><operator>::</operator><name>Weak</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isObjCGCStrong</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getObjCGCAttr</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Qualifiers</name><operator>::</operator><name>Strong</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>Qualifiers</name><operator>::</operator><name>ObjCLifetime</name> <macro><name>getObjCLifetime</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getQualifiers</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getObjCLifetime</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasNonTrivialObjCLifetime</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getQualifiers</name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasNonTrivialObjCLifetime</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasStrongOrWeakObjCLifetime</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getQualifiers</name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasStrongOrWeakObjCLifetime</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>isNonWeakInMRRWithObjCWeak</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<enum>enum <name>PrimitiveDefaultInitializeKind</name> <block>{



<decl><name>PDIK_Trivial</name></decl>,



<decl><name>PDIK_ARCStrong</name></decl>,



<decl><name>PDIK_ARCWeak</name></decl>,


<decl><name>PDIK_Struct</name></decl>
}</block>;</enum>






<expr_stmt><expr><name>PrimitiveDefaultInitializeKind</name>
<macro><name>isNonTrivialToPrimitiveDefaultInitialize</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<enum>enum <name>PrimitiveCopyKind</name> <block>{



<decl><name>PCK_Trivial</name></decl>,




<decl><name>PCK_VolatileTrivial</name></decl>,



<decl><name>PCK_ARCStrong</name></decl>,



<decl><name>PCK_ARCWeak</name></decl>,







<decl><name>PCK_Struct</name></decl>
}</block>;</enum>




<expr_stmt><expr><name>PrimitiveCopyKind</name> <macro><name>isNonTrivialToPrimitiveCopy</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>







<expr_stmt><expr><name>PrimitiveCopyKind</name> <macro><name>isNonTrivialToPrimitiveDestructiveMove</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<enum>enum <name>DestructionKind</name> <block>{
<decl><name>DK_none</name></decl>,
<decl><name>DK_cxx_destructor</name></decl>,
<decl><name>DK_objc_strong_lifetime</name></decl>,
<decl><name>DK_objc_weak_lifetime</name></decl>,
<decl><name>DK_nontrivial_c_struct</name></decl>
}</block>;</enum>





<expr_stmt><expr><name>DestructionKind</name> <macro><name>isDestructedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isDestructedTypeImpl</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>





<expr_stmt><expr><name>bool</name> <macro><name>hasNonTrivialToPrimitiveDefaultInitializeCUnion</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>hasNonTrivialToPrimitiveDestructCUnion</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>hasNonTrivialToPrimitiveCopyCUnion</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>











<expr_stmt><expr><name>bool</name> <macro><name>isCForbiddenLValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>















<decl_stmt><decl><type><name>QualType</name></type> <name>substObjCTypeArgs</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>ctx</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <name>typeArgs</name></expr></argument>,
<argument><expr><name>ObjCSubstitutionContext</name> <name>context</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





















<decl_stmt><decl><type><name>QualType</name></type> <name>substObjCMemberType</name><argument_list>(<argument><expr><name>QualType</name> <name>objectType</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><name>dc</name></expr></argument>,
<argument><expr><name>ObjCSubstitutionContext</name> <name>context</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>stripObjCKindOfType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>QualType</name> <macro><name>getAtomicUnqualifiedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<label><name>private</name>:</label>



<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isConstant</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ASTContext</name><modifier>&amp;</modifier></type> <name>Ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>QualType</name></type> <name>getDesugaredType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SplitQualType</name></type> <name>getSplitDesugaredType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SplitQualType</name></type> <name>getSplitUnqualifiedTypeImpl</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>QualType</name></type> <name>getSingleStepDesugaredTypeImpl</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>type</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>QualType</name></type> <name>IgnoreParens</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DestructionKind</name></type> <name>isDestructedTypeImpl</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>hasNonTrivialToPrimitiveDefaultInitializeCUnion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>hasNonTrivialToPrimitiveDestructCUnion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>hasNonTrivialToPrimitiveCopyCUnion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list>;</function_decl>
};

}

namespace <macro><name>llvm</name></macro> <block>{<block_content>



<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>simplify_type</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>QualType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>using</name> <name>SimpleType</name> <operator>=</operator> <specifier>const</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>Type</name> <operator>*</operator></expr>;

<expr><specifier>static</specifier> <name>SimpleType</name> <macro><name>getSimplifiedValue</name><argument_list>(<argument>::clang::QualType Val</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Val</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;</return></block></expr>
}</block></expr></expr_stmt>
</block_content>}</block><empty_stmt>;</empty_stmt>


<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator>
struct <name><name>PointerLikeTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>QualType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <operator>*</operator><macro><name>getAsVoidPointer</name><argument_list>(<argument>clang::QualType P</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>P</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr>;</return></block></expr>
}</block>

<specifier>static</specifier> <specifier>inline</specifier> <name>clang</name><operator>::</operator><name>QualType</name> <macro><name>getFromVoidPointer</name><argument_list>(<argument>void *P</argument>)</argument_list></macro> <block>{
<return>return <expr><name>clang</name><operator>::</operator><name>QualType</name><operator>::</operator><call><name>getFromOpaquePtr</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>constexpr</name> <name>int</name></type> <name>NumLowBitsAvailable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
};

}

namespace <macro><name>clang</name></macro> <block>{<block_content>




<decl_stmt><decl><type><name>class</name></type> <name>ExtQualsTypeCommonBase</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ExtQuals</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>QualType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>Type</name></decl>;</decl_stmt>






<decl_stmt><decl><type><specifier>const</specifier> <name>Type</name> <modifier>*</modifier><specifier>const</specifier></type> <name>BaseType</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>CanonicalType</name></decl>;</decl_stmt>

<macro><name>ExtQualsTypeCommonBase</name><argument_list>(<argument>const Type *baseType</argument>, <argument>QualType canon</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>BaseType</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>CanonicalType</name><argument_list>(<argument>canon</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>











<decl_stmt><decl><type><name>class</name></type> <name>ExtQuals</name> <range>: <expr><name>public</name> <name>ExtQualsTypeCommonBase</name></expr></range></decl>, <decl><type ref="prev"/><name>public</name> <name>llvm</name>::<name>FoldingSetNode</name> <block>{<block_content>















<decl_stmt><decl><type><name>Qualifiers</name></type> <name>Quals</name></decl>;</decl_stmt>

<function><type><name>ExtQuals</name> <modifier>*</modifier></type><name>this_</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>this</name></expr>;</return> </block_content>}</block></function>

<label><name>public</name>:</label>
<macro><name>ExtQuals</name><argument_list>(<argument>const Type *baseType</argument>, <argument>QualType canon</argument>, <argument>Qualifiers quals</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>ExtQualsTypeCommonBase</name><argument_list>(<argument><expr><name>baseType</name></expr></argument>,
<argument><expr><ternary><condition><expr><call><name><name>canon</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>QualType</name><argument_list>(<argument><expr><call><name>this_</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>canon</name></expr></else></ternary></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>Quals</name><argument_list>(<argument>quals</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Quals</name><operator>.</operator><name>hasNonFastQualifiers</name></name><argument_list>()</argument_list></call>
<operator>&amp;&amp;</operator> <literal type="string">"ExtQuals created with no fast qualifiers"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>Quals</name><operator>.</operator><name>hasFastQualifiers</name></name><argument_list>()</argument_list></call>
<operator>&amp;&amp;</operator> <literal type="string">"ExtQuals created with fast qualifiers"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name>Qualifiers</name> <macro><name>getQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Quals</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasObjCGCAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Quals</name><operator>.</operator><name>hasObjCGCAttr</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>Qualifiers</name><operator>::</operator><name>GC</name> <macro><name>getObjCGCAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Quals</name><operator>.</operator><name>getObjCGCAttr</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasObjCLifetime</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Quals</name><operator>.</operator><name>hasObjCLifetime</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>Qualifiers</name><operator>::</operator><name>ObjCLifetime</name> <macro><name>getObjCLifetime</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Quals</name><operator>.</operator><name>getObjCLifetime</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasAddressSpace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Quals</name><operator>.</operator><name>hasAddressSpace</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>LangAS</name> <macro><name>getAddressSpace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Quals</name><operator>.</operator><name>getAddressSpace</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><macro><name>getBaseType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BaseType</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>void</name></type> <name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getBaseType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>BaseType</name></expr></argument>,
<argument><expr><name>Qualifiers</name> <name>Quals</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>Quals</name><operator>.</operator><name>hasFastQualifiers</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"fast qualifiers in ExtQuals hash!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>BaseType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Quals</name><operator>.</operator><name>Profile</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<enum>enum <name>RefQualifierKind</name> <block>{

<decl><name>RQ_None</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,


<decl><name>RQ_LValue</name></decl>,


<decl><name>RQ_RValue</name></decl>
}</block>;</enum>


<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>AutoTypeKeyword</name> <block>{<block_content>

<expr_stmt><expr><name>Auto</name></expr><operator>,</operator>


<expr><name>DecltypeAuto</name></expr><operator>,</operator>


<expr><name>GNUAutoType</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



























<decl_stmt><decl><type><name>class</name></type> <name>alignas</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list> <name>Type</name> <range>: <expr><name>public</name> <name>ExtQualsTypeCommonBase</name> <block>{
<expr><name>public</name><operator>:</operator>
enum <name>TypeClass</name> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPE</name><parameter_list>(<parameter><type><name>Class</name></type></parameter>, <parameter><type><name>Base</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Class,</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAST_TYPE</name><parameter_list>(<parameter><type><name>Class</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TypeLast = Class</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_TYPE</name><parameter_list>(<parameter><type><name>Class</name></type></parameter>, <parameter><type><name>Base</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeNodes.inc"</cpp:file></cpp:include>
}</block></expr>;

<expr><name>private</name><operator>:</operator>

<name>class</name> <name>TypeBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>Type</name></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>friend</name> <name>class</name> <name>TypePropertyCache</name></expr>;


<expr><name>unsigned</name> <name>TC</name> <operator>:</operator> <literal type="number">8</literal></expr>;


<expr><name>unsigned</name> <name>Dependence</name> <operator>:</operator> <name>llvm</name><operator>::</operator><name><name>BitWidth</name><argument_list type="generic">&lt;<argument><expr><name>TypeDependence</name></expr></argument>&gt;</argument_list></name></expr>;



<expr><name>mutable</name> <name>unsigned</name> <name>CacheValid</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>mutable</name> <name>unsigned</name> <name>CachedLinkage</name> <operator>:</operator> <literal type="number">3</literal></expr>;


<expr><name>mutable</name> <name>unsigned</name> <name>CachedLocalOrUnnamed</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>mutable</name> <name>unsigned</name> <name>FromAST</name> <operator>:</operator> <literal type="number">1</literal></expr>;

<expr><name>bool</name> <macro><name>isCacheValid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>CacheValid</name></expr>;</return>
}</block>

<name>Linkage</name> <macro><name>getLinkage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isCacheValid</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"getting linkage from invalid cache"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Linkage</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CachedLinkage</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasLocalOrUnnamedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isCacheValid</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"getting linkage from invalid cache"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>CachedLocalOrUnnamed</name></expr>;</return>
}</block>
}</expr>;
enum <expr><block>{ <expr><name>NumTypeBits</name> <operator>=</operator> <literal type="number">8</literal> <operator>+</operator> <name>llvm</name><operator>::</operator><name><name>BitWidth</name><argument_list type="generic">&lt;<argument><expr><name>TypeDependence</name></expr></argument>&gt;</argument_list></name> <operator>+</operator> <literal type="number">6</literal></expr> }</block></expr>;

<expr><name>protected</name><operator>:</operator>



<name>class</name> <name>ArrayTypeBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ArrayType</name></expr>;

<expr><name>unsigned</name> <operator>:</operator> <name>NumTypeBits</name></expr>;



<expr><name>unsigned</name> <name>IndexTypeQuals</name> <operator>:</operator> <literal type="number">3</literal></expr>;




<expr><name>unsigned</name> <name>SizeModifier</name> <operator>:</operator> <literal type="number">3</literal></expr>;
}</block></expr>;

<expr><name>class</name> <name>ConstantArrayTypeBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ConstantArrayType</name></expr>;

<expr><name>unsigned</name> <operator>:</operator> <name>NumTypeBits</name> <operator>+</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">3</literal></expr>;


<expr><name>unsigned</name> <name>HasStoredSizeExpr</name> <operator>:</operator> <literal type="number">1</literal></expr>;
}</block></expr>;

<expr><name>class</name> <name>BuiltinTypeBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>BuiltinType</name></expr>;

<expr><name>unsigned</name> <operator>:</operator> <name>NumTypeBits</name></expr>;


<expr><name>unsigned</name> <name>Kind</name> <operator>:</operator> <literal type="number">8</literal></expr>;
}</block></expr>;




<expr><name>class</name> <name>FunctionTypeBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>FunctionProtoType</name></expr>;
<expr><name>friend</name> <name>class</name> <name>FunctionType</name></expr>;

<expr><name>unsigned</name> <operator>:</operator> <name>NumTypeBits</name></expr>;



<expr><name>unsigned</name> <name>ExtInfo</name> <operator>:</operator> <literal type="number">13</literal></expr>;




<expr><name>unsigned</name> <name>RefQualifier</name> <operator>:</operator> <literal type="number">2</literal></expr>;







<expr><name>unsigned</name> <name>FastTypeQuals</name> <operator>:</operator> <name>Qualifiers</name><operator>::</operator><name>FastWidth</name></expr>;

<expr><name>unsigned</name> <name>HasExtQuals</name> <operator>:</operator> <literal type="number">1</literal></expr>;





<expr><name>unsigned</name> <name>NumParams</name> <operator>:</operator> <literal type="number">16</literal></expr>;


<expr><name>unsigned</name> <name>ExceptionSpecType</name> <operator>:</operator> <literal type="number">4</literal></expr>;


<expr><name>unsigned</name> <name>HasExtParameterInfos</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>unsigned</name> <name>Variadic</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>unsigned</name> <name>HasTrailingReturn</name> <operator>:</operator> <literal type="number">1</literal></expr>;
}</block></expr>;

<expr><name>class</name> <name>ObjCObjectTypeBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ObjCObjectType</name></expr>;

<expr><name>unsigned</name> <operator>:</operator> <name>NumTypeBits</name></expr>;


<expr><name>unsigned</name> <name>NumTypeArgs</name> <operator>:</operator> <literal type="number">7</literal></expr>;


<expr><name>unsigned</name> <name>NumProtocols</name> <operator>:</operator> <literal type="number">6</literal></expr>;


<expr><name>unsigned</name> <name>IsKindOf</name> <operator>:</operator> <literal type="number">1</literal></expr>;
}</block></expr>;

<expr><name>class</name> <name>ReferenceTypeBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ReferenceType</name></expr>;

<expr><name>unsigned</name> <operator>:</operator> <name>NumTypeBits</name></expr>;












<expr><name>unsigned</name> <name>SpelledAsLValue</name> <operator>:</operator> <literal type="number">1</literal></expr>;



<expr><name>unsigned</name> <name>InnerRef</name> <operator>:</operator> <literal type="number">1</literal></expr>;
}</block></expr>;

<expr><name>class</name> <name>TypeWithKeywordBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>TypeWithKeyword</name></expr>;

<expr><name>unsigned</name> <operator>:</operator> <name>NumTypeBits</name></expr>;


<expr><name>unsigned</name> <name>Keyword</name> <operator>:</operator> <literal type="number">8</literal></expr>;
}</block></expr>;

enum <expr><block>{ <expr><name>NumTypeWithKeywordBits</name> <operator>=</operator> <literal type="number">8</literal></expr> }</block></expr>;

<expr><name>class</name> <name>ElaboratedTypeBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ElaboratedType</name></expr>;

<expr><name>unsigned</name> <operator>:</operator> <name>NumTypeBits</name></expr>;
<expr><name>unsigned</name> <operator>:</operator> <name>NumTypeWithKeywordBits</name></expr>;


<expr><name>unsigned</name> <name>HasOwnedTagDecl</name> <operator>:</operator> <literal type="number">1</literal></expr>;
}</block></expr>;

<expr><name>class</name> <name>VectorTypeBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>VectorType</name></expr>;
<expr><name>friend</name> <name>class</name> <name>DependentVectorType</name></expr>;

<expr><name>unsigned</name> <operator>:</operator> <name>NumTypeBits</name></expr>;



<expr><name>unsigned</name> <name>VecKind</name> <operator>:</operator> <literal type="number">3</literal></expr>;

<expr><name>uint32_t</name> <name>NumElements</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>AttributedTypeBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>AttributedType</name></expr>;

<expr><name>unsigned</name> <operator>:</operator> <name>NumTypeBits</name></expr>;


<expr><name>unsigned</name> <name>AttrKind</name> <operator>:</operator> <literal type="number">32</literal> <operator>-</operator> <name>NumTypeBits</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>AutoTypeBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>AutoType</name></expr>;

<expr><name>unsigned</name> <operator>:</operator> <name>NumTypeBits</name></expr>;



<expr><name>unsigned</name> <name>Keyword</name> <operator>:</operator> <literal type="number">2</literal></expr>;








<expr><name>unsigned</name> <name>NumArgs</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>SubstTemplateTypeParmPackTypeBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>SubstTemplateTypeParmPackType</name></expr>;

<expr><name>unsigned</name> <operator>:</operator> <name>NumTypeBits</name></expr>;








<expr><name>unsigned</name> <name>NumArgs</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>TemplateSpecializationTypeBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>TemplateSpecializationType</name></expr>;

<expr><name>unsigned</name> <operator>:</operator> <name>NumTypeBits</name></expr>;


<expr><name>unsigned</name> <name>TypeAlias</name> <operator>:</operator> <literal type="number">1</literal></expr>;








<expr><name>unsigned</name> <name>NumArgs</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>DependentTemplateSpecializationTypeBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>DependentTemplateSpecializationType</name></expr>;

<expr><name>unsigned</name> <operator>:</operator> <name>NumTypeBits</name></expr>;
<expr><name>unsigned</name> <operator>:</operator> <name>NumTypeWithKeywordBits</name></expr>;








<expr><name>unsigned</name> <name>NumArgs</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>PackExpansionTypeBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>PackExpansionType</name></expr>;

<expr><name>unsigned</name> <operator>:</operator> <name>NumTypeBits</name></expr>;












<expr><name>unsigned</name> <name>NumExpansions</name></expr>;
}</block></expr>;

<expr>union <block>{
<expr><name>TypeBitfields</name> <name>TypeBits</name></expr>;
<expr><name>ArrayTypeBitfields</name> <name>ArrayTypeBits</name></expr>;
<expr><name>ConstantArrayTypeBitfields</name> <name>ConstantArrayTypeBits</name></expr>;
<expr><name>AttributedTypeBitfields</name> <name>AttributedTypeBits</name></expr>;
<expr><name>AutoTypeBitfields</name> <name>AutoTypeBits</name></expr>;
<expr><name>BuiltinTypeBitfields</name> <name>BuiltinTypeBits</name></expr>;
<expr><name>FunctionTypeBitfields</name> <name>FunctionTypeBits</name></expr>;
<expr><name>ObjCObjectTypeBitfields</name> <name>ObjCObjectTypeBits</name></expr>;
<expr><name>ReferenceTypeBitfields</name> <name>ReferenceTypeBits</name></expr>;
<expr><name>TypeWithKeywordBitfields</name> <name>TypeWithKeywordBits</name></expr>;
<expr><name>ElaboratedTypeBitfields</name> <name>ElaboratedTypeBits</name></expr>;
<expr><name>VectorTypeBitfields</name> <name>VectorTypeBits</name></expr>;
<expr><name>SubstTemplateTypeParmPackTypeBitfields</name> <name>SubstTemplateTypeParmPackTypeBits</name></expr>;
<expr><name>TemplateSpecializationTypeBitfields</name> <name>TemplateSpecializationTypeBits</name></expr>;
<expr><name>DependentTemplateSpecializationTypeBitfields</name>
<name>DependentTemplateSpecializationTypeBits</name></expr>;
<expr><name>PackExpansionTypeBitfields</name> <name>PackExpansionTypeBits</name></expr>;
}</block></expr>;

<expr><name>private</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>friend</name> <name>class</name> <name>TypePropertyCache</name></expr>;


<expr><name>void</name> <macro><name>setFromAST</name><argument_list>(<argument>bool V = true</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name><name>TypeBits</name><operator>.</operator><name>FromAST</name></name> <operator>=</operator> <name>V</name></expr>;
}</block>

<name>protected</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<macro><name>Type</name><argument_list>(<argument>TypeClass tc</argument>, <argument>QualType canon</argument>, <argument>TypeDependence Dependence</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>ExtQualsTypeCommonBase</name><argument_list>(<argument>this</argument>,
<argument>canon.isNull() ? QualType(this_(), <literal type="number">0</literal>) : canon</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <literal type="number">8</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExtQualsTypeCommonBase</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"changing bitfields changed sizeof(Type)!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>static_assert</name><argument_list>(<argument><expr><call><name>alignof</name><argument_list>(<argument><expr><call><name>decltype</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>%</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><literal type="string">"Insufficient alignment!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>TypeBits</name><operator>.</operator><name>TC</name></name> <operator>=</operator> <name>tc</name></expr>;
<expr><name><name>TypeBits</name><operator>.</operator><name>Dependence</name></name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Dependence</name></expr></argument>)</argument_list></call></expr>;
<expr><name><name>TypeBits</name><operator>.</operator><name>CacheValid</name></name> <operator>=</operator> <name>false</name></expr>;
<expr><name><name>TypeBits</name><operator>.</operator><name>CachedLocalOrUnnamed</name></name> <operator>=</operator> <name>false</name></expr>;
<expr><name><name>TypeBits</name><operator>.</operator><name>CachedLinkage</name></name> <operator>=</operator> <name>NoLinkage</name></expr>;
<expr><name><name>TypeBits</name><operator>.</operator><name>FromAST</name></name> <operator>=</operator> <name>false</name></expr>;
}</block>


<name>Type</name> <operator>*</operator><macro><name>this_</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>this</name></expr>;</return> }</block>

<name>void</name> <macro><name>setDependence</name><argument_list>(<argument>TypeDependence D</argument>)</argument_list></macro> <block>{
<expr><name><name>TypeBits</name><operator>.</operator><name>Dependence</name></name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>addDependence</name><argument_list>(<argument>TypeDependence D</argument>)</argument_list></macro> <block>{ <expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>getDependence</name><argument_list>()</argument_list></call> <operator>|</operator> <name>D</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTWriter</name></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>friend</name> <name>class</name> <name>serialization</name><operator>::</operator><name>AbstractTypeReader</name></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>friend</name> <name>class</name> <name>serialization</name><operator>::</operator><name>AbstractTypeWriter</name></expr>;

<expr><call><name>Type</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><call><name>Type</name><argument_list>(<argument><expr><name>Type</name> <operator>&amp;&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><name>Type</name> <operator>&amp;</operator><name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>Type</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr>;
<expr><name>Type</name> <operator>&amp;</operator><name>operator</name><operator>=</operator><operator>(</operator><name>Type</name> <operator>&amp;&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr>;

<expr><name>TypeClass</name> <macro><name>getTypeClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TypeClass</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>TypeBits</name><operator>.</operator><name>TC</name></name></expr></argument>)</argument_list></call></expr>;</return> }</block>


<name>bool</name> <macro><name>isFromAST</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>TypeBits</name><operator>.</operator><name>FromAST</name></name></expr>;</return> }</block>
















<name>bool</name> <macro><name>containsUnexpandedParameterPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getDependence</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>TypeDependence</name><operator>::</operator><name>UnexpandedPack</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>isCanonicalUnqualified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>CanonicalType</name> <operator>==</operator> <call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>QualType</name> <macro><name>getLocallyUnqualifiedSingleStepDesugaredType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;







<expr><name>bool</name> <macro><name>isSizelessType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isSizelessBuiltinType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>bool</name> <macro><name>isVLSTBuiltinType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>QualType</name> <macro><name>getSveEltType</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;












<expr><name>bool</name> <macro><name>isIncompleteType</name><argument_list>(<argument>NamedDecl **Def = nullptr</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isIncompleteOrObjectType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name>isFunctionType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>isObjectType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{



<return>return <expr><operator>!</operator><call><name>isReferenceType</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isFunctionType</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isVoidType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isLiteralType</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isStructuralType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isStandardLayoutType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;





<expr><name>bool</name> <macro><name>isBuiltinType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isSpecificBuiltinType</name><argument_list>(<argument>unsigned K</argument>)</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>bool</name> <macro><name>isPlaceholderType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><specifier>const</specifier> <name>BuiltinType</name> <operator>*</operator><macro><name>getAsPlaceholderType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isSpecificPlaceholderType</name><argument_list>(<argument>unsigned K</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isNonOverloadPlaceholderType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isIntegerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isEnumeralType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isScopedEnumeralType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isBooleanType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isCharType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isWideCharType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isChar8Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isChar16Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isChar32Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isAnyCharacterType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isIntegralType</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isIntegralOrEnumerationType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isIntegralOrUnscopedEnumerationType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isUnscopedEnumerationType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isRealFloatingType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isComplexType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isAnyComplexType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isFloatingType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isHalfType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isFloat16Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isBFloat16Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isFloat128Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isRealType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isArithmeticType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isVoidType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isScalarType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isAggregateType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isFundamentalType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isCompoundType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isFunctionType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isFunctionNoProtoType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>FunctionNoProtoType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>isFunctionProtoType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>isPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isAnyPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isBlockPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isVoidPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isReferenceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isLValueReferenceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isRValueReferenceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isObjectPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isFunctionPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isFunctionReferenceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isMemberPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isMemberFunctionPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isMemberDataPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isArrayType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isConstantArrayType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isIncompleteArrayType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isVariableArrayType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isDependentSizedArrayType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isRecordType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isClassType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isStructureType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isObjCBoxableRecordType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isInterfaceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isStructureOrClassType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isUnionType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isComplexIntegerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isVectorType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isExtVectorType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isMatrixType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isConstantMatrixType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isDependentAddressSpaceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isObjCObjectPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isObjCRetainableType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isObjCLifetimeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isObjCIndirectLifetimeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isObjCNSObjectType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isObjCIndependentClassType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isObjCObjectType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isObjCQualifiedInterfaceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isObjCQualifiedIdType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isObjCQualifiedClassType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isObjCObjectOrInterfaceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isObjCIdType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isDecltypeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;






<expr><name>bool</name> <macro><name>isObjCInertUnsafeUnretainedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasAttr</name><argument_list>(<argument><expr><name>attr</name><operator>::</operator><name>ObjCInertUnsafeUnretained</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>








<name>bool</name> <macro><name>isObjCIdOrObjectKindOfType</name><argument_list>(<argument>const ASTContext &amp;ctx</argument>,
<argument>const ObjCObjectType *&amp;bound</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>isObjCClassType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;







<expr><name>bool</name> <macro><name>isObjCClassOrClassKindOfType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>isBlockCompatibleObjCPointerType</name><argument_list>(<argument>ASTContext &amp;ctx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isObjCSelType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isObjCBuiltinType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isObjCARCBridgableType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isCARCBridgableType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isTemplateTypeParmType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isNullPtrType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isNothrowT</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isAlignValT</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isStdByteType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isAtomicType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isUndeducedAutoType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>isTypedefNameType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMAGE_TYPE</name><parameter_list>(<parameter><type><name>ImgType</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>, <parameter><type><name>SingletonId</name></type></parameter>, <parameter><type><name>Access</name></type></parameter>, <parameter><type><name>Suffix</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bool is##Id##Type() const;</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenCLImageTypes.def"</cpp:file></cpp:include>

<expr><name>bool</name> <macro><name>isImageType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>isSamplerT</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isEventT</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isClkEventT</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isQueueT</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isReserveIDT</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXT_OPAQUE_TYPE</name><parameter_list>(<parameter><type><name>ExtType</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>, <parameter><type><name>Ext</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bool is##Id##Type() const;</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenCLExtensionTypes.def"</cpp:file></cpp:include>

<expr><name>bool</name> <macro><name>isOCLIntelSubgroupAVCType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isOCLExtOpaqueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>isPipeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isExtIntType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isOpenCLSpecificType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>bool</name> <macro><name>isObjCARCImplicitlyUnretainedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isCUDADeviceBuiltinSurfaceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>isCUDADeviceBuiltinTextureType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>Qualifiers</name><operator>::</operator><name>ObjCLifetime</name> <macro><name>getObjCARCImplicitLifetime</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

enum <expr><name>ScalarTypeKind</name> <block>{
<expr><name>STK_CPointer</name></expr>,
<expr><name>STK_BlockPointer</name></expr>,
<expr><name>STK_ObjCObjectPointer</name></expr>,
<expr><name>STK_MemberPointer</name></expr>,
<expr><name>STK_Bool</name></expr>,
<expr><name>STK_Integral</name></expr>,
<expr><name>STK_Floating</name></expr>,
<expr><name>STK_IntegralComplex</name></expr>,
<expr><name>STK_FloatingComplex</name></expr>,
<expr><name>STK_FixedPoint</name></expr>
}</block></expr>;


<expr><name>ScalarTypeKind</name> <macro><name>getScalarTypeKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>TypeDependence</name> <macro><name>getDependence</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TypeDependence</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>TypeBits</name><operator>.</operator><name>Dependence</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>containsErrors</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getDependence</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>TypeDependence</name><operator>::</operator><name>Error</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>isDependentType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getDependence</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>TypeDependence</name><operator>::</operator><name>Dependent</name></expr>;</return>
}</block>





<name>bool</name> <macro><name>isInstantiationDependentType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getDependence</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>TypeDependence</name><operator>::</operator><name>Instantiation</name></expr>;</return>
}</block>




<name>bool</name> <macro><name>isUndeducedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isVariablyModifiedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getDependence</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>TypeDependence</name><operator>::</operator><name>VariablyModified</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>hasSizedVLAType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>hasUnnamedOrLocalType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>isOverloadableType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isElaboratedTypeSpecifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>canDecayToPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>bool</name> <macro><name>hasPointerRepresentation</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>hasObjCPointerRepresentation</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>hasIntegerRepresentation</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>hasSignedIntegerRepresentation</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>hasUnsignedIntegerRepresentation</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>hasFloatingRepresentation</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><specifier>const</specifier> <name>RecordType</name> <operator>*</operator><macro><name>getAsStructureType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>const</specifier> <name>RecordType</name> <operator>*</operator><macro><name>getAsUnionType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><specifier>const</specifier> <name>ComplexType</name> <operator>*</operator><macro><name>getAsComplexIntegerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><specifier>const</specifier> <name>ObjCObjectType</name> <operator>*</operator><macro><name>getAsObjCInterfaceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><specifier>const</specifier> <name>ObjCObjectPointerType</name> <operator>*</operator><macro><name>getAsObjCInterfacePointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><specifier>const</specifier> <name>ObjCObjectPointerType</name> <operator>*</operator><macro><name>getAsObjCQualifiedIdType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><specifier>const</specifier> <name>ObjCObjectPointerType</name> <operator>*</operator><macro><name>getAsObjCQualifiedClassType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><specifier>const</specifier> <name>ObjCObjectType</name> <operator>*</operator><macro><name>getAsObjCQualifiedInterfaceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>CXXRecordDecl</name> <operator>*</operator><macro><name>getAsCXXRecordDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>RecordDecl</name> <operator>*</operator><macro><name>getAsRecordDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>TagDecl</name> <operator>*</operator><macro><name>getAsTagDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;






<expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><macro><name>getPointeeCXXRecordDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>DeducedType</name> <operator>*</operator><macro><name>getContainedDeducedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>AutoType</name> <operator>*</operator><macro><name>getContainedAutoType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>AutoType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getContainedDeducedType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>bool</name> <macro><name>hasAutoForTrailingReturnType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;







<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier> <name>T</name> <operator>*</operator><macro><name>getAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;






<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier> <name>T</name> <operator>*</operator><macro><name>getAsAdjusted</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><specifier>const</specifier> <name>ArrayType</name> <operator>*</operator><macro><name>getAsArrayTypeUnsafe</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;







<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier> <name>T</name> <operator>*</operator><macro><name>castAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><specifier>const</specifier> <name>ArrayType</name> <operator>*</operator><macro><name>castAsArrayTypeUnsafe</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>hasAttr</name><argument_list>(<argument>attr::Kind AK</argument>)</argument_list></macro> <specifier>const</specifier></expr>;




<expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><macro><name>getBaseElementTypeUnsafe</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><macro><name>getArrayElementTypeNoTypeQual</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><macro><name>getPointeeOrArrayElementType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>QualType</name> <macro><name>getPointeeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><macro><name>getUnqualifiedDesugaredType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isPromotableIntegerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>bool</name> <macro><name>isSignedIntegerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>bool</name> <macro><name>isUnsignedIntegerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isSignedIntegerOrEnumerationType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isUnsignedIntegerOrEnumerationType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isFixedPointType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isFixedPointOrIntegerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isSaturatedFixedPointType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isUnsaturatedFixedPointType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isSignedFixedPointType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isUnsignedFixedPointType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>bool</name> <macro><name>isConstantSizeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isSpecifierType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>Linkage</name> <macro><name>getLinkage</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>Visibility</name> <macro><name>getVisibility</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLinkageAndVisibility</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getVisibility</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>isVisibilityExplicit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLinkageAndVisibility</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isVisibilityExplicit</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>LinkageInfo</name> <macro><name>getLinkageAndVisibility</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isLinkageValid</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;






<expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>NullabilityKind</name></expr></argument>&gt;</argument_list></name> <macro><name>getNullability</name><argument_list>(<argument>const ASTContext &amp;context</argument>)</argument_list></macro> <specifier>const</specifier></expr>;






<expr><name>bool</name> <macro><name>canHaveNullability</name><argument_list>(<argument>bool ResultIfUnknown = true</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
















<expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<macro><name>getObjCSubstitutions</name><argument_list>(<argument>const DeclContext *dc</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>acceptsObjCTypeParams</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getTypeClassName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>QualType</name> <macro><name>getCanonicalTypeInternal</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>CanonicalType</name></expr>;</return>
}</block>

<name>CanQualType</name> <macro><name>getCanonicalTypeUnqualified</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <macro><name>dump</name><argument_list>(<argument>llvm::raw_ostream &amp;OS</argument>, <argument>const ASTContext &amp;Context</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> <specifier>const</specifier> <name>TypedefType</name> <operator>*</operator><name>Type</name><operator>::</operator><macro><name>getAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> <specifier>const</specifier> <name>TemplateSpecializationType</name> <operator>*</operator><name>Type</name><operator>::</operator><macro><name>getAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> <specifier>const</specifier> <name>AttributedType</name> <operator>*</operator><name>Type</name><operator>::</operator><macro><name>getAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPE</name><parameter_list>(<parameter><type><name>Class</name></type></parameter>, <parameter><type><name>Base</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAF_TYPE</name><parameter_list>(<parameter><type><name>Class</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>template &lt;&gt; inline const Class##Type *Type::getAs() const { return dyn_cast&lt;Class##Type&gt;(CanonicalType); } template &lt;&gt; inline const Class##Type *Type::castAs() const { return cast&lt;Class##Type&gt;(CanonicalType); }</cpp:value></cpp:define>






<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeNodes.inc"</cpp:file></cpp:include>



<expr><name>class</name> <name>BuiltinType</name> <operator>:</operator> <name>public</name> <name>Type</name> <block>{
<expr><name>public</name><operator>:</operator>
enum <name>Kind</name> <block>{

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMAGE_TYPE</name><parameter_list>(<parameter><type><name>ImgType</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>, <parameter><type><name>SingletonId</name></type></parameter>, <parameter><type><name>Access</name></type></parameter>, <parameter><type><name>Suffix</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Id,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenCLImageTypes.def"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXT_OPAQUE_TYPE</name><parameter_list>(<parameter><type><name>ExtType</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>, <parameter><type><name>Ext</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Id,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenCLExtensionTypes.def"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVE_TYPE</name><parameter_list>(<parameter><type><name>Name</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>, <parameter><type><name>SingletonId</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Id,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/AArch64SVEACLETypes.def"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PPC_VECTOR_TYPE</name><parameter_list>(<parameter><type><name>Name</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>, <parameter><type><name>Size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Id,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/PPCTypes.def"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RVV_TYPE</name><parameter_list>(<parameter><type><name>Name</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>, <parameter><type><name>SingletonId</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Id,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/RISCVVTypes.def"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUILTIN_TYPE</name><parameter_list>(<parameter><type><name>Id</name></type></parameter>, <parameter><type><name>SingletonId</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Id,</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAST_BUILTIN_TYPE</name><parameter_list>(<parameter><type><name>Id</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>LastKind = Id</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/BuiltinTypes.def"</cpp:file></cpp:include>
}</block></expr>;

<expr><name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<macro><name>BuiltinType</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Type</name><argument_list>(<argument>Builtin</argument>, <argument>QualType()</argument>,
<argument>K == Dependent ? TypeDependence::DependentInstantiation
: TypeDependence::None</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>BuiltinTypeBits</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>K</name></expr>;
}</block>

<name>public</name><operator>:</operator>
<name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Kind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>BuiltinTypeBits</name><operator>.</operator><name>Kind</name></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>StringRef</name> <macro><name>getName</name><argument_list>(<argument>const PrintingPolicy &amp;Policy</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getNameAsCString</name><argument_list>(<argument>const PrintingPolicy &amp;Policy</argument>)</argument_list></macro> <specifier>const</specifier> <block>{

<expr><name>StringRef</name> <name>str</name> <operator>=</operator> <call><name>getName</name><argument_list>(<argument><expr><name>Policy</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>str</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>str</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call><index>[<expr><call><name><name>str</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>]</index> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>str</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>isInteger</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>Bool</name> <operator>&amp;&amp;</operator> <call><name>getKind</name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>Int128</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isSignedInteger</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>Char_S</name> <operator>&amp;&amp;</operator> <call><name>getKind</name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>Int128</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isUnsignedInteger</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>Bool</name> <operator>&amp;&amp;</operator> <call><name>getKind</name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>UInt128</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isFloatingPoint</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>Half</name> <operator>&amp;&amp;</operator> <call><name>getKind</name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>Float128</name></expr>;</return>
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>isPlaceholderTypeKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{
<return>return <expr><name>K</name> <operator>&gt;=</operator> <name>Overload</name></expr>;</return>
}</block>




<name>bool</name> <macro><name>isPlaceholderType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isPlaceholderTypeKind</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>










<name>bool</name> <macro><name>isNonOverloadPlaceholderType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>Overload</name></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Builtin</name></expr>;</return> }</block>
}</expr>;



<expr><name>class</name> <name>ComplexType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><name>QualType</name> <name>ElementType</name></expr>;

<macro><name>ComplexType</name><argument_list>(<argument>QualType Element</argument>, <argument>QualType CanonicalPtr</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>Complex</name></expr></argument>, <argument><expr><name>CanonicalPtr</name></expr></argument>, <argument><expr><call><name><name>Element</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>ElementType</name><argument_list>(<argument>Element</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getElementType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ElementType</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getElementType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>QualType Element</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>Element</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Complex</name></expr>;</return> }</block>
}</expr>;


<expr><name>class</name> <name>ParenType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><name>QualType</name> <name>Inner</name></expr>;

<macro><name>ParenType</name><argument_list>(<argument>QualType InnerType</argument>, <argument>QualType CanonType</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>Paren</name></expr></argument>, <argument><expr><name>CanonType</name></expr></argument>, <argument><expr><call><name><name>InnerType</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>, <macro><name>Inner</name><argument_list>(<argument>InnerType</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getInnerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Inner</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getInnerType</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getInnerType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>QualType Inner</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Inner</name><operator>.</operator><name>Profile</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Paren</name></expr>;</return> }</block>
}</expr>;


<expr><name>class</name> <name>PointerType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><name>QualType</name> <name>PointeeType</name></expr>;

<macro><name>PointerType</name><argument_list>(<argument>QualType Pointee</argument>, <argument>QualType CanonicalPtr</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>Pointer</name></expr></argument>, <argument><expr><name>CanonicalPtr</name></expr></argument>, <argument><expr><call><name><name>Pointee</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>PointeeType</name><argument_list>(<argument>Pointee</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getPointeeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PointeeType</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getPointeeType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>QualType Pointee</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>Pointee</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Pointer</name></expr>;</return> }</block>
}</expr>;




<expr><name>class</name> <name>AdjustedType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>QualType</name> <name>OriginalTy</name></expr>;
<expr><name>QualType</name> <name>AdjustedTy</name></expr>;

<expr><name>protected</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<macro><name>AdjustedType</name><argument_list>(<argument>TypeClass TC</argument>, <argument>QualType OriginalTy</argument>, <argument>QualType AdjustedTy</argument>,
<argument>QualType CanonicalPtr</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>TC</name></expr></argument>, <argument><expr><name>CanonicalPtr</name></expr></argument>, <argument><expr><call><name><name>OriginalTy</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OriginalTy</name><argument_list>(<argument><expr><name>OriginalTy</name></expr></argument>)</argument_list></call></expr>, <macro><name>AdjustedTy</name><argument_list>(<argument>AdjustedTy</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getOriginalType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OriginalTy</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>getAdjustedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AdjustedTy</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AdjustedTy</name></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>OriginalTy</name></expr></argument>, <argument><expr><name>AdjustedTy</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>QualType Orig</argument>, <argument>QualType New</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>Orig</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>New</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Adjusted</name> <operator>||</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Decayed</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>DecayedType</name> <operator>:</operator> <name>public</name> <name>AdjustedType</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><specifier>inline</specifier>
<macro><name>DecayedType</name><argument_list>(<argument>QualType OriginalType</argument>, <argument>QualType Decayed</argument>, <argument>QualType Canonical</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getDecayedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getAdjustedType</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>inline</specifier> <name>QualType</name> <macro><name>getPointeeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Decayed</name></expr>;</return> }</block>
}</expr>;




<expr><name>class</name> <name>BlockPointerType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;


<expr><name>QualType</name> <name>PointeeType</name></expr>;

<macro><name>BlockPointerType</name><argument_list>(<argument>QualType Pointee</argument>, <argument>QualType CanonicalCls</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>BlockPointer</name></expr></argument>, <argument><expr><name>CanonicalCls</name></expr></argument>, <argument><expr><call><name><name>Pointee</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>PointeeType</name><argument_list>(<argument>Pointee</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>

<name>QualType</name> <macro><name>getPointeeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PointeeType</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getPointeeType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>QualType Pointee</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>Pointee</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>BlockPointer</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>ReferenceType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>QualType</name> <name>PointeeType</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>ReferenceType</name><argument_list>(<argument>TypeClass tc</argument>, <argument>QualType Referencee</argument>, <argument>QualType CanonicalRef</argument>,
<argument>bool SpelledAsLValue</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Type</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><name>CanonicalRef</name></expr></argument>, <argument><expr><call><name><name>Referencee</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>PointeeType</name><argument_list>(<argument>Referencee</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>ReferenceTypeBits</name><operator>.</operator><name>SpelledAsLValue</name></name> <operator>=</operator> <name>SpelledAsLValue</name></expr>;
<expr><name><name>ReferenceTypeBits</name><operator>.</operator><name>InnerRef</name></name> <operator>=</operator> <call><name><name>Referencee</name><operator>-&gt;</operator><name>isReferenceType</name></name><argument_list>()</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<name>bool</name> <macro><name>isSpelledAsLValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ReferenceTypeBits</name><operator>.</operator><name>SpelledAsLValue</name></name></expr>;</return> }</block>
<name>bool</name> <macro><name>isInnerRef</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ReferenceTypeBits</name><operator>.</operator><name>InnerRef</name></name></expr>;</return> }</block>

<name>QualType</name> <macro><name>getPointeeTypeAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PointeeType</name></expr>;</return> }</block>

<name>QualType</name> <macro><name>getPointeeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{

<expr><specifier>const</specifier> <name>ReferenceType</name> <operator>*</operator><name>T</name> <operator>=</operator> <name>this</name></expr>;
<while>while <condition>(<expr><call><name><name>T</name><operator>-&gt;</operator><name>isInnerRef</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>T</name> <operator>=</operator> <name><name>T</name><operator>-&gt;</operator><name>PointeeType</name><operator>-&gt;</operator><name>castAs</name></name><operator>&lt;</operator><name>ReferenceType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></while></block></expr>
<return>return <expr><name><name>T</name><operator>-&gt;</operator><name>PointeeType</name></name></expr>;</return>
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>PointeeType</name></expr></argument>, <argument><expr><call><name>isSpelledAsLValue</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>,
<argument>QualType Referencee</argument>,
<argument>bool SpelledAsLValue</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>Referencee</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><name>SpelledAsLValue</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>LValueReference</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>RValueReference</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>LValueReferenceType</name> <operator>:</operator> <name>public</name> <name>ReferenceType</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<macro><name>LValueReferenceType</name><argument_list>(<argument>QualType Referencee</argument>, <argument>QualType CanonicalRef</argument>,
<argument>bool SpelledAsLValue</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>ReferenceType</name><argument_list>(<argument>LValueReference</argument>, <argument>Referencee</argument>, <argument>CanonicalRef</argument>,
<argument>SpelledAsLValue</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>LValueReference</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>RValueReferenceType</name> <operator>:</operator> <name>public</name> <name>ReferenceType</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<macro><name>RValueReferenceType</name><argument_list>(<argument>QualType Referencee</argument>, <argument>QualType CanonicalRef</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>ReferenceType</name><argument_list>(<argument>RValueReference</argument>, <argument>Referencee</argument>, <argument>CanonicalRef</argument>, <argument>false</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>RValueReference</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>MemberPointerType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><name>QualType</name> <name>PointeeType</name></expr>;



<expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>Class</name></expr>;

<macro><name>MemberPointerType</name><argument_list>(<argument>QualType Pointee</argument>, <argument>const Type *Cls</argument>, <argument>QualType CanonicalPtr</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>MemberPointer</name></expr></argument>, <argument><expr><name>CanonicalPtr</name></expr></argument>,
<argument><expr><operator>(</operator><call><name><name>Cls</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <operator>~</operator><name>TypeDependence</name><operator>::</operator><name>VariablyModified</name><operator>)</operator> <operator>|</operator>
<call><name><name>Pointee</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>PointeeType</name><argument_list>(<argument><expr><name>Pointee</name></expr></argument>)</argument_list></call></expr>, <macro><name>Class</name><argument_list>(<argument>Cls</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getPointeeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PointeeType</name></expr>;</return> }</block>



<name>bool</name> <macro><name>isMemberFunctionPointer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>PointeeType</name><operator>-&gt;</operator><name>isFunctionProtoType</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isMemberDataPointer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name><name>PointeeType</name><operator>-&gt;</operator><name>isFunctionProtoType</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Type</name> <operator>*</operator><macro><name>getClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Class</name></expr>;</return> }</block>
<name>CXXRecordDecl</name> <operator>*</operator><macro><name>getMostRecentCXXRecordDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getPointeeType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getClass</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>QualType Pointee</argument>,
<argument>const Type *Class</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>Pointee</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>Class</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>MemberPointer</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>ArrayType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>public</name><operator>:</operator>




enum <name>ArraySizeModifier</name> <block>{
<expr><name>Normal</name></expr>, <expr><name>Static</name></expr>, <expr><name>Star</name></expr>
}</block></expr>;

<expr><name>private</name><operator>:</operator>

<name>QualType</name> <name>ElementType</name></expr>;

<expr><name>protected</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<macro><name>ArrayType</name><argument_list>(<argument>TypeClass tc</argument>, <argument>QualType et</argument>, <argument>QualType can</argument>, <argument>ArraySizeModifier sm</argument>,
<argument>unsigned tq</argument>, <argument>const Expr *sz = nullptr</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getElementType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ElementType</name></expr>;</return> }</block>

<name>ArraySizeModifier</name> <macro><name>getSizeModifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>ArraySizeModifier</name><argument_list>(<argument><expr><name><name>ArrayTypeBits</name><operator>.</operator><name>SizeModifier</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Qualifiers</name> <macro><name>getIndexTypeQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Qualifiers</name><operator>::</operator><call><name>fromCVRMask</name><argument_list>(<argument><expr><call><name>getIndexTypeCVRQualifiers</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getIndexTypeCVRQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ArrayTypeBits</name><operator>.</operator><name>IndexTypeQuals</name></name></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ConstantArray</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>VariableArray</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>IncompleteArray</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DependentSizedArray</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>ConstantArrayType</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>ArrayType</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ConstantArrayType</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;

<expr><name>llvm</name><operator>::</operator><name>APInt</name> <name>Size</name></expr>;

<macro><name>ConstantArrayType</name><argument_list>(<argument>QualType et</argument>, <argument>QualType can</argument>, <argument>const llvm::APInt &amp;size</argument>,
<argument>const Expr *sz</argument>, <argument>ArraySizeModifier sm</argument>, <argument>unsigned tq</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>ArrayType</name><argument_list>(<argument><expr><name>ConstantArray</name></expr></argument>, <argument><expr><name>et</name></expr></argument>, <argument><expr><name>can</name></expr></argument>, <argument><expr><name>sm</name></expr></argument>, <argument><expr><name>tq</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>, <macro><name>Size</name><argument_list>(<argument>size</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>ConstantArrayTypeBits</name><operator>.</operator><name>HasStoredSizeExpr</name></name> <operator>=</operator> <name>sz</name> <operator>!=</operator> <name>nullptr</name></expr>;
<if_stmt><if>if <condition>(<expr><name><name>ConstantArrayTypeBits</name><operator>.</operator><name>HasStoredSizeExpr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>can</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"canonical constant array should not have size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}

unsigned numTrailingObjects(OverloadToken&lt;const Expr*&gt;</block></if></if_stmt>) <specifier>const</specifier> <block>{
<return>return <expr><name><name>ConstantArrayTypeBits</name><operator>.</operator><name>HasStoredSizeExpr</name></name></expr>;</return>
}</block></block>

<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>llvm</name><operator>::</operator><name>APInt</name> <operator>&amp;</operator><macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Size</name></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getSizeExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ConstantArrayTypeBits</name><operator>.</operator><name>HasStoredSizeExpr</name></name>
<operator>?</operator> <operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call>
<operator>:</operator> <name>nullptr</name></expr>;</return>
}</block>
<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>



<specifier>static</specifier> <name>unsigned</name> <macro><name>getNumAddressingBits</name><argument_list>(<argument>const ASTContext &amp;Context</argument>,
<argument>QualType ElementType</argument>,
<argument>const llvm::APInt &amp;NumElements</argument>)</argument_list></macro></expr>;



<expr><specifier>static</specifier> <name>unsigned</name> <call><name>getMaxSizeBits</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list></call></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>const ASTContext &amp;Ctx</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><call><name>getElementType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getSize</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getSizeExpr</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getSizeModifier</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getIndexTypeCVRQualifiers</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>const ASTContext &amp;Ctx</argument>,
<argument>QualType ET</argument>, <argument>const llvm::APInt &amp;ArraySize</argument>,
<argument>const Expr *SizeExpr</argument>, <argument>ArraySizeModifier SizeMod</argument>,
<argument>unsigned TypeQuals</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ConstantArray</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>IncompleteArrayType</name> <operator>:</operator> <name>public</name> <name>ArrayType</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<macro><name>IncompleteArrayType</name><argument_list>(<argument>QualType et</argument>, <argument>QualType can</argument>,
<argument>ArraySizeModifier sm</argument>, <argument>unsigned tq</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>ArrayType</name><argument_list>(<argument>IncompleteArray</argument>, <argument>et</argument>, <argument>can</argument>, <argument>sm</argument>, <argument>tq</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>StmtIteratorBase</name></expr>;

<expr><name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>IncompleteArray</name></expr>;</return>
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getElementType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getSizeModifier</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getIndexTypeCVRQualifiers</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>QualType ET</argument>,
<argument>ArraySizeModifier SizeMod</argument>, <argument>unsigned TypeQuals</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>ET</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>SizeMod</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>TypeQuals</name></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;















<expr><name>class</name> <name>VariableArrayType</name> <operator>:</operator> <name>public</name> <name>ArrayType</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;



<expr><name>Stmt</name> <operator>*</operator><name>SizeExpr</name></expr>;


<expr><name>SourceRange</name> <name>Brackets</name></expr>;

<macro><name>VariableArrayType</name><argument_list>(<argument>QualType et</argument>, <argument>QualType can</argument>, <argument>Expr *e</argument>,
<argument>ArraySizeModifier sm</argument>, <argument>unsigned tq</argument>,
<argument>SourceRange brackets</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>ArrayType</name><argument_list>(<argument><expr><name>VariableArray</name></expr></argument>, <argument><expr><name>et</name></expr></argument>, <argument><expr><name>can</name></expr></argument>, <argument><expr><name>sm</name></expr></argument>, <argument><expr><name>tq</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SizeExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Stmt</name><operator>*</operator><operator>)</operator> <name>e</name></expr></argument>)</argument_list></call></expr>, <macro><name>Brackets</name><argument_list>(<argument>brackets</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>StmtIteratorBase</name></expr>;

<expr><name>Expr</name> <operator>*</operator><macro><name>getSizeExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{


<return>return <expr><operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator> <name>SizeExpr</name></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getBracketsRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Brackets</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getLBracketLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Brackets</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getRBracketLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Brackets</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>VariableArray</name></expr>;</return>
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Cannot unique VariableArrayTypes."</literal></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;














<expr><name>class</name> <name>DependentSizedArrayType</name> <operator>:</operator> <name>public</name> <name>ArrayType</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr>;






<expr><name>Stmt</name> <operator>*</operator><name>SizeExpr</name></expr>;


<expr><name>SourceRange</name> <name>Brackets</name></expr>;

<macro><name>DependentSizedArrayType</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>QualType et</argument>, <argument>QualType can</argument>,
<argument>Expr *e</argument>, <argument>ArraySizeModifier sm</argument>, <argument>unsigned tq</argument>,
<argument>SourceRange brackets</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>StmtIteratorBase</name></expr>;

<expr><name>Expr</name> <operator>*</operator><macro><name>getSizeExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{


<return>return <expr><operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator> <name>SizeExpr</name></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getBracketsRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Brackets</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getLBracketLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Brackets</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getRBracketLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Brackets</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DependentSizedArray</name></expr>;</return>
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>, <argument><expr><call><name>getElementType</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getSizeModifier</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getIndexTypeCVRQualifiers</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getSizeExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>const ASTContext &amp;Context</argument>,
<argument>QualType ET</argument>, <argument>ArraySizeModifier SizeMod</argument>,
<argument>unsigned TypeQuals</argument>, <argument>Expr *E</argument>)</argument_list></macro></expr>;
}</block></expr>;












<expr><name>class</name> <name>DependentAddressSpaceType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr>;
<expr><name>Expr</name> <operator>*</operator><name>AddrSpaceExpr</name></expr>;
<expr><name>QualType</name> <name>PointeeType</name></expr>;
<expr><name>SourceLocation</name> <name>loc</name></expr>;

<macro><name>DependentAddressSpaceType</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>QualType PointeeType</argument>,
<argument>QualType can</argument>, <argument>Expr *AddrSpaceExpr</argument>,
<argument>SourceLocation loc</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<name>Expr</name> <operator>*</operator><macro><name>getAddrSpaceExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AddrSpaceExpr</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>getPointeeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PointeeType</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getAttributeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>loc</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DependentAddressSpace</name></expr>;</return>
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>, <argument><expr><call><name>getPointeeType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getAddrSpaceExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>const ASTContext &amp;Context</argument>,
<argument>QualType PointeeType</argument>, <argument>Expr *AddrSpaceExpr</argument>)</argument_list></macro></expr>;
}</block></expr>;











<expr><name>class</name> <name>DependentSizedExtVectorType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr>;
<expr><name>Expr</name> <operator>*</operator><name>SizeExpr</name></expr>;


<expr><name>QualType</name> <name>ElementType</name></expr>;

<expr><name>SourceLocation</name> <name>loc</name></expr>;

<macro><name>DependentSizedExtVectorType</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>QualType ElementType</argument>,
<argument>QualType can</argument>, <argument>Expr *SizeExpr</argument>, <argument>SourceLocation loc</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<name>Expr</name> <operator>*</operator><macro><name>getSizeExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SizeExpr</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>getElementType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ElementType</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getAttributeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>loc</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DependentSizedExtVector</name></expr>;</return>
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>, <argument><expr><call><name>getElementType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getSizeExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>const ASTContext &amp;Context</argument>,
<argument>QualType ElementType</argument>, <argument>Expr *SizeExpr</argument>)</argument_list></macro></expr>;
}</block></expr>;







<expr><name>class</name> <name>VectorType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>public</name><operator>:</operator>
enum <name>VectorKind</name> <block>{

<expr><name>GenericVector</name></expr>,


<expr><name>AltiVecVector</name></expr>,


<expr><name>AltiVecPixel</name></expr>,


<expr><name>AltiVecBool</name></expr>,


<expr><name>NeonVector</name></expr>,


<expr><name>NeonPolyVector</name></expr>,


<expr><name>SveFixedLengthDataVector</name></expr>,


<expr><name>SveFixedLengthPredicateVector</name></expr>
}</block></expr>;

<expr><name>protected</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTContext</name></expr>;


<expr><name>QualType</name> <name>ElementType</name></expr>;

<macro><name>VectorType</name><argument_list>(<argument>QualType vecType</argument>, <argument>unsigned nElements</argument>, <argument>QualType canonType</argument>,
<argument>VectorKind vecKind</argument>)</argument_list></macro>;

<macro><name>VectorType</name><argument_list>(<argument>TypeClass tc</argument>, <argument>QualType vecType</argument>, <argument>unsigned nElements</argument>,
<argument>QualType canonType</argument>, <argument>VectorKind vecKind</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getElementType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ElementType</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>getNumElements</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>VectorTypeBits</name><operator>.</operator><name>NumElements</name></name></expr>;</return> }</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>VectorKind</name> <macro><name>getVectorKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>VectorKind</name><argument_list>(<argument><expr><name><name>VectorTypeBits</name><operator>.</operator><name>VecKind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getElementType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNumElements</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getTypeClass</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getVectorKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>QualType ElementType</argument>,
<argument>unsigned NumElements</argument>, <argument>TypeClass TypeClass</argument>,
<argument>VectorKind VecKind</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>ElementType</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>NumElements</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>TypeClass</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>VecKind</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Vector</name> <operator>||</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ExtVector</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>DependentVectorType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr>;
<expr><name>QualType</name> <name>ElementType</name></expr>;
<expr><name>Expr</name> <operator>*</operator><name>SizeExpr</name></expr>;
<expr><name>SourceLocation</name> <name>Loc</name></expr>;

<macro><name>DependentVectorType</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>QualType ElementType</argument>,
<argument>QualType CanonType</argument>, <argument>Expr *SizeExpr</argument>,
<argument>SourceLocation Loc</argument>, <argument>VectorType::VectorKind vecKind</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<name>Expr</name> <operator>*</operator><macro><name>getSizeExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SizeExpr</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>getElementType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ElementType</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getAttributeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>
<name>VectorType</name><operator>::</operator><name>VectorKind</name> <macro><name>getVectorKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>VectorType</name><operator>::</operator><call><name>VectorKind</name><argument_list>(<argument><expr><name><name>VectorTypeBits</name><operator>.</operator><name>VecKind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DependentVector</name></expr>;</return>
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>, <argument><expr><call><name>getElementType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getSizeExpr</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getVectorKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>const ASTContext &amp;Context</argument>,
<argument>QualType ElementType</argument>, <argument>const Expr *SizeExpr</argument>,
<argument>VectorType::VectorKind VecKind</argument>)</argument_list></macro></expr>;
}</block></expr>;







<expr><name>class</name> <name>ExtVectorType</name> <operator>:</operator> <name>public</name> <name>VectorType</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<macro><name>ExtVectorType</name><argument_list>(<argument>QualType vecType</argument>, <argument>unsigned nElements</argument>, <argument>QualType canonType</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>VectorType</name><argument_list>(<argument>ExtVector</argument>, <argument>vecType</argument>, <argument>nElements</argument>, <argument>canonType</argument>, <argument>GenericVector</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>int</name> <macro><name>getPointAccessorIdx</name><argument_list>(<argument>char c</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<default>default:</default> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
<case>case <expr><literal type="char">'x'</literal></expr>:</case> <case>case <expr><literal type="char">'r'</literal></expr>:</case> <return>return <expr><literal type="number">0</literal></expr>;</return>
<case>case <expr><literal type="char">'y'</literal></expr>:</case> <case>case <expr><literal type="char">'g'</literal></expr>:</case> <return>return <expr><literal type="number">1</literal></expr>;</return>
<case>case <expr><literal type="char">'z'</literal></expr>:</case> <case>case <expr><literal type="char">'b'</literal></expr>:</case> <return>return <expr><literal type="number">2</literal></expr>;</return>
<case>case <expr><literal type="char">'w'</literal></expr>:</case> <case>case <expr><literal type="char">'a'</literal></expr>:</case> <return>return <expr><literal type="number">3</literal></expr>;</return>
<expr_stmt/>}</block_content>
}

static int getNumericAccessorIdx(char c</block></switch>) <block>{
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<default>default:</default> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
<case>case <expr><literal type="char">'0'</literal></expr>:</case> <return>return <expr><literal type="number">0</literal></expr>;</return>
<case>case <expr><literal type="char">'1'</literal></expr>:</case> <return>return <expr><literal type="number">1</literal></expr>;</return>
<case>case <expr><literal type="char">'2'</literal></expr>:</case> <return>return <expr><literal type="number">2</literal></expr>;</return>
<case>case <expr><literal type="char">'3'</literal></expr>:</case> <return>return <expr><literal type="number">3</literal></expr>;</return>
<case>case <expr><literal type="char">'4'</literal></expr>:</case> <return>return <expr><literal type="number">4</literal></expr>;</return>
<case>case <expr><literal type="char">'5'</literal></expr>:</case> <return>return <expr><literal type="number">5</literal></expr>;</return>
<case>case <expr><literal type="char">'6'</literal></expr>:</case> <return>return <expr><literal type="number">6</literal></expr>;</return>
<case>case <expr><literal type="char">'7'</literal></expr>:</case> <return>return <expr><literal type="number">7</literal></expr>;</return>
<case>case <expr><literal type="char">'8'</literal></expr>:</case> <return>return <expr><literal type="number">8</literal></expr>;</return>
<case>case <expr><literal type="char">'9'</literal></expr>:</case> <return>return <expr><literal type="number">9</literal></expr>;</return>
<case>case <expr><literal type="char">'A'</literal></expr>:</case>
<case>case <expr><literal type="char">'a'</literal></expr>:</case> <return>return <expr><literal type="number">10</literal></expr>;</return>
<case>case <expr><literal type="char">'B'</literal></expr>:</case>
<case>case <expr><literal type="char">'b'</literal></expr>:</case> <return>return <expr><literal type="number">11</literal></expr>;</return>
<case>case <expr><literal type="char">'C'</literal></expr>:</case>
<case>case <expr><literal type="char">'c'</literal></expr>:</case> <return>return <expr><literal type="number">12</literal></expr>;</return>
<case>case <expr><literal type="char">'D'</literal></expr>:</case>
<case>case <expr><literal type="char">'d'</literal></expr>:</case> <return>return <expr><literal type="number">13</literal></expr>;</return>
<case>case <expr><literal type="char">'E'</literal></expr>:</case>
<case>case <expr><literal type="char">'e'</literal></expr>:</case> <return>return <expr><literal type="number">14</literal></expr>;</return>
<case>case <expr><literal type="char">'F'</literal></expr>:</case>
<case>case <expr><literal type="char">'f'</literal></expr>:</case> <return>return <expr><literal type="number">15</literal></expr>;</return>
<expr_stmt/>}</block_content>
}

static int getAccessorIdx(char c</block><operator>,</operator> <expr_stmt><expr><name>bool</name> <name>isNumericAccessor</name></expr></expr_stmt></switch>) <block>{
<if_stmt><if>if <condition>(<expr><name>isNumericAccessor</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getNumericAccessorIdx</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>getPointAccessorIdx</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block></block></block>

<name>bool</name> <macro><name>isAccessorWithinNumElements</name><argument_list>(<argument>char c</argument>, <argument>bool isNumericAccessor</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>getAccessorIdx</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>isNumericAccessor</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>unsigned</name><argument_list>(<argument><expr><name>idx</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>getNumElements</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ExtVector</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>MatrixType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>protected</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTContext</name></expr>;


<expr><name>QualType</name> <name>ElementType</name></expr>;

<macro><name>MatrixType</name><argument_list>(<argument>QualType ElementTy</argument>, <argument>QualType CanonElementTy</argument>)</argument_list></macro>;

<macro><name>MatrixType</name><argument_list>(<argument>TypeClass TypeClass</argument>, <argument>QualType ElementTy</argument>, <argument>QualType CanonElementTy</argument>,
<argument>const Expr *RowExpr = nullptr</argument>, <argument>const Expr *ColumnExpr = nullptr</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>

<name>QualType</name> <macro><name>getElementType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ElementType</name></expr>;</return> }</block>






<specifier>static</specifier> <name>bool</name> <macro><name>isValidElementType</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>isDependentType</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<operator>(</operator><call><name><name>T</name><operator>-&gt;</operator><name>isRealType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>T</name><operator>-&gt;</operator><name>isBooleanType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>T</name><operator>-&gt;</operator><name>isEnumeralType</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ConstantMatrix</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DependentSizedMatrix</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>ConstantMatrixType</name> <name>final</name> <operator>:</operator> <name>public</name> <name>MatrixType</name> <block>{
<expr><name>protected</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTContext</name></expr>;



<expr><name>QualType</name> <name>ElementType</name></expr>;


<expr><name>unsigned</name> <name>NumRows</name></expr>;
<expr><name>unsigned</name> <name>NumColumns</name></expr>;

<expr><specifier>static</specifier> <name>constexpr</name> <name>unsigned</name> <name>MaxElementsPerDimension</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">20</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;

<macro><name>ConstantMatrixType</name><argument_list>(<argument>QualType MatrixElementType</argument>, <argument>unsigned NRows</argument>,
<argument>unsigned NColumns</argument>, <argument>QualType CanonElementType</argument>)</argument_list></macro>;

<macro><name>ConstantMatrixType</name><argument_list>(<argument>TypeClass typeClass</argument>, <argument>QualType MatrixType</argument>, <argument>unsigned NRows</argument>,
<argument>unsigned NColumns</argument>, <argument>QualType CanonElementType</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>

<name>unsigned</name> <macro><name>getNumRows</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumRows</name></expr>;</return> }</block>


<name>unsigned</name> <macro><name>getNumColumns</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumColumns</name></expr>;</return> }</block>


<name>unsigned</name> <macro><name>getNumElementsFlattened</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNumRows</name><argument_list>()</argument_list></call> <operator>*</operator> <call><name>getNumColumns</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>constexpr</name> <name>bool</name> <macro><name>isDimensionValid</name><argument_list>(<argument>size_t NumElements</argument>)</argument_list></macro> <block>{
<return>return <expr><name>NumElements</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>NumElements</name> <operator>&lt;=</operator> <name>MaxElementsPerDimension</name></expr>;</return>
}</block>


<specifier>static</specifier> <name>constexpr</name> <name>unsigned</name> <macro><name>getMaxElementsPerDimension</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>MaxElementsPerDimension</name></expr>;</return>
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getElementType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNumRows</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNumColumns</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getTypeClass</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>QualType ElementType</argument>,
<argument>unsigned NumRows</argument>, <argument>unsigned NumColumns</argument>,
<argument>TypeClass TypeClass</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>ElementType</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>NumRows</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>NumColumns</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>TypeClass</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ConstantMatrix</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>DependentSizedMatrixType</name> <name>final</name> <operator>:</operator> <name>public</name> <name>MatrixType</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr>;
<expr><name>Expr</name> <operator>*</operator><name>RowExpr</name></expr>;
<expr><name>Expr</name> <operator>*</operator><name>ColumnExpr</name></expr>;

<expr><name>SourceLocation</name> <name>loc</name></expr>;

<macro><name>DependentSizedMatrixType</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>QualType ElementType</argument>,
<argument>QualType CanonicalType</argument>, <argument>Expr *RowExpr</argument>,
<argument>Expr *ColumnExpr</argument>, <argument>SourceLocation loc</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getElementType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ElementType</name></expr>;</return> }</block>
<name>Expr</name> <operator>*</operator><macro><name>getRowExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RowExpr</name></expr>;</return> }</block>
<name>Expr</name> <operator>*</operator><macro><name>getColumnExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColumnExpr</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getAttributeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>loc</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DependentSizedMatrix</name></expr>;</return>
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>, <argument><expr><call><name>getElementType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRowExpr</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getColumnExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>const ASTContext &amp;Context</argument>,
<argument>QualType ElementType</argument>, <argument>Expr *RowExpr</argument>, <argument>Expr *ColumnExpr</argument>)</argument_list></macro></expr>;
}</block></expr>;



<expr><name>class</name> <name>FunctionType</name> <operator>:</operator> <name>public</name> <name>Type</name> <block>{

<expr><name>QualType</name> <name>ResultType</name></expr>;

<expr><name>public</name><operator>:</operator>





















<name>class</name> <name>ExtParameterInfo</name> <block>{
enum <expr><block>{
<expr><name>ABIMask</name> <operator>=</operator> <literal type="number">0x0F</literal></expr>,
<expr><name>IsConsumed</name> <operator>=</operator> <literal type="number">0x10</literal></expr>,
<expr><name>HasPassObjSize</name> <operator>=</operator> <literal type="number">0x20</literal></expr>,
<expr><name>IsNoEscape</name> <operator>=</operator> <literal type="number">0x40</literal></expr>,
}</block></expr>;
<expr><name>unsigned</name> <name>char</name> <name>Data</name> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>ExtParameterInfo</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;


<expr><name>ParameterABI</name> <macro><name>getABI</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>ParameterABI</name><argument_list>(<argument><expr><name>Data</name> <operator>&amp;</operator> <name>ABIMask</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>ExtParameterInfo</name> <macro><name>withABI</name><argument_list>(<argument>ParameterABI kind</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>ExtParameterInfo</name> <name>copy</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;
<expr><name><name>copy</name><operator>.</operator><name>Data</name></name> <operator>=</operator> <operator>(</operator><name><name>copy</name><operator>.</operator><name>Data</name></name> <operator>&amp;</operator> <operator>~</operator><name>ABIMask</name><operator>)</operator> <operator>|</operator> <call><name>unsigned</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>copy</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>isConsumed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>Data</name> <operator>&amp;</operator> <name>IsConsumed</name><operator>)</operator></expr>;</return> }</block>
<name>ExtParameterInfo</name> <macro><name>withIsConsumed</name><argument_list>(<argument>bool consumed</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>ExtParameterInfo</name> <name>copy</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;
<if_stmt><if>if <condition>(<expr><name>consumed</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>copy</name><operator>.</operator><name>Data</name></name> <operator>|=</operator> <name>IsConsumed</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>copy</name><operator>.</operator><name>Data</name></name> <operator>&amp;=</operator> <operator>~</operator><name>IsConsumed</name></expr>;</expr_stmt></block_content></block></else></if_stmt></block></expr>
<return>return <expr><name>copy</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasPassObjectSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Data</name> <operator>&amp;</operator> <name>HasPassObjSize</name></expr>;</return> }</block>
<name>ExtParameterInfo</name> <macro><name>withHasPassObjectSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>ExtParameterInfo</name> <name>Copy</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;
<expr><name><name>Copy</name><operator>.</operator><name>Data</name></name> <operator>|=</operator> <name>HasPassObjSize</name></expr>;
<return>return <expr><name>Copy</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isNoEscape</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Data</name> <operator>&amp;</operator> <name>IsNoEscape</name></expr>;</return> }</block>
<name>ExtParameterInfo</name> <macro><name>withIsNoEscape</name><argument_list>(<argument>bool NoEscape</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>ExtParameterInfo</name> <name>Copy</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;
<if_stmt><if>if <condition>(<expr><name>NoEscape</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>Copy</name><operator>.</operator><name>Data</name></name> <operator>|=</operator> <name>IsNoEscape</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>Copy</name><operator>.</operator><name>Data</name></name> <operator>&amp;=</operator> <operator>~</operator><name>IsNoEscape</name></expr>;</expr_stmt></block_content></block></else></if_stmt></block></expr>
<return>return <expr><name>Copy</name></expr>;</return>
}</block>

<name>unsigned</name> <name>char</name> <macro><name>getOpaqueValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Data</name></expr>;</return> }</block>
<specifier>static</specifier> <name>ExtParameterInfo</name> <macro><name>getFromOpaqueValue</name><argument_list>(<argument>unsigned char data</argument>)</argument_list></macro> <block>{
<expr><name>ExtParameterInfo</name> <name>result</name></expr>;
<expr><name><name>result</name><operator>.</operator><name>Data</name></name> <operator>=</operator> <name>data</name></expr>;
<return>return <expr><name>result</name></expr>;</return>
}</block>

<name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><name>ExtParameterInfo</name> <name>lhs</name>, <name>ExtParameterInfo</name> <name>rhs</name><operator>)</operator> <block>{
<return>return <expr><name><name>lhs</name><operator>.</operator><name>Data</name></name> <operator>==</operator> <name><name>rhs</name><operator>.</operator><name>Data</name></name></expr>;</return>
}</block>

<name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><name>ExtParameterInfo</name> <name>lhs</name>, <name>ExtParameterInfo</name> <name>rhs</name><operator>)</operator> <block>{
<return>return <expr><name><name>lhs</name><operator>.</operator><name>Data</name></name> <operator>!=</operator> <name><name>rhs</name><operator>.</operator><name>Data</name></name></expr>;</return>
}</block>
}</expr>;





















<expr><name>class</name> <name>ExtInfo</name> <block>{
<expr><name>friend</name> <name>class</name> <name>FunctionType</name></expr>;









enum <expr><block>{ <expr><name>CallConvMask</name> <operator>=</operator> <literal type="number">0x1F</literal></expr> }</block></expr>;
enum <expr><block>{ <expr><name>NoReturnMask</name> <operator>=</operator> <literal type="number">0x20</literal></expr> }</block></expr>;
enum <expr><block>{ <expr><name>ProducesResultMask</name> <operator>=</operator> <literal type="number">0x40</literal></expr> }</block></expr>;
enum <expr><block>{ <expr><name>NoCallerSavedRegsMask</name> <operator>=</operator> <literal type="number">0x80</literal></expr> }</block></expr>;
enum <expr><block>{
<expr><name>RegParmMask</name> <operator>=</operator> <literal type="number">0x700</literal></expr>,
<expr><name>RegParmOffset</name> <operator>=</operator> <literal type="number">8</literal></expr>
}</block></expr>;
enum <expr><block>{ <expr><name>NoCfCheckMask</name> <operator>=</operator> <literal type="number">0x800</literal></expr> }</block></expr>;
enum <expr><block>{ <expr><name>CmseNSCallMask</name> <operator>=</operator> <literal type="number">0x1000</literal></expr> }</block></expr>;
<expr><name>uint16_t</name> <name>Bits</name> <operator>=</operator> <name>CC_C</name></expr>;

<macro><name>ExtInfo</name><argument_list>(<argument>unsigned Bits</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Bits</name><argument_list>(<argument>static_cast&lt;uint16_t&gt;(Bits)</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>


<macro><name>ExtInfo</name><argument_list>(<argument>bool noReturn</argument>, <argument>bool hasRegParm</argument>, <argument>unsigned regParm</argument>, <argument>CallingConv cc</argument>,
<argument>bool producesResult</argument>, <argument>bool noCallerSavedRegs</argument>, <argument>bool NoCfCheck</argument>,
<argument>bool cmseNSCall</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>!</operator><name>hasRegParm</name> <operator>||</operator> <name>regParm</name> <operator>&lt;</operator> <literal type="number">7</literal><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Invalid regparm value"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>Bits</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>cc</name><operator>)</operator> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>noReturn</name></expr> ?</condition><then> <expr><name>NoReturnMask</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
<operator>(</operator><ternary><condition><expr><name>producesResult</name></expr> ?</condition><then> <expr><name>ProducesResultMask</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
<operator>(</operator><ternary><condition><expr><name>noCallerSavedRegs</name></expr> ?</condition><then> <expr><name>NoCallerSavedRegsMask</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
<operator>(</operator><ternary><condition><expr><name>hasRegParm</name></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>regParm</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>RegParmOffset</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
<operator>(</operator><ternary><condition><expr><name>NoCfCheck</name></expr> ?</condition><then> <expr><name>NoCfCheckMask</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
<operator>(</operator><ternary><condition><expr><name>cmseNSCall</name></expr> ?</condition><then> <expr><name>CmseNSCallMask</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;
}</block>



<call><name>ExtInfo</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;



<macro><name>ExtInfo</name><argument_list>(<argument>CallingConv CC</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Bits</name><argument_list>(<argument>CC</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>getNoReturn</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Bits</name> <operator>&amp;</operator> <name>NoReturnMask</name></expr>;</return> }</block>
<name>bool</name> <macro><name>getProducesResult</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Bits</name> <operator>&amp;</operator> <name>ProducesResultMask</name></expr>;</return> }</block>
<name>bool</name> <macro><name>getCmseNSCall</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Bits</name> <operator>&amp;</operator> <name>CmseNSCallMask</name></expr>;</return> }</block>
<name>bool</name> <macro><name>getNoCallerSavedRegs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Bits</name> <operator>&amp;</operator> <name>NoCallerSavedRegsMask</name></expr>;</return> }</block>
<name>bool</name> <macro><name>getNoCfCheck</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Bits</name> <operator>&amp;</operator> <name>NoCfCheckMask</name></expr>;</return> }</block>
<name>bool</name> <macro><name>getHasRegParm</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><operator>(</operator><name>Bits</name> <operator>&amp;</operator> <name>RegParmMask</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>RegParmOffset</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return> }</block>

<name>unsigned</name> <macro><name>getRegParm</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>unsigned</name> <name>RegParm</name> <operator>=</operator> <operator>(</operator><name>Bits</name> <operator>&amp;</operator> <name>RegParmMask</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>RegParmOffset</name></expr>;
<if_stmt><if>if <condition>(<expr><name>RegParm</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>--</operator><name>RegParm</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>RegParm</name></expr>;</return>
}</block>

<name>CallingConv</name> <macro><name>getCC</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>CallingConv</name><argument_list>(<argument><expr><name>Bits</name> <operator>&amp;</operator> <name>CallConvMask</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><name>ExtInfo</name> <name>Other</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>Bits</name> <operator>==</operator> <name><name>Other</name><operator>.</operator><name>Bits</name></name></expr>;</return>
}</block>
<name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><name>ExtInfo</name> <name>Other</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>Bits</name> <operator>!=</operator> <name><name>Other</name><operator>.</operator><name>Bits</name></name></expr>;</return>
}</block>




<name>ExtInfo</name> <macro><name>withNoReturn</name><argument_list>(<argument>bool noReturn</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>noReturn</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExtInfo</name><argument_list>(<argument><expr><name>Bits</name> <operator>|</operator> <name>NoReturnMask</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>ExtInfo</name><argument_list>(<argument><expr><name>Bits</name> <operator>&amp;</operator> <operator>~</operator><name>NoReturnMask</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block>

<name>ExtInfo</name> <macro><name>withProducesResult</name><argument_list>(<argument>bool producesResult</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>producesResult</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExtInfo</name><argument_list>(<argument><expr><name>Bits</name> <operator>|</operator> <name>ProducesResultMask</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>ExtInfo</name><argument_list>(<argument><expr><name>Bits</name> <operator>&amp;</operator> <operator>~</operator><name>ProducesResultMask</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block>

<name>ExtInfo</name> <macro><name>withCmseNSCall</name><argument_list>(<argument>bool cmseNSCall</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>cmseNSCall</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExtInfo</name><argument_list>(<argument><expr><name>Bits</name> <operator>|</operator> <name>CmseNSCallMask</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>ExtInfo</name><argument_list>(<argument><expr><name>Bits</name> <operator>&amp;</operator> <operator>~</operator><name>CmseNSCallMask</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block>

<name>ExtInfo</name> <macro><name>withNoCallerSavedRegs</name><argument_list>(<argument>bool noCallerSavedRegs</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>noCallerSavedRegs</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExtInfo</name><argument_list>(<argument><expr><name>Bits</name> <operator>|</operator> <name>NoCallerSavedRegsMask</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>ExtInfo</name><argument_list>(<argument><expr><name>Bits</name> <operator>&amp;</operator> <operator>~</operator><name>NoCallerSavedRegsMask</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block>

<name>ExtInfo</name> <macro><name>withNoCfCheck</name><argument_list>(<argument>bool noCfCheck</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>noCfCheck</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExtInfo</name><argument_list>(<argument><expr><name>Bits</name> <operator>|</operator> <name>NoCfCheckMask</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>ExtInfo</name><argument_list>(<argument><expr><name>Bits</name> <operator>&amp;</operator> <operator>~</operator><name>NoCfCheckMask</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block>

<name>ExtInfo</name> <macro><name>withRegParm</name><argument_list>(<argument>unsigned RegParm</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>RegParm</name> <operator>&lt;</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator> <literal type="string">"Invalid regparm value"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>ExtInfo</name><argument_list>(<argument><expr><operator>(</operator><name>Bits</name> <operator>&amp;</operator> <operator>~</operator><name>RegParmMask</name><operator>)</operator> <operator>|</operator>
<operator>(</operator><operator>(</operator><name>RegParm</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>RegParmOffset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>ExtInfo</name> <macro><name>withCallingConv</name><argument_list>(<argument>CallingConv cc</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>ExtInfo</name><argument_list>(<argument><expr><operator>(</operator><name>Bits</name> <operator>&amp;</operator> <operator>~</operator><name>CallConvMask</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>unsigned</name><operator>)</operator> <name>cc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>Bits</name></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;




struct <expr><name>ExceptionType</name> <block>{ <expr><name>QualType</name> <name>Type</name></expr>; }</block></expr>;





struct <macro><name>alignas</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <expr><name>FunctionTypeExtraBitfields</name> <block>{



<expr><name>unsigned</name> <name>NumExceptionType</name></expr>;
}</block></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>FunctionType</name><argument_list>(<argument>TypeClass tc</argument>, <argument>QualType res</argument>, <argument>QualType Canonical</argument>,
<argument>TypeDependence Dependence</argument>, <argument>ExtInfo Info</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Type</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><name>Canonical</name></expr></argument>, <argument><expr><name>Dependence</name></expr></argument>)</argument_list></call></expr>, <macro><name>ResultType</name><argument_list>(<argument>res</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>FunctionTypeBits</name><operator>.</operator><name>ExtInfo</name></name> <operator>=</operator> <name><name>Info</name><operator>.</operator><name>Bits</name></name></expr>;
}</block>

<name>Qualifiers</name> <macro><name>getFastTypeQuals</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Qualifiers</name><operator>::</operator><call><name>fromFastMask</name><argument_list>(<argument><expr><name><name>FunctionTypeBits</name><operator>.</operator><name>FastTypeQuals</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getReturnType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ResultType</name></expr>;</return> }</block>

<name>bool</name> <macro><name>getHasRegParm</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getExtInfo</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getHasRegParm</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>unsigned</name> <macro><name>getRegParmType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getExtInfo</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getRegParm</name><argument_list>()</argument_list></call></expr>;</return> }</block>




<name>bool</name> <macro><name>getNoReturnAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getExtInfo</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getNoReturn</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>getCmseNSCallAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getExtInfo</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCmseNSCall</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>CallingConv</name> <macro><name>getCallConv</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getExtInfo</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCC</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>ExtInfo</name> <macro><name>getExtInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>ExtInfo</name><argument_list>(<argument><expr><name><name>FunctionTypeBits</name><operator>.</operator><name>ExtInfo</name></name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<call><name>static_assert</name><argument_list>(<argument><expr><operator>(</operator><operator>~</operator><name>Qualifiers</name><operator>::</operator><name>FastMask</name> <operator>&amp;</operator> <name>Qualifiers</name><operator>::</operator><name>CVRMask</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><literal type="string">"Const, volatile and restrict are assumed to be a subset of "</literal>
<literal type="string">"the fast qualifiers."</literal></expr></argument>)</argument_list></call></expr>;

<expr><name>bool</name> <macro><name>isConst</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getFastTypeQuals</name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasConst</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>isVolatile</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getFastTypeQuals</name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasVolatile</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>isRestrict</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getFastTypeQuals</name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasRestrict</name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>QualType</name> <macro><name>getCallResultType</name><argument_list>(<argument>const ASTContext &amp;Context</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getReturnType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getNonLValueExprType</name><argument_list>(<argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>StringRef</name> <macro><name>getNameForCallConv</name><argument_list>(<argument>CallingConv CC</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>FunctionNoProto</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>FunctionProto</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>FunctionNoProtoType</name> <operator>:</operator> <name>public</name> <name>FunctionType</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<macro><name>FunctionNoProtoType</name><argument_list>(<argument>QualType Result</argument>, <argument>QualType Canonical</argument>, <argument>ExtInfo Info</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>FunctionType</name><argument_list>(<argument>FunctionNoProto</argument>, <argument>Result</argument>, <argument>Canonical</argument>,
<argument>Result-&gt;getDependence() &amp;
~(TypeDependence::DependentInstantiation |
TypeDependence::UnexpandedPack)</argument>,
<argument>Info</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>


<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getReturnType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getExtInfo</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>QualType ResultType</argument>,
<argument>ExtInfo Info</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Info</name><operator>.</operator><name>Profile</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>ResultType</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>FunctionNoProto</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>FunctionProtoType</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>FunctionType</name></expr>,
<expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;
<argument><expr><name>FunctionProtoType</name></expr></argument>, <argument><expr><name>QualType</name></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>,
<argument><expr><name>FunctionType</name><operator>::</operator><name>FunctionTypeExtraBitfields</name></expr></argument>, <argument><expr><name>FunctionType</name><operator>::</operator><name>ExceptionType</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><name>FunctionDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>FunctionType</name><operator>::</operator><name>ExtParameterInfo</name></expr></argument>, <argument><expr><name>Qualifiers</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;











































<expr><name>public</name><operator>:</operator>




struct <name>ExceptionSpecInfo</name> <block>{

<expr><name>ExceptionSpecificationType</name> <name>Type</name> <operator>=</operator> <name>EST_None</name></expr>;


<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <name>Exceptions</name></expr>;


<expr><name>Expr</name> <operator>*</operator><name>NoexceptExpr</name> <operator>=</operator> <name>nullptr</name></expr>;



<expr><name>FunctionDecl</name> <operator>*</operator><name>SourceDecl</name> <operator>=</operator> <name>nullptr</name></expr>;



<expr><name>FunctionDecl</name> <operator>*</operator><name>SourceTemplate</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><call><name>ExceptionSpecInfo</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<macro><name>ExceptionSpecInfo</name><argument_list>(<argument>ExceptionSpecificationType EST</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Type</name><argument_list>(<argument>EST</argument>)</argument_list></macro> <expr><block>{}</block></expr>
}</block></expr>;




struct <expr><name>ExtProtoInfo</name> <block>{
<expr><name>FunctionType</name><operator>::</operator><name>ExtInfo</name> <name>ExtInfo</name></expr>;
<expr><name>bool</name> <name>Variadic</name> <operator>:</operator> <literal type="number">1</literal></expr>;
<expr><name>bool</name> <name>HasTrailingReturn</name> <operator>:</operator> <literal type="number">1</literal></expr>;
<expr><name>Qualifiers</name> <name>TypeQuals</name></expr>;
<expr><name>RefQualifierKind</name> <name>RefQualifier</name> <operator>=</operator> <name>RQ_None</name></expr>;
<expr><name>ExceptionSpecInfo</name> <name>ExceptionSpec</name></expr>;
<expr><specifier>const</specifier> <name>ExtParameterInfo</name> <operator>*</operator><name>ExtParameterInfos</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>SourceLocation</name> <name>EllipsisLoc</name></expr>;

<expr><call><name>ExtProtoInfo</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>Variadic</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>, <macro><name>HasTrailingReturn</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>

<macro><name>ExtProtoInfo</name><argument_list>(<argument>CallingConv CC</argument>)</argument_list></macro>
<operator>:</operator> <call><name>ExtInfo</name><argument_list>(<argument><expr><name>CC</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Variadic</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>, <macro><name>HasTrailingReturn</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>

<name>ExtProtoInfo</name> <macro><name>withExceptionSpec</name><argument_list>(<argument>const ExceptionSpecInfo &amp;ESI</argument>)</argument_list></macro> <block>{
<expr><name>ExtProtoInfo</name> <call><name>Result</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;
<expr><name><name>Result</name><operator>.</operator><name>ExceptionSpec</name></name> <operator>=</operator> <name>ESI</name></expr>;
<return>return <expr><name>Result</name></expr>;</return>
}</block>
}</expr>;

<expr><name>private</name><operator>:</operator>
<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;QualType&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNumParams</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;SourceLocation&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isVariadic</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;FunctionTypeExtraBitfields&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasExtraBitfields</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;ExceptionType&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getExceptionSpecSize</name><argument_list>()</argument_list></call><operator>.</operator><name>NumExceptionType</name></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;Expr *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getExceptionSpecSize</name><argument_list>()</argument_list></call><operator>.</operator><name>NumExprPtr</name></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;FunctionDecl *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getExceptionSpecSize</name><argument_list>()</argument_list></call><operator>.</operator><name>NumFunctionDeclPtr</name></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;ExtParameterInfo&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasExtParameterInfos</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name>getNumParams</name><argument_list>()</argument_list></call> <operator>:</operator> <literal type="number">0</literal></expr>;</return>
}</block>



<specifier>static</specifier> <name>bool</name> <macro><name>containsAnyUnexpandedParameterPack</name><argument_list>(<argument>const QualType *ArgArray</argument>,
<argument>unsigned numArgs</argument>)</argument_list></macro> <block>{
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>Idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>Idx</name> <operator>&lt;</operator> <name>numArgs</name></expr>;</condition> <incr><expr><operator>++</operator><name>Idx</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>ArgArray</name><index>[<expr><name>Idx</name></expr>]</index></name><operator>-&gt;</operator><call><name>containsUnexpandedParameterPack</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for></block></expr>

<return>return <expr><name>false</name></expr>;</return>
}</block>

<macro><name>FunctionProtoType</name><argument_list>(<argument>QualType result</argument>, <argument>ArrayRef&lt;QualType&gt; params</argument>,
<argument>QualType canonical</argument>, <argument>const ExtProtoInfo &amp;epi</argument>)</argument_list></macro></expr>;




struct <expr><name>ExceptionSpecSizeHolder</name> <block>{
<expr><name>unsigned</name> <name>NumExceptionType</name></expr>;
<expr><name>unsigned</name> <name>NumExprPtr</name></expr>;
<expr><name>unsigned</name> <name>NumFunctionDeclPtr</name></expr>;
}</block></expr>;



<expr><specifier>static</specifier> <name>ExceptionSpecSizeHolder</name>
<macro><name>getExceptionSpecSize</name><argument_list>(<argument>ExceptionSpecificationType EST</argument>, <argument>unsigned NumExceptions</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><name>EST</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EST_None</name></expr>:</case>
<case>case <expr><name>EST_DynamicNone</name></expr>:</case>
<case>case <expr><name>EST_MSAny</name></expr>:</case>
<case>case <expr><name>EST_BasicNoexcept</name></expr>:</case>
<case>case <expr><name>EST_Unparsed</name></expr>:</case>
<case>case <expr><name>EST_NoThrow</name></expr>:</case>
<return>return <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>;</return>

<case>case <expr><name>EST_Dynamic</name></expr>:</case>
<return>return <expr><block>{<expr><name>NumExceptions</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>;</return>

<case>case <expr><name>EST_DependentNoexcept</name></expr>:</case>
<case>case <expr><name>EST_NoexceptFalse</name></expr>:</case>
<case>case <expr><name>EST_NoexceptTrue</name></expr>:</case>
<return>return <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>;</return>

<case>case <expr><name>EST_Uninstantiated</name></expr>:</case>
<return>return <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>;</return>

<case>case <expr><name>EST_Unevaluated</name></expr>:</case>
<return>return <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>;</return>
<expr_stmt/>}</block_content>
llvm_unreachable("bad exception specification kind"</block></switch>)</block></expr>;
}</block>



<name>ExceptionSpecSizeHolder</name> <macro><name>getExceptionSpecSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getExceptionSpecSize</name><argument_list>(<argument><expr><call><name>getExceptionSpecType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNumExceptions</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>hasExtraBitfields</name><argument_list>(<argument>ExceptionSpecificationType EST</argument>)</argument_list></macro> <block>{


<return>return <expr><name>EST</name> <operator>==</operator> <name>EST_Dynamic</name></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasExtraBitfields</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasExtraBitfields</name><argument_list>(<argument><expr><call><name>getExceptionSpecType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasExtQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>FunctionTypeBits</name><operator>.</operator><name>HasExtQuals</name></name></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>unsigned</name> <macro><name>getNumParams</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>FunctionTypeBits</name><operator>.</operator><name>NumParams</name></name></expr>;</return> }</block>

<name>QualType</name> <macro><name>getParamType</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getNumParams</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"invalid parameter index"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>param_type_begin</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</return>
}</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <macro><name>getParamTypes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>param_type_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>param_type_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>ExtProtoInfo</name> <macro><name>getExtProtoInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>ExtProtoInfo</name> <name>EPI</name></expr>;
<expr><name><name>EPI</name><operator>.</operator><name>ExtInfo</name></name> <operator>=</operator> <call><name>getExtInfo</name><argument_list>()</argument_list></call></expr>;
<expr><name><name>EPI</name><operator>.</operator><name>Variadic</name></name> <operator>=</operator> <call><name>isVariadic</name><argument_list>()</argument_list></call></expr>;
<expr><name><name>EPI</name><operator>.</operator><name>EllipsisLoc</name></name> <operator>=</operator> <call><name>getEllipsisLoc</name><argument_list>()</argument_list></call></expr>;
<expr><name><name>EPI</name><operator>.</operator><name>HasTrailingReturn</name></name> <operator>=</operator> <call><name>hasTrailingReturn</name><argument_list>()</argument_list></call></expr>;
<expr><name><name>EPI</name><operator>.</operator><name>ExceptionSpec</name></name> <operator>=</operator> <call><name>getExceptionSpecInfo</name><argument_list>()</argument_list></call></expr>;
<expr><name><name>EPI</name><operator>.</operator><name>TypeQuals</name></name> <operator>=</operator> <call><name>getMethodQuals</name><argument_list>()</argument_list></call></expr>;
<expr><name><name>EPI</name><operator>.</operator><name>RefQualifier</name></name> <operator>=</operator> <call><name>getRefQualifier</name><argument_list>()</argument_list></call></expr>;
<expr><name><name>EPI</name><operator>.</operator><name>ExtParameterInfos</name></name> <operator>=</operator> <call><name>getExtParameterInfosOrNull</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>EPI</name></expr>;</return>
}</block>


<name>ExceptionSpecificationType</name> <macro><name>getExceptionSpecType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExceptionSpecificationType</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name><name>FunctionTypeBits</name><operator>.</operator><name>ExceptionSpecType</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasExceptionSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getExceptionSpecType</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>EST_None</name></expr>;</return> }</block>


<name>bool</name> <macro><name>hasDynamicExceptionSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isDynamicExceptionSpec</name><argument_list>(<argument><expr><call><name>getExceptionSpecType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasNoexceptExceptionSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isNoexceptExceptionSpec</name><argument_list>(<argument><expr><call><name>getExceptionSpecType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasDependentExceptionSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>hasInstantiationDependentExceptionSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>ExceptionSpecInfo</name> <macro><name>getExceptionSpecInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>ExceptionSpecInfo</name> <name>Result</name></expr>;
<expr><name><name>Result</name><operator>.</operator><name>Type</name></name> <operator>=</operator> <call><name>getExceptionSpecType</name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name><name>Result</name><operator>.</operator><name>Type</name></name> <operator>==</operator> <name>EST_Dynamic</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>Exceptions</name></name> <operator>=</operator> <call><name>exceptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content> else if (isComputedNoexcept(Result.Type</block></if></if_stmt>))</block> <block>{
<expr><name><name>Result</name><operator>.</operator><name>NoexceptExpr</name></name> <operator>=</operator> <call><name>getNoexceptExpr</name><argument_list>()</argument_list></call></expr>;
}</block></expr> <if_stmt><if type="elseif">else if <condition>(<expr><name><name>Result</name><operator>.</operator><name>Type</name></name> <operator>==</operator> <name>EST_Uninstantiated</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>SourceDecl</name></name> <operator>=</operator> <call><name>getExceptionSpecDecl</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>SourceTemplate</name></name> <operator>=</operator> <call><name>getExceptionSpecTemplate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content> else if (Result.Type == EST_Unevaluated</block></if></if_stmt>) <block>{
<expr><name><name>Result</name><operator>.</operator><name>SourceDecl</name></name> <operator>=</operator> <call><name>getExceptionSpecDecl</name><argument_list>()</argument_list></call></expr>;
}</block></block></expr>
<return>return <expr><name>Result</name></expr>;</return>
}</block>


<name>unsigned</name> <macro><name>getNumExceptions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getExceptionSpecType</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EST_Dynamic</name>
<operator>?</operator> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTypeExtraBitfields</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call>
<operator>-&gt;</operator><name>NumExceptionType</name>
<operator>:</operator> <literal type="number">0</literal></expr>;</return>
}</block>


<name>QualType</name> <macro><name>getExceptionType</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getNumExceptions</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid exception number!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>exception_begin</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</return>
}</block>



<name>Expr</name> <operator>*</operator><macro><name>getNoexceptExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isComputedNoexcept</name><argument_list>(<argument><expr><call><name>getExceptionSpecType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>





<name>FunctionDecl</name> <operator>*</operator><macro><name>getExceptionSpecDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getExceptionSpecType</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>EST_Uninstantiated</name> <operator>&amp;&amp;</operator>
<call><name>getExceptionSpecType</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>EST_Unevaluated</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</return>
}</block>





<name>FunctionDecl</name> <operator>*</operator><macro><name>getExceptionSpecTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getExceptionSpecType</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>EST_Uninstantiated</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">1</literal></expr>]</index></expr>;</return>
}</block>



<name>CanThrowResult</name> <macro><name>canThrow</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>bool</name> <macro><name>isNothrow</name><argument_list>(<argument>bool ResultIfDependent = false</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ResultIfDependent</name> <operator>?</operator> <call><name>canThrow</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>CT_Can</name> <operator>:</operator> <call><name>canThrow</name><argument_list>()</argument_list></call> <operator>==</operator> <name>CT_Cannot</name></expr>;</return>
}</block>


<name>bool</name> <macro><name>isVariadic</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>FunctionTypeBits</name><operator>.</operator><name>Variadic</name></name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getEllipsisLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>isVariadic</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>
</then><else>: <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>







<name>bool</name> <macro><name>isTemplateVariadic</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>hasTrailingReturn</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>FunctionTypeBits</name><operator>.</operator><name>HasTrailingReturn</name></name></expr>;</return> }</block>

<name>Qualifiers</name> <macro><name>getMethodQuals</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasExtQualifiers</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Qualifiers</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>getFastTypeQuals</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block>


<name>RefQualifierKind</name> <macro><name>getRefQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>RefQualifierKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>FunctionTypeBits</name><operator>.</operator><name>RefQualifier</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>param_type_iterator</name> <operator>=</operator> <specifier>const</specifier> <name>QualType</name> <operator>*</operator></expr>;
<expr><name>using</name> <name>param_type_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>param_type_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>param_type_range</name> <macro><name>param_types</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>param_type_range</name><argument_list>(<argument><expr><call><name>param_type_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>param_type_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>param_type_iterator</name> <macro><name>param_type_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>param_type_iterator</name> <macro><name>param_type_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>param_type_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumParams</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>exception_iterator</name> <operator>=</operator> <specifier>const</specifier> <name>QualType</name> <operator>*</operator></expr>;

<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <macro><name>exceptions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>exception_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>exception_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>exception_iterator</name> <macro><name>exception_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>exception_iterator</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ExceptionType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>exception_iterator</name> <macro><name>exception_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>exception_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumExceptions</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>hasExtParameterInfos</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>FunctionTypeBits</name><operator>.</operator><name>HasExtParameterInfos</name></name></expr>;</return>
}</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ExtParameterInfo</name></expr></argument>&gt;</argument_list></name> <macro><name>getExtParameterInfos</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasExtParameterInfos</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ExtParameterInfo</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ExtParameterInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getNumParams</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<specifier>const</specifier> <name>ExtParameterInfo</name> <operator>*</operator><macro><name>getExtParameterInfosOrNull</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasExtParameterInfos</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ExtParameterInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ExtParameterInfo</name> <macro><name>getExtParameterInfo</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <call><name>getNumParams</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"parameter index out of range"</literal></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name>hasExtParameterInfos</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ExtParameterInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>ExtParameterInfo</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ParameterABI</name> <macro><name>getParameterABI</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <call><name>getNumParams</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"parameter index out of range"</literal></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name>hasExtParameterInfos</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ExtParameterInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index><operator>.</operator><call><name>getABI</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>ParameterABI</name><operator>::</operator><name>Ordinary</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isParamConsumed</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <call><name>getNumParams</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"parameter index out of range"</literal></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name>hasExtParameterInfos</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ExtParameterInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index><operator>.</operator><call><name>isConsumed</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>printExceptionSpecification</name><argument_list>(<argument>raw_ostream &amp;OS</argument>,
<argument>const PrintingPolicy &amp;Policy</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>FunctionProto</name></expr>;</return>
}</block>

<name>void</name> <call><name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>QualType Result</argument>,
<argument>param_type_iterator ArgTys</argument>, <argument>unsigned NumArgs</argument>,
<argument>const ExtProtoInfo &amp;EPI</argument>, <argument>const ASTContext &amp;Context</argument>,
<argument>bool Canonical</argument>)</argument_list></macro></expr>;
}</block></expr>;






<expr><name>class</name> <name>UnresolvedUsingType</name> <operator>:</operator> <name>public</name> <name>Type</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><name>UnresolvedUsingTypenameDecl</name> <operator>*</operator><name>Decl</name></expr>;

<expr><call><name>UnresolvedUsingType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>UnresolvedUsingTypenameDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Type</name><argument_list>(<argument><expr><name>UnresolvedUsing</name></expr></argument>, <argument><expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>TypeDependence</name><operator>::</operator><name>DependentInstantiation</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Decl</name><argument_list>(<argument>const_cast&lt;UnresolvedUsingTypenameDecl *&gt;(D)</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>UnresolvedUsingTypenameDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Decl</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>UnresolvedUsing</name></expr>;</return>
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Decl</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>,
<argument>UnresolvedUsingTypenameDecl *D</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;

<expr><name>class</name> <name>TypedefType</name> <operator>:</operator> <name>public</name> <name>Type</name> <block>{
<expr><name>TypedefNameDecl</name> <operator>*</operator><name>Decl</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<macro><name>TypedefType</name><argument_list>(<argument>TypeClass tc</argument>, <argument>const TypedefNameDecl *D</argument>, <argument>QualType underlying</argument>,
<argument>QualType can</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<name>TypedefNameDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Decl</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Typedef</name></expr>;</return> }</block>
}</expr>;



<expr><name>class</name> <name>MacroQualifiedType</name> <operator>:</operator> <name>public</name> <name>Type</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><name>QualType</name> <name>UnderlyingTy</name></expr>;
<expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>MacroII</name></expr>;

<macro><name>MacroQualifiedType</name><argument_list>(<argument>QualType UnderlyingTy</argument>, <argument>QualType CanonTy</argument>,
<argument>const IdentifierInfo *MacroII</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>MacroQualified</name></expr></argument>, <argument><expr><name>CanonTy</name></expr></argument>, <argument><expr><call><name><name>UnderlyingTy</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>UnderlyingTy</name><argument_list>(<argument><expr><name>UnderlyingTy</name></expr></argument>)</argument_list></call></expr>, <macro><name>MacroII</name><argument_list>(<argument>MacroII</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>AttributedType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>UnderlyingTy</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Expected a macro qualified type to only wrap attributed types."</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><macro><name>getMacroIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MacroII</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>getUnderlyingType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>UnderlyingTy</name></expr>;</return> }</block>



<name>QualType</name> <macro><name>getModifiedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>MacroQualified</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>TypeOfExprType</name> <operator>:</operator> <name>public</name> <name>Type</name> <block>{
<expr><name>Expr</name> <operator>*</operator><name>TOExpr</name></expr>;

<expr><name>protected</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<macro><name>TypeOfExprType</name><argument_list>(<argument>Expr *E</argument>, <argument>QualType can = QualType()</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<name>Expr</name> <operator>*</operator><macro><name>getUnderlyingExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TOExpr</name></expr>;</return> }</block>


<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>TypeOfExpr</name></expr>;</return> }</block>
}</expr>;







<expr><name>class</name> <name>DependentTypeOfExprType</name>
<operator>:</operator> <name>public</name> <name>TypeOfExprType</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>DependentTypeOfExprType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>TypeOfExprType</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>, <macro><name>Context</name><argument_list>(<argument>Context</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>, <argument><expr><call><name>getUnderlyingExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <call><name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;


<expr><name>class</name> <name>TypeOfType</name> <operator>:</operator> <name>public</name> <name>Type</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><name>QualType</name> <name>TOType</name></expr>;

<macro><name>TypeOfType</name><argument_list>(<argument>QualType T</argument>, <argument>QualType can</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>TypeOf</name></expr></argument>, <argument><expr><name>can</name></expr></argument>, <argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>, <macro><name>TOType</name><argument_list>(<argument>T</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>TypedefType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>can</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid canonical type"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getUnderlyingType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TOType</name></expr>;</return> }</block>


<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getUnderlyingType</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>TypeOf</name></expr>;</return> }</block>
}</expr>;


<expr><name>class</name> <name>DecltypeType</name> <operator>:</operator> <name>public</name> <name>Type</name> <block>{
<expr><name>Expr</name> <operator>*</operator><name>E</name></expr>;
<expr><name>QualType</name> <name>UnderlyingType</name></expr>;

<expr><name>protected</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<macro><name>DecltypeType</name><argument_list>(<argument>Expr *E</argument>, <argument>QualType underlyingType</argument>, <argument>QualType can = QualType()</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<name>Expr</name> <operator>*</operator><macro><name>getUnderlyingExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>E</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>getUnderlyingType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>UnderlyingType</name></expr>;</return> }</block>


<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Decltype</name></expr>;</return> }</block>
}</expr>;







<expr><name>class</name> <name>DependentDecltypeType</name> <operator>:</operator> <name>public</name> <name>DecltypeType</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>DependentDecltypeType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>, <argument><expr><call><name>getUnderlyingExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <call><name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;


<expr><name>class</name> <name>UnaryTransformType</name> <operator>:</operator> <name>public</name> <name>Type</name> <block>{
<expr><name>public</name><operator>:</operator>
enum <name>UTTKind</name> <block>{
<expr><name>EnumUnderlyingType</name></expr>
}</block></expr>;

<expr><name>private</name><operator>:</operator>

<name>QualType</name> <name>BaseType</name></expr>;


<expr><name>QualType</name> <name>UnderlyingType</name></expr>;

<expr><name>UTTKind</name> <name>UKind</name></expr>;

<expr><name>protected</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<macro><name>UnaryTransformType</name><argument_list>(<argument>QualType BaseTy</argument>, <argument>QualType UnderlyingTy</argument>, <argument>UTTKind UKind</argument>,
<argument>QualType CanonicalTy</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>isDependentType</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>UnderlyingType</name></expr>;</return> }</block>

<name>QualType</name> <macro><name>getUnderlyingType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>UnderlyingType</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>getBaseType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BaseType</name></expr>;</return> }</block>

<name>UTTKind</name> <macro><name>getUTTKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>UKind</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>UnaryTransform</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>DependentUnaryTransformType</name> <operator>:</operator> <name>public</name> <name>UnaryTransformType</name></expr>,
<expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>DependentUnaryTransformType</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>QualType BaseType</argument>,
<argument>UTTKind UKind</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getBaseType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getUTTKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>QualType BaseType</argument>,
<argument>UTTKind UKind</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>BaseType</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>UKind</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>
}</block></expr>;

<expr><name>class</name> <name>TagType</name> <operator>:</operator> <name>public</name> <name>Type</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>friend</name> <name>class</name> <name>serialization</name><operator>::</operator><name>AbstractTypeReader</name></expr>;



<expr><name>TagDecl</name> <operator>*</operator><name>decl</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>TagType</name><argument_list>(<argument>TypeClass TC</argument>, <argument>const TagDecl *D</argument>, <argument>QualType can</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<name>TagDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isBeingDefined</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Enum</name> <operator>||</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Record</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>RecordType</name> <operator>:</operator> <name>public</name> <name>TagType</name> <block>{
<expr><name>protected</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><name>explicit</name> <call><name>RecordType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RecordDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>TagType</name><argument_list>(<argument>Record</argument>, <argument>reinterpret_cast&lt;const TagDecl*&gt;(D)</argument>, <argument>QualType()</argument>)</argument_list></macro> <block>{}</block>
<name>explicit</name> <macro><name>RecordType</name><argument_list>(<argument>TypeClass TC</argument>, <argument>RecordDecl *D</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>TagType</name><argument_list>(<argument>TC</argument>, <argument>reinterpret_cast&lt;const TagDecl*&gt;(D)</argument>, <argument>QualType()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<name>RecordDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>RecordDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TagType</name><operator>::</operator><call><name>getDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>hasConstFields</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Record</name></expr>;</return> }</block>
}</expr>;



<expr><name>class</name> <name>EnumType</name> <operator>:</operator> <name>public</name> <name>TagType</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><name>explicit</name> <call><name>EnumType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>EnumDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>TagType</name><argument_list>(<argument>Enum</argument>, <argument>reinterpret_cast&lt;const TagDecl*&gt;(D)</argument>, <argument>QualType()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<name>EnumDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>EnumDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TagType</name><operator>::</operator><call><name>getDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Enum</name></expr>;</return> }</block>
}</expr>;













<expr><name>class</name> <name>AttributedType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>using</name> <name>Kind</name> <operator>=</operator> <name>attr</name><operator>::</operator><name>Kind</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><name>QualType</name> <name>ModifiedType</name></expr>;
<expr><name>QualType</name> <name>EquivalentType</name></expr>;

<macro><name>AttributedType</name><argument_list>(<argument>QualType canon</argument>, <argument>attr::Kind attrKind</argument>, <argument>QualType modified</argument>,
<argument>QualType equivalent</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>Attributed</name></expr></argument>, <argument><expr><name>canon</name></expr></argument>, <argument><expr><call><name><name>equivalent</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ModifiedType</name><argument_list>(<argument><expr><name>modified</name></expr></argument>)</argument_list></call></expr>, <macro><name>EquivalentType</name><argument_list>(<argument>equivalent</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>AttributedTypeBits</name><operator>.</operator><name>AttrKind</name></name> <operator>=</operator> <name>attrKind</name></expr>;
}</block>

<name>public</name><operator>:</operator>
<name>Kind</name> <macro><name>getAttrKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Kind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>AttributedTypeBits</name><operator>.</operator><name>AttrKind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>QualType</name> <macro><name>getModifiedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ModifiedType</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>getEquivalentType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>EquivalentType</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getEquivalentType</name><argument_list>()</argument_list></call></expr>;</return> }</block>
















<name>bool</name> <macro><name>isQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>isMSTypeSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>isCallingConv</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>NullabilityKind</name></expr></argument>&gt;</argument_list></name> <macro><name>getImmediateNullability</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><specifier>static</specifier> <name>Kind</name> <macro><name>getNullabilityAttrKind</name><argument_list>(<argument>NullabilityKind kind</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><name>kind</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NullabilityKind</name><operator>::</operator><name>NonNull</name></expr>:</case>
<return>return <expr><name>attr</name><operator>::</operator><name>TypeNonNull</name></expr>;</return>

<case>case <expr><name>NullabilityKind</name><operator>::</operator><name>Nullable</name></expr>:</case>
<return>return <expr><name>attr</name><operator>::</operator><name>TypeNullable</name></expr>;</return>

<case>case <expr><name>NullabilityKind</name><operator>::</operator><name>NullableResult</name></expr>:</case>
<return>return <expr><name>attr</name><operator>::</operator><name>TypeNullableResult</name></expr>;</return>

<case>case <expr><name>NullabilityKind</name><operator>::</operator><name>Unspecified</name></expr>:</case>
<return>return <expr><name>attr</name><operator>::</operator><name>TypeNullUnspecified</name></expr>;</return>
<expr_stmt/>}</block_content>
llvm_unreachable("Unknown nullability kind."</block></switch>)</block></expr>;
}</block>










<specifier>static</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>NullabilityKind</name></expr></argument>&gt;</argument_list></name> <call><name>stripOuterNullability</name><argument_list>(<argument><expr><name>QualType</name> <operator>&amp;</operator><name>T</name></expr></argument>)</argument_list></call></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getAttrKind</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ModifiedType</name></expr></argument>, <argument><expr><name>EquivalentType</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>Kind attrKind</argument>,
<argument>QualType modified</argument>, <argument>QualType equivalent</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>attrKind</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>modified</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>equivalent</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Attributed</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>TemplateTypeParmType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;


struct <expr><name>CanonicalTTPTInfo</name> <block>{
<expr><name>unsigned</name> <name>Depth</name> <operator>:</operator> <literal type="number">15</literal></expr>;
<expr><name>unsigned</name> <name>ParameterPack</name> <operator>:</operator> <literal type="number">1</literal></expr>;
<expr><name>unsigned</name> <name>Index</name> <operator>:</operator> <literal type="number">16</literal></expr>;
}</block></expr>;

<expr>union <block>{

<expr><name>CanonicalTTPTInfo</name> <name>CanTTPTInfo</name></expr>;


<expr><name>TemplateTypeParmDecl</name> <operator>*</operator><name>TTPDecl</name></expr>;
}</block></expr>;


<macro><name>TemplateTypeParmType</name><argument_list>(<argument>TemplateTypeParmDecl *TTPDecl</argument>, <argument>QualType Canon</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>TemplateTypeParm</name></expr></argument>, <argument><expr><name>Canon</name></expr></argument>,
<argument><expr><name>TypeDependence</name><operator>::</operator><name>DependentInstantiation</name> <operator>|</operator>
<operator>(</operator><call><name><name>Canon</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>TypeDependence</name><operator>::</operator><name>UnexpandedPack</name><operator>)</operator></expr></argument>)</argument_list></call></expr>,
<macro><name>TTPDecl</name><argument_list>(<argument>TTPDecl</argument>)</argument_list></macro> <expr><block>{}</block>


<macro><name>TemplateTypeParmType</name><argument_list>(<argument>unsigned D</argument>, <argument>unsigned I</argument>, <argument>bool PP</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Type</name><argument_list>(<argument>TemplateTypeParm</argument>, <argument>QualType(this, <literal type="number">0</literal>)</argument>,
<argument>TypeDependence::DependentInstantiation |
(PP ? TypeDependence::UnexpandedPack : TypeDependence::None)</argument>)</argument_list></macro> <block>{
<expr><name><name>CanTTPTInfo</name><operator>.</operator><name>Depth</name></name> <operator>=</operator> <name>D</name></expr>;
<expr><name><name>CanTTPTInfo</name><operator>.</operator><name>Index</name></name> <operator>=</operator> <name>I</name></expr>;
<expr><name><name>CanTTPTInfo</name><operator>.</operator><name>ParameterPack</name></name> <operator>=</operator> <name>PP</name></expr>;
}</block>

<specifier>const</specifier> <name>CanonicalTTPTInfo</name><operator>&amp;</operator> <macro><name>getCanTTPTInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>QualType</name> <name>Can</name> <operator>=</operator> <call><name>getCanonicalTypeInternal</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name><name>Can</name><operator>-&gt;</operator><name>castAs</name></name><operator>&lt;</operator><name>TemplateTypeParmType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>-&gt;</operator><name>CanTTPTInfo</name></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>unsigned</name> <macro><name>getDepth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getCanTTPTInfo</name><argument_list>()</argument_list></call><operator>.</operator><name>Depth</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>getIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getCanTTPTInfo</name><argument_list>()</argument_list></call><operator>.</operator><name>Index</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isParameterPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getCanTTPTInfo</name><argument_list>()</argument_list></call><operator>.</operator><name>ParameterPack</name></expr>;</return> }</block>

<name>TemplateTypeParmDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isCanonicalUnqualified</name><argument_list>()</argument_list></call> <operator>?</operator> <name>nullptr</name> <operator>:</operator> <name>TTPDecl</name></expr>;</return>
}</block>

<name>IdentifierInfo</name> <operator>*</operator><macro><name>getIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getDepth</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getIndex</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>isParameterPack</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>unsigned Depth</argument>,
<argument>unsigned Index</argument>, <argument>bool ParameterPack</argument>,
<argument>TemplateTypeParmDecl *TTPDecl</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>Depth</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><name>ParameterPack</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>TTPDecl</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>TemplateTypeParm</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>SubstTemplateTypeParmType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;


<expr><specifier>const</specifier> <name>TemplateTypeParmType</name> <operator>*</operator><name>Replaced</name></expr>;

<macro><name>SubstTemplateTypeParmType</name><argument_list>(<argument>const TemplateTypeParmType *Param</argument>, <argument>QualType Canon</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>SubstTemplateTypeParm</name></expr></argument>, <argument><expr><name>Canon</name></expr></argument>, <argument><expr><call><name><name>Canon</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>Replaced</name><argument_list>(<argument>Param</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>

<specifier>const</specifier> <name>TemplateTypeParmType</name> <operator>*</operator><macro><name>getReplacedParameter</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Replaced</name></expr>;</return>
}</block>



<name>QualType</name> <macro><name>getReplacementType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCanonicalTypeInternal</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getReplacementType</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getReplacedParameter</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getReplacementType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>,
<argument>const TemplateTypeParmType *Replaced</argument>,
<argument>QualType Replacement</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>Replaced</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>Replacement</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SubstTemplateTypeParm</name></expr>;</return>
}</block>
}</expr>;













<expr><name>class</name> <name>SubstTemplateTypeParmPackType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;


<expr><specifier>const</specifier> <name>TemplateTypeParmType</name> <operator>*</operator><name>Replaced</name></expr>;



<expr><specifier>const</specifier> <name>TemplateArgument</name> <operator>*</operator><name>Arguments</name></expr>;

<macro><name>SubstTemplateTypeParmPackType</name><argument_list>(<argument>const TemplateTypeParmType *Param</argument>,
<argument>QualType Canon</argument>,
<argument>const TemplateArgument &amp;ArgPack</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<name>IdentifierInfo</name> <operator>*</operator><macro><name>getIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Replaced</name><operator>-&gt;</operator><name>getIdentifier</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<specifier>const</specifier> <name>TemplateTypeParmType</name> <operator>*</operator><macro><name>getReplacedParameter</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Replaced</name></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>SubstTemplateTypeParmPackTypeBits</name><operator>.</operator><name>NumArgs</name></name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>TemplateArgument</name> <macro><name>getArgumentPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>void</name> <call><name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>void</name> <call><name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TemplateTypeParmType</name> <operator>*</operator><name>Replaced</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TemplateArgument</name> <operator>&amp;</operator><name>ArgPack</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SubstTemplateTypeParmPack</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>DeducedType</name> <operator>:</operator> <name>public</name> <name>Type</name> <block>{
<expr><name>protected</name><operator>:</operator>
<macro><name>DeducedType</name><argument_list>(<argument>TypeClass TC</argument>, <argument>QualType DeducedAsType</argument>,
<argument>TypeDependence ExtraDependence</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Type</name><argument_list>(<argument>TC</argument>,

<argument>DeducedAsType.isNull() ? QualType(this, <literal type="number">0</literal>)
: DeducedAsType.getCanonicalType()</argument>,
<argument>ExtraDependence | (DeducedAsType.isNull()
? TypeDependence::None
: DeducedAsType-&gt;getDependence() &amp;
~TypeDependence::VariablyModified)</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>isCanonicalUnqualified</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getCanonicalTypeInternal</name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>QualType</name> <macro><name>getDeducedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><operator>!</operator><call><name>isCanonicalUnqualified</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getCanonicalTypeInternal</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>
<name>bool</name> <macro><name>isDeduced</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name>isCanonicalUnqualified</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isDependentType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Auto</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DeducedTemplateSpecialization</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <macro><name>alignas</name><argument_list>(<argument><literal type="number">8</literal></argument>)</argument_list></macro> <name>AutoType</name> <operator>:</operator> <name>public</name> <name>DeducedType</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><name>ConceptDecl</name> <operator>*</operator><name>TypeConstraintConcept</name></expr>;

<macro><name>AutoType</name><argument_list>(<argument>QualType DeducedAsType</argument>, <argument>AutoTypeKeyword Keyword</argument>,
<argument>TypeDependence ExtraDependence</argument>, <argument>ConceptDecl *CD</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; TypeConstraintArgs</argument>)</argument_list></macro>;

<expr><specifier>const</specifier> <name>TemplateArgument</name> <operator>*</operator><macro><name>getArgBuffer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>TemplateArgument</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>TemplateArgument</name> <operator>*</operator><macro><name>getArgBuffer</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>

<specifier>const</specifier> <name>TemplateArgument</name> <operator>*</operator><macro><name>getArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getArgBuffer</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>AutoTypeBits</name><operator>.</operator><name>NumArgs</name></name></expr>;</return>
}</block>

<specifier>const</specifier> <name>TemplateArgument</name> <operator>&amp;</operator><macro><name>getArg</name><argument_list>(<argument>unsigned Idx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <macro><name>getTypeConstraintArguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><call><name>getArgs</name><argument_list>()</argument_list></call></expr>, <macro><name>getNumArgs</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block>

<name>ConceptDecl</name> <operator>*</operator><macro><name>getTypeConstraintConcept</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TypeConstraintConcept</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isConstrained</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TypeConstraintConcept</name> <operator>!=</operator> <name>nullptr</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isDecltypeAuto</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getKeyword</name><argument_list>()</argument_list></call> <operator>==</operator> <name>AutoTypeKeyword</name><operator>::</operator><name>DecltypeAuto</name></expr>;</return>
}</block>

<name>AutoTypeKeyword</name> <macro><name>getKeyword</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>AutoTypeKeyword</name><operator>)</operator><name><name>AutoTypeBits</name><operator>.</operator><name>Keyword</name></name></expr>;</return>
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>const ASTContext &amp;Context</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>, <argument><expr><call><name>getDeducedType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getKeyword</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>isDependentType</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getTypeConstraintConcept</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getTypeConstraintArguments</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>const ASTContext &amp;Context</argument>,
<argument>QualType Deduced</argument>, <argument>AutoTypeKeyword Keyword</argument>,
<argument>bool IsDependent</argument>, <argument>ConceptDecl *CD</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; Arguments</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Auto</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>DeducedTemplateSpecializationType</name> <operator>:</operator> <name>public</name> <name>DeducedType</name></expr>,
<expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;


<expr><name>TemplateName</name> <name>Template</name></expr>;

<macro><name>DeducedTemplateSpecializationType</name><argument_list>(<argument>TemplateName Template</argument>,
<argument>QualType DeducedAsType</argument>,
<argument>bool IsDeducedAsDependent</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>DeducedType</name><argument_list>(<argument><expr><name>DeducedTemplateSpecialization</name></expr></argument>, <argument><expr><name>DeducedAsType</name></expr></argument>,
<argument><expr><call><name>toTypeDependence</name><argument_list>(<argument><expr><call><name><name>Template</name><operator>.</operator><name>getDependence</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>|</operator>
<operator>(</operator><ternary><condition><expr><name>IsDeducedAsDependent</name></expr>
?</condition><then> <expr><name>TypeDependence</name><operator>::</operator><name>DependentInstantiation</name></expr>
</then><else>: <expr><name>TypeDependence</name><operator>::</operator><name>None</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>,
<macro><name>Template</name><argument_list>(<argument>Template</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>

<name>TemplateName</name> <macro><name>getTemplateName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Template</name></expr>;</return>}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getTemplateName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getDeducedType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>isDependentType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>TemplateName Template</argument>,
<argument>QualType Deduced</argument>, <argument>bool IsDependent</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Template</name><operator>.</operator><name>Profile</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>Deduced</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><name>IsDependent</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DeducedTemplateSpecialization</name></expr>;</return>
}</block>
}</expr>;





















<expr><name>class</name> <macro><name>alignas</name><argument_list>(<argument><literal type="number">8</literal></argument>)</argument_list></macro> <name>TemplateSpecializationType</name>
<operator>:</operator> <name>public</name> <name>Type</name></expr>,
<expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;








<expr><name>TemplateName</name> <name>Template</name></expr>;

<macro><name>TemplateSpecializationType</name><argument_list>(<argument>TemplateName T</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; Args</argument>,
<argument>QualType Canon</argument>,
<argument>QualType Aliased</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>











<specifier>static</specifier> <name>bool</name>
<call><name>anyDependentTemplateArguments</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>Converted</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>bool</name>
<call><name>anyDependentTemplateArguments</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <operator>&amp;</operator></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>Converted</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>bool</name> <call><name>anyInstantiationDependentTemplateArguments</name><argument_list>(
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>)</argument_list></call></expr>;



<expr><name>bool</name> <macro><name>isCurrentInstantiation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>InjectedClassNameType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getCanonicalTypeInternal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
















<name>bool</name> <macro><name>isTypeAlias</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>TemplateSpecializationTypeBits</name><operator>.</operator><name>TypeAlias</name></name></expr>;</return> }</block>



<name>QualType</name> <macro><name>getAliasedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isTypeAlias</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"not a type alias template specialization"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>QualType</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>iterator</name> <operator>=</operator> <specifier>const</specifier> <name>TemplateArgument</name> <operator>*</operator></expr>;

<expr><name>iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getArgs</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>TemplateName</name> <macro><name>getTemplateName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Template</name></expr>;</return> }</block>


<specifier>const</specifier> <name>TemplateArgument</name> <operator>*</operator><macro><name>getArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>TemplateArgument</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>TemplateSpecializationTypeBits</name><operator>.</operator><name>NumArgs</name></name></expr>;</return>
}</block>



<specifier>const</specifier> <name>TemplateArgument</name> <operator>&amp;</operator><macro><name>getArg</name><argument_list>(<argument>unsigned Idx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <macro><name>template_arguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><call><name>getArgs</name><argument_list>()</argument_list></call></expr>, <macro><name>getNumArgs</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name>isDependentType</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isCurrentInstantiation</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isTypeAlias</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>isTypeAlias</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getAliasedType</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>getCanonicalTypeInternal</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>const ASTContext &amp;Ctx</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Template</name></expr></argument>, <argument><expr><call><name>template_arguments</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name>isTypeAlias</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>getAliasedType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>TemplateName T</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; Args</argument>,
<argument>const ASTContext &amp;Context</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>TemplateSpecialization</name></expr>;</return>
}</block>
}</expr>;



<expr><name>void</name> <call><name>printTemplateArgumentList</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>Policy</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TemplateParameterList</name> <operator>*</operator><name>TPL</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;

<expr><name>void</name> <call><name>printTemplateArgumentList</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>Policy</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TemplateParameterList</name> <operator>*</operator><name>TPL</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;

<expr><name>void</name> <call><name>printTemplateArgumentList</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <operator>&amp;</operator><name>Args</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>Policy</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TemplateParameterList</name> <operator>*</operator><name>TPL</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;


















<expr><name>class</name> <name>InjectedClassNameType</name> <operator>:</operator> <name>public</name> <name>Type</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTNodeImporter</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>friend</name> <name>class</name> <name>serialization</name><operator>::</operator><name>AbstractTypeReader</name></expr>;

<expr><name>CXXRecordDecl</name> <operator>*</operator><name>Decl</name></expr>;










<expr><name>QualType</name> <name>InjectedType</name></expr>;

<macro><name>InjectedClassNameType</name><argument_list>(<argument>CXXRecordDecl *D</argument>, <argument>QualType TST</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>InjectedClassName</name></expr></argument>, <argument><expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>TypeDependence</name><operator>::</operator><name>DependentInstantiation</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Decl</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>, <macro><name>InjectedType</name><argument_list>(<argument>TST</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>TemplateSpecializationType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TST</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>TST</name><operator>.</operator><name>hasQualifiers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>TST</name><operator>-&gt;</operator><name>isDependentType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getInjectedSpecializationType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>InjectedType</name></expr>;</return> }</block>

<specifier>const</specifier> <name>TemplateSpecializationType</name> <operator>*</operator><macro><name>getInjectedTST</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>TemplateSpecializationType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>InjectedType</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>TemplateName</name> <macro><name>getTemplateName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getInjectedTST</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTemplateName</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>CXXRecordDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>InjectedClassName</name></expr>;</return>
}</block>
}</expr>;


enum <expr><name>TagTypeKind</name> <block>{

<expr><name>TTK_Struct</name></expr>,


<expr><name>TTK_Interface</name></expr>,


<expr><name>TTK_Union</name></expr>,


<expr><name>TTK_Class</name></expr>,


<expr><name>TTK_Enum</name></expr>
}</block></expr>;



enum <expr><name>ElaboratedTypeKeyword</name> <block>{

<expr><name>ETK_Struct</name></expr>,


<expr><name>ETK_Interface</name></expr>,


<expr><name>ETK_Union</name></expr>,


<expr><name>ETK_Class</name></expr>,


<expr><name>ETK_Enum</name></expr>,



<expr><name>ETK_Typename</name></expr>,


<expr><name>ETK_None</name></expr>
}</block></expr>;





<expr><name>class</name> <name>TypeWithKeyword</name> <operator>:</operator> <name>public</name> <name>Type</name> <block>{
<expr><name>protected</name><operator>:</operator>
<macro><name>TypeWithKeyword</name><argument_list>(<argument>ElaboratedTypeKeyword Keyword</argument>, <argument>TypeClass tc</argument>,
<argument>QualType Canonical</argument>, <argument>TypeDependence Dependence</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Type</name><argument_list>(<argument>tc</argument>, <argument>Canonical</argument>, <argument>Dependence</argument>)</argument_list></macro> <block>{
<expr><name><name>TypeWithKeywordBits</name><operator>.</operator><name>Keyword</name></name> <operator>=</operator> <name>Keyword</name></expr>;
}</block>

<name>public</name><operator>:</operator>
<name>ElaboratedTypeKeyword</name> <macro><name>getKeyword</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ElaboratedTypeKeyword</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>TypeWithKeywordBits</name><operator>.</operator><name>Keyword</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>ElaboratedTypeKeyword</name> <macro><name>getKeywordForTypeSpec</name><argument_list>(<argument>unsigned TypeSpec</argument>)</argument_list></macro></expr>;



<expr><specifier>static</specifier> <name>TagTypeKind</name> <macro><name>getTagTypeKindForTypeSpec</name><argument_list>(<argument>unsigned TypeSpec</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>ElaboratedTypeKeyword</name> <macro><name>getKeywordForTagTypeKind</name><argument_list>(<argument>TagTypeKind Tag</argument>)</argument_list></macro></expr>;




<expr><specifier>static</specifier> <name>TagTypeKind</name> <macro><name>getTagTypeKindForKeyword</name><argument_list>(<argument>ElaboratedTypeKeyword Keyword</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>KeywordIsTagTypeKind</name><argument_list>(<argument>ElaboratedTypeKeyword Keyword</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>StringRef</name> <macro><name>getKeywordName</name><argument_list>(<argument>ElaboratedTypeKeyword Keyword</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>StringRef</name> <macro><name>getTagTypeKindName</name><argument_list>(<argument>TagTypeKind Kind</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getKeywordName</name><argument_list>(<argument><expr><call><name>getKeywordForTagTypeKind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>class</name> <name>CannotCastToThisType</name> <block>{}</block></expr>;
<expr><specifier>static</specifier> <name>CannotCastToThisType</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;
}</block></expr>;









<expr><name>class</name> <name>ElaboratedType</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>TypeWithKeyword</name></expr>,
<expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ElaboratedType</name></expr></argument>, <argument><expr><name>TagDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>NestedNameSpecifier</name> <operator>*</operator><name>NNS</name></expr>;


<expr><name>QualType</name> <name>NamedType</name></expr>;





<macro><name>ElaboratedType</name><argument_list>(<argument>ElaboratedTypeKeyword Keyword</argument>, <argument>NestedNameSpecifier *NNS</argument>,
<argument>QualType NamedType</argument>, <argument>QualType CanonType</argument>, <argument>TagDecl *OwnedTagDecl</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>TypeWithKeyword</name><argument_list>(<argument><expr><name>Keyword</name></expr></argument>, <argument><expr><name>Elaborated</name></expr></argument>, <argument><expr><name>CanonType</name></expr></argument>,




<argument><expr><call><name><name>NamedType</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call> <operator>|</operator>
<operator>(</operator><ternary><condition><expr><name>NNS</name></expr> ?</condition><then> <expr><call><name>toSyntacticDependence</name><argument_list>(
<argument><expr><call><name>toTypeDependence</name><argument_list>(<argument><expr><call><name><name>NNS</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><name>TypeDependence</name><operator>::</operator><name>None</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>,
<expr><call><name>NNS</name><argument_list>(<argument><expr><name>NNS</name></expr></argument>)</argument_list></call></expr>, <macro><name>NamedType</name><argument_list>(<argument>NamedType</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>ElaboratedTypeBits</name><operator>.</operator><name>HasOwnedTagDecl</name></name> <operator>=</operator> <name>false</name></expr>;
<if_stmt><if>if <condition>(<expr><name>OwnedTagDecl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ElaboratedTypeBits</name><operator>.</operator><name>HasOwnedTagDecl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TagDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>=</operator> <name>OwnedTagDecl</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
assert(!(Keyword == ETK_None &amp;&amp; NNS == nullptr</block></if></if_stmt>) <operator>&amp;&amp;</operator>
<literal type="string">"ElaboratedType cannot have elaborated type keyword "</literal>
<literal type="string">"and name qualifier both null."</literal>)</block></expr>;
}</block>

<name>public</name><operator>:</operator>

<name>NestedNameSpecifier</name> <operator>*</operator><macro><name>getQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NNS</name></expr>;</return> }</block>


<name>QualType</name> <macro><name>getNamedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NamedType</name></expr>;</return> }</block>


<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getNamedType</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>



<name>TagDecl</name> <operator>*</operator><macro><name>getOwnedTagDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ElaboratedTypeBits</name><operator>.</operator><name>HasOwnedTagDecl</name></name> <operator>?</operator> <operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TagDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call>
<operator>:</operator> <name>nullptr</name></expr>;</return>
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getKeyword</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NNS</name></expr></argument>, <argument><expr><name>NamedType</name></expr></argument>, <argument><expr><call><name>getOwnedTagDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>ElaboratedTypeKeyword Keyword</argument>,
<argument>NestedNameSpecifier *NNS</argument>, <argument>QualType NamedType</argument>,
<argument>TagDecl *OwnedTagDecl</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>Keyword</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>NNS</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>NamedType</name><operator>.</operator><name>Profile</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>OwnedTagDecl</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Elaborated</name></expr>;</return> }</block>
}</expr>;













<expr><name>class</name> <name>DependentNameType</name> <operator>:</operator> <name>public</name> <name>TypeWithKeyword</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;


<expr><name>NestedNameSpecifier</name> <operator>*</operator><name>NNS</name></expr>;


<expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>Name</name></expr>;

<macro><name>DependentNameType</name><argument_list>(<argument>ElaboratedTypeKeyword Keyword</argument>, <argument>NestedNameSpecifier *NNS</argument>,
<argument>const IdentifierInfo *Name</argument>, <argument>QualType CanonType</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>TypeWithKeyword</name><argument_list>(<argument><expr><name>Keyword</name></expr></argument>, <argument><expr><name>DependentName</name></expr></argument>, <argument><expr><name>CanonType</name></expr></argument>,
<argument><expr><name>TypeDependence</name><operator>::</operator><name>DependentInstantiation</name> <operator>|</operator>
<call><name>toTypeDependence</name><argument_list>(<argument><expr><call><name><name>NNS</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>NNS</name><argument_list>(<argument><expr><name>NNS</name></expr></argument>)</argument_list></call></expr>, <macro><name>Name</name><argument_list>(<argument>Name</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>

<name>NestedNameSpecifier</name> <operator>*</operator><macro><name>getQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NNS</name></expr>;</return> }</block>






<specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><macro><name>getIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Name</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getKeyword</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NNS</name></expr></argument>, <argument><expr><name>Name</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>ElaboratedTypeKeyword Keyword</argument>,
<argument>NestedNameSpecifier *NNS</argument>, <argument>const IdentifierInfo *Name</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>Keyword</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>NNS</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>Name</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DependentName</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <macro><name>alignas</name><argument_list>(<argument><literal type="number">8</literal></argument>)</argument_list></macro> <name>DependentTemplateSpecializationType</name>
<operator>:</operator> <name>public</name> <name>TypeWithKeyword</name></expr>,
<expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;


<expr><name>NestedNameSpecifier</name> <operator>*</operator><name>NNS</name></expr>;


<expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>Name</name></expr>;

<macro><name>DependentTemplateSpecializationType</name><argument_list>(<argument>ElaboratedTypeKeyword Keyword</argument>,
<argument>NestedNameSpecifier *NNS</argument>,
<argument>const IdentifierInfo *Name</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; Args</argument>,
<argument>QualType Canon</argument>)</argument_list></macro>;

<expr><specifier>const</specifier> <name>TemplateArgument</name> <operator>*</operator><macro><name>getArgBuffer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>TemplateArgument</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>TemplateArgument</name> <operator>*</operator><macro><name>getArgBuffer</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>NestedNameSpecifier</name> <operator>*</operator><macro><name>getQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NNS</name></expr>;</return> }</block>
<specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><macro><name>getIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Name</name></expr>;</return> }</block>


<specifier>const</specifier> <name>TemplateArgument</name> <operator>*</operator><macro><name>getArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getArgBuffer</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>DependentTemplateSpecializationTypeBits</name><operator>.</operator><name>NumArgs</name></name></expr>;</return>
}</block>

<specifier>const</specifier> <name>TemplateArgument</name> <operator>&amp;</operator><macro><name>getArg</name><argument_list>(<argument>unsigned Idx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <macro><name>template_arguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><call><name>getArgs</name><argument_list>()</argument_list></call></expr>, <macro><name>getNumArgs</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block>

<name>using</name> <name>iterator</name> <operator>=</operator> <specifier>const</specifier> <name>TemplateArgument</name> <operator>*</operator></expr>;

<expr><name>iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getArgs</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>const ASTContext &amp;Context</argument>)</argument_list></macro> <block>{
<macro><name>Profile</name><argument_list>(<argument>ID</argument>, <argument>Context</argument>, <argument>getKeyword()</argument>, <argument>NNS</argument>, <argument>Name</argument>, <argument>{getArgs()</argument>, <argument>getNumArgs()}</argument>)</argument_list></macro>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>,
<argument>const ASTContext &amp;Context</argument>,
<argument>ElaboratedTypeKeyword Keyword</argument>,
<argument>NestedNameSpecifier *Qualifier</argument>,
<argument>const IdentifierInfo *Name</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; Args</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DependentTemplateSpecialization</name></expr>;</return>
}</block>
}</expr>;























<expr><name>class</name> <name>PackExpansionType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;


<expr><name>QualType</name> <name>Pattern</name></expr>;

<macro><name>PackExpansionType</name><argument_list>(<argument>QualType Pattern</argument>, <argument>QualType Canon</argument>,
<argument>Optional&lt;unsigned&gt; NumExpansions</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>PackExpansion</name></expr></argument>, <argument><expr><name>Canon</name></expr></argument>,
<argument><expr><operator>(</operator><call><name><name>Pattern</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call> <operator>|</operator> <name>TypeDependence</name><operator>::</operator><name>Dependent</name> <operator>|</operator>
<name>TypeDependence</name><operator>::</operator><name>Instantiation</name><operator>)</operator> <operator>&amp;</operator>
<operator>~</operator><name>TypeDependence</name><operator>::</operator><name>UnexpandedPack</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Pattern</name><argument_list>(<argument>Pattern</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>PackExpansionTypeBits</name><operator>.</operator><name>NumExpansions</name></name> <operator>=</operator>
<ternary><condition><expr><name>NumExpansions</name></expr> ?</condition><then> <expr><operator>*</operator><name>NumExpansions</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;
}</block>

<name>public</name><operator>:</operator>



<name>QualType</name> <macro><name>getPattern</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Pattern</name></expr>;</return> }</block>



<name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <macro><name>getNumExpansions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name><name>PackExpansionTypeBits</name><operator>.</operator><name>NumExpansions</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>PackExpansionTypeBits</name><operator>.</operator><name>NumExpansions</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>None</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getPattern</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNumExpansions</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>QualType Pattern</argument>,
<argument>Optional&lt;unsigned&gt; NumExpansions</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>Pattern</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><call><name><name>NumExpansions</name><operator>.</operator><name>hasValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>NumExpansions</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><operator>*</operator><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PackExpansion</name></expr>;</return>
}</block>
}</expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>ObjCProtocolQualifiers</name> <block>{
<expr><name>protected</name><operator>:</operator>
<call><name>ObjCProtocolQualifiers</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>ObjCProtocolDecl</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><macro><name>getProtocolStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolQualifiers</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getProtocolStorage</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ObjCProtocolDecl</name> <operator>*</operator><operator>*</operator><macro><name>getProtocolStorage</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getProtocolStorageImpl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setNumProtocols</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro> <block>{
<expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>setNumProtocolsImpl</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>initialize</name><argument_list>(<argument>ArrayRef&lt;ObjCProtocolDecl *&gt; protocols</argument>)</argument_list></macro> <block>{
<expr><call><name>setNumProtocols</name><argument_list>(<argument><expr><call><name><name>protocols</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getNumProtocols</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>protocols</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"bitfield overflow in protocol count"</literal></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>protocols</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>getProtocolStorage</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>protocols</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>protocols</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ObjCProtocolDecl</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<name>public</name><operator>:</operator>
<name>using</name> <name>qual_iterator</name> <operator>=</operator> <name>ObjCProtocolDecl</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator></expr>;
<expr><name>using</name> <name>qual_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>qual_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>qual_range</name> <macro><name>quals</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>qual_range</name><argument_list>(<argument><expr><call><name>qual_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>qual_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>qual_iterator</name> <macro><name>qual_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getProtocolStorage</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>qual_iterator</name> <macro><name>qual_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>qual_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumProtocols</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>qual_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getNumProtocols</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return> }</block>



<name>unsigned</name> <macro><name>getNumProtocols</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getNumProtocolsImpl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>ObjCProtocolDecl</name> <operator>*</operator><macro><name>getProtocol</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <call><name>getNumProtocols</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Out-of-range protocol access"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>qual_begin</name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index></expr>;</return>
}</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getProtocols</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>qual_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNumProtocols</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>ObjCTypeParamType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>,
<expr><name>public</name> <name><name>ObjCProtocolQualifiers</name><argument_list type="generic">&lt;<argument><expr><name>ObjCTypeParamType</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;
<expr><name>friend</name> <name>class</name> <name><name>ObjCProtocolQualifiers</name><argument_list type="generic">&lt;<argument><expr><name>ObjCTypeParamType</name></expr></argument>&gt;</argument_list></name></expr>;


<expr><name>unsigned</name> <name>NumProtocols</name> <operator>:</operator> <literal type="number">6</literal></expr>;

<expr><name>ObjCTypeParamDecl</name> <operator>*</operator><name>OTPDecl</name></expr>;




<expr><name>ObjCProtocolDecl</name> <operator>*</operator><operator>*</operator><call><name>getProtocolStorageImpl</name><argument_list>()</argument_list></call></expr>;



<expr><name>unsigned</name> <macro><name>getNumProtocolsImpl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumProtocols</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setNumProtocolsImpl</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro> <block>{
<expr><name>NumProtocols</name> <operator>=</operator> <name>N</name></expr>;
}</block>

<macro><name>ObjCTypeParamType</name><argument_list>(<argument>const ObjCTypeParamDecl *D</argument>,
<argument>QualType can</argument>,
<argument>ArrayRef&lt;ObjCProtocolDecl *&gt; protocols</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getCanonicalTypeInternal</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCTypeParam</name></expr>;</return>
}</block>

<name>void</name> <call><name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>,
<argument>const ObjCTypeParamDecl *OTPDecl</argument>,
<argument>QualType CanonicalType</argument>,
<argument>ArrayRef&lt;ObjCProtocolDecl *&gt; protocols</argument>)</argument_list></macro></expr>;

<expr><name>ObjCTypeParamDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OTPDecl</name></expr>;</return> }</block>
}</expr>;





























<expr><name>class</name> <name>ObjCObjectType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>,
<expr><name>public</name> <name><name>ObjCProtocolQualifiers</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name><name>ObjCProtocolQualifiers</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectType</name></expr></argument>&gt;</argument_list></name></expr>;














<expr><name>QualType</name> <name>BaseType</name></expr>;


<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ObjCObjectType</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name>
<name>CachedSuperClassType</name></expr>;

<expr><name>QualType</name> <operator>*</operator><call><name>getTypeArgStorage</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>QualType</name> <operator>*</operator><macro><name>getTypeArgStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectType</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getTypeArgStorage</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ObjCProtocolDecl</name> <operator>*</operator><operator>*</operator><call><name>getProtocolStorageImpl</name><argument_list>()</argument_list></call></expr>;


<expr><name>unsigned</name> <macro><name>getNumProtocolsImpl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ObjCObjectTypeBits</name><operator>.</operator><name>NumProtocols</name></name></expr>;</return>
}</block>
<name>void</name> <macro><name>setNumProtocolsImpl</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro> <block>{
<expr><name><name>ObjCObjectTypeBits</name><operator>.</operator><name>NumProtocols</name></name> <operator>=</operator> <name>N</name></expr>;
}</block>

<name>protected</name><operator>:</operator>
enum <name>Nonce_ObjCInterface</name> <block>{ <expr><name>Nonce_ObjCInterface</name></expr> }</block></expr>;

<macro><name>ObjCObjectType</name><argument_list>(<argument>QualType Canonical</argument>, <argument>QualType Base</argument>,
<argument>ArrayRef&lt;QualType&gt; typeArgs</argument>,
<argument>ArrayRef&lt;ObjCProtocolDecl *&gt; protocols</argument>,
<argument>bool isKindOf</argument>)</argument_list></macro>;

<expr><call><name>ObjCObjectType</name><argument_list>(<argument><expr>enum <name>Nonce_ObjCInterface</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Type</name><argument_list>(<argument><expr><name>ObjCInterface</name></expr></argument>, <argument><expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TypeDependence</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>,
<macro><name>BaseType</name><argument_list>(<argument>QualType(this_(), <literal type="number">0</literal>)</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>ObjCObjectTypeBits</name><operator>.</operator><name>NumProtocols</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name><name>ObjCObjectTypeBits</name><operator>.</operator><name>NumTypeArgs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name><name>ObjCObjectTypeBits</name><operator>.</operator><name>IsKindOf</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;
}</block>

<name>void</name> <macro><name>computeSuperClassTypeSlow</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>public</name><operator>:</operator>






<name>QualType</name> <macro><name>getBaseType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BaseType</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isObjCId</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getBaseType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isSpecificBuiltinType</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>ObjCId</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isObjCClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getBaseType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isSpecificBuiltinType</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>ObjCClass</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isObjCUnqualifiedId</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>qual_empty</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isObjCId</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>isObjCUnqualifiedClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>qual_empty</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isObjCClass</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>isObjCUnqualifiedIdOrClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>qual_empty</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>BuiltinType</name> <modifier>*</modifier></type><name>T</name> <init>= <expr><call><name>getBaseType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>BuiltinType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>BuiltinType</name><operator>::</operator><name>ObjCId</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>BuiltinType</name><operator>::</operator><name>ObjCClass</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>
<name>bool</name> <macro><name>isObjCQualifiedId</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>qual_empty</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isObjCId</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>isObjCQualifiedClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>qual_empty</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isObjCClass</name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getInterface</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isSpecialized</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isSpecializedAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ObjCObjectTypeBits</name><operator>.</operator><name>NumTypeArgs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
}</block>



<name>bool</name> <macro><name>isUnspecialized</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>isSpecialized</name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>bool</name> <macro><name>isUnspecializedAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>isSpecializedAsWritten</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <macro><name>getTypeArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <macro><name>getTypeArgsAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getTypeArgStorage</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name><name>ObjCObjectTypeBits</name><operator>.</operator><name>NumTypeArgs</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>isKindOfTypeAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ObjCObjectTypeBits</name><operator>.</operator><name>IsKindOf</name></name></expr>;</return> }</block>


<name>bool</name> <macro><name>isKindOfType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;







<expr><name>QualType</name> <macro><name>getSuperClassType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>CachedSuperClassType</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>computeSuperClassTypeSlow</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<call><name>assert</name><argument_list>(<argument><expr><call><name><name>CachedSuperClassType</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Superclass not set?"</literal></expr></argument>)</argument_list></call></block></expr>;
<return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><call><name><name>CachedSuperClassType</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>QualType</name> <macro><name>stripObjCKindOfTypeAndQuals</name><argument_list>(<argument>const ASTContext &amp;ctx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCObject</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCInterface</name></expr>;</return>
}</block>
}</expr>;





<expr><name>class</name> <name>ObjCObjectTypeImpl</name> <operator>:</operator> <name>public</name> <name>ObjCObjectType</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;




<macro><name>ObjCObjectTypeImpl</name><argument_list>(<argument>QualType Canonical</argument>, <argument>QualType Base</argument>,
<argument>ArrayRef&lt;QualType&gt; typeArgs</argument>,
<argument>ArrayRef&lt;ObjCProtocolDecl *&gt; protocols</argument>,
<argument>bool isKindOf</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>ObjCObjectType</name><argument_list>(<argument>Canonical</argument>, <argument>Base</argument>, <argument>typeArgs</argument>, <argument>protocols</argument>, <argument>isKindOf</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>void</name> <call><name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>,
<argument>QualType Base</argument>,
<argument>ArrayRef&lt;QualType&gt; typeArgs</argument>,
<argument>ArrayRef&lt;ObjCProtocolDecl *&gt; protocols</argument>,
<argument>bool isKindOf</argument>)</argument_list></macro></expr>;
}</block></expr>;

<expr><specifier>inline</specifier> <name>QualType</name> <operator>*</operator><name>ObjCObjectType</name><operator>::</operator><macro><name>getTypeArgStorage</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectTypeImpl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>ObjCProtocolDecl</name> <operator>*</operator><operator>*</operator><name>ObjCObjectType</name><operator>::</operator><macro><name>getProtocolStorageImpl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name><operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getTypeArgStorage</name><argument_list>()</argument_list></call> <operator>+</operator> <name><name>ObjCObjectTypeBits</name><operator>.</operator><name>NumTypeArgs</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>ObjCProtocolDecl</name> <operator>*</operator><operator>*</operator><name>ObjCTypeParamType</name><operator>::</operator><macro><name>getProtocolStorageImpl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name><operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCTypeParamType</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>













<name>class</name> <name>ObjCInterfaceType</name> <operator>:</operator> <name>public</name> <name>ObjCObjectType</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ObjCInterfaceDecl</name></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>friend</name> <name>class</name> <name>serialization</name><operator>::</operator><name>AbstractTypeReader</name></expr>;

<expr><name>mutable</name> <name>ObjCInterfaceDecl</name> <operator>*</operator><name>Decl</name></expr>;

<expr><call><name>ObjCInterfaceType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>ObjCObjectType</name><argument_list>(<argument><expr><name>Nonce_ObjCInterface</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Decl</name><argument_list>(<argument>const_cast&lt;ObjCInterfaceDecl*&gt;(D)</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>

<name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Decl</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCInterface</name></expr>;</return>
}</block>





enum <block>{
<expr><name>qual_iterator</name></expr>,
<expr><name>qual_begin</name></expr>,
<expr><name>qual_end</name></expr>,
<expr><name>getNumProtocols</name></expr>,
<expr><name>getProtocol</name></expr>
}</block></expr>;
}</block></expr>;

<expr><specifier>inline</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><name>ObjCObjectType</name><operator>::</operator><macro><name>getInterface</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>QualType</name> <name>baseType</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>()</argument_list></call></expr>;
<while>while <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>ObjT</name> <init>= <expr><name><name>baseType</name><operator>-&gt;</operator><name>getAs</name></name><operator>&lt;</operator><name>ObjCObjectType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>T</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCInterfaceType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ObjT</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>baseType</name> <operator>=</operator> <call><name><name>ObjT</name><operator>-&gt;</operator><name>getBaseType</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>

return nullptr</block><empty_stmt>;</empty_stmt></while>
}</block>










<name>class</name> <name>ObjCObjectPointerType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><name>QualType</name> <name>PointeeType</name></expr>;

<macro><name>ObjCObjectPointerType</name><argument_list>(<argument>QualType Canonical</argument>, <argument>QualType Pointee</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>ObjCObjectPointer</name></expr></argument>, <argument><expr><name>Canonical</name></expr></argument>, <argument><expr><call><name><name>Pointee</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>PointeeType</name><argument_list>(<argument>Pointee</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>


<name>QualType</name> <macro><name>getPointeeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PointeeType</name></expr>;</return> }</block>
























<specifier>const</specifier> <name>ObjCObjectType</name> <operator>*</operator><macro><name>getObjectType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>PointeeType</name><operator>-&gt;</operator><name>castAs</name></name><operator>&lt;</operator><name>ObjCObjectType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>






<specifier>const</specifier> <name>ObjCInterfaceType</name> <operator>*</operator><macro><name>getInterfaceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;





<expr><name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getInterfaceDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getObjectType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getInterface</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isObjCIdType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getObjectType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isObjCUnqualifiedId</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isObjCClassType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getObjectType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isObjCUnqualifiedClass</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>isObjCIdOrClassType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getObjectType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isObjCUnqualifiedIdOrClass</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isObjCQualifiedIdType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getObjectType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isObjCQualifiedId</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isObjCQualifiedClassType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getObjectType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isObjCQualifiedClass</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>isKindOfType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getObjectType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isKindOfType</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>bool</name> <macro><name>isSpecialized</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getObjectType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isSpecialized</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>bool</name> <macro><name>isSpecializedAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getObjectType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isSpecializedAsWritten</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>isUnspecialized</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getObjectType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isUnspecialized</name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>bool</name> <macro><name>isUnspecializedAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>isSpecializedAsWritten</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <macro><name>getTypeArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getObjectType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTypeArgs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <macro><name>getTypeArgsAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getObjectType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTypeArgsAsWritten</name><argument_list>()</argument_list></call></expr>;</return>
}</block>




<name>using</name> <name>qual_iterator</name> <operator>=</operator> <name>ObjCObjectType</name><operator>::</operator><name>qual_iterator</name></expr>;
<expr><name>using</name> <name>qual_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>qual_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>qual_range</name> <macro><name>quals</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>qual_range</name><argument_list>(<argument><expr><call><name>qual_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>qual_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>qual_iterator</name> <macro><name>qual_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getObjectType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>qual_begin</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>qual_iterator</name> <macro><name>qual_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getObjectType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>qual_end</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>qual_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getObjectType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>qual_empty</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>unsigned</name> <macro><name>getNumProtocols</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getObjectType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNumProtocols</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>ObjCProtocolDecl</name> <operator>*</operator><macro><name>getProtocol</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getObjectType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getProtocol</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>







<name>QualType</name> <macro><name>getSuperClassType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><specifier>const</specifier> <name>ObjCObjectPointerType</name> <operator>*</operator><macro><name>stripObjCKindOfTypeAndQuals</name><argument_list>(
<argument>const ASTContext &amp;ctx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getPointeeType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>QualType T</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>T</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCObjectPointer</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>AtomicType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><name>QualType</name> <name>ValueType</name></expr>;

<macro><name>AtomicType</name><argument_list>(<argument>QualType ValTy</argument>, <argument>QualType Canonical</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>Atomic</name></expr></argument>, <argument><expr><name>Canonical</name></expr></argument>, <argument><expr><call><name><name>ValTy</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>, <macro><name>ValueType</name><argument_list>(<argument>ValTy</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>


<name>QualType</name> <macro><name>getValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ValueType</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getValueType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>QualType T</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>T</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Atomic</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>PipeType</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><name>QualType</name> <name>ElementType</name></expr>;
<expr><name>bool</name> <name>isRead</name></expr>;

<macro><name>PipeType</name><argument_list>(<argument>QualType elemType</argument>, <argument>QualType CanonicalPtr</argument>, <argument>bool isRead</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>Pipe</name></expr></argument>, <argument><expr><name>CanonicalPtr</name></expr></argument>, <argument><expr><call><name><name>elemType</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ElementType</name><argument_list>(<argument><expr><name>elemType</name></expr></argument>)</argument_list></call></expr>, <macro><name>isRead</name><argument_list>(<argument>isRead</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getElementType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ElementType</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>

<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>getElementType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>isReadOnly</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>QualType T</argument>, <argument>bool isRead</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>T</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><name>isRead</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Pipe</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isReadOnly</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>isRead</name></expr>;</return> }</block>
}</expr>;


<expr><name>class</name> <name>ExtIntType</name> <name>final</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;
<expr><name>unsigned</name> <name>IsUnsigned</name> <operator>:</operator> <literal type="number">1</literal></expr>;
<expr><name>unsigned</name> <name>NumBits</name> <operator>:</operator> <literal type="number">24</literal></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>ExtIntType</name><argument_list>(<argument>bool isUnsigned</argument>, <argument>unsigned NumBits</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<name>bool</name> <macro><name>isUnsigned</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsUnsigned</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isSigned</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><name>IsUnsigned</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>getNumBits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumBits</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><call><name>isUnsigned</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNumBits</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>bool IsUnsigned</argument>,
<argument>unsigned NumBits</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><name>IsUnsigned</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>NumBits</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ExtInt</name></expr>;</return> }</block>
}</expr>;

<expr><name>class</name> <name>DependentExtIntType</name> <name>final</name> <operator>:</operator> <name>public</name> <name>Type</name></expr>, <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;
<expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>ExprAndUnsigned</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>DependentExtIntType</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>bool IsUnsigned</argument>,
<argument>Expr *NumBits</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<name>bool</name> <macro><name>isUnsigned</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isSigned</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>isUnsigned</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>Expr</name> <operator>*</operator><macro><name>getNumBitsExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>isSugared</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>desugar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>, <argument><expr><call><name>isUnsigned</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNumBitsExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>
<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>const ASTContext &amp;Context</argument>,
<argument>bool IsUnsigned</argument>, <argument>Expr *NumBitsExpr</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Type *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DependentExtInt</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>QualifierCollector</name> <operator>:</operator> <name>public</name> <name>Qualifiers</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>QualifierCollector</name><argument_list>(<argument>Qualifiers Qs = Qualifiers()</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Qualifiers</name><argument_list>(<argument>Qs</argument>)</argument_list></macro> <block>{}</block>




<specifier>const</specifier> <name>Type</name> <operator>*</operator><macro><name>strip</name><argument_list>(<argument>QualType type</argument>)</argument_list></macro> <block>{
<expr><call><name>addFastQualifiers</name><argument_list>(<argument><expr><call><name><name>type</name><operator>.</operator><name>getLocalFastQualifiers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>type</name><operator>.</operator><name>hasLocalNonFastQualifiers</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>type</name><operator>.</operator><name>getTypePtrUnsafe</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<specifier>const</specifier> <name>ExtQuals</name> <operator>*</operator><name>extQuals</name> <operator>=</operator> <call><name><name>type</name><operator>.</operator><name>getExtQualsUnsafe</name></name><argument_list>()</argument_list></call></block></expr>;
<expr><call><name>addConsistentQualifiers</name><argument_list>(<argument><expr><call><name><name>extQuals</name><operator>-&gt;</operator><name>getQualifiers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>extQuals</name><operator>-&gt;</operator><name>getBaseType</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>QualType</name> <macro><name>apply</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>QualType QT</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>QualType</name> <macro><name>apply</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>const Type* T</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr>;








<expr><name>class</name> <macro><name>alignas</name><argument_list>(<argument><literal type="number">8</literal></argument>)</argument_list></macro> <name>TypeSourceInfo</name> <block>{


<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><name>QualType</name> <name>Ty</name></expr>;

<macro><name>TypeSourceInfo</name><argument_list>(<argument>QualType ty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Ty</name><argument_list>(<argument>ty</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>

<name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Ty</name></expr>;</return> }</block>


<name>TypeLoc</name> <macro><name>getTypeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>void</name> <macro><name>overrideType</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <block>{ <expr><name>Ty</name> <operator>=</operator> <name>T</name></expr>; }</block></expr>
}</block></expr>;



<expr><specifier>inline</specifier> <name>SplitQualType</name> <name>SplitQualType</name><operator>::</operator><macro><name>getSingleStepDesugaredType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>SplitQualType</name> <name>desugar</name> <operator>=</operator>
<call><name><name>Ty</name><operator>-&gt;</operator><name>getLocallyUnqualifiedSingleStepDesugaredType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>split</name><argument_list>()</argument_list></call></expr>;
<expr><call><name><name>desugar</name><operator>.</operator><name>Quals</name><operator>.</operator><name>addConsistentQualifiers</name></name><argument_list>(<argument><expr><name>Quals</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>desugar</name></expr>;</return>
}</block>

<specifier>inline</specifier> <specifier>const</specifier> <name>Type</name> <operator>*</operator><name>QualType</name><operator>::</operator><macro><name>getTypePtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCommonPtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>BaseType</name></expr>;</return>
}</block>

<specifier>inline</specifier> <specifier>const</specifier> <name>Type</name> <operator>*</operator><name>QualType</name><operator>::</operator><macro><name>getTypePtrOrNull</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>isNull</name><argument_list>()</argument_list></call> <operator>?</operator> <name>nullptr</name> <operator>:</operator> <call><name>getCommonPtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>BaseType</name><operator>)</operator></expr>;</return>
}</block>

<specifier>inline</specifier> <name>SplitQualType</name> <name>QualType</name><operator>::</operator><macro><name>split</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasLocalNonFastQualifiers</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SplitQualType</name><argument_list>(<argument><expr><call><name>getTypePtrUnsafe</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Qualifiers</name><operator>::</operator><call><name>fromFastMask</name><argument_list>(<argument><expr><call><name>getLocalFastQualifiers</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<specifier>const</specifier> <name>ExtQuals</name> <operator>*</operator><name>eq</name> <operator>=</operator> <call><name>getExtQualsUnsafe</name><argument_list>()</argument_list></call></block></expr>;
<expr><name>Qualifiers</name> <name>qs</name> <operator>=</operator> <call><name><name>eq</name><operator>-&gt;</operator><name>getQualifiers</name></name><argument_list>()</argument_list></call></expr>;
<expr><call><name><name>qs</name><operator>.</operator><name>addFastQualifiers</name></name><argument_list>(<argument><expr><call><name>getLocalFastQualifiers</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>SplitQualType</name><argument_list>(<argument><expr><call><name><name>eq</name><operator>-&gt;</operator><name>getBaseType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>qs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>Qualifiers</name> <name>QualType</name><operator>::</operator><macro><name>getLocalQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>Qualifiers</name> <name>Quals</name></expr>;
<if_stmt><if>if <condition>(<expr><call><name>hasLocalNonFastQualifiers</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Quals</name> <operator>=</operator> <call><name>getExtQualsUnsafe</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getQualifiers</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<call><name><name>Quals</name><operator>.</operator><name>addFastQualifiers</name></name><argument_list>(<argument><expr><call><name>getLocalFastQualifiers</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;
<return>return <expr><name>Quals</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>Qualifiers</name> <name>QualType</name><operator>::</operator><macro><name>getQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>Qualifiers</name> <name>quals</name> <operator>=</operator> <call><name>getCommonPtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>CanonicalType</name><operator>.</operator><name>getLocalQualifiers</name></name><argument_list>()</argument_list></call></expr>;
<expr><call><name><name>quals</name><operator>.</operator><name>addFastQualifiers</name></name><argument_list>(<argument><expr><call><name>getLocalFastQualifiers</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>quals</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>unsigned</name> <name>QualType</name><operator>::</operator><macro><name>getCVRQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>unsigned</name> <name>cvr</name> <operator>=</operator> <call><name>getCommonPtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>CanonicalType</name><operator>.</operator><name>getLocalCVRQualifiers</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>cvr</name> <operator>|=</operator> <call><name>getLocalCVRQualifiers</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>cvr</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>QualType</name> <name>QualType</name><operator>::</operator><macro><name>getCanonicalType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>QualType</name> <name>canon</name> <operator>=</operator> <call><name>getCommonPtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>CanonicalType</name></expr>;
<return>return <expr><call><name><name>canon</name><operator>.</operator><name>withFastQualifiers</name></name><argument_list>(<argument><expr><call><name>getLocalFastQualifiers</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>QualType</name><operator>::</operator><macro><name>isCanonical</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isCanonicalUnqualified</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>QualType</name><operator>::</operator><macro><name>isCanonicalAsParam</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isCanonical</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<expr><call><name>hasLocalQualifiers</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name>getTypePtr</name><argument_list>()</argument_list></call></block></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>T</name><operator>-&gt;</operator><name>isVariablyModifiedType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>T</name><operator>-&gt;</operator><name>hasSizedVLAType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>FunctionType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>QualType</name><operator>::</operator><macro><name>isConstQualified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isLocalConstQualified</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name>getCommonPtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>CanonicalType</name><operator>.</operator><name>isLocalConstQualified</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>QualType</name><operator>::</operator><macro><name>isRestrictQualified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isLocalRestrictQualified</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name>getCommonPtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>CanonicalType</name><operator>.</operator><name>isLocalRestrictQualified</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<specifier>inline</specifier> <name>bool</name> <name>QualType</name><operator>::</operator><macro><name>isVolatileQualified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isLocalVolatileQualified</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name>getCommonPtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>CanonicalType</name><operator>.</operator><name>isLocalVolatileQualified</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>QualType</name><operator>::</operator><macro><name>hasQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasLocalQualifiers</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name>getCommonPtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>CanonicalType</name><operator>.</operator><name>hasLocalQualifiers</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>QualType</name> <name>QualType</name><operator>::</operator><macro><name>getUnqualifiedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getCanonicalTypeInternal</name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasLocalQualifiers</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><call><name>getSplitUnqualifiedTypeImpl</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call><operator>.</operator><name>Ty</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>SplitQualType</name> <name>QualType</name><operator>::</operator><macro><name>getSplitUnqualifiedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getCanonicalTypeInternal</name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasLocalQualifiers</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>split</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name>getSplitUnqualifiedTypeImpl</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>void</name> <name>QualType</name><operator>::</operator><macro><name>removeLocalConst</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>removeLocalFastQualifiers</name><argument_list>(<argument><expr><name>Qualifiers</name><operator>::</operator><name>Const</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>inline</specifier> <name>void</name> <name>QualType</name><operator>::</operator><macro><name>removeLocalRestrict</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>removeLocalFastQualifiers</name><argument_list>(<argument><expr><name>Qualifiers</name><operator>::</operator><name>Restrict</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>inline</specifier> <name>void</name> <name>QualType</name><operator>::</operator><macro><name>removeLocalVolatile</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>removeLocalFastQualifiers</name><argument_list>(<argument><expr><name>Qualifiers</name><operator>::</operator><name>Volatile</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>inline</specifier> <name>void</name> <name>QualType</name><operator>::</operator><macro><name>removeLocalCVRQualifiers</name><argument_list>(<argument>unsigned Mask</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>Mask</name> <operator>&amp;</operator> <operator>~</operator><name>Qualifiers</name><operator>::</operator><name>CVRMask</name><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"mask has non-CVR bits"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>static_assert</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>Qualifiers</name><operator>::</operator><name>CVRMask</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>Qualifiers</name><operator>::</operator><name>FastMask</name></expr></argument>,
<argument><expr><literal type="string">"Fast bits differ from CVR bits!"</literal></expr></argument>)</argument_list></call></expr>;


<expr><call><name>removeLocalFastQualifiers</name><argument_list>(<argument><expr><name>Mask</name></expr></argument>)</argument_list></call></expr>;
}</block>


<specifier>inline</specifier> <name>bool</name> <name>QualType</name><operator>::</operator><macro><name>hasAddressSpace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getQualifiers</name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasAddressSpace</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<specifier>inline</specifier> <name>LangAS</name> <name>QualType</name><operator>::</operator><macro><name>getAddressSpace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getQualifiers</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAddressSpace</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<specifier>inline</specifier> <name>Qualifiers</name><operator>::</operator><name>GC</name> <name>QualType</name><operator>::</operator><macro><name>getObjCGCAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getQualifiers</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getObjCGCAttr</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>QualType</name><operator>::</operator><macro><name>hasNonTrivialToPrimitiveDefaultInitializeCUnion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>RD</name> <operator>=</operator> <call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBaseElementTypeUnsafe</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getAsRecordDecl</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>hasNonTrivialToPrimitiveDefaultInitializeCUnion</name><argument_list>(<argument><expr><name>RD</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>QualType</name><operator>::</operator><macro><name>hasNonTrivialToPrimitiveDestructCUnion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>RD</name> <operator>=</operator> <call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBaseElementTypeUnsafe</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getAsRecordDecl</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>hasNonTrivialToPrimitiveDestructCUnion</name><argument_list>(<argument><expr><name>RD</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>QualType</name><operator>::</operator><macro><name>hasNonTrivialToPrimitiveCopyCUnion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>RD</name> <operator>=</operator> <call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBaseElementTypeUnsafe</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getAsRecordDecl</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>hasNonTrivialToPrimitiveCopyCUnion</name><argument_list>(<argument><expr><name>RD</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>FunctionType</name><operator>::</operator><name>ExtInfo</name> <macro><name>getFunctionExtInfo</name><argument_list>(<argument>const Type &amp;t</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>PT</name> <init>= <expr><name><name>t</name><operator>.</operator><name>getAs</name></name><operator>&lt;</operator><name>PointerType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>FT</name> <init>= <expr><call><name><name>PT</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>FunctionType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>FT</name><operator>-&gt;</operator><name>getExtInfo</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/>}</block_content> else if (const auto *FT = t.getAs&lt;FunctionType&gt;(</block></if></if_stmt>))</block></expr>
<return>return <expr><call><name><name>FT</name><operator>-&gt;</operator><name>getExtInfo</name></name><argument_list>()</argument_list></call></expr>;</return></block></expr>

<return>return <expr><name>FunctionType</name><operator>::</operator><call><name>ExtInfo</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>FunctionType</name><operator>::</operator><name>ExtInfo</name> <macro><name>getFunctionExtInfo</name><argument_list>(<argument>QualType t</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getFunctionExtInfo</name><argument_list>(<argument><expr><operator>*</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>






<specifier>inline</specifier> <name>bool</name> <name>QualType</name><operator>::</operator><macro><name>isMoreQualifiedThan</name><argument_list>(<argument>QualType other</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>Qualifiers</name> <name>MyQuals</name> <operator>=</operator> <call><name>getQualifiers</name><argument_list>()</argument_list></call></expr>;
<expr><name>Qualifiers</name> <name>OtherQuals</name> <operator>=</operator> <call><name><name>other</name><operator>.</operator><name>getQualifiers</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><operator>(</operator><name>MyQuals</name> <operator>!=</operator> <name>OtherQuals</name> <operator>&amp;&amp;</operator> <call><name><name>MyQuals</name><operator>.</operator><name>compatiblyIncludes</name></name><argument_list>(<argument><expr><name>OtherQuals</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block>





<specifier>inline</specifier> <name>bool</name> <name>QualType</name><operator>::</operator><macro><name>isAtLeastAsQualifiedAs</name><argument_list>(<argument>QualType other</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>Qualifiers</name> <name>OtherQuals</name> <operator>=</operator> <call><name><name>other</name><operator>.</operator><name>getQualifiers</name></name><argument_list>()</argument_list></call></expr>;


<if_stmt><if>if <condition>(<expr><call><name>getUnqualifiedType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isVoidType</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>OtherQuals</name><operator>.</operator><name>removeUnaligned</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name>getQualifiers</name><argument_list>()</argument_list></call><operator>.</operator><call><name>compatiblyIncludes</name><argument_list>(<argument><expr><name>OtherQuals</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>










<specifier>inline</specifier> <name>QualType</name> <name>QualType</name><operator>::</operator><macro><name>getNonReferenceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>RefType</name> <init>= <expr><call><name><operator>(</operator><operator>*</operator><name>this</name><operator>)</operator><operator>-&gt;</operator><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>ReferenceType</name></expr></argument>&gt;</argument_list></name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>RefType</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return></block_content></block></else></if_stmt>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>QualType</name><operator>::</operator><macro><name>isCForbiddenLValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><operator>(</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isVoidType</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>hasQualifiers</name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator>
<call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isFunctionType</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block>




<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isFundamentalType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isVoidType</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name>isNullPtrType</name><argument_list>()</argument_list></call> <operator>||</operator>


<operator>(</operator><call><name>isArithmeticType</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isEnumeralType</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block>




<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isCompoundType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{



<return>return <expr><call><name>isArrayType</name><argument_list>()</argument_list></call> <operator>||</operator>

<call><name>isFunctionType</name><argument_list>()</argument_list></call> <operator>||</operator>

<call><name>isPointerType</name><argument_list>()</argument_list></call> <operator>||</operator>

<call><name>isReferenceType</name><argument_list>()</argument_list></call> <operator>||</operator>

<call><name>isRecordType</name><argument_list>()</argument_list></call> <operator>||</operator>


<call><name>isUnionType</name><argument_list>()</argument_list></call> <operator>||</operator>

<call><name>isEnumeralType</name><argument_list>()</argument_list></call> <operator>||</operator>

<call><name>isMemberPointerType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isFunctionType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>FunctionType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>PointerType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isAnyPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isPointerType</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isObjCObjectPointerType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isBlockPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>BlockPointerType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isReferenceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ReferenceType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isLValueReferenceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>LValueReferenceType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isRValueReferenceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>RValueReferenceType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isObjectPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{



<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>T</name> <init>= <expr><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>PointerType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>!</operator><call><name><name>T</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isFunctionType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isFunctionPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>T</name> <init>= <expr><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>PointerType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isFunctionType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isFunctionReferenceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>T</name> <init>= <expr><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>ReferenceType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isFunctionType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isMemberPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>MemberPointerType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isMemberFunctionPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>T</name> <init>= <expr><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>MemberPointerType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>isMemberFunctionPointer</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isMemberDataPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>T</name> <init>= <expr><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>MemberPointerType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>isMemberDataPointer</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isArrayType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isConstantArrayType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ConstantArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isIncompleteArrayType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>IncompleteArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isVariableArrayType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>VariableArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isDependentSizedArrayType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>DependentSizedArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isBuiltinType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>BuiltinType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isRecordType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>RecordType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isEnumeralType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>EnumType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isAnyComplexType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ComplexType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isVectorType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>VectorType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isExtVectorType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ExtVectorType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isMatrixType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>MatrixType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isConstantMatrixType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ConstantMatrixType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isDependentAddressSpaceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>DependentAddressSpaceType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isObjCObjectPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectPointerType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isObjCObjectType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isObjCObjectOrInterfaceType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ObjCInterfaceType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isAtomicType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>AtomicType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isUndeducedAutoType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>AutoType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isObjCQualifiedIdType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>OPT</name> <init>= <expr><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectPointerType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>OPT</name><operator>-&gt;</operator><name>isObjCQualifiedIdType</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isObjCQualifiedClassType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>OPT</name> <init>= <expr><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectPointerType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>OPT</name><operator>-&gt;</operator><name>isObjCQualifiedClassType</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isObjCIdType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>OPT</name> <init>= <expr><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectPointerType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>OPT</name><operator>-&gt;</operator><name>isObjCIdType</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isObjCClassType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>OPT</name> <init>= <expr><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectPointerType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>OPT</name><operator>-&gt;</operator><name>isObjCClassType</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isObjCSelType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>OPT</name> <init>= <expr><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>PointerType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>OPT</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isSpecificBuiltinType</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>ObjCSel</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isObjCBuiltinType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isObjCIdType</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isObjCClassType</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isObjCSelType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isDecltypeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>DecltypeType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMAGE_TYPE</name><parameter_list>(<parameter><type><name>ImgType</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>, <parameter><type><name>SingletonId</name></type></parameter>, <parameter><type><name>Access</name></type></parameter>, <parameter><type><name>Suffix</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>inline bool Type::is##Id##Type() const { return isSpecificBuiltinType(BuiltinType::Id); }</cpp:value></cpp:define>



<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenCLImageTypes.def"</cpp:file></cpp:include>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isSamplerT</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isSpecificBuiltinType</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>OCLSampler</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isEventT</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isSpecificBuiltinType</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>OCLEvent</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isClkEventT</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isSpecificBuiltinType</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>OCLClkEvent</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isQueueT</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isSpecificBuiltinType</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>OCLQueue</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isReserveIDT</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isSpecificBuiltinType</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>OCLReserveID</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isImageType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMAGE_TYPE</name><parameter_list>(<parameter><type><name>ImgType</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>, <parameter><type><name>SingletonId</name></type></parameter>, <parameter><type><name>Access</name></type></parameter>, <parameter><type><name>Suffix</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>is##Id##Type() ||</cpp:value></cpp:define>
<return>return
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenCLImageTypes.def"</cpp:file></cpp:include>
<expr><name>false</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isPipeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>PipeType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isExtIntType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ExtIntType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXT_OPAQUE_TYPE</name><parameter_list>(<parameter><type><name>ExtType</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>, <parameter><type><name>Ext</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>inline bool Type::is##Id##Type() const { return isSpecificBuiltinType(BuiltinType::Id); }</cpp:value></cpp:define>



<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenCLExtensionTypes.def"</cpp:file></cpp:include>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isOCLIntelSubgroupAVCType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INTEL_SUBGROUP_AVC_TYPE</name><parameter_list>(<parameter><type><name>ExtType</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>isOCLIntelSubgroupAVC##Id##Type() ||</cpp:value></cpp:define>

<return>return
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenCLExtensionTypes.def"</cpp:file></cpp:include>
<expr><name>false</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isOCLExtOpaqueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXT_OPAQUE_TYPE</name><parameter_list>(<parameter><type><name>ExtType</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>, <parameter><type><name>Ext</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>is##Id##Type() ||</cpp:value></cpp:define>
<return>return
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenCLExtensionTypes.def"</cpp:file></cpp:include>
<expr><name>false</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isOpenCLSpecificType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isSamplerT</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isEventT</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isImageType</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isClkEventT</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name>isQueueT</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isReserveIDT</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isPipeType</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isOCLExtOpaqueType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isTemplateTypeParmType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>TemplateTypeParmType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isSpecificBuiltinType</name><argument_list>(<argument>unsigned K</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>BuiltinType</name> <modifier>*</modifier></type><name>BT</name> <init>= <expr><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>BuiltinType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<return>return <expr><call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>BuiltinType</name><operator>::</operator><name>Kind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>K</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>
return false</block><empty_stmt>;</empty_stmt></if></if_stmt>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isPlaceholderType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>BT</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>BuiltinType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>BT</name><operator>-&gt;</operator><name>isPlaceholderType</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>

<specifier>inline</specifier> <specifier>const</specifier> <name>BuiltinType</name> <operator>*</operator><name>Type</name><operator>::</operator><macro><name>getAsPlaceholderType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>BT</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>BuiltinType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>BT</name><operator>-&gt;</operator><name>isPlaceholderType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>BT</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>nullptr</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isSpecificPlaceholderType</name><argument_list>(<argument>unsigned K</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><call><name>isPlaceholderTypeKind</name><argument_list>(<argument><expr><operator>(</operator><name>BuiltinType</name><operator>::</operator><name>Kind</name><operator>)</operator> <name>K</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>isSpecificBuiltinType</name><argument_list>(<argument><expr><name>K</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isNonOverloadPlaceholderType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>BT</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>BuiltinType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>BT</name><operator>-&gt;</operator><name>isNonOverloadPlaceholderType</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isVoidType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isSpecificBuiltinType</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>Void</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isHalfType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{

<return>return <expr><call><name>isSpecificBuiltinType</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>Half</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isFloat16Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isSpecificBuiltinType</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>Float16</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isBFloat16Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isSpecificBuiltinType</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>BFloat16</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isFloat128Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isSpecificBuiltinType</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>Float128</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isNullPtrType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isSpecificBuiltinType</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>NullPtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <call><name>IsEnumDeclComplete</name><argument_list>(<argument><expr><name>EnumDecl</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;
<expr><name>bool</name> <call><name>IsEnumDeclScoped</name><argument_list>(<argument><expr><name>EnumDecl</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;

<expr><specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isIntegerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>BT</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>BuiltinType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>BuiltinType</name><operator>::</operator><name>Bool</name> <operator>&amp;&amp;</operator>
<call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>BuiltinType</name><operator>::</operator><name>Int128</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>EnumType</name> <modifier>*</modifier></type><name>ET</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>EnumType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>


<return>return <expr><call><name>IsEnumDeclComplete</name><argument_list>(<argument><expr><call><name><name>ET</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>IsEnumDeclScoped</name><argument_list>(<argument><expr><call><name><name>ET</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>
return isExtIntType(</block></if></if_stmt>)</block></expr>;
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isFixedPointType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>BT</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>BuiltinType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<return>return <expr><call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>BuiltinType</name><operator>::</operator><name>ShortAccum</name> <operator>&amp;&amp;</operator>
<call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>BuiltinType</name><operator>::</operator><name>SatULongFract</name></expr>;</return>
<expr_stmt/>}</block_content>
return false</block><empty_stmt>;</empty_stmt></if></if_stmt>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isFixedPointOrIntegerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isFixedPointType</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isIntegerType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isSaturatedFixedPointType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>BT</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>BuiltinType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<return>return <expr><call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>BuiltinType</name><operator>::</operator><name>SatShortAccum</name> <operator>&amp;&amp;</operator>
<call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>BuiltinType</name><operator>::</operator><name>SatULongFract</name></expr>;</return>
<expr_stmt/>}</block_content>
return false</block><empty_stmt>;</empty_stmt></if></if_stmt>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isUnsaturatedFixedPointType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isFixedPointType</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isSaturatedFixedPointType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isSignedFixedPointType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>BT</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>BuiltinType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><operator>(</operator><call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>BuiltinType</name><operator>::</operator><name>ShortAccum</name> <operator>&amp;&amp;</operator>
<call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>BuiltinType</name><operator>::</operator><name>LongAccum</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>BuiltinType</name><operator>::</operator><name>ShortFract</name> <operator>&amp;&amp;</operator>
<call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>BuiltinType</name><operator>::</operator><name>LongFract</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>BuiltinType</name><operator>::</operator><name>SatShortAccum</name> <operator>&amp;&amp;</operator>
<call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>BuiltinType</name><operator>::</operator><name>SatLongAccum</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>BuiltinType</name><operator>::</operator><name>SatShortFract</name> <operator>&amp;&amp;</operator>
<call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>BuiltinType</name><operator>::</operator><name>SatLongFract</name><operator>)</operator><operator>)</operator></expr>;</return>
<expr_stmt/>}</block_content>
return false</block><empty_stmt>;</empty_stmt></if></if_stmt>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isUnsignedFixedPointType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isFixedPointType</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isSignedFixedPointType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isScalarType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>BT</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>BuiltinType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>BuiltinType</name><operator>::</operator><name>Void</name> <operator>&amp;&amp;</operator>
<call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>BuiltinType</name><operator>::</operator><name>NullPtr</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>EnumType</name> <modifier>*</modifier></type><name>ET</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>EnumType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>


<return>return <expr><call><name>IsEnumDeclComplete</name><argument_list>(<argument><expr><call><name><name>ET</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>PointerType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>BlockPointerType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>MemberPointerType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ComplexType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectPointerType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isExtIntType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isIntegralOrEnumerationType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>BT</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>BuiltinType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>BuiltinType</name><operator>::</operator><name>Bool</name> <operator>&amp;&amp;</operator>
<call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>BuiltinType</name><operator>::</operator><name>Int128</name></expr>;</return></block_content></block></if></if_stmt></block></expr>



<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>ET</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>EnumType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>IsEnumDeclComplete</name><argument_list>(<argument><expr><call><name><name>ET</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name>isExtIntType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isBooleanType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>BT</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>BuiltinType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>BuiltinType</name><operator>::</operator><name>Bool</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isUndeducedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <operator>*</operator><name>DT</name> <operator>=</operator> <call><name>getContainedDeducedType</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>DT</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>DT</name><operator>-&gt;</operator><name>isDeduced</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isOverloadableType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isDependentType</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isRecordType</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isEnumeralType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>isTypedefNameType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>TypedefType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>TST</name> <operator>=</operator> <call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>TemplateSpecializationType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>TST</name><operator>-&gt;</operator><name>isTypeAlias</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>


<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>canDecayToPointerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isFunctionType</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isArrayType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>hasPointerRepresentation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>isPointerType</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isReferenceType</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isBlockPointerType</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name>isObjCObjectPointerType</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isNullPtrType</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>Type</name><operator>::</operator><macro><name>hasObjCPointerRepresentation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isObjCObjectPointerType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <specifier>const</specifier> <name>Type</name> <operator>*</operator><name>Type</name><operator>::</operator><macro><name>getBaseElementTypeUnsafe</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>type</name> <operator>=</operator> <name>this</name></expr>;
<while>while <condition>(<decl><type><specifier>const</specifier> <name>ArrayType</name> <modifier>*</modifier></type><name>arrayType</name> <init>= <expr><call><name><name>type</name><operator>-&gt;</operator><name>getAsArrayTypeUnsafe</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name><name>arrayType</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></while></block></expr>
<return>return <expr><name>type</name></expr>;</return>
}</block>

<specifier>inline</specifier> <specifier>const</specifier> <name>Type</name> <operator>*</operator><name>Type</name><operator>::</operator><macro><name>getPointeeOrArrayElementType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>type</name> <operator>=</operator> <name>this</name></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>type</name><operator>-&gt;</operator><name>isAnyPointerType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>type</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name><name>type</name><operator>-&gt;</operator><name>isArrayType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>type</name><operator>-&gt;</operator><name>getBaseElementTypeUnsafe</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>type</name></expr>;</return>
}</block>


<specifier>inline</specifier> <specifier>const</specifier> <name>StreamingDiagnostic</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><specifier>const</specifier> <name>StreamingDiagnostic</name> <operator>&amp;</operator><name>PD</name>,
<name>LangAS</name> <name>AS</name><operator>)</operator> <block>{
<expr><call><name><name>PD</name><operator>.</operator><name>AddTaggedVal</name></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>underlying_type_t</name><argument_list type="generic">&lt;<argument><expr><name>LangAS</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>AS</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>DiagnosticsEngine</name><operator>::</operator><name>ArgumentKind</name><operator>::</operator><name>ak_addrspace</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>PD</name></expr>;</return>
}</block>



<specifier>inline</specifier> <specifier>const</specifier> <name>StreamingDiagnostic</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><specifier>const</specifier> <name>StreamingDiagnostic</name> <operator>&amp;</operator><name>PD</name>,
<name>Qualifiers</name> <name>Q</name><operator>)</operator> <block>{
<expr><call><name><name>PD</name><operator>.</operator><name>AddTaggedVal</name></name><argument_list>(<argument><expr><call><name><name>Q</name><operator>.</operator><name>getAsOpaqueValue</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>DiagnosticsEngine</name><operator>::</operator><name>ArgumentKind</name><operator>::</operator><name>ak_qual</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>PD</name></expr>;</return>
}</block>



<specifier>inline</specifier> <specifier>const</specifier> <name>StreamingDiagnostic</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><specifier>const</specifier> <name>StreamingDiagnostic</name> <operator>&amp;</operator><name>PD</name>,
<name>QualType</name> <name>T</name><operator>)</operator> <block>{
<expr><call><name><name>PD</name><operator>.</operator><name>AddTaggedVal</name></name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>intptr_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>T</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>DiagnosticsEngine</name><operator>::</operator><name>ak_qualtype</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>PD</name></expr>;</return>
}</block>



<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>TypeIsArrayType</name> <operator>=</operator>
<name>std</name><operator>::</operator><name><name>integral_constant</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>ArrayType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>ArrayType</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier> <name>T</name> <operator>*</operator><name>Type</name><operator>::</operator><macro><name>getAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>TypeIsArrayType</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"ArrayType cannot be used with getAs!"</literal></expr></argument>)</argument_list></call></expr>;


<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>Ty</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ty</name></expr>;</return></block_content></block></if></if_stmt></block></expr>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></range></decl></decl_stmt>



<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getUnqualifiedDesugaredType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier> <name>T</name> <operator>*</operator><name>Type</name><operator>::</operator><macro><name>getAsAdjusted</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>TypeIsArrayType</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>, <argument><expr><literal type="string">"ArrayType cannot be used with getAsAdjusted!"</literal></expr></argument>)</argument_list></call></expr>;


<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>Ty</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Ty</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>Type</name> <modifier>*</modifier></type><name>Ty</name> <init>= <expr><name>this</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>Ty</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>A</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>AttributedType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Ty</name> <operator>=</operator> <call><name><name>A</name><operator>-&gt;</operator><name>getModifiedType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>E</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ElaboratedType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Ty</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>desugar</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>P</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ParenType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Ty</name> <operator>=</operator> <call><name><name>P</name><operator>-&gt;</operator><name>desugar</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>A</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>AdjustedType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Ty</name> <operator>=</operator> <call><name><name>A</name><operator>-&gt;</operator><name>desugar</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>M</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>MacroQualifiedType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Ty</name> <operator>=</operator> <call><name><name>M</name><operator>-&gt;</operator><name>desugar</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<break>break;</break></block_content></block></else></if_stmt>
</block_content>}</block></while>



<return>return <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr>;</return>
}

inline <expr_stmt><expr><specifier>const</specifier> <name>ArrayType</name> <operator>*</operator><name>Type</name><operator>::</operator><macro><name>getAsArrayTypeUnsafe</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>arr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>



<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getUnqualifiedDesugaredType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator> <specifier>const</specifier> <name>T</name> <operator>*</operator><name>Type</name><operator>::</operator><macro><name>castAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>TypeIsArrayType</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"ArrayType cannot be used with castAs!"</literal></expr></argument>)</argument_list></call></expr>;

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>ty</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ty</name></expr>;</return></block_content></block></if></if_stmt>
<call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getUnqualifiedDesugaredType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

inline <expr_stmt><expr><specifier>const</specifier> <name>ArrayType</name> <operator>*</operator><name>Type</name><operator>::</operator><macro><name>castAsArrayTypeUnsafe</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CanonicalType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content> <return>return <expr><name>arr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getUnqualifiedDesugaredType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

DecayedType<expr_stmt><expr><operator>::</operator><macro><name>DecayedType</name><argument_list>(<argument>QualType OriginalType</argument>, <argument>QualType DecayedPtr</argument>,
<argument>QualType CanonicalPtr</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>AdjustedType</name><argument_list>(<argument>Decayed</argument>, <argument>OriginalType</argument>, <argument>DecayedPtr</argument>, <argument>CanonicalPtr</argument>)</argument_list></macro> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><name>QualType</name> <name>Adjusted</name> <operator>=</operator> <call><name>getAdjustedType</name><argument_list>()</argument_list></call></expr>;
<expr><operator>(</operator><name>void</name><operator>)</operator><name>AttributedType</name><operator>::</operator><call><name>stripOuterNullability</name><argument_list>(<argument><expr><name>Adjusted</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>PointerType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Adjusted</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>

<name>QualType</name> <name>DecayedType</name><operator>::</operator><macro><name>getPointeeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>QualType</name> <name>Decayed</name> <operator>=</operator> <call><name>getDecayedType</name><argument_list>()</argument_list></call></expr>;
<expr><operator>(</operator><name>void</name><operator>)</operator><name>AttributedType</name><operator>::</operator><call><name>stripOuterNullability</name><argument_list>(<argument><expr><name>Decayed</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>PointerType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Decayed</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPointeeType</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>





<decl_stmt><decl><type><name>void</name></type> <name>FixedPointValueToString</name><argument_list>(<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Str</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>APSInt</name> <name>Val</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>Scale</name></expr></argument>)</argument_list></decl>;</decl_stmt>

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
