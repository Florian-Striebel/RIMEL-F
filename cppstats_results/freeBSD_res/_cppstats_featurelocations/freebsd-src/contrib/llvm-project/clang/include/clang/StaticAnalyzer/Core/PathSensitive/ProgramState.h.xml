<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_PROGRAMSTATE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_PROGRAMSTATE_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/ConstraintManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/DynamicTypeInfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/Environment.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/ProgramState_Fwd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/SValBuilder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/Store.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/FoldingSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ImmutableMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Allocator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>APSInt</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>ento</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>AnalysisManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CallEvent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CallEventManager</name></decl>;</decl_stmt>

<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><call><call><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ConstraintManager</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>ConstraintManagerCreator</name></expr></argument>)</argument_list></call><argument_list>(
<argument><expr><name>ProgramStateManager</name> <operator>&amp;</operator></expr></argument>, <argument><expr><name>ExprEngine</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><call><call><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>StoreManager</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>StoreManagerCreator</name></expr></argument>)</argument_list></call><argument_list>(
<argument><expr><name>ProgramStateManager</name> <operator>&amp;</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></typedef>





<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator> struct <name>ProgramStatePartialTrait</name></expr>;</expr_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator> struct <name>ProgramStateTrait</name> <block>{
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>T</name><operator>::</operator><name>data_type</name> <name>data_type</name></expr>;</expr_stmt></typedef>
<specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <operator>*</operator><macro><name>MakeVoidPtr</name><argument_list>(<argument>data_type D</argument>)</argument_list></macro> <block>{ <return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>D</name></expr>;</return> }</block>
<specifier>static</specifier> <specifier>inline</specifier> <name>data_type</name> <macro><name>MakeData</name><argument_list>(<argument>void *const* P</argument>)</argument_list></macro> <block>{
<return>return <expr><name>P</name> <operator>?</operator> <operator>(</operator><name>data_type</name><operator>)</operator> <operator>*</operator><name>P</name> <operator>:</operator> <operator>(</operator><name>data_type</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
}</block>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>













<decl_stmt><decl><type><name>class</name></type> <name>ProgramState</name> <range>: <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>ImmutableSet</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>APSInt</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>IntSetTy</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>ImmutableMap</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>*</operator></expr></argument>, <argument><expr><name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>GenericDataMap</name></expr>;</expr_stmt></typedef>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>ProgramState</name><operator>&amp;</operator> <name>R</name><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ProgramStateManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ExplodedGraph</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ExplodedNode</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ProgramStateManager</name> <modifier>*</modifier></type><name>stateMgr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Environment</name></type> <name>Env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Store</name></type> <name>store</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GenericDataMap</name></type> <name>GDM</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>refCount</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>ProgramStateRef</name></type> <name>makeWithStore</name><argument_list>(<argument><expr><specifier>const</specifier> <name>StoreRef</name> <operator>&amp;</operator><name>store</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>setStore</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>StoreRef</name> <modifier>&amp;</modifier></type><name>storeRef</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>

<macro><name>ProgramState</name><argument_list>(<argument>ProgramStateManager *mgr</argument>, <argument>const Environment&amp; env</argument>,
<argument>StoreRef st</argument>, <argument>GenericDataMap gdm</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>



<expr_stmt><expr><call><name>ProgramState</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ProgramState</name> <operator>&amp;</operator><name>RHS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>~</operator><call><name>ProgramState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>int64_t</name> <macro><name>getID</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>ProgramStateManager</name> <operator>&amp;</operator><macro><name>getStateManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>*</operator><name>stateMgr</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>AnalysisManager</name> <operator>&amp;</operator><macro><name>getAnalysisManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>ConstraintManager</name> <operator>&amp;</operator><macro><name>getConstraintManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>Environment</name><operator>&amp;</operator> <macro><name>getEnvironment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Env</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>Store</name> <macro><name>getStore</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>store</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>GenericDataMap</name> <macro><name>getGDM</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>GDM</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setGDM</name><parameter_list>(<parameter><decl><type><name>GenericDataMap</name></type> <name>gdm</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>GDM</name> <operator>=</operator> <name>gdm</name></expr>;</expr_stmt> </block_content>}</block></function>




<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name><operator>&amp;</operator> <name>ID</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ProgramState</name> <operator>*</operator><name>V</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>V</name><operator>-&gt;</operator><name>Env</name><operator>.</operator><name>Profile</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name><name>V</name><operator>-&gt;</operator><name>store</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>V</name><operator>-&gt;</operator><name>GDM</name><operator>.</operator><name>Profile</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name><operator>&amp;</operator> <name>ID</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>BasicValueFactory</name> <operator>&amp;</operator><macro><name>getBasicVals</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>SymbolManager</name> <operator>&amp;</operator><macro><name>getSymbolManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
































<decl_stmt><decl><type><name>LLVM_NODISCARD</name> <name>ProgramStateRef</name></type> <name>assume</name><argument_list>(<argument><expr><name>DefinedOrUnknownSVal</name> <name>cond</name></expr></argument>,
<argument><expr><name>bool</name> <name>assumption</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<expr_stmt><expr><name>LLVM_NODISCARD</name> <name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>ProgramStateRef</name></expr></argument>, <argument><expr><name>ProgramStateRef</name></expr></argument>&gt;</argument_list></name>
<macro><name>assume</name><argument_list>(<argument>DefinedOrUnknownSVal cond</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<decl_stmt><decl><type><name>LLVM_NODISCARD</name> <name>ProgramStateRef</name></type>
<name>assumeInBound</name><argument_list>(<argument><expr><name>DefinedOrUnknownSVal</name> <name>idx</name></expr></argument>, <argument><expr><name>DefinedOrUnknownSVal</name> <name>upperBound</name></expr></argument>,
<argument><expr><name>bool</name> <name>assumption</name></expr></argument>, <argument><expr><name>QualType</name> <name>IndexType</name> <operator>=</operator> <call><name>QualType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list> const</decl>;</decl_stmt>







<decl_stmt><decl><type><name>LLVM_NODISCARD</name> <name>ProgramStateRef</name></type> <name>assumeInclusiveRange</name><argument_list>(<argument><expr><name>DefinedOrUnknownSVal</name> <name>Val</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>APSInt</name> <operator>&amp;</operator><name>From</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>APSInt</name> <operator>&amp;</operator><name>To</name></expr></argument>,
<argument><expr><name>bool</name> <name>assumption</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<expr_stmt><expr><name>LLVM_NODISCARD</name> <name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>ProgramStateRef</name></expr></argument>, <argument><expr><name>ProgramStateRef</name></expr></argument>&gt;</argument_list></name>
<macro><name>assumeInclusiveRange</name><argument_list>(<argument>DefinedOrUnknownSVal Val</argument>, <argument>const llvm::APSInt &amp;From</argument>,
<argument>const llvm::APSInt &amp;To</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<decl_stmt><decl><type><name>ConditionTruthVal</name></type> <name>isNonNull</name><argument_list>(<argument><expr><name>SVal</name> <name>V</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>ConditionTruthVal</name></type> <name>isNull</name><argument_list>(<argument><expr><name>SVal</name> <name>V</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>ConditionTruthVal</name></type> <name>areEqual</name><argument_list>(<argument><expr><name>SVal</name> <name>Lhs</name></expr></argument>, <argument><expr><name>SVal</name> <name>Rhs</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>VarRegion</name><modifier>*</modifier></type> <name>getRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LC</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>







<decl_stmt><decl><type><name>LLVM_NODISCARD</name> <name>ProgramStateRef</name></type> <name>BindExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LCtx</name></expr></argument>, <argument><expr><name>SVal</name> <name>V</name></expr></argument>,
<argument><expr><name>bool</name> <name>Invalidate</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>LLVM_NODISCARD</name> <name>ProgramStateRef</name></type> <name>bindLoc</name><argument_list>(<argument><expr><name>Loc</name> <name>location</name></expr></argument>, <argument><expr><name>SVal</name> <name>V</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LCtx</name></expr></argument>,
<argument><expr><name>bool</name> <name>notifyChanges</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>LLVM_NODISCARD</name> <name>ProgramStateRef</name></type> <name>bindLoc</name><argument_list>(<argument><expr><name>SVal</name> <name>location</name></expr></argument>, <argument><expr><name>SVal</name> <name>V</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LCtx</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>







<decl_stmt><decl><type><name>LLVM_NODISCARD</name> <name>ProgramStateRef</name></type>
<name>bindDefaultInitial</name><argument_list>(<argument><expr><name>SVal</name> <name>loc</name></expr></argument>, <argument><expr><name>SVal</name> <name>V</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LCtx</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>LLVM_NODISCARD</name> <name>ProgramStateRef</name></type>
<name>bindDefaultZero</name><argument_list>(<argument><expr><name>SVal</name> <name>loc</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LCtx</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>LLVM_NODISCARD</name> <name>ProgramStateRef</name></type> <name>killBinding</name><argument_list>(<argument><expr><name>Loc</name> <name>LV</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



















<decl_stmt><decl><type><name>LLVM_NODISCARD</name> <name>ProgramStateRef</name></type>
<name>invalidateRegions</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Regions</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>E</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>BlockCount</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LCtx</name></expr></argument>,
<argument><expr><name>bool</name> <name>CausesPointerEscape</name></expr></argument>, <argument><expr><name>InvalidatedSymbols</name> <operator>*</operator><name>IS</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CallEvent</name> <operator>*</operator><name>Call</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>RegionAndSymbolInvalidationTraits</name> <operator>*</operator><name>ITraits</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>LLVM_NODISCARD</name> <name>ProgramStateRef</name></type>
<name>invalidateRegions</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SVal</name></expr></argument>&gt;</argument_list></name> <name>Regions</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>E</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>BlockCount</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LCtx</name></expr></argument>,
<argument><expr><name>bool</name> <name>CausesPointerEscape</name></expr></argument>, <argument><expr><name>InvalidatedSymbols</name> <operator>*</operator><name>IS</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CallEvent</name> <operator>*</operator><name>Call</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>RegionAndSymbolInvalidationTraits</name> <operator>*</operator><name>ITraits</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>LLVM_NODISCARD</name> <name>ProgramStateRef</name></type> <name>enterStackFrame</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>CallEvent</name> <operator>&amp;</operator><name>Call</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><name>CalleeCtx</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>SVal</name></type> <name>getSelfSVal</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LC</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>Loc</name></type> <name>getLValue</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXBaseSpecifier</name> <operator>&amp;</operator><name>BaseSpec</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>SubRegion</name> <operator>*</operator><name>Super</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>Loc</name></type> <name>getLValue</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>BaseClass</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>SubRegion</name> <operator>*</operator><name>Super</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsVirtual</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>Loc</name></type> <name>getLValue</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>Call</name></expr></argument>, <argument><expr><name>unsigned</name> <name>Index</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LC</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>Loc</name></type> <name>getLValue</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LC</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>Loc</name></type> <name>getLValue</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CompoundLiteralExpr</name> <operator>*</operator><name>literal</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LC</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>SVal</name></type> <name>getLValue</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCIvarDecl</name> <operator>*</operator><name>decl</name></expr></argument>, <argument><expr><name>SVal</name> <name>base</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>SVal</name></type> <name>getLValue</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><name>decl</name></expr></argument>, <argument><expr><name>SVal</name> <name>Base</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>SVal</name></type> <name>getLValue</name><argument_list>(<argument><expr><specifier>const</specifier> <name>IndirectFieldDecl</name> <operator>*</operator><name>decl</name></expr></argument>, <argument><expr><name>SVal</name> <name>Base</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>SVal</name></type> <name>getLValue</name><argument_list>(<argument><expr><name>QualType</name> <name>ElementType</name></expr></argument>, <argument><expr><name>SVal</name> <name>Idx</name></expr></argument>, <argument><expr><name>SVal</name> <name>Base</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>SVal</name></type> <name>getSVal</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LCtx</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>SVal</name></type> <name>getSValAsScalarOrLoc</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>Ex</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LCtx</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>SVal</name></type> <name>getSVal</name><argument_list>(<argument><expr><name>Loc</name> <name>LV</name></expr></argument>, <argument><expr><name>QualType</name> <name>T</name> <operator>=</operator> <call><name>QualType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>SVal</name></type> <name>getRawSVal</name><argument_list>(<argument><expr><name>Loc</name> <name>LV</name></expr></argument>, <argument><expr><name>QualType</name> <name>T</name><operator>=</operator> <call><name>QualType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>SVal</name></type> <name>getSVal</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MemRegion</name><operator>*</operator> <name>R</name></expr></argument>, <argument><expr><name>QualType</name> <name>T</name> <operator>=</operator> <call><name>QualType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>SVal</name></type> <name>getSValAsScalarOrLoc</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><name>R</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>region_iterator</name> <init>= <expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><operator>*</operator></expr></init></decl>;</decl_stmt>








<decl_stmt><decl><type><name>bool</name></type> <name>scanReachableSymbols</name><argument_list>(<argument><expr><name>SVal</name> <name>val</name></expr></argument>, <argument><expr><name>SymbolVisitor</name><operator>&amp;</operator> <name>visitor</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>scanReachableSymbols</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>region_iterator</name></expr></argument>&gt;</argument_list></name> <name>Reachable</name></expr></argument>,
<argument><expr><name>SymbolVisitor</name> <operator>&amp;</operator><name>visitor</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>CB</name></expr></argument>&gt;</argument_list></name> <name>CB</name></type> <name>scanReachableSymbols</name><argument_list>(<argument><expr><name>SVal</name> <name>val</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>CB</name></expr></argument>&gt;</argument_list></name> <name>CB</name></type>
<name>scanReachableSymbols</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>region_iterator</name></expr></argument>&gt;</argument_list></name> <name>Reachable</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type> <name>FindGDM</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>K</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>LLVM_NODISCARD</name> <name>ProgramStateRef</name></type>
<name>add</name><argument_list>(<argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>key_type</name> <name>K</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>data_type</name>
<macro><name>get</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>MakeData</name><argument_list>(<argument><expr><call><name>FindGDM</name><argument_list>(<argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>GDMIndex</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>lookup_type</name>
<macro><name>get</name><argument_list>(<argument>typename ProgramStateTrait&lt;T&gt;::key_type key</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>void</name> <operator>*</operator><specifier>const</specifier><operator>*</operator> <name>d</name> <operator>=</operator> <call><name>FindGDM</name><argument_list>(<argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>GDMIndex</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Lookup</name><argument_list>(<argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>MakeData</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>context_type</name> <macro><name>get_context</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>LLVM_NODISCARD</name> <name>ProgramStateRef</name></type>
<name>remove</name><argument_list>(<argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>key_type</name> <name>K</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>LLVM_NODISCARD</name> <name>ProgramStateRef</name></type>
<name>remove</name><argument_list>(<argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>key_type</name> <name>K</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>context_type</name> <name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>LLVM_NODISCARD</name> <name>ProgramStateRef</name> <macro><name>remove</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>LLVM_NODISCARD</name> <name>ProgramStateRef</name></type>
<name>set</name><argument_list>(<argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>data_type</name> <name>D</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>LLVM_NODISCARD</name> <name>ProgramStateRef</name></type>
<name>set</name><argument_list>(<argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>key_type</name> <name>K</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value_type</name> <name>E</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>LLVM_NODISCARD</name> <name>ProgramStateRef</name></type>
<name>set</name><argument_list>(<argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>key_type</name> <name>K</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value_type</name> <name>E</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>context_type</name> <name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>contains</name><argument_list>(<argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>key_type</name> <name>key</name></expr></argument>)</argument_list> const <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type> <name>d</name> <init>= <expr><call><name>FindGDM</name><argument_list>(<argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>GDMIndex</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Contains</name><argument_list>(<argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>MakeData</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>printJson</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>Out</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LCtx</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>NL</name> <operator>=</operator> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>unsigned</name> <name>int</name> <name>Space</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><name>bool</name> <name>IsDot</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>printDOT</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>Out</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LCtx</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>int</name> <name>Space</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<label><name>private</name>:</label>
<function_decl><type><name>friend</name> <name>void</name></type> <name>ProgramStateRetain</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProgramState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>friend</name> <name>void</name></type> <name>ProgramStateRelease</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProgramState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>ProgramStateRef</name></type>
<name>invalidateRegionsImpl</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SVal</name></expr></argument>&gt;</argument_list></name> <name>Values</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>E</name></expr></argument>, <argument><expr><name>unsigned</name> <name>BlockCount</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LCtx</name></expr></argument>,
<argument><expr><name>bool</name> <name>ResultsInSymbolEscape</name></expr></argument>,
<argument><expr><name>InvalidatedSymbols</name> <operator>*</operator><name>IS</name></expr></argument>,
<argument><expr><name>RegionAndSymbolInvalidationTraits</name> <operator>*</operator><name>HTraits</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CallEvent</name> <operator>*</operator><name>Call</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>





<decl_stmt><decl><type><name>class</name></type> <name>ProgramStateManager</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ProgramState</name></decl>;</decl_stmt>
<function_decl><type><name>friend</name> <name>void</name></type> <name>ProgramStateRelease</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProgramState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<label><name>private</name>:</label>

<decl_stmt><decl><type><name>ExprEngine</name> <modifier>*</modifier></type><name>Eng</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>EnvironmentManager</name></type> <name>EnvMgr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>StoreManager</name></expr></argument>&gt;</argument_list></name> <name>StoreMgr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ConstraintManager</name></expr></argument>&gt;</argument_list></name> <name>ConstraintMgr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ProgramState</name><operator>::</operator><name>GenericDataMap</name><operator>::</operator><name>Factory</name> <name>GDMFactory</name></expr>;</expr_stmt>

<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>*</operator></expr></argument>,<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>*</operator></expr></argument>,<argument><expr><name>void</name> <operator>(</operator><operator>*</operator><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <name>GDMContextsTy</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>GDMContextsTy</name></type> <name>GDMContexts</name></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>ProgramState</name></expr></argument>&gt;</argument_list></name> <name>StateSet</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>SValBuilder</name></expr></argument>&gt;</argument_list></name> <name>svalBuilder</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CallEventManager</name></expr></argument>&gt;</argument_list></name> <name>CallEventMgr</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name> <operator>&amp;</operator><name>Alloc</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ProgramState</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>freeStates</name></expr>;</expr_stmt>

<label><name>public</name>:</label>
<macro><name>ProgramStateManager</name><argument_list>(<argument>ASTContext &amp;Ctx</argument>,
<argument>StoreManagerCreator CreateStoreManager</argument>,
<argument>ConstraintManagerCreator CreateConstraintManager</argument>,
<argument>llvm::BumpPtrAllocator&amp; alloc</argument>,
<argument>ExprEngine *expreng</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><operator>~</operator><call><name>ProgramStateManager</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>ProgramStateRef</name></type> <name>getInitialState</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LocationContext</name> <modifier>*</modifier></type><name>InitLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>getContext</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>svalBuilder</name><operator>-&gt;</operator><name>getContext</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><macro><name>getContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>svalBuilder</name><operator>-&gt;</operator><name>getContext</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>BasicValueFactory</name> <modifier>&amp;</modifier></type><name>getBasicVals</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>svalBuilder</name><operator>-&gt;</operator><name>getBasicValueFactory</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>SValBuilder</name> <modifier>&amp;</modifier></type><name>getSValBuilder</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><operator>*</operator><name>svalBuilder</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>SValBuilder</name> <operator>&amp;</operator><macro><name>getSValBuilder</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>*</operator><name>svalBuilder</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>SymbolManager</name> <modifier>&amp;</modifier></type><name>getSymbolManager</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>svalBuilder</name><operator>-&gt;</operator><name>getSymbolManager</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>SymbolManager</name> <operator>&amp;</operator><macro><name>getSymbolManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>svalBuilder</name><operator>-&gt;</operator><name>getSymbolManager</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name><operator>&amp;</operator> <macro><name>getAllocator</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Alloc</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>MemRegionManager</name><modifier>&amp;</modifier></type> <name>getRegionManager</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>svalBuilder</name><operator>-&gt;</operator><name>getRegionManager</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>MemRegionManager</name> <operator>&amp;</operator><macro><name>getRegionManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>svalBuilder</name><operator>-&gt;</operator><name>getRegionManager</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>CallEventManager</name> <modifier>&amp;</modifier></type><name>getCallEventManager</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><name>CallEventMgr</name></expr>;</return> </block_content>}</block></function>

<function><type><name>StoreManager</name> <modifier>&amp;</modifier></type><name>getStoreManager</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><name>StoreMgr</name></expr>;</return> </block_content>}</block></function>
<function><type><name>ConstraintManager</name> <modifier>&amp;</modifier></type><name>getConstraintManager</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><name>ConstraintMgr</name></expr>;</return> </block_content>}</block></function>
<function><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>getOwningEngine</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><name>Eng</name></expr>;</return> </block_content>}</block></function>

<function_decl><type><name>ProgramStateRef</name></type>
<name>removeDeadBindingsFromEnvironmentAndStore</name><parameter_list>(<parameter><decl><type><name>ProgramStateRef</name></type> <name>St</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>StackFrameContext</name> <modifier>*</modifier></type><name>LCtx</name></decl></parameter>,
<parameter><decl><type><name>SymbolReaper</name> <modifier>&amp;</modifier></type><name>SymReaper</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>

<function><type><name>SVal</name></type> <name>ArrayToPointer</name><parameter_list>(<parameter><decl><type><name>Loc</name></type> <name>Array</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ElementTy</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>StoreMgr</name><operator>-&gt;</operator><name>ArrayToPointer</name></name><argument_list>(<argument><expr><name>Array</name></expr></argument>, <argument><expr><name>ElementTy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name>ProgramStateRef</name></type> <name>addGDM</name><parameter_list>(<parameter><decl><type><name>ProgramStateRef</name></type> <name>St</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>Key</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>Data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ProgramStateRef</name></type> <name>removeGDM</name><parameter_list>(<parameter><decl><type><name>ProgramStateRef</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>Key</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>void</name></type> <name>iterBindings</name><argument_list>(<argument><expr><name>ProgramStateRef</name> <name>state</name></expr></argument>, <argument><expr><name>StoreManager</name><operator>::</operator><name>BindingsHandler</name><operator>&amp;</operator> <name>F</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>StoreMgr</name><operator>-&gt;</operator><name>iterBindings</name></name><argument_list>(<argument><expr><call><name><name>state</name><operator>-&gt;</operator><name>getStore</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>F</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function_decl><type><name>ProgramStateRef</name></type> <name>getPersistentState</name><parameter_list>(<parameter><decl><type><name>ProgramState</name> <modifier>&amp;</modifier></type><name>Impl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ProgramStateRef</name></type> <name>getPersistentStateWithGDM</name><parameter_list>(<parameter><decl><type><name>ProgramStateRef</name></type> <name>FromState</name></decl></parameter>,
<parameter><decl><type><name>ProgramStateRef</name></type> <name>GDMState</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>bool</name></type> <name>haveEqualConstraints</name><argument_list>(<argument><expr><name>ProgramStateRef</name> <name>S1</name></expr></argument>, <argument><expr><name>ProgramStateRef</name> <name>S2</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>ConstraintMgr</name><operator>-&gt;</operator><name>haveEqualConstraints</name></name><argument_list>(<argument><expr><name>S1</name></expr></argument>, <argument><expr><name>S2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>haveEqualEnvironments</name><argument_list>(<argument><expr><name>ProgramStateRef</name> <name>S1</name></expr></argument>, <argument><expr><name>ProgramStateRef</name> <name>S2</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name><name>S1</name><operator>-&gt;</operator><name>Env</name></name> <operator>==</operator> <name><name>S2</name><operator>-&gt;</operator><name>Env</name></name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>haveEqualStores</name><argument_list>(<argument><expr><name>ProgramStateRef</name> <name>S1</name></expr></argument>, <argument><expr><name>ProgramStateRef</name> <name>S2</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name><name>S1</name><operator>-&gt;</operator><name>store</name></name> <operator>==</operator> <name><name>S2</name><operator>-&gt;</operator><name>store</name></name></expr>;</return>
</block_content>}</block></decl></decl_stmt>




















<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>ProgramStateRef</name></type> <name>set</name><argument_list>(<argument><expr><name>ProgramStateRef</name> <name>st</name></expr></argument>, <argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>data_type</name> <name>D</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>addGDM</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>GDMIndex</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>MakeVoidPtr</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>ProgramStateRef</name></type> <name>set</name><argument_list>(<argument><expr><name>ProgramStateRef</name> <name>st</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>key_type</name> <name>K</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value_type</name> <name>V</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>context_type</name> <name>C</name></expr></argument>)</argument_list> <block>{<block_content>

<return>return <expr><call><name>addGDM</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>GDMIndex</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>MakeVoidPtr</name><argument_list>(<argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Set</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>get</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><name>K</name></expr></argument>, <argument><expr><name>V</name></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>ProgramStateRef</name></type> <name>add</name><argument_list>(<argument><expr><name>ProgramStateRef</name> <name>st</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>key_type</name> <name>K</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>context_type</name> <name>C</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>addGDM</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>GDMIndex</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>MakeVoidPtr</name><argument_list>(<argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Add</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>get</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><name>K</name></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>ProgramStateRef</name></type> <name>remove</name><argument_list>(<argument><expr><name>ProgramStateRef</name> <name>st</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>key_type</name> <name>K</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>context_type</name> <name>C</name></expr></argument>)</argument_list> <block>{<block_content>

<return>return <expr><call><name>addGDM</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>GDMIndex</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>MakeVoidPtr</name><argument_list>(<argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Remove</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>get</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><name>K</name></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>ProgramStateRef</name></type> <name>remove</name><parameter_list>(<parameter><decl><type><name>ProgramStateRef</name></type> <name>st</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>removeGDM</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>GDMIndex</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>FindGDMContext</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>index</name></expr></argument>,
<argument><expr><name>void</name> <operator>*</operator><call>(<modifier>*</modifier><name>CreateContext</name>)<argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name><operator>&amp;</operator></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator><name>DeleteContext</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>context_type</name> <macro><name>get_context</name><argument_list>()</argument_list></macro> <block>{
<expr><name>void</name> <operator>*</operator><name>p</name> <operator>=</operator> <call><name>FindGDMContext</name><argument_list>(<argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>GDMIndex</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>CreateContext</name></expr></argument>,
<argument><expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>DeleteContext</name></expr></argument>)</argument_list></call></expr>;

<return>return <expr><name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>MakeContext</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>






<expr_stmt><expr><specifier>inline</specifier> <name>ConstraintManager</name> <operator>&amp;</operator><name>ProgramState</name><operator>::</operator><macro><name>getConstraintManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>stateMgr</name><operator>-&gt;</operator><name>getConstraintManager</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>inline</specifier> <specifier>const</specifier> <name>VarRegion</name><operator>*</operator> <name>ProgramState</name><operator>::</operator><macro><name>getRegion</name><argument_list>(<argument>const VarDecl *D</argument>,
<argument>const LocationContext *LC</argument>)</argument_list></macro> <specifier>const</specifier>
<block>{
<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getRegionManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getVarRegion</name><argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr><name>LC</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>ProgramStateRef</name> <name>ProgramState</name><operator>::</operator><macro><name>assume</name><argument_list>(<argument>DefinedOrUnknownSVal Cond</argument>,
<argument>bool Assumption</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Cond</name><operator>.</operator><name>isUnknown</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>this</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>ConstraintMgr</name>
<operator>-&gt;</operator><name>assume</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>Cond</name><operator>.</operator><name>castAs</name></name><operator>&lt;</operator><name>DefinedSVal</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><name>Assumption</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>ProgramStateRef</name></expr></argument> , <argument><expr><name>ProgramStateRef</name></expr></argument> &gt;</argument_list></name>
<name>ProgramState</name><operator>::</operator><macro><name>assume</name><argument_list>(<argument>DefinedOrUnknownSVal Cond</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Cond</name><operator>.</operator><name>isUnknown</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>std</name><operator>::</operator><call><name>make_pair</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>ConstraintMgr</name>
<operator>-&gt;</operator><name>assumeDual</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>Cond</name><operator>.</operator><name>castAs</name></name><operator>&lt;</operator><name>DefinedSVal</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
}

inline <expr_stmt><expr><name>ProgramStateRef</name> <name>ProgramState</name><operator>::</operator><macro><name>assumeInclusiveRange</name><argument_list>(
<argument>DefinedOrUnknownSVal Val</argument>, <argument>const llvm::APSInt &amp;From</argument>, <argument>const llvm::APSInt &amp;To</argument>,
<argument>bool Assumption</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Val</name><operator>.</operator><name>isUnknown</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>this</name></expr>;</return></block_content></block></if></if_stmt>

<call><name>assert</name><argument_list>(<argument><expr><name><name>Val</name><operator>.</operator><name>getAs</name></name><operator>&lt;</operator><name>NonLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Only NonLocs are supported!"</literal></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>ConstraintMgr</name><operator>-&gt;</operator><name>assumeInclusiveRange</name></name><argument_list>(
<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>Val</name><operator>.</operator><name>castAs</name></name><operator>&lt;</operator><name>NonLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><name>From</name></expr></argument>, <argument><expr><name>To</name></expr></argument>, <argument><expr><name>Assumption</name></expr></argument>)</argument_list></call></expr>;</return>
}

inline <expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>ProgramStateRef</name></expr></argument>, <argument><expr><name>ProgramStateRef</name></expr></argument>&gt;</argument_list></name>
<name>ProgramState</name><operator>::</operator><macro><name>assumeInclusiveRange</name><argument_list>(<argument>DefinedOrUnknownSVal Val</argument>,
<argument>const llvm::APSInt &amp;From</argument>,
<argument>const llvm::APSInt &amp;To</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Val</name><operator>.</operator><name>isUnknown</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>std</name><operator>::</operator><call><name>make_pair</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<call><name>assert</name><argument_list>(<argument><expr><name><name>Val</name><operator>.</operator><name>getAs</name></name><operator>&lt;</operator><name>NonLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Only NonLocs are supported!"</literal></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>ConstraintMgr</name><operator>-&gt;</operator><name>assumeInclusiveRangeDual</name></name><argument_list>(
<argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>Val</name><operator>.</operator><name>castAs</name></name><operator>&lt;</operator><name>NonLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><name>From</name></expr></argument>, <argument><expr><name>To</name></expr></argument>)</argument_list></call></expr>;</return>
}

inline <expr_stmt><expr><name>ProgramStateRef</name> <name>ProgramState</name><operator>::</operator><macro><name>bindLoc</name><argument_list>(<argument>SVal LV</argument>, <argument>SVal V</argument>, <argument>const LocationContext *LCtx</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>Loc</name></expr></argument>&gt;</argument_list></name></type> <name>L</name> <init>= <expr><name><name>LV</name><operator>.</operator><name>getAs</name></name><operator>&lt;</operator><name>Loc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>bindLoc</name><argument_list>(<argument><expr><operator>*</operator><name>L</name></expr></argument>, <argument><expr><name>V</name></expr></argument>, <argument><expr><name>LCtx</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>this</name></expr>;</return>
}

inline <expr_stmt><expr><name>Loc</name> <name>ProgramState</name><operator>::</operator><macro><name>getLValue</name><argument_list>(<argument>const CXXBaseSpecifier &amp;BaseSpec</argument>,
<argument>const SubRegion *Super</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>auto</name> <operator>*</operator><name>Base</name> <operator>=</operator> <call><name><name>BaseSpec</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getAsCXXRecordDecl</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>loc</name><operator>::</operator><call><name>MemRegionVal</name><argument_list>(
<argument><expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getRegionManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCXXBaseObjectRegion</name><argument_list>(
<argument><expr><name>Base</name></expr></argument>, <argument><expr><name>Super</name></expr></argument>, <argument><expr><call><name><name>BaseSpec</name><operator>.</operator><name>isVirtual</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>Loc</name> <name>ProgramState</name><operator>::</operator><macro><name>getLValue</name><argument_list>(<argument>const CXXRecordDecl *BaseClass</argument>,
<argument>const SubRegion *Super</argument>,
<argument>bool IsVirtual</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>loc</name><operator>::</operator><call><name>MemRegionVal</name><argument_list>(
<argument><expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getRegionManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCXXBaseObjectRegion</name><argument_list>(
<argument><expr><name>BaseClass</name></expr></argument>, <argument><expr><name>Super</name></expr></argument>, <argument><expr><name>IsVirtual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>Loc</name> <name>ProgramState</name><operator>::</operator><macro><name>getLValue</name><argument_list>(<argument>const VarDecl *VD</argument>,
<argument>const LocationContext *LC</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>StoreMgr</name><operator>-&gt;</operator><name>getLValueVar</name></name><argument_list>(<argument><expr><name>VD</name></expr></argument>, <argument><expr><name>LC</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>Loc</name> <name>ProgramState</name><operator>::</operator><macro><name>getLValue</name><argument_list>(<argument>const CompoundLiteralExpr *literal</argument>,
<argument>const LocationContext *LC</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>StoreMgr</name><operator>-&gt;</operator><name>getLValueCompoundLiteral</name></name><argument_list>(<argument><expr><name>literal</name></expr></argument>, <argument><expr><name>LC</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>SVal</name> <name>ProgramState</name><operator>::</operator><macro><name>getLValue</name><argument_list>(<argument>const ObjCIvarDecl *D</argument>, <argument>SVal Base</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>StoreMgr</name><operator>-&gt;</operator><name>getLValueIvar</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr><name>Base</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>SVal</name> <name>ProgramState</name><operator>::</operator><macro><name>getLValue</name><argument_list>(<argument>const FieldDecl *D</argument>, <argument>SVal Base</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>StoreMgr</name><operator>-&gt;</operator><name>getLValueField</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr><name>Base</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>SVal</name> <name>ProgramState</name><operator>::</operator><macro><name>getLValue</name><argument_list>(<argument>const IndirectFieldDecl *D</argument>,
<argument>SVal Base</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>StoreManager</name> <operator>&amp;</operator><name>SM</name> <operator>=</operator> <operator>*</operator><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><name>StoreMgr</name></expr>;
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>I</name> <range>: <expr><call><name><name>D</name><operator>-&gt;</operator><name>chain</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<expr_stmt><expr><name>Base</name> <operator>=</operator> <call><name><name>SM</name><operator>.</operator><name>getLValueField</name></name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>FieldDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>

<return>return <expr><name>Base</name></expr>;</return>
}

inline <expr_stmt><expr><name>SVal</name> <name>ProgramState</name><operator>::</operator><macro><name>getLValue</name><argument_list>(<argument>QualType ElementType</argument>, <argument>SVal Idx</argument>, <argument>SVal Base</argument>)</argument_list></macro> <specifier>const</specifier><block>{
<if_stmt><if>if <condition>(<decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>NonLoc</name></expr></argument>&gt;</argument_list></name></type> <name>N</name> <init>= <expr><name><name>Idx</name><operator>.</operator><name>getAs</name></name><operator>&lt;</operator><name>NonLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>StoreMgr</name><operator>-&gt;</operator><name>getLValueElement</name></name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>, <argument><expr><operator>*</operator><name>N</name></expr></argument>, <argument><expr><name>Base</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>UnknownVal</name><argument_list>()</argument_list></call></expr>;</return>
}

inline <expr_stmt><expr><name>SVal</name> <name>ProgramState</name><operator>::</operator><macro><name>getSVal</name><argument_list>(<argument>const Stmt *Ex</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro> <specifier>const</specifier><block>{
<return>return <expr><call><name><name>Env</name><operator>.</operator><name>getSVal</name></name><argument_list>(<argument><expr><call><name>EnvironmentEntry</name><argument_list>(<argument><expr><name>Ex</name></expr></argument>, <argument><expr><name>LCtx</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>*</operator><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><name>svalBuilder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>SVal</name>
<name>ProgramState</name><operator>::</operator><macro><name>getSValAsScalarOrLoc</name><argument_list>(<argument>const Stmt *S</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Ex</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QualType</name></type> <name>T</name> <init>= <expr><call><name><name>Ex</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Ex</name><operator>-&gt;</operator><name>isGLValue</name></name><argument_list>()</argument_list></call> <operator>||</operator> <name>Loc</name><operator>::</operator><call><name>isLocType</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>isIntegralOrEnumerationType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getSVal</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>LCtx</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>

<return>return <expr><call><name>UnknownVal</name><argument_list>()</argument_list></call></expr>;</return>
}

inline <expr_stmt><expr><name>SVal</name> <name>ProgramState</name><operator>::</operator><macro><name>getRawSVal</name><argument_list>(<argument>Loc LV</argument>, <argument>QualType T</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>StoreMgr</name><operator>-&gt;</operator><name>getBinding</name></name><argument_list>(<argument><expr><call><name>getStore</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>LV</name></expr></argument>, <argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>SVal</name> <name>ProgramState</name><operator>::</operator><macro><name>getSVal</name><argument_list>(<argument>const MemRegion* R</argument>, <argument>QualType T</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>StoreMgr</name><operator>-&gt;</operator><name>getBinding</name></name><argument_list>(<argument><expr><call><name>getStore</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>loc</name><operator>::</operator><call><name>MemRegionVal</name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>BasicValueFactory</name> <operator>&amp;</operator><name>ProgramState</name><operator>::</operator><macro><name>getBasicVals</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBasicVals</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>SymbolManager</name> <operator>&amp;</operator><name>ProgramState</name><operator>::</operator><macro><name>getSymbolManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSymbolManager</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>ProgramStateRef</name> <name>ProgramState</name><operator>::</operator><macro><name>add</name><argument_list>(<argument>typename ProgramStateTrait&lt;T&gt;::key_type K</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>add</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>K</name></expr></argument>, <argument><expr><call><name><name>get_context</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name><name>ProgramStateTrait</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>context_type</name> <name>ProgramState</name><operator>::</operator><macro><name>get_context</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>get_context</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>ProgramStateRef</name> <name>ProgramState</name><operator>::</operator><macro><name>remove</name><argument_list>(<argument>typename ProgramStateTrait&lt;T&gt;::key_type K</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>remove</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>K</name></expr></argument>, <argument><expr><call><name><name>get_context</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>ProgramStateRef</name> <name>ProgramState</name><operator>::</operator><macro><name>remove</name><argument_list>(<argument>typename ProgramStateTrait&lt;T&gt;::key_type K</argument>,
<argument>typename ProgramStateTrait&lt;T&gt;::context_type C</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>remove</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>K</name></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>ProgramStateRef</name> <name>ProgramState</name><operator>::</operator><macro><name>remove</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>remove</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>ProgramStateRef</name> <name>ProgramState</name><operator>::</operator><macro><name>set</name><argument_list>(<argument>typename ProgramStateTrait&lt;T&gt;::data_type D</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>ProgramStateRef</name> <name>ProgramState</name><operator>::</operator><macro><name>set</name><argument_list>(<argument>typename ProgramStateTrait&lt;T&gt;::key_type K</argument>,
<argument>typename ProgramStateTrait&lt;T&gt;::value_type E</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>K</name></expr></argument>, <argument><expr><name>E</name></expr></argument>, <argument><expr><call><name><name>get_context</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>ProgramStateRef</name> <name>ProgramState</name><operator>::</operator><macro><name>set</name><argument_list>(<argument>typename ProgramStateTrait&lt;T&gt;::key_type K</argument>,
<argument>typename ProgramStateTrait&lt;T&gt;::value_type E</argument>,
<argument>typename ProgramStateTrait&lt;T&gt;::context_type C</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>K</name></expr></argument>, <argument><expr><name>E</name></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>CB</name></expr></argument>&gt;</argument_list></name>
<name>CB</name> <name>ProgramState</name><operator>::</operator><macro><name>scanReachableSymbols</name><argument_list>(<argument>SVal val</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>CB</name> <call><name>cb</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>scanReachableSymbols</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>cb</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>CB</name></expr></argument>&gt;</argument_list></name>
<name>CB</name> <name>ProgramState</name><operator>::</operator><macro><name>scanReachableSymbols</name><argument_list>(
<argument>llvm::iterator_range&lt;region_iterator&gt; Reachable</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>CB</name> <call><name>cb</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>scanReachableSymbols</name><argument_list>(<argument><expr><name>Reachable</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>cb</name></expr>;</return>
}</block></expr></expr_stmt>





<decl_stmt><decl><type><name>class</name></type> <name>ScanReachableSymbols</name> <block>{<block_content>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseSet</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>VisitedItems</name></expr>;</expr_stmt></typedef>

<decl_stmt><decl><type><name>VisitedItems</name></type> <name>visited</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ProgramStateRef</name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SymbolVisitor</name> <modifier>&amp;</modifier></type><name>visitor</name></decl>;</decl_stmt>
<label><name>public</name>:</label>
<macro><name>ScanReachableSymbols</name><argument_list>(<argument>ProgramStateRef st</argument>, <argument>SymbolVisitor &amp;v</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>state</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>visitor</name><argument_list>(<argument>v</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>scan</name><argument_list>(<argument>nonloc::LazyCompoundVal val</argument>)</argument_list></macro></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>scan</name><argument_list>(<argument><expr><name>nonloc</name><operator>::</operator><name>CompoundVal</name> <name>val</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>bool</name></type> <name>scan</name><parameter_list>(<parameter><decl><type><name>SVal</name></type> <name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>scan</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MemRegion</name> <modifier>*</modifier></type><name>R</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>scan</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SymExpr</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>)</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

}

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
