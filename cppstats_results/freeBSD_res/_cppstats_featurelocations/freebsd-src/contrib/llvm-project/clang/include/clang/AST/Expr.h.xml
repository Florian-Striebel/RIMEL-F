<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/Expr.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_EXPR_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_EXPR_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/APValue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ComputeDependence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclAccessPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DependenceFlags.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/OperationKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Stmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TemplateBase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/CharInfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LangOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SyncScope.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TypeTraits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/APFloat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/APSInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/AtomicOrdering.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/TrailingObjects.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>APValue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BlockDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXBaseSpecifier</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXMemberCallExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXOperatorCallExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CastExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Decl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>IdentifierInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MaterializeTemporaryExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>NamedDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCPropertyRefExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>OpaqueValueExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ParmVarDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>StringLiteral</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TargetInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ValueDecl</name></decl>;</decl_stmt>


<typedef>typedef <type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>CXXBaseSpecifier</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>CXXCastPath</name>;</typedef>



<struct>struct <name>SubobjectAdjustment</name> <block>{
<enum>enum <block>{
<decl><name>DerivedToBaseAdjustment</name></decl>,
<decl><name>FieldAdjustment</name></decl>,
<decl><name>MemberPointerAdjustment</name></decl>
}</block> <decl><name>Kind</name></decl>;</enum>

<struct>struct <name>DTB</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>CastExpr</name> <modifier>*</modifier></type><name>BasePath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>DerivedClass</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>P</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>MemberPointerType</name> <modifier>*</modifier></type><name>MPT</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHS</name></decl>;</decl_stmt>
}</block>;</struct>

<union>union <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>DTB</name></name></type> <name>DerivedToBase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>Field</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>P</name></name></type> <name>Ptr</name></decl>;</decl_stmt>
}</block>;</union>

<expr_stmt><expr><call><name>SubobjectAdjustment</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CastExpr</name> <operator>*</operator><name>BasePath</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>DerivedClass</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>Kind</name><argument_list>(<argument>DerivedToBaseAdjustment</argument>)</argument_list></macro> <block>{
<expr><name><name>DerivedToBase</name><operator>.</operator><name>BasePath</name></name> <operator>=</operator> <name>BasePath</name></expr>;
<expr><name><name>DerivedToBase</name><operator>.</operator><name>DerivedClass</name></name> <operator>=</operator> <name>DerivedClass</name></expr>;
}</block>

<call><name>SubobjectAdjustment</name><argument_list>(<argument><expr><name>FieldDecl</name> <operator>*</operator><name>Field</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>Kind</name><argument_list>(<argument>FieldAdjustment</argument>)</argument_list></macro> <block>{
<expr><name><name>this</name><operator>-&gt;</operator><name>Field</name></name> <operator>=</operator> <name>Field</name></expr>;
}</block>

<call><name>SubobjectAdjustment</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MemberPointerType</name> <operator>*</operator><name>MPT</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>RHS</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>Kind</name><argument_list>(<argument>MemberPointerAdjustment</argument>)</argument_list></macro> <block>{
<expr><name><name>this</name><operator>-&gt;</operator><name>Ptr</name><operator>.</operator><name>MPT</name></name> <operator>=</operator> <name>MPT</name></expr>;
<expr><name><name>this</name><operator>-&gt;</operator><name>Ptr</name><operator>.</operator><name>RHS</name></name> <operator>=</operator> <name>RHS</name></expr>;
}</block></expr></expr_stmt>
}</block>;</struct>




<decl_stmt><decl><type><name>class</name></type> <name>Expr</name> <range>: <expr><name>public</name> <name>ValueStmt</name> <block>{
<expr><name>QualType</name> <name>TR</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>Expr</name><argument_list>()</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><call><name>Expr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name><operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><call><name>Expr</name><argument_list>(<argument><expr><name>Expr</name> <operator>&amp;&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><name>Expr</name> <operator>&amp;</operator><name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>Expr</name><operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr>;
<expr><name>Expr</name> <operator>&amp;</operator><name>operator</name><operator>=</operator><operator>(</operator><name>Expr</name><operator>&amp;&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>Expr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>QualType T</argument>, <argument>ExprValueKind VK</argument>, <argument>ExprObjectKind OK</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>ValueStmt</name><argument_list>(<argument>SC</argument>)</argument_list></macro> <block>{
<expr><name><name>ExprBits</name><operator>.</operator><name>Dependent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name><name>ExprBits</name><operator>.</operator><name>ValueKind</name></name> <operator>=</operator> <name>VK</name></expr>;
<expr><name><name>ExprBits</name><operator>.</operator><name>ObjectKind</name></name> <operator>=</operator> <name>OK</name></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ExprBits</name><operator>.</operator><name>ObjectKind</name></name> <operator>==</operator> <name>OK</name> <operator>&amp;&amp;</operator> <literal type="string">"truncated kind"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setType</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>Expr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>EmptyShell</argument>)</argument_list></macro> <operator>:</operator> <macro><name>ValueStmt</name><argument_list>(<argument>SC</argument>)</argument_list></macro> <block>{ }</block>



<name>void</name> <macro><name>setDependence</name><argument_list>(<argument>ExprDependence Deps</argument>)</argument_list></macro> <block>{
<expr><name><name>ExprBits</name><operator>.</operator><name>Dependent</name></name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Deps</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>friend</name> <name>class</name> <name>ASTImporter</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TR</name></expr>;</return> }</block>
<name>void</name> <macro><name>setType</name><argument_list>(<argument>QualType t</argument>)</argument_list></macro> <block>{






<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name><name>t</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>t</name><operator>-&gt;</operator><name>isReferenceType</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Expressions can't have reference type"</literal></expr></argument>)</argument_list></call></expr>;

<expr><name>TR</name> <operator>=</operator> <name>t</name></expr>;
}</block>

<name>ExprDependence</name> <macro><name>getDependence</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExprDependence</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>ExprBits</name><operator>.</operator><name>Dependent</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>










<name>bool</name> <macro><name>isValueDependent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDependence</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>ExprDependence</name><operator>::</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>














<name>bool</name> <macro><name>isTypeDependent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDependence</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>ExprDependence</name><operator>::</operator><name>Type</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


























<name>bool</name> <macro><name>isInstantiationDependent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDependence</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>ExprDependence</name><operator>::</operator><name>Instantiation</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>















<name>bool</name> <macro><name>containsUnexpandedParameterPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDependence</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>ExprDependence</name><operator>::</operator><name>UnexpandedPack</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>containsErrors</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDependence</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>ExprDependence</name><operator>::</operator><name>Error</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>SourceLocation</name> <macro><name>getExprLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;




<expr><name>bool</name> <macro><name>isReadIfDiscardedInCPlusPlus11</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;





<expr><name>bool</name> <macro><name>isUnusedResultAWarning</name><argument_list>(<argument>const Expr *&amp;WarnExpr</argument>, <argument>SourceLocation &amp;Loc</argument>,
<argument>SourceRange &amp;R1</argument>, <argument>SourceRange &amp;R2</argument>,
<argument>ASTContext &amp;Ctx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;












<expr><name>bool</name> <macro><name>isLValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getValueKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>VK_LValue</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isPRValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getValueKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>VK_PRValue</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isXValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getValueKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>VK_XValue</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isGLValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getValueKind</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>VK_PRValue</name></expr>;</return> }</block>

enum <name>LValueClassification</name> <block>{
<expr><name>LV_Valid</name></expr>,
<expr><name>LV_NotObjectType</name></expr>,
<expr><name>LV_IncompleteVoidType</name></expr>,
<expr><name>LV_DuplicateVectorComponents</name></expr>,
<expr><name>LV_InvalidExpression</name></expr>,
<expr><name>LV_InvalidMessageExpression</name></expr>,
<expr><name>LV_MemberFunction</name></expr>,
<expr><name>LV_SubObjCPropertySetting</name></expr>,
<expr><name>LV_ClassTemporary</name></expr>,
<expr><name>LV_ArrayTemporary</name></expr>
}</block></expr>;

<expr><name>LValueClassification</name> <macro><name>ClassifyLValue</name><argument_list>(<argument>ASTContext &amp;Ctx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

enum <expr><name>isModifiableLvalueResult</name> <block>{
<expr><name>MLV_Valid</name></expr>,
<expr><name>MLV_NotObjectType</name></expr>,
<expr><name>MLV_IncompleteVoidType</name></expr>,
<expr><name>MLV_DuplicateVectorComponents</name></expr>,
<expr><name>MLV_InvalidExpression</name></expr>,
<expr><name>MLV_LValueCast</name></expr>,
<expr><name>MLV_IncompleteType</name></expr>,
<expr><name>MLV_ConstQualified</name></expr>,
<expr><name>MLV_ConstQualifiedField</name></expr>,
<expr><name>MLV_ConstAddrSpace</name></expr>,
<expr><name>MLV_ArrayType</name></expr>,
<expr><name>MLV_NoSetterProperty</name></expr>,
<expr><name>MLV_MemberFunction</name></expr>,
<expr><name>MLV_SubObjCPropertySetting</name></expr>,
<expr><name>MLV_InvalidMessageExpression</name></expr>,
<expr><name>MLV_ClassTemporary</name></expr>,
<expr><name>MLV_ArrayTemporary</name></expr>
}</block></expr>;









<expr><name>isModifiableLvalueResult</name>
<macro><name>isModifiableLvalue</name><argument_list>(<argument>ASTContext &amp;Ctx</argument>, <argument>SourceLocation *Loc = nullptr</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>class</name> <name>Classification</name> <block>{
<expr><name>public</name><operator>:</operator>

enum <name>Kinds</name> <block>{
<expr><name>CL_LValue</name></expr>,
<expr><name>CL_XValue</name></expr>,
<expr><name>CL_Function</name></expr>,
<expr><name>CL_Void</name></expr>,
<expr><name>CL_AddressableVoid</name></expr>,
<expr><name>CL_DuplicateVectorComponents</name></expr>,
<expr><name>CL_MemberFunction</name></expr>,
<expr><name>CL_SubObjCPropertySetting</name></expr>,
<expr><name>CL_ClassTemporary</name></expr>,
<expr><name>CL_ArrayTemporary</name></expr>,
<expr><name>CL_ObjCMessageRValue</name></expr>,
<expr><name>CL_PRValue</name></expr>
}</block></expr>;

enum <expr><name>ModifiableType</name> <block>{
<expr><name>CM_Untested</name></expr>,
<expr><name>CM_Modifiable</name></expr>,
<expr><name>CM_RValue</name></expr>,
<expr><name>CM_Function</name></expr>,
<expr><name>CM_LValueCast</name></expr>,
<expr><name>CM_NoSetterProperty</name></expr>,
<expr><name>CM_ConstQualified</name></expr>,
<expr><name>CM_ConstQualifiedField</name></expr>,
<expr><name>CM_ConstAddrSpace</name></expr>,
<expr><name>CM_ArrayType</name></expr>,
<expr><name>CM_IncompleteType</name></expr>
}</block></expr>;

<expr><name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>Expr</name></expr>;

<expr><name>unsigned</name> <name>short</name> <name>Kind</name></expr>;
<expr><name>unsigned</name> <name>short</name> <name>Modifiable</name></expr>;

<expr><name>explicit</name> <macro><name>Classification</name><argument_list>(<argument>Kinds k</argument>, <argument>ModifiableType m</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>, <macro><name>Modifiable</name><argument_list>(<argument>m</argument>)</argument_list></macro>
<expr><block>{}</block>

<name>public</name><operator>:</operator>
<macro><name>Classification</name><argument_list>()</argument_list></macro> <block>{}</block>

<name>Kinds</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Kinds</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>ModifiableType</name> <macro><name>getModifiable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Modifiable</name> <operator>!=</operator> <name>CM_Untested</name> <operator>&amp;&amp;</operator> <literal type="string">"Did not test for modifiability."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ModifiableType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Modifiable</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>bool</name> <macro><name>isLValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>CL_LValue</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isXValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>CL_XValue</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isGLValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>&lt;=</operator> <name>CL_XValue</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isPRValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>&gt;=</operator> <name>CL_Function</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isRValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>&gt;=</operator> <name>CL_XValue</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isModifiable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getModifiable</name><argument_list>()</argument_list></call> <operator>==</operator> <name>CM_Modifiable</name></expr>;</return> }</block>


<specifier>static</specifier> <name>Classification</name> <macro><name>makeSimpleLValue</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>Classification</name><argument_list>(<argument><expr><name>CL_LValue</name></expr></argument>, <argument><expr><name>CM_Modifiable</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

}</expr>;












<expr><name>Classification</name> <macro><name>Classify</name><argument_list>(<argument>ASTContext &amp;Ctx</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>ClassifyImpl</name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>









<name>Classification</name> <macro><name>ClassifyModifiable</name><argument_list>(<argument>ASTContext &amp;Ctx</argument>, <argument>SourceLocation &amp;Loc</argument>)</argument_list></macro> <specifier>const</specifier><block>{
<return>return <expr><call><name>ClassifyImpl</name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Loc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>FPOptions</name> <macro><name>getFPFeaturesInEffect</name><argument_list>(<argument>const LangOptions &amp;LO</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><specifier>static</specifier> <name>ExprValueKind</name> <macro><name>getValueKindForType</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>ReferenceType</name> <modifier>*</modifier></type><name>RT</name> <init>= <expr><name><name>T</name><operator>-&gt;</operator><name>getAs</name></name><operator>&lt;</operator><name>ReferenceType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>LValueReferenceType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RT</name></expr></argument>)</argument_list></call>
<operator>?</operator> <name>VK_LValue</name>
<operator>:</operator> <operator>(</operator><call><name><name>RT</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isFunctionType</name><argument_list>()</argument_list></call>
<operator>?</operator> <name>VK_LValue</name> <operator>:</operator> <name>VK_XValue</name><operator>)</operator><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>VK_PRValue</name></expr>;</return>
}</block>


<name>ExprValueKind</name> <macro><name>getValueKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExprValueKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>ExprBits</name><operator>.</operator><name>ValueKind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>ExprObjectKind</name> <macro><name>getObjectKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExprObjectKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>ExprBits</name><operator>.</operator><name>ObjectKind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isOrdinaryOrBitFieldObject</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>ExprObjectKind</name> <name>OK</name> <operator>=</operator> <call><name>getObjectKind</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><operator>(</operator><name>OK</name> <operator>==</operator> <name>OK_Ordinary</name> <operator>||</operator> <name>OK</name> <operator>==</operator> <name>OK_BitField</name><operator>)</operator></expr>;</return>
}</block>


<name>void</name> <macro><name>setValueKind</name><argument_list>(<argument>ExprValueKind Cat</argument>)</argument_list></macro> <block>{ <expr><name><name>ExprBits</name><operator>.</operator><name>ValueKind</name></name> <operator>=</operator> <name>Cat</name></expr>; }</block>


<name>void</name> <macro><name>setObjectKind</name><argument_list>(<argument>ExprObjectKind Cat</argument>)</argument_list></macro> <block>{ <expr><name><name>ExprBits</name><operator>.</operator><name>ObjectKind</name></name> <operator>=</operator> <name>Cat</name></expr>; }</block>

<name>private</name><operator>:</operator>
<name>Classification</name> <macro><name>ClassifyImpl</name><argument_list>(<argument>ASTContext &amp;Ctx</argument>, <argument>SourceLocation *Loc</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>public</name><operator>:</operator>






<name>bool</name> <macro><name>refersToBitField</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getObjectKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>OK_BitField</name></expr>;</return> }</block>








<name>FieldDecl</name> <operator>*</operator><call><name>getSourceBitField</name><argument_list>()</argument_list></call></expr>;

<expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><macro><name>getSourceBitField</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getSourceBitField</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>Decl</name> <operator>*</operator><call><name>getReferencedDeclOfCallee</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getReferencedDeclOfCallee</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getReferencedDeclOfCallee</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<specifier>const</specifier> <name>ObjCPropertyRefExpr</name> <operator>*</operator><macro><name>getObjCProperty</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isObjCSelfExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>refersToVectorElement</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>refersToMatrixElement</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getObjectKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>OK_MatrixComponent</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>refersToGlobalRegisterVar</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>hasPlaceholderType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isPlaceholderType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasPlaceholderType</name><argument_list>(<argument>BuiltinType::Kind K</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><call><name>isPlaceholderTypeKind</name><argument_list>(<argument><expr><name>K</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>BuiltinType</name> <modifier>*</modifier></type><name>BT</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>BuiltinType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>BT</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>K</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>











<decl_stmt><decl><type><name>bool</name></type> <name>isKnownToHaveBooleanValue</name><argument_list>(<argument><expr><name>bool</name> <name>Semantic</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>







<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>APSInt</name></expr></argument>&gt;</argument_list></name></type> <name>getIntegerConstantExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <operator>*</operator><name>Loc</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>bool</name> <name>isEvaluated</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isIntegerConstantExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <operator>*</operator><name>Loc</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isCXX98IntegralConstantExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<decl_stmt><decl><type><name>bool</name></type> <name>isCXX11ConstantExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>, <argument><expr><name>APValue</name> <operator>*</operator><name>Result</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <operator>*</operator><name>Loc</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isPotentialConstantExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;
<argument><expr><name>PartialDiagnosticAt</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Diags</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isPotentialConstantExprUnevaluated</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;
<argument><expr><name>PartialDiagnosticAt</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Diags</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name>bool</name></type> <name>isConstantInitializer</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>, <argument><expr><name>bool</name> <name>ForRef</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><operator>*</operator><name>Culprit</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<struct>struct <name>EvalStatus</name> <block>{


<decl_stmt><decl><type><name>bool</name></type> <name>HasSideEffects</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>HasUndefinedBehavior</name></decl>;</decl_stmt>








<decl_stmt><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>PartialDiagnosticAt</name></expr></argument>&gt;</argument_list></name> <modifier>*</modifier></type><name>Diag</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>EvalStatus</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>HasSideEffects</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>HasUndefinedBehavior</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Diag</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{}</block>



<name>bool</name> <macro><name>hasSideEffects</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>HasSideEffects</name></expr>;</return>
}</block></expr></expr_stmt>
}</block>;</struct>


<decl_stmt><decl><type><name><name>struct</name> <name>EvalResult</name></name></type> <range>: <expr><name>EvalStatus</name> <block>{

<expr><name>APValue</name> <name>Val</name></expr>;



<expr><name>bool</name> <macro><name>isGlobalLValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr></range></decl>;</decl_stmt>







<decl_stmt><decl><type><name>bool</name></type> <name>EvaluateAsRValue</name><argument_list>(<argument><expr><name>EvalResult</name> <operator>&amp;</operator><name>Result</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><name>bool</name> <name>InConstantContext</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>EvaluateAsBooleanCondition</name><argument_list>(<argument><expr><name>bool</name> <operator>&amp;</operator><name>Result</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><name>bool</name> <name>InConstantContext</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<enum>enum <name>SideEffectsKind</name> <block>{
<decl><name>SE_NoSideEffects</name></decl>,
<decl><name>SE_AllowUndefinedBehavior</name></decl>,

<decl><name>SE_AllowSideEffects</name></decl>
}</block>;</enum>



<decl_stmt><decl><type><name>bool</name></type> <name>EvaluateAsInt</name><argument_list>(<argument><expr><name>EvalResult</name> <operator>&amp;</operator><name>Result</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><name>SideEffectsKind</name> <name>AllowSideEffects</name> <operator>=</operator> <name>SE_NoSideEffects</name></expr></argument>,
<argument><expr><name>bool</name> <name>InConstantContext</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>EvaluateAsFloat</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>APFloat</name> <operator>&amp;</operator><name>Result</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><name>SideEffectsKind</name> <name>AllowSideEffects</name> <operator>=</operator> <name>SE_NoSideEffects</name></expr></argument>,
<argument><expr><name>bool</name> <name>InConstantContext</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>EvaluateAsFixedPoint</name><argument_list>(<argument><expr><name>EvalResult</name> <operator>&amp;</operator><name>Result</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><name>SideEffectsKind</name> <name>AllowSideEffects</name> <operator>=</operator> <name>SE_NoSideEffects</name></expr></argument>,
<argument><expr><name>bool</name> <name>InConstantContext</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isEvaluatable</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><name>SideEffectsKind</name> <name>AllowSideEffects</name> <operator>=</operator> <name>SE_NoSideEffects</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>








<decl_stmt><decl><type><name>bool</name></type> <name>HasSideEffects</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><name>bool</name> <name>IncludePossibleEffects</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>hasNonTrivialCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name>APSInt</name> <macro><name>EvaluateKnownConstInt</name><argument_list>(
<argument>const ASTContext &amp;Ctx</argument>,
<argument>SmallVectorImpl&lt;PartialDiagnosticAt&gt; *Diag = nullptr</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>APSInt</name> <macro><name>EvaluateKnownConstIntCheckOverflow</name><argument_list>(
<argument>const ASTContext &amp;Ctx</argument>,
<argument>SmallVectorImpl&lt;PartialDiagnosticAt&gt; *Diag = nullptr</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>EvaluateForOverflow</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>EvaluateAsLValue</name><argument_list>(<argument><expr><name>EvalResult</name> <operator>&amp;</operator><name>Result</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><name>bool</name> <name>InConstantContext</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>EvaluateAsInitializer</name><argument_list>(<argument><expr><name>APValue</name> <operator>&amp;</operator><name>Result</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>PartialDiagnosticAt</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Notes</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>EvaluateWithSubstitution</name><argument_list>(<argument><expr><name>APValue</name> <operator>&amp;</operator><name>Value</name></expr></argument>, <argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>Callee</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>This</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>ConstantExprKind</name> <block>{<block_content>


<expr_stmt><expr><name>Normal</name></expr><operator>,</operator>


<expr><name>NonClassTemplateArgument</name></expr><operator>,</operator>

<expr><name>ClassTemplateArgument</name></expr><operator>,</operator>



<expr><name>ImmediateInvocation</name></expr><operator>,</operator></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>EvaluateAsConstantExpr</name><argument_list>(
<argument><expr><name>EvalResult</name> <operator>&amp;</operator><name>Result</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><name>ConstantExprKind</name> <name>Kind</name> <operator>=</operator> <name>ConstantExprKind</name><operator>::</operator><name>Normal</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>








<decl_stmt><decl><type><name>bool</name></type> <name>tryEvaluateObjectSize</name><argument_list>(<argument><expr><name>uint64_t</name> <operator>&amp;</operator><name>Result</name></expr></argument>, <argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>Type</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<enum>enum <name>NullPointerConstantKind</name> <block>{

<decl><name>NPCK_NotNull</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,






<decl><name>NPCK_ZeroExpression</name></decl>,


<decl><name>NPCK_ZeroLiteral</name></decl>,


<decl><name>NPCK_CXX11_nullptr</name></decl>,


<decl><name>NPCK_GNUNull</name></decl>
}</block>;</enum>



<enum>enum <name>NullPointerConstantValueDependence</name> <block>{

<decl><name>NPC_NeverValueDependent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,



<decl><name>NPC_ValueDependentIsNull</name></decl>,



<decl><name>NPC_ValueDependentIsNotNull</name></decl>
}</block>;</enum>




<decl_stmt><decl><type><name>NullPointerConstantKind</name></type> <name>isNullPointerConstant</name><argument_list>(
<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><name>NullPointerConstantValueDependence</name> <name>NPC</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isOBJCGCCandidate</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>isBoundMemberFunction</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<function_decl><type><specifier>static</specifier> <name>QualType</name></type> <name>findBoundMemberType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>Expr</name> <modifier>*</modifier></type><name>IgnoreUnlessSpelledInSource</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>IgnoreUnlessSpelledInSource</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>IgnoreUnlessSpelledInSource</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>





<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>IgnoreImpCasts</name><argument_list>()</argument_list></macro> <name>LLVM_READONLY</name></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>IgnoreImpCasts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>IgnoreImpCasts</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>







<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>IgnoreCasts</name><argument_list>()</argument_list></macro> <name>LLVM_READONLY</name></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>IgnoreCasts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>IgnoreCasts</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>






<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>IgnoreImplicit</name><argument_list>()</argument_list></macro> <name>LLVM_READONLY</name></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>IgnoreImplicit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>IgnoreImplicit</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>






<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>IgnoreImplicitAsWritten</name><argument_list>()</argument_list></macro> <name>LLVM_READONLY</name></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>IgnoreImplicitAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>IgnoreImplicitAsWritten</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>








<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>IgnoreParens</name><argument_list>()</argument_list></macro> <name>LLVM_READONLY</name></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>IgnoreParens</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>IgnoreParens</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>










<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>IgnoreParenImpCasts</name><argument_list>()</argument_list></macro> <name>LLVM_READONLY</name></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>IgnoreParenImpCasts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>IgnoreParenImpCasts</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>





<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>IgnoreParenCasts</name><argument_list>()</argument_list></macro> <name>LLVM_READONLY</name></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>IgnoreParenCasts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>IgnoreParenCasts</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>IgnoreConversionOperatorSingleStep</name><argument_list>()</argument_list></macro> <name>LLVM_READONLY</name></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>IgnoreConversionOperatorSingleStep</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>IgnoreConversionOperatorSingleStep</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>









<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>IgnoreParenLValueCasts</name><argument_list>()</argument_list></macro> <name>LLVM_READONLY</name></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>IgnoreParenLValueCasts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>IgnoreParenLValueCasts</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>







<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>IgnoreParenNoopCasts</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>)</argument_list> <name>LLVM_READONLY</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>IgnoreParenNoopCasts</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>IgnoreParenNoopCasts</name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>






<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>IgnoreParenBaseCasts</name><argument_list>()</argument_list></macro> <name>LLVM_READONLY</name></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>IgnoreParenBaseCasts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>IgnoreParenBaseCasts</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>








<expr_stmt><expr><name>bool</name> <macro><name>isDefaultArgument</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isTemporaryObject</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>TempTy</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isImplicitCXXThis</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>hasAnyTypeDependentArguments</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Exprs</name></decl></parameter>)</parameter_list>;</function_decl>








<expr_stmt><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><macro><name>getBestDynamicClassType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getBestDynamicClassTypeExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>skipRValueSubobjectAdjustments</name><argument_list>(
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>CommaLHS</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>SubobjectAdjustment</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Adjustments</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>skipRValueSubobjectAdjustments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>CommaLHSs</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>SubobjectAdjustment</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>Adjustments</name></expr>;
<return>return <expr><call><name>skipRValueSubobjectAdjustments</name><argument_list>(<argument><expr><name>CommaLHSs</name></expr></argument>, <argument><expr><name>Adjustments</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isSameComparisonOperand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name><modifier>*</modifier></type> <name>E1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name><modifier>*</modifier></type> <name>E2</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>firstExprConstant</name> <operator>&amp;&amp;</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>lastExprConstant</name></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>PointerLikeTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>NumLowBitsAvailable</name> <operator>&lt;=</operator>
<name>llvm</name><operator>::</operator><name>detail</name><operator>::</operator><name><name>ConstantLog2</name><argument_list type="generic">&lt;<argument><expr><name>alignof</name><operator>(</operator><name>Expr</name><operator>)</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"PointerLikeTypeTraits&lt;Expr*&gt; assumes too much alignment."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>ConstantExprKind</name> <init>= <expr><name>Expr</name><operator>::</operator><name>ConstantExprKind</name></expr></init></decl>;</decl_stmt>






<decl_stmt><decl><type><name>class</name></type> <name>FullExpr</name> <range>: <expr><name>public</name> <name>Expr</name> <block>{
<expr><name>protected</name><operator>:</operator>
<name>Stmt</name> <operator>*</operator><name>SubExpr</name></expr>;

<macro><name>FullExpr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>Expr *subexpr</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Expr</name><argument_list>(<argument><expr><name>SC</name></expr></argument>, <argument><expr><call><name><name>subexpr</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>subexpr</name><operator>-&gt;</operator><name>getValueKind</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>subexpr</name><operator>-&gt;</operator><name>getObjectKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>SubExpr</name><argument_list>(<argument>subexpr</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>
<macro><name>FullExpr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>SC</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>
<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SubExpr</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SubExpr</name></expr></argument>)</argument_list></call></expr>;</return> }</block>



<name>void</name> <macro><name>setSubExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>SubExpr</name> <operator>=</operator> <name>E</name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>firstFullExprConstant</name> <operator>&amp;&amp;</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>lastFullExprConstant</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>ConstantExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>FullExpr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ConstantExpr</name></expr></argument>, <argument><expr><name>APValue</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>APInt</name><operator>::</operator><name>WordType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"ConstantExpr assumes that llvm::APInt::WordType is uint64_t "</literal>
<literal type="string">"for tail-allocated storage"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;

<expr><name>public</name><operator>:</operator>

enum <name>ResultStorageKind</name> <block>{ <expr><name>RSK_None</name></expr>, <expr><name>RSK_Int64</name></expr>, <expr><name>RSK_APValue</name></expr> }</block></expr>;

<expr><name>private</name><operator>:</operator>
<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;APValue&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ConstantExprBits</name><operator>.</operator><name>ResultKind</name></name> <operator>==</operator> <name>ConstantExpr</name><operator>::</operator><name>RSK_APValue</name></expr>;</return>
}</block>
<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;uint64_t&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ConstantExprBits</name><operator>.</operator><name>ResultKind</name></name> <operator>==</operator> <name>ConstantExpr</name><operator>::</operator><name>RSK_Int64</name></expr>;</return>
}</block>

<name>uint64_t</name> <operator>&amp;</operator><macro><name>Int64Result</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ConstantExprBits</name><operator>.</operator><name>ResultKind</name></name> <operator>==</operator> <name>ConstantExpr</name><operator>::</operator><name>RSK_Int64</name> <operator>&amp;&amp;</operator>
<literal type="string">"invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>uint64_t</name> <operator>&amp;</operator><macro><name>Int64Result</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ConstantExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>Int64Result</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>APValue</name> <operator>&amp;</operator><macro><name>APValueResult</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ConstantExprBits</name><operator>.</operator><name>ResultKind</name></name> <operator>==</operator> <name>ConstantExpr</name><operator>::</operator><name>RSK_APValue</name> <operator>&amp;&amp;</operator>
<literal type="string">"invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>APValue</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>APValue</name> <operator>&amp;</operator><macro><name>APValueResult</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ConstantExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>APValueResult</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<macro><name>ConstantExpr</name><argument_list>(<argument>Expr *SubExpr</argument>, <argument>ResultStorageKind StorageKind</argument>,
<argument>bool IsImmediateInvocation</argument>)</argument_list></macro></expr>;
<macro><name>ConstantExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>ResultStorageKind StorageKind</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>ConstantExpr</name> <operator>*</operator><call><name>Create</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>APValue</name> <operator>&amp;</operator><name>Result</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>ConstantExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>Expr *E</argument>,
<argument>ResultStorageKind Storage = RSK_None</argument>,
<argument>bool IsImmediateInvocation = false</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>ConstantExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Context</argument>,
<argument>ResultStorageKind StorageKind</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>ResultStorageKind</name> <call><name>getStorageKind</name><argument_list>(<argument><expr><specifier>const</specifier> <name>APValue</name> <operator>&amp;</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>ResultStorageKind</name> <call><name>getStorageKind</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list></call></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>SubExpr</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>SubExpr</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ConstantExprClass</name></expr>;</return>
}</block>

<name>void</name> <macro><name>SetResult</name><argument_list>(<argument>APValue Value</argument>, <argument>const ASTContext &amp;Context</argument>)</argument_list></macro> <block>{
<expr><call><name>MoveIntoResult</name><argument_list>(<argument><expr><name>Value</name></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>void</name> <call><name>MoveIntoResult</name><argument_list>(<argument><expr><name>APValue</name> <operator>&amp;</operator><name>Value</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list></call></expr>;

<expr><name>APValue</name><operator>::</operator><name>ValueKind</name> <macro><name>getResultAPValueKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>APValue</name><operator>::</operator><name>ValueKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>ConstantExprBits</name><operator>.</operator><name>APValueKind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>ResultStorageKind</name> <macro><name>getResultStorageKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ResultStorageKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>ConstantExprBits</name><operator>.</operator><name>ResultKind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>bool</name> <macro><name>isImmediateInvocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ConstantExprBits</name><operator>.</operator><name>IsImmediateInvocation</name></name></expr>;</return>
}</block>
<name>bool</name> <macro><name>hasAPValueResult</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ConstantExprBits</name><operator>.</operator><name>APValueKind</name></name> <operator>!=</operator> <name>APValue</name><operator>::</operator><name>None</name></expr>;</return>
}</block>
<name>APValue</name> <macro><name>getAPValueResult</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>APValue</name> <operator>&amp;</operator><macro><name>getResultAsAPValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>APValueResult</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>llvm</name><operator>::</operator><name>APSInt</name> <macro><name>getResultAsAPSInt</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubExpr</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubExpr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OpaqueValueExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>Expr</name> <operator>*</operator><name>SourceExpr</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>OpaqueValueExpr</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>QualType T</argument>, <argument>ExprValueKind VK</argument>,
<argument>ExprObjectKind OK = OK_Ordinary</argument>, <argument>Expr *SourceExpr = nullptr</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>OpaqueValueExprClass</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>OK</name></expr></argument>)</argument_list></call></expr>, <macro><name>SourceExpr</name><argument_list>(<argument>SourceExpr</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setIsUnique</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;
<expr><name><name>OpaqueValueExprBits</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>Loc</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>




<specifier>static</specifier> <specifier>const</specifier> <name>OpaqueValueExpr</name> <operator>*</operator><call><name>findInCopyConstruct</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;

<expr><name>explicit</name> <macro><name>OpaqueValueExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>OpaqueValueExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>


<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>OpaqueValueExprBits</name><operator>.</operator><name>Loc</name></name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><name>SourceExpr</name> <operator>?</operator> <call><name><name>SourceExpr</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><ternary><condition><expr><name>SourceExpr</name></expr> ?</condition><then> <expr><call><name><name>SourceExpr</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getExprLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><ternary><condition><expr><name>SourceExpr</name></expr> ?</condition><then> <expr><call><name><name>SourceExpr</name><operator>-&gt;</operator><name>getExprLoc</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>









<name>Expr</name> <operator>*</operator><macro><name>getSourceExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SourceExpr</name></expr>;</return> }</block>

<name>void</name> <macro><name>setIsUnique</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>!</operator><name>V</name> <operator>||</operator> <name>SourceExpr</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"unique OVEs are expected to have source expressions"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>OpaqueValueExprBits</name><operator>.</operator><name>IsUnique</name></name> <operator>=</operator> <name>V</name></expr>;
}</block>

<name>bool</name> <macro><name>isUnique</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>OpaqueValueExprBits</name><operator>.</operator><name>IsUnique</name></name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OpaqueValueExprClass</name></expr>;</return>
}</block>
}</expr>;
























<expr><name>class</name> <name>DeclRefExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>DeclRefExpr</name></expr></argument>, <argument><expr><name>NestedNameSpecifierLoc</name></expr></argument>,
<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>,
<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>ValueDecl</name> <operator>*</operator><name>D</name></expr>;



<expr><name>DeclarationNameLoc</name> <name>DNLoc</name></expr>;

<expr><name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;NestedNameSpecifierLoc&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasQualifier</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;NamedDecl *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasFoundDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;ASTTemplateKWAndArgsInfo&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>hasFoundDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>DeclRefExprBits</name><operator>.</operator><name>HasFoundDecl</name></name></expr>;</return> }</block>

<macro><name>DeclRefExpr</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>SourceLocation TemplateKWLoc</argument>, <argument>ValueDecl *D</argument>,
<argument>bool RefersToEnlosingVariableOrCapture</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>, <argument>NamedDecl *FoundD</argument>,
<argument>const TemplateArgumentListInfo *TemplateArgs</argument>, <argument>QualType T</argument>,
<argument>ExprValueKind VK</argument>, <argument>NonOdrUseReason NOUR</argument>)</argument_list></macro></expr>;


<expr><name>explicit</name> <macro><name>DeclRefExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>DeclRefExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<macro><name>DeclRefExpr</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>ValueDecl *D</argument>,
<argument>bool RefersToEnclosingVariableOrCapture</argument>, <argument>QualType T</argument>,
<argument>ExprValueKind VK</argument>, <argument>SourceLocation L</argument>,
<argument>const DeclarationNameLoc &amp;LocInfo = DeclarationNameLoc()</argument>,
<argument>NonOdrUseReason NOUR = NOUR_None</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>DeclRefExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>SourceLocation TemplateKWLoc</argument>, <argument>ValueDecl *D</argument>,
<argument>bool RefersToEnclosingVariableOrCapture</argument>, <argument>SourceLocation NameLoc</argument>,
<argument>QualType T</argument>, <argument>ExprValueKind VK</argument>, <argument>NamedDecl *FoundD = nullptr</argument>,
<argument>const TemplateArgumentListInfo *TemplateArgs = nullptr</argument>,
<argument>NonOdrUseReason NOUR = NOUR_None</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>DeclRefExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>SourceLocation TemplateKWLoc</argument>, <argument>ValueDecl *D</argument>,
<argument>bool RefersToEnclosingVariableOrCapture</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>, <argument>QualType T</argument>, <argument>ExprValueKind VK</argument>,
<argument>NamedDecl *FoundD = nullptr</argument>,
<argument>const TemplateArgumentListInfo *TemplateArgs = nullptr</argument>,
<argument>NonOdrUseReason NOUR = NOUR_None</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>DeclRefExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>bool HasQualifier</argument>,
<argument>bool HasFoundDecl</argument>,
<argument>bool HasTemplateKWAndArgsInfo</argument>,
<argument>unsigned NumTemplateArgs</argument>)</argument_list></macro></expr>;

<expr><name>ValueDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>D</name></expr>;</return> }</block>
<specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>D</name></expr>;</return> }</block>
<name>void</name> <call><name>setDecl</name><argument_list>(<argument><expr><name>ValueDecl</name> <operator>*</operator><name>NewD</name></expr></argument>)</argument_list></call></expr>;

<expr><name>DeclarationNameInfo</name> <macro><name>getNameInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>DeclarationNameInfo</name><argument_list>(<argument><expr><call><name>getDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getDeclName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DNLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>DeclRefExprBits</name><operator>.</operator><name>Loc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setLocation</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>DeclRefExprBits</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;
<expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;



<expr><name>bool</name> <macro><name>hasQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>DeclRefExprBits</name><operator>.</operator><name>HasQualifier</name></name></expr>;</return> }</block>



<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasQualifier</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>NestedNameSpecifierLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>NestedNameSpecifierLoc</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>NestedNameSpecifier</name> <operator>*</operator><macro><name>getQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getQualifierLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getNestedNameSpecifier</name><argument_list>()</argument_list></call></expr>;</return>
}</block>







<name>NamedDecl</name> <operator>*</operator><macro><name>getFoundDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>hasFoundDecl</name><argument_list>()</argument_list></call> <operator>?</operator> <operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>:</operator> <name>D</name></expr>;</return>
}</block>



<specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><macro><name>getFoundDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasFoundDecl</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>D</name></expr></else></ternary></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>DeclRefExprBits</name><operator>.</operator><name>HasTemplateKWAndArgsInfo</name></name></expr>;</return>
}</block>



<name>SourceLocation</name> <macro><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TemplateKWLoc</name></expr>;</return>
}</block>



<name>SourceLocation</name> <macro><name>getLAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LAngleLoc</name></expr>;</return>
}</block>



<name>SourceLocation</name> <macro><name>getRAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RAngleLoc</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasTemplateKeyword</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLAngleLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>copyTemplateArgumentsInto</name><argument_list>(<argument><expr><name>TemplateArgumentListInfo</name> <operator>&amp;</operator><name>List</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>copyInto</name><argument_list>(
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>TemplateArgumentLoc</name> <operator>*</operator><macro><name>getTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}



unsigned <macro><name>getNumTemplateArgs</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NumTemplateArgs</name></expr>;</return>
}

ArrayRef<expr_stmt><expr><operator>&lt;</operator><name>TemplateArgumentLoc</name><operator>&gt;</operator> <macro><name>template_arguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><call><name>getTemplateArgs</name><argument_list>()</argument_list></call></expr>, <macro><name>getNumTemplateArgs</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hadMultipleCandidates</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>DeclRefExprBits</name><operator>.</operator><name>HadMultipleCandidates</name></name></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>void</name></type> <name>setHadMultipleCandidates</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>V</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>DeclRefExprBits</name><operator>.</operator><name>HadMultipleCandidates</name></name> <operator>=</operator> <name>V</name></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>NonOdrUseReason</name> <macro><name>isNonOdrUse</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>NonOdrUseReason</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>DeclRefExprBits</name><operator>.</operator><name>NonOdrUseReason</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>refersToEnclosingVariableOrCapture</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>DeclRefExprBits</name><operator>.</operator><name>RefersToEnclosingVariableOrCapture</name></name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DeclRefExprClass</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>child_range</name></type> <name>children</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
};









<decl_stmt><decl><type><name>class</name></type> <name>APNumericStorage</name> <block>{<block_content>
<union>union <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>VAL</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>pVal</name></decl>;</decl_stmt>
}</block>;</union>
<decl_stmt><decl><type><name>unsigned</name></type> <name>BitWidth</name></decl>;</decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasAllocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>llvm</name><operator>::</operator><name>APInt</name><operator>::</operator><call><name>getNumWords</name><argument_list>(<argument><expr><name>BitWidth</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><call><name>APNumericStorage</name><argument_list>(<argument><expr><specifier>const</specifier> <name>APNumericStorage</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>APNumericStorage</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>

<label><name>protected</name>:</label>
<expr_stmt><expr><call><name>APNumericStorage</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>VAL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>BitWidth</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro> <expr><block>{ }</block>

<name>llvm</name><operator>::</operator><name>APInt</name> <macro><name>getIntValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>unsigned</name> <name>NumWords</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name>APInt</name><operator>::</operator><call><name>getNumWords</name><argument_list>(<argument><expr><name>BitWidth</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>NumWords</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>llvm</name><operator>::</operator><call><name>APInt</name><argument_list>(<argument><expr><name>BitWidth</name></expr></argument>, <argument><expr><name>NumWords</name></expr></argument>, <argument><expr><name>pVal</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>llvm</name><operator>::</operator><call><name>APInt</name><argument_list>(<argument><expr><name>BitWidth</name></expr></argument>, <argument><expr><name>VAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block></expr></expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>setIntValue</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>APInt</name> <operator>&amp;</operator><name>Val</name></expr></argument>)</argument_list></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>APIntStorage</name> <range>: <expr><name>private</name> <name>APNumericStorage</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>llvm</name><operator>::</operator><name>APInt</name> <macro><name>getValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getIntValue</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setValue</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>const llvm::APInt &amp;Val</argument>)</argument_list></macro> <block>{
<expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;

<expr><name>class</name> <name>APFloatStorage</name> <operator>:</operator> <name>private</name> <name>APNumericStorage</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>llvm</name><operator>::</operator><name>APFloat</name> <macro><name>getValue</name><argument_list>(<argument>const llvm::fltSemantics &amp;Semantics</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>APFloat</name><argument_list>(<argument><expr><name>Semantics</name></expr></argument>, <argument><expr><call><name>getIntValue</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>setValue</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>const llvm::APFloat &amp;Val</argument>)</argument_list></macro> <block>{
<expr><call><name>setIntValue</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><call><name><name>Val</name><operator>.</operator><name>bitcastToAPInt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;

<expr><name>class</name> <name>IntegerLiteral</name> <operator>:</operator> <name>public</name> <name>Expr</name></expr>, <expr><name>public</name> <name>APIntStorage</name> <block>{
<expr><name>SourceLocation</name> <name>Loc</name></expr>;


<expr><name>explicit</name> <macro><name>IntegerLiteral</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>IntegerLiteralClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>

<name>public</name><operator>:</operator>


<macro><name>IntegerLiteral</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>const llvm::APInt &amp;V</argument>, <argument>QualType type</argument>,
<argument>SourceLocation l</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>IntegerLiteral</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>const llvm::APInt &amp;V</argument>,
<argument>QualType type</argument>, <argument>SourceLocation l</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>IntegerLiteral</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>EmptyShell Empty</argument>)</argument_list></macro></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>

<name>void</name> <macro><name>setLocation</name><argument_list>(<argument>SourceLocation Location</argument>)</argument_list></macro> <block>{ <expr><name>Loc</name> <operator>=</operator> <name>Location</name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>IntegerLiteralClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>FixedPointLiteral</name> <operator>:</operator> <name>public</name> <name>Expr</name></expr>, <expr><name>public</name> <name>APIntStorage</name> <block>{
<expr><name>SourceLocation</name> <name>Loc</name></expr>;
<expr><name>unsigned</name> <name>Scale</name></expr>;


<expr><name>explicit</name> <macro><name>FixedPointLiteral</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>FixedPointLiteralClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<macro><name>FixedPointLiteral</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>const llvm::APInt &amp;V</argument>, <argument>QualType type</argument>,
<argument>SourceLocation l</argument>, <argument>unsigned Scale</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>FixedPointLiteral</name> <operator>*</operator><macro><name>CreateFromRawInt</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>const llvm::APInt &amp;V</argument>,
<argument>QualType type</argument>, <argument>SourceLocation l</argument>,
<argument>unsigned Scale</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>FixedPointLiteral</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>EmptyShell Empty</argument>)</argument_list></macro></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>

<name>void</name> <macro><name>setLocation</name><argument_list>(<argument>SourceLocation Location</argument>)</argument_list></macro> <block>{ <expr><name>Loc</name> <operator>=</operator> <name>Location</name></expr>; }</block>

<name>unsigned</name> <macro><name>getScale</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Scale</name></expr>;</return> }</block>
<name>void</name> <macro><name>setScale</name><argument_list>(<argument>unsigned S</argument>)</argument_list></macro> <block>{ <expr><name>Scale</name> <operator>=</operator> <name>S</name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>FixedPointLiteralClass</name></expr>;</return>
}</block>

<name>std</name><operator>::</operator><name>string</name> <macro><name>getValueAsString</name><argument_list>(<argument>unsigned Radix</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>CharacterLiteral</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>public</name><operator>:</operator>
enum <name>CharacterKind</name> <block>{
<expr><name>Ascii</name></expr>,
<expr><name>Wide</name></expr>,
<expr><name>UTF8</name></expr>,
<expr><name>UTF16</name></expr>,
<expr><name>UTF32</name></expr>
}</block></expr>;

<expr><name>private</name><operator>:</operator>
<name>unsigned</name> <name>Value</name></expr>;
<expr><name>SourceLocation</name> <name>Loc</name></expr>;
<expr><name>public</name><operator>:</operator>

<macro><name>CharacterLiteral</name><argument_list>(<argument>unsigned value</argument>, <argument>CharacterKind kind</argument>, <argument>QualType type</argument>,
<argument>SourceLocation l</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>CharacterLiteralClass</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Value</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>, <macro><name>Loc</name><argument_list>(<argument>l</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CharacterLiteralBits</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>kind</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><name>ExprDependence</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;
}</block>


<macro><name>CharacterLiteral</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CharacterLiteralClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>

<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>
<name>CharacterKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>CharacterKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>CharacterLiteralBits</name><operator>.</operator><name>Kind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>

<name>unsigned</name> <macro><name>getValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Value</name></expr>;</return> }</block>

<name>void</name> <macro><name>setLocation</name><argument_list>(<argument>SourceLocation Location</argument>)</argument_list></macro> <block>{ <expr><name>Loc</name> <operator>=</operator> <name>Location</name></expr>; }</block>
<name>void</name> <macro><name>setKind</name><argument_list>(<argument>CharacterKind kind</argument>)</argument_list></macro> <block>{ <expr><name><name>CharacterLiteralBits</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>kind</name></expr>; }</block>
<name>void</name> <macro><name>setValue</name><argument_list>(<argument>unsigned Val</argument>)</argument_list></macro> <block>{ <expr><name>Value</name> <operator>=</operator> <name>Val</name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CharacterLiteralClass</name></expr>;</return>
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>print</name><argument_list>(<argument>unsigned val</argument>, <argument>CharacterKind Kind</argument>, <argument>raw_ostream &amp;OS</argument>)</argument_list></macro></expr>;


<expr><name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>FloatingLiteral</name> <operator>:</operator> <name>public</name> <name>Expr</name></expr>, <expr><name>private</name> <name>APFloatStorage</name> <block>{
<expr><name>SourceLocation</name> <name>Loc</name></expr>;

<macro><name>FloatingLiteral</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>const llvm::APFloat &amp;V</argument>, <argument>bool isexact</argument>,
<argument>QualType Type</argument>, <argument>SourceLocation L</argument>)</argument_list></macro>;


<expr><name>explicit</name> <macro><name>FloatingLiteral</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>EmptyShell Empty</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>FloatingLiteral</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>const llvm::APFloat &amp;V</argument>,
<argument>bool isexact</argument>, <argument>QualType Type</argument>, <argument>SourceLocation L</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>FloatingLiteral</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>EmptyShell Empty</argument>)</argument_list></macro></expr>;

<expr><name>llvm</name><operator>::</operator><name>APFloat</name> <macro><name>getValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>APFloatStorage</name><operator>::</operator><call><name>getValue</name><argument_list>(<argument><expr><call><name>getSemantics</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>setValue</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>const llvm::APFloat &amp;Val</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>getSemantics</name><argument_list>()</argument_list></call> <operator>==</operator> <operator>&amp;</operator><call><name><name>Val</name><operator>.</operator><name>getSemantics</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Inconsistent semantics"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>APFloatStorage</name><operator>::</operator><call><name>setValue</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr>;
}</block>



<name>llvm</name><operator>::</operator><name>APFloatBase</name><operator>::</operator><name>Semantics</name> <macro><name>getRawSemantics</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>APFloatBase</name><operator>::</operator><name>Semantics</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name><name>FloatingLiteralBits</name><operator>.</operator><name>Semantics</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>void</name> <macro><name>setRawSemantics</name><argument_list>(<argument>llvm::APFloatBase::Semantics Sem</argument>)</argument_list></macro> <block>{
<expr><name><name>FloatingLiteralBits</name><operator>.</operator><name>Semantics</name></name> <operator>=</operator> <name>Sem</name></expr>;
}</block>


<specifier>const</specifier> <name>llvm</name><operator>::</operator><name>fltSemantics</name> <operator>&amp;</operator><macro><name>getSemantics</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><name>APFloatBase</name><operator>::</operator><call><name>EnumToSemantics</name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>APFloatBase</name><operator>::</operator><name>Semantics</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name><name>FloatingLiteralBits</name><operator>.</operator><name>Semantics</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>void</name> <macro><name>setSemantics</name><argument_list>(<argument>const llvm::fltSemantics &amp;Sem</argument>)</argument_list></macro> <block>{
<expr><name><name>FloatingLiteralBits</name><operator>.</operator><name>Semantics</name></name> <operator>=</operator> <name>llvm</name><operator>::</operator><name>APFloatBase</name><operator>::</operator><call><name>SemanticsToEnum</name><argument_list>(<argument><expr><name>Sem</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>bool</name> <macro><name>isExact</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>FloatingLiteralBits</name><operator>.</operator><name>IsExact</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setExact</name><argument_list>(<argument>bool E</argument>)</argument_list></macro> <block>{ <expr><name><name>FloatingLiteralBits</name><operator>.</operator><name>IsExact</name></name> <operator>=</operator> <name>E</name></expr>; }</block>




<name>double</name> <macro><name>getValueAsApproximateDouble</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLocation</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>Loc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>FloatingLiteralClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;






<expr><name>class</name> <name>ImaginaryLiteral</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>Stmt</name> <operator>*</operator><name>Val</name></expr>;
<expr><name>public</name><operator>:</operator>
<macro><name>ImaginaryLiteral</name><argument_list>(<argument>Expr *val</argument>, <argument>QualType Ty</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ImaginaryLiteralClass</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <macro><name>Val</name><argument_list>(<argument>val</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><name>ExprDependence</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>ImaginaryLiteral</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ImaginaryLiteralClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setSubExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>Val</name> <operator>=</operator> <name>E</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>Val</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Val</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ImaginaryLiteralClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Val</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Val</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


















<expr><name>class</name> <name>StringLiteral</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>StringLiteral</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>,
<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;















<expr><name>public</name><operator>:</operator>
enum <name>StringKind</name> <block>{ <expr><name>Ascii</name></expr>, <expr><name>Wide</name></expr>, <expr><name>UTF8</name></expr>, <expr><name>UTF16</name></expr>, <expr><name>UTF32</name></expr> }</block></expr>;

<expr><name>private</name><operator>:</operator>
<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;unsigned&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><literal type="number">1</literal></expr>;</return> }</block>
<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;SourceLocation&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNumConcatenated</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;char&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getByteLength</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>char</name> <operator>*</operator><macro><name>getStrDataAsChar</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getStrDataAsChar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>const</specifier> <name>uint16_t</name> <operator>*</operator><macro><name>getStrDataAsUInt16</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>uint16_t</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>uint32_t</name> <operator>*</operator><macro><name>getStrDataAsUInt32</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>uint32_t</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<macro><name>StringLiteral</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>StringRef Str</argument>, <argument>StringKind Kind</argument>,
<argument>bool Pascal</argument>, <argument>QualType Ty</argument>, <argument>const SourceLocation *Loc</argument>,
<argument>unsigned NumConcatenated</argument>)</argument_list></macro></expr>;


<macro><name>StringLiteral</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>unsigned NumConcatenated</argument>, <argument>unsigned Length</argument>,
<argument>unsigned CharByteWidth</argument>)</argument_list></macro>;


<expr><specifier>static</specifier> <name>unsigned</name> <macro><name>mapCharByteWidth</name><argument_list>(<argument>TargetInfo const &amp;Target</argument>, <argument>StringKind SK</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <macro><name>setStrTokenLoc</name><argument_list>(<argument>unsigned TokNum</argument>, <argument>SourceLocation L</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>TokNum</name> <operator>&lt;</operator> <call><name>getNumConcatenated</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid tok number"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>TokNum</name></expr>]</index> <operator>=</operator> <name>L</name></expr>;
}</block>

<name>public</name><operator>:</operator>


<specifier>static</specifier> <name>StringLiteral</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>StringRef Str</argument>,
<argument>StringKind Kind</argument>, <argument>bool Pascal</argument>, <argument>QualType Ty</argument>,
<argument>const SourceLocation *Loc</argument>,
<argument>unsigned NumConcatenated</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>StringLiteral</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>StringRef Str</argument>,
<argument>StringKind Kind</argument>, <argument>bool Pascal</argument>, <argument>QualType Ty</argument>,
<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>Create</name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>Str</name></expr></argument>, <argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>Pascal</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Loc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>StringLiteral</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>,
<argument>unsigned NumConcatenated</argument>, <argument>unsigned Length</argument>,
<argument>unsigned CharByteWidth</argument>)</argument_list></macro></expr>;

<expr><name>StringRef</name> <macro><name>getString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getCharByteWidth</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
<literal type="string">"This function is used in places that assume strings use char"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>StringRef</name><argument_list>(<argument><expr><call><name>getStrDataAsChar</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getByteLength</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>StringRef</name> <macro><name>getBytes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{

<return>return <expr><call><name>StringRef</name><argument_list>(<argument><expr><call><name>getStrDataAsChar</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getByteLength</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>outputString</name><argument_list>(<argument>raw_ostream &amp;OS</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>uint32_t</name> <macro><name>getCodeUnit</name><argument_list>(<argument>size_t i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getLength</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"out of bounds access"</literal></expr></argument>)</argument_list></call></expr>;
<switch>switch <condition>(<expr><call><name>getCharByteWidth</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getStrDataAsChar</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<return>return <expr><call><name>getStrDataAsUInt16</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case>
<return>return <expr><call><name>getStrDataAsUInt32</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</return>
<expr_stmt/>}</block_content>
llvm_unreachable("Unsupported character width!"</block></switch>)</block></expr>;
}</block>

<name>unsigned</name> <macro><name>getByteLength</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getCharByteWidth</name><argument_list>()</argument_list></call> <operator>*</operator> <call><name>getLength</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>unsigned</name> <macro><name>getLength</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>unsigned</name> <macro><name>getCharByteWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>StringLiteralBits</name><operator>.</operator><name>CharByteWidth</name></name></expr>;</return> }</block>

<name>StringKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>StringKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>StringLiteralBits</name><operator>.</operator><name>Kind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isAscii</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Ascii</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isWide</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Wide</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isUTF8</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>UTF8</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isUTF16</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>UTF16</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isUTF32</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>UTF32</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isPascal</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>StringLiteralBits</name><operator>.</operator><name>IsPascal</name></name></expr>;</return> }</block>

<name>bool</name> <macro><name>containsNonAscii</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<for>for <control>(<init><decl><type><name>auto</name></type> <name>c</name> <range>: <expr><call><name>getString</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isASCII</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>containsNonAsciiOrNull</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<for>for <control>(<init><decl><type><name>auto</name></type> <name>c</name> <range>: <expr><call><name>getString</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isASCII</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name>c</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>



<name>unsigned</name> <macro><name>getNumConcatenated</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>StringLiteralBits</name><operator>.</operator><name>NumConcatenated</name></name></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getStrTokenLoc</name><argument_list>(<argument>unsigned TokNum</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>TokNum</name> <operator>&lt;</operator> <call><name>getNumConcatenated</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid tok number"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>TokNum</name></expr>]</index></expr>;</return>
}</block>








<name>SourceLocation</name>
<macro><name>getLocationOfByte</name><argument_list>(<argument>unsigned ByteNo</argument>, <argument>const SourceManager &amp;SM</argument>,
<argument>const LangOptions &amp;Features</argument>, <argument>const TargetInfo &amp;Target</argument>,
<argument>unsigned *StartToken = nullptr</argument>,
<argument>unsigned *StartTokenByteOffset = nullptr</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<typedef>typedef <type><specifier>const</specifier> <name>SourceLocation</name> <modifier>*</modifier></type><name>tokloc_iterator</name>;</typedef>

<name>tokloc_iterator</name> <macro><name>tokloc_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block></block>

<name>tokloc_iterator</name> <macro><name>tokloc_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumConcatenated</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><operator>*</operator><call><name>tokloc_begin</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><operator>*</operator><operator>(</operator><call><name>tokloc_end</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>StringLiteralClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>PredefinedExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>PredefinedExpr</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;





<expr><name>public</name><operator>:</operator>
enum <name>IdentKind</name> <block>{
<expr><name>Func</name></expr>,
<expr><name>Function</name></expr>,
<expr><name>LFunction</name></expr>,
<expr><name>FuncDName</name></expr>,
<expr><name>FuncSig</name></expr>,
<expr><name>LFuncSig</name></expr>,
<expr><name>PrettyFunction</name></expr>,


<expr><name>PrettyFunctionNoVirtual</name></expr>
}</block></expr>;

<expr><name>private</name><operator>:</operator>
<macro><name>PredefinedExpr</name><argument_list>(<argument>SourceLocation L</argument>, <argument>QualType FNTy</argument>, <argument>IdentKind IK</argument>,
<argument>StringLiteral *SL</argument>)</argument_list></macro></expr>;

<expr><name>explicit</name> <macro><name>PredefinedExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>bool HasFunctionName</argument>)</argument_list></macro></expr>;


<expr><name>bool</name> <macro><name>hasFunctionName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>PredefinedExprBits</name><operator>.</operator><name>HasFunctionName</name></name></expr>;</return> }</block>

<name>void</name> <macro><name>setFunctionName</name><argument_list>(<argument>StringLiteral *SL</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasFunctionName</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"This PredefinedExpr has no storage for a function name!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>=</operator> <name>SL</name></expr>;
}</block>

<name>public</name><operator>:</operator>

<specifier>static</specifier> <name>PredefinedExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>SourceLocation L</argument>,
<argument>QualType FNTy</argument>, <argument>IdentKind IK</argument>, <argument>StringLiteral *SL</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>PredefinedExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>,
<argument>bool HasFunctionName</argument>)</argument_list></macro></expr>;

<expr><name>IdentKind</name> <macro><name>getIdentKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>IdentKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>PredefinedExprBits</name><operator>.</operator><name>Kind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>PredefinedExprBits</name><operator>.</operator><name>Loc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setLocation</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>PredefinedExprBits</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>StringLiteral</name> <operator>*</operator><macro><name>getFunctionName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>hasFunctionName</name><argument_list>()</argument_list></call>
<operator>?</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>StringLiteral</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>:</operator> <name>nullptr</name></expr>;</return>
}</block>

<specifier>const</specifier> <name>StringLiteral</name> <operator>*</operator><macro><name>getFunctionName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasFunctionName</name><argument_list>()</argument_list></call></expr>
?</condition><then> <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>StringLiteral</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<specifier>static</specifier> <name>StringRef</name> <macro><name>getIdentKindName</name><argument_list>(<argument>IdentKind IK</argument>)</argument_list></macro></expr>;
<expr><name>StringRef</name> <macro><name>getIdentKindName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getIdentKindName</name><argument_list>(<argument><expr><call><name>getIdentKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name> <macro><name>ComputeName</name><argument_list>(<argument>IdentKind IK</argument>, <argument>const Decl *CurrentDecl</argument>)</argument_list></macro></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PredefinedExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>hasFunctionName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>hasFunctionName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;





<expr><name>class</name> <name>SYCLUniqueStableNameExpr</name> <name>final</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>SourceLocation</name> <name>OpLoc</name></expr>, <expr><name>LParen</name></expr>, <expr><name>RParen</name></expr>;
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>TypeInfo</name></expr>;

<macro><name>SYCLUniqueStableNameExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>QualType ResultTy</argument>)</argument_list></macro>;
<macro><name>SYCLUniqueStableNameExpr</name><argument_list>(<argument>SourceLocation OpLoc</argument>, <argument>SourceLocation LParen</argument>,
<argument>SourceLocation RParen</argument>, <argument>QualType ResultTy</argument>,
<argument>TypeSourceInfo *TSI</argument>)</argument_list></macro>;

<expr><name>void</name> <macro><name>setTypeSourceInfo</name><argument_list>(<argument>TypeSourceInfo *Ty</argument>)</argument_list></macro> <block>{ <expr><name>TypeInfo</name> <operator>=</operator> <name>Ty</name></expr>; }</block>

<name>void</name> <macro><name>setLocation</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>OpLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>void</name> <macro><name>setLParenLocation</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>LParen</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>void</name> <macro><name>setRParenLocation</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RParen</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>public</name><operator>:</operator>
<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeSourceInfo</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>TypeInfo</name></expr>;</return> }</block>

<specifier>const</specifier> <name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TypeInfo</name></expr>;</return> }</block>

<specifier>static</specifier> <name>SYCLUniqueStableNameExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>SourceLocation OpLoc</argument>, <argument>SourceLocation LParen</argument>,
<argument>SourceLocation RParen</argument>, <argument>TypeSourceInfo *TSI</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>SYCLUniqueStableNameExpr</name> <operator>*</operator><call><name>CreateEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>)</argument_list></call></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParen</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OpLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getLParenLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParen</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getRParenLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParen</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SYCLUniqueStableNameExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>std</name><operator>::</operator><name>string</name> <macro><name>ComputeName</name><argument_list>(<argument>ASTContext &amp;Context</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name> <macro><name>ComputeName</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>QualType Ty</argument>)</argument_list></macro></expr>;
}</block></expr>;



<expr><name>class</name> <name>ParenExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>SourceLocation</name> <name>L</name></expr>, <expr><name>R</name></expr>;
<expr><name>Stmt</name> <operator>*</operator><name>Val</name></expr>;
<expr><name>public</name><operator>:</operator>
<macro><name>ParenExpr</name><argument_list>(<argument>SourceLocation l</argument>, <argument>SourceLocation r</argument>, <argument>Expr *val</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ParenExprClass</name></expr></argument>, <argument><expr><call><name><name>val</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>val</name><operator>-&gt;</operator><name>getValueKind</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>val</name><operator>-&gt;</operator><name>getObjectKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>L</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>R</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>, <macro><name>Val</name><argument_list>(<argument>val</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>ParenExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ParenExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setSubExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>Val</name> <operator>=</operator> <name>E</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>L</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>R</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getLParen</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>L</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLParen</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>L</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getRParen</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>R</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParen</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>R</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ParenExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Val</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Val</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;











<expr><name>class</name> <name>UnaryOperator</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>UnaryOperator</name></expr></argument>, <argument><expr><name>FPOptionsOverride</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>Stmt</name> <operator>*</operator><name>Val</name></expr>;

<expr><name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;FPOptionsOverride&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><name><name>UnaryOperatorBits</name><operator>.</operator><name>HasFPFeatures</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
}</block>

<name>FPOptionsOverride</name> <operator>&amp;</operator><macro><name>getTrailingFPFeatures</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>UnaryOperatorBits</name><operator>.</operator><name>HasFPFeatures</name></name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>FPOptionsOverride</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>FPOptionsOverride</name> <operator>&amp;</operator><macro><name>getTrailingFPFeatures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>UnaryOperatorBits</name><operator>.</operator><name>HasFPFeatures</name></name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>FPOptionsOverride</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator></expr>
<typedef>typedef <type><name>UnaryOperatorKind</name></type> <name>Opcode</name>;</typedef>

<name>protected</name><operator>:</operator>
<macro><name>UnaryOperator</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>Expr *input</argument>, <argument>Opcode opc</argument>, <argument>QualType type</argument>,
<argument>ExprValueKind VK</argument>, <argument>ExprObjectKind OK</argument>, <argument>SourceLocation l</argument>,
<argument>bool CanOverflow</argument>, <argument>FPOptionsOverride FPFeatures</argument>)</argument_list></macro></block></expr>;


<expr><name>explicit</name> <macro><name>UnaryOperator</name><argument_list>(<argument>bool HasFPFeatures</argument>, <argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>UnaryOperatorClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{
<expr><name><name>UnaryOperatorBits</name><operator>.</operator><name>Opc</name></name> <operator>=</operator> <name>UO_AddrOf</name></expr>;
<expr><name><name>UnaryOperatorBits</name><operator>.</operator><name>HasFPFeatures</name></name> <operator>=</operator> <name>HasFPFeatures</name></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>UnaryOperator</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>bool hasFPFeatures</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>UnaryOperator</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>Expr *input</argument>, <argument>Opcode opc</argument>,
<argument>QualType type</argument>, <argument>ExprValueKind VK</argument>,
<argument>ExprObjectKind OK</argument>, <argument>SourceLocation l</argument>,
<argument>bool CanOverflow</argument>, <argument>FPOptionsOverride FPFeatures</argument>)</argument_list></macro></expr>;

<expr><name>Opcode</name> <macro><name>getOpcode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Opcode</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>UnaryOperatorBits</name><operator>.</operator><name>Opc</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>setOpcode</name><argument_list>(<argument>Opcode Opc</argument>)</argument_list></macro> <block>{ <expr><name><name>UnaryOperatorBits</name><operator>.</operator><name>Opc</name></name> <operator>=</operator> <name>Opc</name></expr>; }</block>

<name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setSubExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>Val</name> <operator>=</operator> <name>E</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getOperatorLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>UnaryOperatorBits</name><operator>.</operator><name>Loc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setOperatorLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>UnaryOperatorBits</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>







<name>bool</name> <macro><name>canOverflow</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>UnaryOperatorBits</name><operator>.</operator><name>CanOverflow</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setCanOverflow</name><argument_list>(<argument>bool C</argument>)</argument_list></macro> <block>{ <expr><name><name>UnaryOperatorBits</name><operator>.</operator><name>CanOverflow</name></name> <operator>=</operator> <name>C</name></expr>; }</block>



<name>bool</name> <macro><name>isFPContractableWithinStatement</name><argument_list>(<argument>const LangOptions &amp;LO</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getFPFeaturesInEffect</name><argument_list>(<argument><expr><name>LO</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>allowFPContractWithinStatement</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isFEnvAccessOn</name><argument_list>(<argument>const LangOptions &amp;LO</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getFPFeaturesInEffect</name><argument_list>(<argument><expr><name>LO</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getAllowFEnvAccess</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>isPostfix</name><argument_list>(<argument>Opcode Op</argument>)</argument_list></macro> <block>{
<return>return <expr><name>Op</name> <operator>==</operator> <name>UO_PostInc</name> <operator>||</operator> <name>Op</name> <operator>==</operator> <name>UO_PostDec</name></expr>;</return>
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>isPrefix</name><argument_list>(<argument>Opcode Op</argument>)</argument_list></macro> <block>{
<return>return <expr><name>Op</name> <operator>==</operator> <name>UO_PreInc</name> <operator>||</operator> <name>Op</name> <operator>==</operator> <name>UO_PreDec</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isPrefix</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isPrefix</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>isPostfix</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isPostfix</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isIncrementOp</name><argument_list>(<argument>Opcode Op</argument>)</argument_list></macro> <block>{
<return>return <expr><name>Op</name> <operator>==</operator> <name>UO_PreInc</name> <operator>||</operator> <name>Op</name> <operator>==</operator> <name>UO_PostInc</name></expr>;</return>
}</block>
<name>bool</name> <macro><name>isIncrementOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isIncrementOp</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isDecrementOp</name><argument_list>(<argument>Opcode Op</argument>)</argument_list></macro> <block>{
<return>return <expr><name>Op</name> <operator>==</operator> <name>UO_PreDec</name> <operator>||</operator> <name>Op</name> <operator>==</operator> <name>UO_PostDec</name></expr>;</return>
}</block>
<name>bool</name> <macro><name>isDecrementOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isDecrementOp</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isIncrementDecrementOp</name><argument_list>(<argument>Opcode Op</argument>)</argument_list></macro> <block>{ <return>return <expr><name>Op</name> <operator>&lt;=</operator> <name>UO_PreDec</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isIncrementDecrementOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isIncrementDecrementOp</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isArithmeticOp</name><argument_list>(<argument>Opcode Op</argument>)</argument_list></macro> <block>{
<return>return <expr><name>Op</name> <operator>&gt;=</operator> <name>UO_Plus</name> <operator>&amp;&amp;</operator> <name>Op</name> <operator>&lt;=</operator> <name>UO_LNot</name></expr>;</return>
}</block>
<name>bool</name> <macro><name>isArithmeticOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isArithmeticOp</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>



<specifier>static</specifier> <name>StringRef</name> <macro><name>getOpcodeStr</name><argument_list>(<argument>Opcode Op</argument>)</argument_list></macro></expr>;



<expr><specifier>static</specifier> <name>Opcode</name> <macro><name>getOverloadedOpcode</name><argument_list>(<argument>OverloadedOperatorKind OO</argument>, <argument>bool Postfix</argument>)</argument_list></macro></expr>;



<expr><specifier>static</specifier> <name>OverloadedOperatorKind</name> <macro><name>getOverloadedOperator</name><argument_list>(<argument>Opcode Opc</argument>)</argument_list></macro></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>isPostfix</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name><name>Val</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>getOperatorLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><ternary><condition><expr><call><name>isPostfix</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getOperatorLoc</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name><name>Val</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getExprLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getOperatorLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>UnaryOperatorClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Val</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Val</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasStoredFPFeatures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>UnaryOperatorBits</name><operator>.</operator><name>HasFPFeatures</name></name></expr>;</return> }</block>


<name>FPOptionsOverride</name> <macro><name>getStoredFPFeatures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTrailingFPFeatures</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>protected</name><operator>:</operator>

<name>void</name> <macro><name>setStoredFPFeatures</name><argument_list>(<argument>FPOptionsOverride F</argument>)</argument_list></macro> <block>{ <expr><call><name>getTrailingFPFeatures</name><argument_list>()</argument_list></call> <operator>=</operator> <name>F</name></expr>; }</block>

<name>public</name><operator>:</operator>


<name>FPOptions</name> <macro><name>getFPFeaturesInEffect</name><argument_list>(<argument>const LangOptions &amp;LO</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name><name>UnaryOperatorBits</name><operator>.</operator><name>HasFPFeatures</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getStoredFPFeatures</name><argument_list>()</argument_list></call><operator>.</operator><call><name>applyOverrides</name><argument_list>(<argument><expr><name>LO</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>FPOptions</name><operator>::</operator><call><name>defaultWithoutTrailingStorage</name><argument_list>(<argument><expr><name>LO</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>FPOptionsOverride</name> <macro><name>getFPOptionsOverride</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name><name>UnaryOperatorBits</name><operator>.</operator><name>HasFPFeatures</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getStoredFPFeatures</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>FPOptionsOverride</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>friend</name> <name>TrailingObjects</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;
}</block></expr>;




<expr><name>class</name> <name>OffsetOfNode</name> <block>{
<expr><name>public</name><operator>:</operator>

enum <name>Kind</name> <block>{

<expr><name>Array</name> <operator>=</operator> <literal type="number">0x00</literal></expr>,

<expr><name>Field</name> <operator>=</operator> <literal type="number">0x01</literal></expr>,

<expr><name>Identifier</name> <operator>=</operator> <literal type="number">0x02</literal></expr>,


<expr><name>Base</name> <operator>=</operator> <literal type="number">0x03</literal></expr>
}</block></expr>;

<expr><name>private</name><operator>:</operator>
enum <block>{ <expr><name>MaskBits</name> <operator>=</operator> <literal type="number">2</literal></expr>, <expr><name>Mask</name> <operator>=</operator> <literal type="number">0x03</literal></expr> }</block></expr>;


<expr><name>SourceRange</name> <name>Range</name></expr>;










<expr><name>uintptr_t</name> <name>Data</name></expr>;

<expr><name>public</name><operator>:</operator>

<macro><name>OffsetOfNode</name><argument_list>(<argument>SourceLocation LBracketLoc</argument>, <argument>unsigned Index</argument>,
<argument>SourceLocation RBracketLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Range</name><argument_list>(<argument><expr><name>LBracketLoc</name></expr></argument>, <argument><expr><name>RBracketLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>Data</name><argument_list>(<argument>(Index &lt;&lt; <literal type="number">2</literal>) | Array</argument>)</argument_list></macro> <expr><block>{}</block>


<macro><name>OffsetOfNode</name><argument_list>(<argument>SourceLocation DotLoc</argument>, <argument>FieldDecl *Field</argument>, <argument>SourceLocation NameLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Range</name><argument_list>(<argument><expr><call><name><name>DotLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call> <operator>?</operator> <name>DotLoc</name> <operator>:</operator> <name>NameLoc</name></expr></argument>, <argument><expr><name>NameLoc</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Data</name><argument_list>(<argument>reinterpret_cast&lt;uintptr_t&gt;(Field) | OffsetOfNode::Field</argument>)</argument_list></macro> <expr><block>{}</block>


<macro><name>OffsetOfNode</name><argument_list>(<argument>SourceLocation DotLoc</argument>, <argument>IdentifierInfo *Name</argument>,
<argument>SourceLocation NameLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Range</name><argument_list>(<argument><expr><call><name><name>DotLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call> <operator>?</operator> <name>DotLoc</name> <operator>:</operator> <name>NameLoc</name></expr></argument>, <argument><expr><name>NameLoc</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Data</name><argument_list>(<argument>reinterpret_cast&lt;uintptr_t&gt;(Name) | Identifier</argument>)</argument_list></macro> <expr><block>{}</block>


<name>explicit</name> <call><name>OffsetOfNode</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXBaseSpecifier</name> <operator>*</operator><name>Base</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Range</name><argument_list>()</argument_list></call></expr>, <macro><name>Data</name><argument_list>(<argument>reinterpret_cast&lt;uintptr_t&gt;(Base) | OffsetOfNode::Base</argument>)</argument_list></macro> <expr><block>{}</block>


<name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Kind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Data</name> <operator>&amp;</operator> <name>Mask</name></expr></argument>)</argument_list></call></expr>;</return> }</block>



<name>unsigned</name> <macro><name>getArrayExprIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Array</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Data</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal></expr>;</return>
}</block>


<name>FieldDecl</name> <operator>*</operator><macro><name>getField</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Field</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>FieldDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Data</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>Mask</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>IdentifierInfo</name> <operator>*</operator><macro><name>getFieldName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>CXXBaseSpecifier</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Base</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXBaseSpecifier</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Data</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>Mask</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>







<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Range</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;















<expr><name>class</name> <name>OffsetOfExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OffsetOfExpr</name></expr></argument>, <argument><expr><name>OffsetOfNode</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>SourceLocation</name> <name>OperatorLoc</name></expr>, <expr><name>RParenLoc</name></expr>;

<expr><name>TypeSourceInfo</name> <operator>*</operator><name>TSInfo</name></expr>;

<expr><name>unsigned</name> <name>NumComps</name></expr>;

<expr><name>unsigned</name> <name>NumExprs</name></expr>;

<expr><name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;OffsetOfNode&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumComps</name></expr>;</return>
}</block>

<macro><name>OffsetOfExpr</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>QualType type</argument>,
<argument>SourceLocation OperatorLoc</argument>, <argument>TypeSourceInfo *tsi</argument>,
<argument>ArrayRef&lt;OffsetOfNode&gt; comps</argument>, <argument>ArrayRef&lt;Expr*&gt; exprs</argument>,
<argument>SourceLocation RParenLoc</argument>)</argument_list></macro></expr>;

<expr><name>explicit</name> <macro><name>OffsetOfExpr</name><argument_list>(<argument>unsigned numComps</argument>, <argument>unsigned numExprs</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>OffsetOfExprClass</name></expr></argument>, <argument><expr><call><name>EmptyShell</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TSInfo</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NumComps</name><argument_list>(<argument><expr><name>numComps</name></expr></argument>)</argument_list></call></expr>, <macro><name>NumExprs</name><argument_list>(<argument>numExprs</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>

<specifier>static</specifier> <name>OffsetOfExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>QualType type</argument>,
<argument>SourceLocation OperatorLoc</argument>, <argument>TypeSourceInfo *tsi</argument>,
<argument>ArrayRef&lt;OffsetOfNode&gt; comps</argument>,
<argument>ArrayRef&lt;Expr*&gt; exprs</argument>, <argument>SourceLocation RParenLoc</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>OffsetOfExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumComps</argument>, <argument>unsigned NumExprs</argument>)</argument_list></macro></expr>;


<expr><name>SourceLocation</name> <macro><name>getOperatorLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OperatorLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setOperatorLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>OperatorLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation R</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>R</name></expr>; }</block>

<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TSInfo</name></expr>;</return>
}</block>
<name>void</name> <macro><name>setTypeSourceInfo</name><argument_list>(<argument>TypeSourceInfo *tsi</argument>)</argument_list></macro> <block>{
<expr><name>TSInfo</name> <operator>=</operator> <name>tsi</name></expr>;
}</block>

<specifier>const</specifier> <name>OffsetOfNode</name> <operator>&amp;</operator><macro><name>getComponent</name><argument_list>(<argument>unsigned Idx</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Idx</name> <operator>&lt;</operator> <name>NumComps</name> <operator>&amp;&amp;</operator> <literal type="string">"Subscript out of range"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OffsetOfNode</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>Idx</name></expr>]</index></expr>;</return>
}</block>

<name>void</name> <macro><name>setComponent</name><argument_list>(<argument>unsigned Idx</argument>, <argument>OffsetOfNode ON</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Idx</name> <operator>&lt;</operator> <name>NumComps</name> <operator>&amp;&amp;</operator> <literal type="string">"Subscript out of range"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OffsetOfNode</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>Idx</name></expr>]</index> <operator>=</operator> <name>ON</name></expr>;
}</block>

<name>unsigned</name> <macro><name>getNumComponents</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumComps</name></expr>;</return>
}</block>

<name>Expr</name><operator>*</operator> <macro><name>getIndexExpr</name><argument_list>(<argument>unsigned Idx</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Idx</name> <operator>&lt;</operator> <name>NumExprs</name> <operator>&amp;&amp;</operator> <literal type="string">"Subscript out of range"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>Idx</name></expr>]</index></expr>;</return>
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getIndexExpr</name><argument_list>(<argument>unsigned Idx</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Idx</name> <operator>&lt;</operator> <name>NumExprs</name> <operator>&amp;&amp;</operator> <literal type="string">"Subscript out of range"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>Idx</name></expr>]</index></expr>;</return>
}</block>

<name>void</name> <macro><name>setIndexExpr</name><argument_list>(<argument>unsigned Idx</argument>, <argument>Expr* E</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Idx</name> <operator>&lt;</operator> <name>NumComps</name> <operator>&amp;&amp;</operator> <literal type="string">"Subscript out of range"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>Idx</name></expr>]</index> <operator>=</operator> <name>E</name></expr>;
}</block>

<name>unsigned</name> <macro><name>getNumExpressions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumExprs</name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>OperatorLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OffsetOfExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<expr><name>Stmt</name> <operator>*</operator><operator>*</operator><name>begin</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>begin</name> <operator>+</operator> <name>NumExprs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>Stmt</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><name>begin</name> <operator>=</operator>
<call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>begin</name> <operator>+</operator> <name>NumExprs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>friend</name> <name>TrailingObjects</name></expr>;
}</block></expr>;




<expr><name>class</name> <name>UnaryExprOrTypeTraitExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr>union <block>{
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>Ty</name></expr>;
<expr><name>Stmt</name> <operator>*</operator><name>Ex</name></expr>;
}</block> <name>Argument</name></expr>;
<expr><name>SourceLocation</name> <name>OpLoc</name></expr>, <expr><name>RParenLoc</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>UnaryExprOrTypeTraitExpr</name><argument_list>(<argument>UnaryExprOrTypeTrait ExprKind</argument>, <argument>TypeSourceInfo *TInfo</argument>,
<argument>QualType resultType</argument>, <argument>SourceLocation op</argument>,
<argument>SourceLocation rp</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>UnaryExprOrTypeTraitExprClass</name></expr></argument>, <argument><expr><name>resultType</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>,
<argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OpLoc</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>, <macro><name>RParenLoc</name><argument_list>(<argument>rp</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>ExprKind</name> <operator>&lt;=</operator> <name>UETT_Last</name> <operator>&amp;&amp;</operator> <literal type="string">"invalid enum value!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>UnaryExprOrTypeTraitExprBits</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>ExprKind</name></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ExprKind</name></expr></argument>)</argument_list></call> <operator>==</operator>
<name><name>UnaryExprOrTypeTraitExprBits</name><operator>.</operator><name>Kind</name></name> <operator>&amp;&amp;</operator>
<literal type="string">"UnaryExprOrTypeTraitExprBits.Kind overflow!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>UnaryExprOrTypeTraitExprBits</name><operator>.</operator><name>IsType</name></name> <operator>=</operator> <name>true</name></expr>;
<expr><name><name>Argument</name><operator>.</operator><name>Ty</name></name> <operator>=</operator> <name>TInfo</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>UnaryExprOrTypeTraitExpr</name><argument_list>(<argument>UnaryExprOrTypeTrait ExprKind</argument>, <argument>Expr *E</argument>,
<argument>QualType resultType</argument>, <argument>SourceLocation op</argument>,
<argument>SourceLocation rp</argument>)</argument_list></macro></expr>;


<expr><name>explicit</name> <macro><name>UnaryExprOrTypeTraitExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>UnaryExprOrTypeTraitExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>

<name>UnaryExprOrTypeTrait</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>UnaryExprOrTypeTrait</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>UnaryExprOrTypeTraitExprBits</name><operator>.</operator><name>Kind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>setKind</name><argument_list>(<argument>UnaryExprOrTypeTrait K</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>K</name> <operator>&lt;=</operator> <name>UETT_Last</name> <operator>&amp;&amp;</operator> <literal type="string">"invalid enum value!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>UnaryExprOrTypeTraitExprBits</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>K</name></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>K</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>UnaryExprOrTypeTraitExprBits</name><operator>.</operator><name>Kind</name></name> <operator>&amp;&amp;</operator>
<literal type="string">"UnaryExprOrTypeTraitExprBits.Kind overflow!"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name>bool</name> <macro><name>isArgumentType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>UnaryExprOrTypeTraitExprBits</name><operator>.</operator><name>IsType</name></name></expr>;</return> }</block>
<name>QualType</name> <macro><name>getArgumentType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getArgumentTypeInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getArgumentTypeInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isArgumentType</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"calling getArgumentType() when arg is expr"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>Argument</name><operator>.</operator><name>Ty</name></name></expr>;</return>
}</block>
<name>Expr</name> <operator>*</operator><macro><name>getArgumentExpr</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isArgumentType</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"calling getArgumentExpr() when arg is type"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>Argument</name><operator>.</operator><name>Ex</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getArgumentExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>UnaryExprOrTypeTraitExpr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getArgumentExpr</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setArgument</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{
<expr><name><name>Argument</name><operator>.</operator><name>Ex</name></name> <operator>=</operator> <name>E</name></expr>;
<expr><name><name>UnaryExprOrTypeTraitExprBits</name><operator>.</operator><name>IsType</name></name> <operator>=</operator> <name>false</name></expr>;
}</block>
<name>void</name> <macro><name>setArgument</name><argument_list>(<argument>TypeSourceInfo *TInfo</argument>)</argument_list></macro> <block>{
<expr><name><name>Argument</name><operator>.</operator><name>Ty</name></name> <operator>=</operator> <name>TInfo</name></expr>;
<expr><name><name>UnaryExprOrTypeTraitExprBits</name><operator>.</operator><name>IsType</name></name> <operator>=</operator> <name>true</name></expr>;
}</block>



<name>QualType</name> <macro><name>getTypeOfArgument</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>isArgumentType</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getArgumentType</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>getArgumentExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getOperatorLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OpLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setOperatorLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>OpLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>OpLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>UnaryExprOrTypeTraitExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <call><name>children</name><argument_list>()</argument_list></call></expr>;
<expr><name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr>;






<expr><name>class</name> <name>ArraySubscriptExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
enum <expr><block>{ <expr><name>LHS</name></expr>, <expr><name>RHS</name></expr>, <expr><name>END_EXPR</name></expr> }</block></expr>;
<expr><name>Stmt</name> <operator>*</operator><name><name>SubExprs</name><index>[<expr><name>END_EXPR</name></expr>]</index></name></expr>;

<expr><name>bool</name> <macro><name>lhsIsBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getRHS</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isIntegerType</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>public</name><operator>:</operator>
<macro><name>ArraySubscriptExpr</name><argument_list>(<argument>Expr *lhs</argument>, <argument>Expr *rhs</argument>, <argument>QualType t</argument>, <argument>ExprValueKind VK</argument>,
<argument>ExprObjectKind OK</argument>, <argument>SourceLocation rbracketloc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ArraySubscriptExprClass</argument>, <argument>t</argument>, <argument>VK</argument>, <argument>OK</argument>)</argument_list></macro> <block>{
<expr><name><name>SubExprs</name><index>[<expr><name>LHS</name></expr>]</index></name> <operator>=</operator> <name>lhs</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>RHS</name></expr>]</index></name> <operator>=</operator> <name>rhs</name></expr>;
<expr><name><name>ArrayOrMatrixSubscriptExprBits</name><operator>.</operator><name>RBracketLoc</name></name> <operator>=</operator> <name>rbracketloc</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>ArraySubscriptExpr</name><argument_list>(<argument>EmptyShell Shell</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ArraySubscriptExprClass</argument>, <argument>Shell</argument>)</argument_list></macro> <block>{ }</block>










<name>Expr</name> <operator>*</operator><macro><name>getLHS</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>LHS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getLHS</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>LHS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setLHS</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>LHS</name></expr>]</index></name> <operator>=</operator> <name>E</name></expr>; }</block>

<name>Expr</name> <operator>*</operator><macro><name>getRHS</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>RHS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getRHS</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>RHS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setRHS</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>RHS</name></expr>]</index></name> <operator>=</operator> <name>E</name></expr>; }</block>

<name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><ternary><condition><expr><call><name>lhsIsBase</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getLHS</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>getRHS</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><ternary><condition><expr><call><name>lhsIsBase</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getLHS</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>getRHS</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getIdx</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><ternary><condition><expr><call><name>lhsIsBase</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getRHS</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>getLHS</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getIdx</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><ternary><condition><expr><call><name>lhsIsBase</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getRHS</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>getLHS</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getLHS</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getRBracketLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getRBracketLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ArrayOrMatrixSubscriptExprBits</name><operator>.</operator><name>RBracketLoc</name></name></expr>;</return>
}</block>
<name>void</name> <macro><name>setRBracketLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{
<expr><name><name>ArrayOrMatrixSubscriptExprBits</name><operator>.</operator><name>RBracketLoc</name></name> <operator>=</operator> <name>L</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getExprLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getBase</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getExprLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ArraySubscriptExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><name>END_EXPR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>END_EXPR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>MatrixSubscriptExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
enum <expr><block>{ <expr><name>BASE</name></expr>, <expr><name>ROW_IDX</name></expr>, <expr><name>COLUMN_IDX</name></expr>, <expr><name>END_EXPR</name></expr> }</block></expr>;
<expr><name>Stmt</name> <operator>*</operator><name><name>SubExprs</name><index>[<expr><name>END_EXPR</name></expr>]</index></name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>MatrixSubscriptExpr</name><argument_list>(<argument>Expr *Base</argument>, <argument>Expr *RowIdx</argument>, <argument>Expr *ColumnIdx</argument>, <argument>QualType T</argument>,
<argument>SourceLocation RBracketLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>MatrixSubscriptExprClass</argument>, <argument>T</argument>, <argument>Base-&gt;getValueKind()</argument>,
<argument>OK_MatrixComponent</argument>)</argument_list></macro> <block>{
<expr><name><name>SubExprs</name><index>[<expr><name>BASE</name></expr>]</index></name> <operator>=</operator> <name>Base</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>ROW_IDX</name></expr>]</index></name> <operator>=</operator> <name>RowIdx</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>COLUMN_IDX</name></expr>]</index></name> <operator>=</operator> <name>ColumnIdx</name></expr>;
<expr><name><name>ArrayOrMatrixSubscriptExprBits</name><operator>.</operator><name>RBracketLoc</name></name> <operator>=</operator> <name>RBracketLoc</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>MatrixSubscriptExpr</name><argument_list>(<argument>EmptyShell Shell</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>MatrixSubscriptExprClass</argument>, <argument>Shell</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <macro><name>isIncomplete</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>bool</name> <name>IsIncomplete</name> <operator>=</operator> <call><name>hasPlaceholderType</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>IncompleteMatrixIdx</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>SubExprs</name><index>[<expr><name>COLUMN_IDX</name></expr>]</index></name> <operator>||</operator> <name>IsIncomplete</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"expressions without column index must be marked as incomplete"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>IsIncomplete</name></expr>;</return>
}</block>
<name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>BASE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>BASE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setBase</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>BASE</name></expr>]</index></name> <operator>=</operator> <name>E</name></expr>; }</block>

<name>Expr</name> <operator>*</operator><macro><name>getRowIdx</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>ROW_IDX</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getRowIdx</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>ROW_IDX</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setRowIdx</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>ROW_IDX</name></expr>]</index></name> <operator>=</operator> <name>E</name></expr>; }</block>

<name>Expr</name> <operator>*</operator><macro><name>getColumnIdx</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>COLUMN_IDX</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getColumnIdx</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isIncomplete</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"cannot get the column index of an incomplete expression"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>COLUMN_IDX</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>setColumnIdx</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>COLUMN_IDX</name></expr>]</index></name> <operator>=</operator> <name>E</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getBase</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getRBracketLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getExprLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getBase</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getExprLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getRBracketLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ArrayOrMatrixSubscriptExprBits</name><operator>.</operator><name>RBracketLoc</name></name></expr>;</return>
}</block>
<name>void</name> <macro><name>setRBracketLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{
<expr><name><name>ArrayOrMatrixSubscriptExprBits</name><operator>.</operator><name>RBracketLoc</name></name> <operator>=</operator> <name>L</name></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>MatrixSubscriptExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>END_EXPR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>END_EXPR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>CallExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
enum <expr><block>{ <expr><name>FN</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><name>PREARGS_START</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;


<expr><name>unsigned</name> <name>NumArgs</name></expr>;



<expr><name>SourceLocation</name> <name>RParenLoc</name></expr>;

























<expr><name>Stmt</name> <operator>*</operator><operator>*</operator><macro><name>getTrailingStmts</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>char</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>+</operator>
<name><name>CallExprBits</name><operator>.</operator><name>OffsetToTrailingObjects</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>Stmt</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><macro><name>getTrailingStmts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CallExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getTrailingStmts</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<specifier>static</specifier> <name>unsigned</name> <macro><name>offsetToTrailingObjects</name><argument_list>(<argument>StmtClass SC</argument>)</argument_list></macro></expr>;

<expr><name>unsigned</name> <macro><name>getSizeOfTrailingStmts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><literal type="number">1</literal> <operator>+</operator> <call><name>getNumPreArgs</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</return>
}</block>

<name>size_t</name> <macro><name>getOffsetOfTrailingFPFeatures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasStoredFPFeatures</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>CallExprBits</name><operator>.</operator><name>OffsetToTrailingObjects</name></name> <operator>+</operator> <call><name>getSizeOfTrailingStmts</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
enum <name>class</name> <name>ADLCallKind</name> <operator>:</operator> <name>bool</name> <block>{ <expr><name>NotADL</name></expr>, <expr><name>UsesADL</name></expr> }</block></expr>;
<expr><specifier>static</specifier> <name>constexpr</name> <name>ADLCallKind</name> <name>NotADL</name> <operator>=</operator> <name>ADLCallKind</name><operator>::</operator><name>NotADL</name></expr>;
<expr><specifier>static</specifier> <name>constexpr</name> <name>ADLCallKind</name> <name>UsesADL</name> <operator>=</operator> <name>ADLCallKind</name><operator>::</operator><name>UsesADL</name></expr>;

<expr><name>protected</name><operator>:</operator>


<macro><name>CallExpr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>Expr *Fn</argument>, <argument>ArrayRef&lt;Expr *&gt; PreArgs</argument>,
<argument>ArrayRef&lt;Expr *&gt; Args</argument>, <argument>QualType Ty</argument>, <argument>ExprValueKind VK</argument>,
<argument>SourceLocation RParenLoc</argument>, <argument>FPOptionsOverride FPFeatures</argument>,
<argument>unsigned MinNumArgs</argument>, <argument>ADLCallKind UsesADL</argument>)</argument_list></macro></expr>;


<macro><name>CallExpr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>unsigned NumPreArgs</argument>, <argument>unsigned NumArgs</argument>,
<argument>bool hasFPFeatures</argument>, <argument>EmptyShell Empty</argument>)</argument_list></macro>;



<expr><specifier>static</specifier> <name>unsigned</name> <macro><name>sizeOfTrailingObjects</name><argument_list>(<argument>unsigned NumPreArgs</argument>, <argument>unsigned NumArgs</argument>,
<argument>bool HasFPFeatures</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>NumPreArgs</name> <operator>+</operator> <name>NumArgs</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>+</operator>
<name>HasFPFeatures</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FPOptionsOverride</name></expr></argument>)</argument_list></sizeof></expr>;</return>
}</block>

<name>Stmt</name> <operator>*</operator><macro><name>getPreArg</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <call><name>getNumPreArgs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Prearg access out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getTrailingStmts</name><argument_list>()</argument_list></call><index>[<expr><name>PREARGS_START</name> <operator>+</operator> <name>I</name></expr>]</index></expr>;</return>
}</block>
<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getPreArg</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <call><name>getNumPreArgs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Prearg access out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getTrailingStmts</name><argument_list>()</argument_list></call><index>[<expr><name>PREARGS_START</name> <operator>+</operator> <name>I</name></expr>]</index></expr>;</return>
}</block>
<name>void</name> <macro><name>setPreArg</name><argument_list>(<argument>unsigned I</argument>, <argument>Stmt *PreArg</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <call><name>getNumPreArgs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Prearg access out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getTrailingStmts</name><argument_list>()</argument_list></call><index>[<expr><name>PREARGS_START</name> <operator>+</operator> <name>I</name></expr>]</index> <operator>=</operator> <name>PreArg</name></expr>;
}</block>

<name>unsigned</name> <macro><name>getNumPreArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CallExprBits</name><operator>.</operator><name>NumPreArgs</name></name></expr>;</return> }</block>


<name>FPOptionsOverride</name> <operator>*</operator><macro><name>getTrailingFPFeatures</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasStoredFPFeatures</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>FPOptionsOverride</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>char</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>CallExprBits</name><operator>.</operator><name>OffsetToTrailingObjects</name></name> <operator>+</operator>
<call><name>getSizeOfTrailingStmts</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>FPOptionsOverride</name> <operator>*</operator><macro><name>getTrailingFPFeatures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasStoredFPFeatures</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>FPOptionsOverride</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>+</operator>
<name><name>CallExprBits</name><operator>.</operator><name>OffsetToTrailingObjects</name></name> <operator>+</operator> <call><name>getSizeOfTrailingStmts</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>


















<specifier>static</specifier> <name>CallExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>Expr *Fn</argument>,
<argument>ArrayRef&lt;Expr *&gt; Args</argument>, <argument>QualType Ty</argument>, <argument>ExprValueKind VK</argument>,
<argument>SourceLocation RParenLoc</argument>,
<argument>FPOptionsOverride FPFeatures</argument>, <argument>unsigned MinNumArgs = <literal type="number">0</literal></argument>,
<argument>ADLCallKind UsesADL = NotADL</argument>)</argument_list></macro></expr>;









<expr><specifier>static</specifier> <name>CallExpr</name> <operator>*</operator><macro><name>CreateTemporary</name><argument_list>(<argument>void *Mem</argument>, <argument>Expr *Fn</argument>, <argument>QualType Ty</argument>,
<argument>ExprValueKind VK</argument>, <argument>SourceLocation RParenLoc</argument>,
<argument>ADLCallKind UsesADL = NotADL</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>CallExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>unsigned NumArgs</argument>,
<argument>bool HasFPFeatures</argument>, <argument>EmptyShell Empty</argument>)</argument_list></macro></expr>;

<expr><name>Expr</name> <operator>*</operator><macro><name>getCallee</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getTrailingStmts</name><argument_list>()</argument_list></call><index>[<expr><name>FN</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getCallee</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getTrailingStmts</name><argument_list>()</argument_list></call><index>[<expr><name>FN</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setCallee</name><argument_list>(<argument>Expr *F</argument>)</argument_list></macro> <block>{ <expr><call><name>getTrailingStmts</name><argument_list>()</argument_list></call><index>[<expr><name>FN</name></expr>]</index> <operator>=</operator> <name>F</name></expr>; }</block>

<name>ADLCallKind</name> <macro><name>getADLCallKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ADLCallKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>CallExprBits</name><operator>.</operator><name>UsesADL</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>setADLCallKind</name><argument_list>(<argument>ADLCallKind V = UsesADL</argument>)</argument_list></macro> <block>{
<expr><name><name>CallExprBits</name><operator>.</operator><name>UsesADL</name></name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>bool</name> <macro><name>usesADL</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getADLCallKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>UsesADL</name></expr>;</return> }</block>

<name>bool</name> <macro><name>hasStoredFPFeatures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CallExprBits</name><operator>.</operator><name>HasFPFeatures</name></name></expr>;</return> }</block>

<name>Decl</name> <operator>*</operator><macro><name>getCalleeDecl</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>getCallee</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getReferencedDeclOfCallee</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getCalleeDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCallee</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getReferencedDeclOfCallee</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>FunctionDecl</name> <operator>*</operator><macro><name>getDirectCallee</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getCalleeDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><macro><name>getDirectCallee</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getCalleeDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumArgs</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><operator>*</operator><macro><name>getArgs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getTrailingStmts</name><argument_list>()</argument_list></call> <operator>+</operator> <name>PREARGS_START</name> <operator>+</operator>
<call><name>getNumPreArgs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><macro><name>getArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getTrailingStmts</name><argument_list>()</argument_list></call> <operator>+</operator> <name>PREARGS_START</name> <operator>+</operator> <call><name>getNumPreArgs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>Expr</name> <operator>*</operator><macro><name>getArg</name><argument_list>(<argument>unsigned Arg</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Arg</name> <operator>&lt;</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Arg access out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getArgs</name><argument_list>()</argument_list></call><index>[<expr><name>Arg</name></expr>]</index></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getArg</name><argument_list>(<argument>unsigned Arg</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Arg</name> <operator>&lt;</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Arg access out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getArgs</name><argument_list>()</argument_list></call><index>[<expr><name>Arg</name></expr>]</index></expr>;</return>
}</block>





<name>void</name> <macro><name>setArg</name><argument_list>(<argument>unsigned Arg</argument>, <argument>Expr *ArgExpr</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Arg</name> <operator>&lt;</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Arg access out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getArgs</name><argument_list>()</argument_list></call><index>[<expr><name>Arg</name></expr>]</index> <operator>=</operator> <name>ArgExpr</name></expr>;
}</block>


<name>void</name> <macro><name>computeDependence</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><name>clang</name><operator>::</operator><call><name>computeDependence</name><argument_list>(
<argument><expr><name>this</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getTrailingStmts</name><argument_list>()</argument_list></call> <operator>+</operator> <name>PREARGS_START</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>getNumPreArgs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>







<name>void</name> <macro><name>shrinkNumArgs</name><argument_list>(<argument>unsigned NewNumArgs</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>NewNumArgs</name> <operator>&lt;=</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"shrinkNumArgs cannot increase the number of arguments!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>NumArgs</name> <operator>=</operator> <name>NewNumArgs</name></expr>;
}</block>




<name>void</name> <macro><name>setNumArgsUnsafe</name><argument_list>(<argument>unsigned NewNumArgs</argument>)</argument_list></macro> <block>{ <expr><name>NumArgs</name> <operator>=</operator> <name>NewNumArgs</name></expr>; }</block></expr>

<typedef>typedef <type><name>ExprIterator</name></type> <name>arg_iterator</name>;</typedef></block></expr>
<typedef>typedef <type><name>ConstExprIterator</name></type> <name>const_arg_iterator</name>;</typedef></block></expr>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>arg_iterator</name></expr></argument>&gt;</argument_list></name> <name>arg_range</name></expr>;</expr_stmt></typedef></block></expr>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_arg_iterator</name></expr></argument>&gt;</argument_list></name> <name>const_arg_range</name></expr>;</expr_stmt></typedef>

<name>arg_range</name> <macro><name>arguments</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>arg_range</name><argument_list>(<argument><expr><call><name>arg_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>arg_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></block>
<name>const_arg_range</name> <macro><name>arguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_arg_range</name><argument_list>(<argument><expr><call><name>arg_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>arg_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>arg_iterator</name> <macro><name>arg_begin</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>getTrailingStmts</name><argument_list>()</argument_list></call> <operator>+</operator> <name>PREARGS_START</name> <operator>+</operator> <call><name>getNumPreArgs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>arg_iterator</name> <macro><name>arg_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>arg_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>const_arg_iterator</name> <macro><name>arg_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTrailingStmts</name><argument_list>()</argument_list></call> <operator>+</operator> <name>PREARGS_START</name> <operator>+</operator> <call><name>getNumPreArgs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>const_arg_iterator</name> <macro><name>arg_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>arg_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call></expr>;</return> }</block>





<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getRawSubExprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getTrailingStmts</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>PREARGS_START</name> <operator>+</operator> <call><name>getNumPreArgs</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>unsigned</name> <macro><name>getNumCommas</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal> <operator>:</operator> <literal type="number">0</literal></expr>;</return> }</block>


<name>FPOptionsOverride</name> <macro><name>getStoredFPFeatures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasStoredFPFeatures</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><call><name>getTrailingFPFeatures</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setStoredFPFeatures</name><argument_list>(<argument>FPOptionsOverride F</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasStoredFPFeatures</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><operator>*</operator><call><name>getTrailingFPFeatures</name><argument_list>()</argument_list></call> <operator>=</operator> <name>F</name></expr>;
}</block>



<name>FPOptions</name> <macro><name>getFPFeaturesInEffect</name><argument_list>(<argument>const LangOptions &amp;LO</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasStoredFPFeatures</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getStoredFPFeatures</name><argument_list>()</argument_list></call><operator>.</operator><call><name>applyOverrides</name><argument_list>(<argument><expr><name>LO</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>FPOptions</name><operator>::</operator><call><name>defaultWithoutTrailingStorage</name><argument_list>(<argument><expr><name>LO</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>FPOptionsOverride</name> <macro><name>getFPFeatures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasStoredFPFeatures</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getStoredFPFeatures</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>FPOptionsOverride</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>unsigned</name> <macro><name>getBuiltinCallee</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isUnevaluatedBuiltinCall</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>QualType</name> <macro><name>getCallReturnType</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><specifier>const</specifier> <name>Attr</name> <operator>*</operator><macro><name>getUnusedResultAttr</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>hasUnusedResultAttr</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getUnusedResultAttr</name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>nullptr</name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;
<expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;



<expr><name>bool</name> <macro><name>isBuiltinAssumeFalse</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>void</name> <macro><name>markDependentForPostponedNameLookup</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>getDependence</name><argument_list>()</argument_list></call> <operator>|</operator> <name>ExprDependence</name><operator>::</operator><name>TypeValueInstantiation</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>bool</name> <macro><name>isCallToStdMove</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>FD</name> <operator>=</operator> <call><name>getDirectCallee</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>FD</name> <operator>&amp;&amp;</operator> <call><name><name>FD</name><operator>-&gt;</operator><name>isInStdNamespace</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>FD</name><operator>-&gt;</operator><name>getIdentifier</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>FD</name><operator>-&gt;</operator><name>getIdentifier</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isStr</name><argument_list>(<argument><expr><literal type="string">"move"</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>firstCallExprConstant</name> <operator>&amp;&amp;</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>lastCallExprConstant</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>getTrailingStmts</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getTrailingStmts</name><argument_list>()</argument_list></call> <operator>+</operator> <name>PREARGS_START</name> <operator>+</operator>
<call><name>getNumPreArgs</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>getTrailingStmts</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getTrailingStmts</name><argument_list>()</argument_list></call> <operator>+</operator> <name>PREARGS_START</name> <operator>+</operator>
<call><name>getNumPreArgs</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


struct <expr><name>MemberExprNameQualifier</name> <block>{


<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;



<expr><name>DeclAccessPair</name> <name>FoundDecl</name></expr>;
}</block></expr>;



<expr><name>class</name> <name>MemberExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>MemberExpr</name></expr></argument>, <argument><expr><name>MemberExprNameQualifier</name></expr></argument>,
<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>,
<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;



<expr><name>Stmt</name> <operator>*</operator><name>Base</name></expr>;



<expr><name>ValueDecl</name> <operator>*</operator><name>MemberDecl</name></expr>;



<expr><name>DeclarationNameLoc</name> <name>MemberDNLoc</name></expr>;


<expr><name>SourceLocation</name> <name>MemberLoc</name></expr>;

<expr><name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;MemberExprNameQualifier&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasQualifierOrFoundDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;ASTTemplateKWAndArgsInfo&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasQualifierOrFoundDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>MemberExprBits</name><operator>.</operator><name>HasQualifierOrFoundDecl</name></name></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>MemberExprBits</name><operator>.</operator><name>HasTemplateKWAndArgsInfo</name></name></expr>;</return>
}</block>

<macro><name>MemberExpr</name><argument_list>(<argument>Expr *Base</argument>, <argument>bool IsArrow</argument>, <argument>SourceLocation OperatorLoc</argument>,
<argument>ValueDecl *MemberDecl</argument>, <argument>const DeclarationNameInfo &amp;NameInfo</argument>,
<argument>QualType T</argument>, <argument>ExprValueKind VK</argument>, <argument>ExprObjectKind OK</argument>,
<argument>NonOdrUseReason NOUR</argument>)</argument_list></macro></expr>;
<macro><name>MemberExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Expr</name><argument_list>(<argument><expr><name>MemberExprClass</name></expr></argument>, <argument><expr><name>Empty</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Base</name><argument_list>()</argument_list></call></expr>, <macro><name>MemberDecl</name><argument_list>()</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>MemberExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>Expr *Base</argument>, <argument>bool IsArrow</argument>,
<argument>SourceLocation OperatorLoc</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>SourceLocation TemplateKWLoc</argument>, <argument>ValueDecl *MemberDecl</argument>,
<argument>DeclAccessPair FoundDecl</argument>,
<argument>DeclarationNameInfo MemberNameInfo</argument>,
<argument>const TemplateArgumentListInfo *TemplateArgs</argument>,
<argument>QualType T</argument>, <argument>ExprValueKind VK</argument>, <argument>ExprObjectKind OK</argument>,
<argument>NonOdrUseReason NOUR</argument>)</argument_list></macro></expr>;



<expr><specifier>static</specifier> <name>MemberExpr</name> <operator>*</operator><macro><name>CreateImplicit</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>Expr *Base</argument>,
<argument>bool IsArrow</argument>, <argument>ValueDecl *MemberDecl</argument>,
<argument>QualType T</argument>, <argument>ExprValueKind VK</argument>,
<argument>ExprObjectKind OK</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>Create</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>Base</name></expr></argument>, <argument><expr><name>IsArrow</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>NestedNameSpecifierLoc</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>MemberDecl</name></expr></argument>,
<argument><expr><name>DeclAccessPair</name><operator>::</operator><call><name>make</name><argument_list>(<argument><expr><name>MemberDecl</name></expr></argument>, <argument><expr><call><name><name>MemberDecl</name><operator>-&gt;</operator><name>getAccess</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>DeclarationNameInfo</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>OK</name></expr></argument>, <argument><expr><name>NOUR_None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>MemberExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>bool HasQualifier</argument>,
<argument>bool HasFoundDecl</argument>,
<argument>bool HasTemplateKWAndArgsInfo</argument>,
<argument>unsigned NumTemplateArgs</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <macro><name>setBase</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>Base</name> <operator>=</operator> <name>E</name></expr>; }</block>
<name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Base</name></expr></argument>)</argument_list></call></expr>;</return> }</block>





<name>ValueDecl</name> <operator>*</operator><macro><name>getMemberDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MemberDecl</name></expr>;</return> }</block>
<name>void</name> <call><name>setMemberDecl</name><argument_list>(<argument><expr><name>ValueDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;


<expr><name>DeclAccessPair</name> <macro><name>getFoundDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasQualifierOrFoundDecl</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>DeclAccessPair</name><operator>::</operator><call><name>make</name><argument_list>(<argument><expr><call><name>getMemberDecl</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getMemberDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getAccess</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>MemberExprNameQualifier</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>FoundDecl</name></expr>;</return>
}</block>




<name>bool</name> <macro><name>hasQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getQualifier</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block>




<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasQualifierOrFoundDecl</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>NestedNameSpecifierLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>MemberExprNameQualifier</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>QualifierLoc</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>




<expr_stmt><expr><name>NestedNameSpecifier</name> <operator>*</operator><macro><name>getQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getQualifierLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getNestedNameSpecifier</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>SourceLocation</name> <macro><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TemplateKWLoc</name></expr>;</return>
}



SourceLocation <macro><name>getLAngleLoc</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LAngleLoc</name></expr>;</return>
}



SourceLocation <macro><name>getRAngleLoc</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RAngleLoc</name></expr>;</return>
}


bool <macro><name>hasTemplateKeyword</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{ <return>return <expr><call><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLAngleLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>copyTemplateArgumentsInto</name><argument_list>(<argument><expr><name>TemplateArgumentListInfo</name> <operator>&amp;</operator><name>List</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>copyInto</name><argument_list>(
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>TemplateArgumentLoc</name> <operator>*</operator><macro><name>getTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}



unsigned <macro><name>getNumTemplateArgs</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NumTemplateArgs</name></expr>;</return>
}

ArrayRef<expr_stmt><expr><operator>&lt;</operator><name>TemplateArgumentLoc</name><operator>&gt;</operator> <macro><name>template_arguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><call><name>getTemplateArgs</name><argument_list>()</argument_list></call></expr>, <macro><name>getNumTemplateArgs</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>DeclarationNameInfo</name> <macro><name>getMemberNameInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>DeclarationNameInfo</name><argument_list>(<argument><expr><call><name><name>MemberDecl</name><operator>-&gt;</operator><name>getDeclName</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>MemberLoc</name></expr></argument>, <argument><expr><name>MemberDNLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getOperatorLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>MemberExprBits</name><operator>.</operator><name>OperatorLoc</name></name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isArrow</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>MemberExprBits</name><operator>.</operator><name>IsArrow</name></name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setArrow</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>A</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>MemberExprBits</name><operator>.</operator><name>IsArrow</name></name> <operator>=</operator> <name>A</name></expr>;</expr_stmt> </block_content>}</block></function>



<expr_stmt><expr><name>SourceLocation</name> <macro><name>getMemberLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MemberLoc</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setMemberLoc</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>L</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>MemberLoc</name> <operator>=</operator> <name>L</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;</expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;</expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getExprLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>MemberLoc</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isImplicitAccess</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getBase</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>getBase</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isImplicitCXXThis</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hadMultipleCandidates</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>MemberExprBits</name><operator>.</operator><name>HadMultipleCandidates</name></name></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>void</name></type> <name>setHadMultipleCandidates</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>V</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>MemberExprBits</name><operator>.</operator><name>HadMultipleCandidates</name></name> <operator>=</operator> <name>V</name></expr>;</expr_stmt>
</block_content>}</block></function>





<decl_stmt><decl><type><name>bool</name></type> <name>performsVirtualDispatch</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><name>LO</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name><name>LO</name><operator>.</operator><name>AppleKext</name></name> <operator>||</operator> <operator>!</operator><call><name>hasQualifier</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name>NonOdrUseReason</name> <macro><name>isNonOdrUse</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>NonOdrUseReason</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>MemberExprBits</name><operator>.</operator><name>NonOdrUseReason</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>MemberExprClass</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>child_range</name></type> <name>children</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Base</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Base</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
};



<decl_stmt><decl><type><name>class</name></type> <name>CompoundLiteralExpr</name> <range>: <expr><name>public</name> <name>Expr</name> <block>{



<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;




<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>TInfoAndScope</name></expr>;
<expr><name>Stmt</name> <operator>*</operator><name>Init</name></expr>;
<expr><name>public</name><operator>:</operator>
<macro><name>CompoundLiteralExpr</name><argument_list>(<argument>SourceLocation lparenloc</argument>, <argument>TypeSourceInfo *tinfo</argument>,
<argument>QualType T</argument>, <argument>ExprValueKind VK</argument>, <argument>Expr *init</argument>, <argument>bool fileScope</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>CompoundLiteralExprClass</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>lparenloc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>TInfoAndScope</name><argument_list>(<argument><expr><name>tinfo</name></expr></argument>, <argument><expr><name>fileScope</name></expr></argument>)</argument_list></call></expr>, <macro><name>Init</name><argument_list>(<argument>init</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>CompoundLiteralExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CompoundLiteralExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>Expr</name> <operator>*</operator><macro><name>getInitializer</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setInitializer</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>Init</name> <operator>=</operator> <name>E</name></expr>; }</block>

<name>bool</name> <macro><name>isFileScope</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>TInfoAndScope</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setFileScope</name><argument_list>(<argument>bool FS</argument>)</argument_list></macro> <block>{ <expr><call><name><name>TInfoAndScope</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>FS</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>TInfoAndScope</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>setTypeSourceInfo</name><argument_list>(<argument>TypeSourceInfo *tinfo</argument>)</argument_list></macro> <block>{
<expr><call><name><name>TInfoAndScope</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><name>tinfo</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Init</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<expr><call><name><name>LParenLoc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Init</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></range></decl></decl_stmt>
<return>return <expr><name>LParenLoc</name></expr>;</return>
}
SourceLocation <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <name>LLVM_READONLY</name> <block>{

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Init</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name><name>Init</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}

static <function><type><name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CompoundLiteralExprClass</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>child_range</name></type> <name>children</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Init</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Init</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Init</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Init</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
};





<decl_stmt><decl><type><name>class</name></type> <name>CastExpr</name> <range>: <expr><name>public</name> <name>Expr</name> <block>{
<expr><name>Stmt</name> <operator>*</operator><name>Op</name></expr>;

<expr><name>bool</name> <macro><name>CastConsistency</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>const</specifier> <name>CXXBaseSpecifier</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><macro><name>path_buffer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CastExpr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>path_buffer</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>CXXBaseSpecifier</name> <operator>*</operator><operator>*</operator><call><name>path_buffer</name><argument_list>()</argument_list></call></expr>;

<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>CastExpr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>QualType ty</argument>, <argument>ExprValueKind VK</argument>, <argument>const CastKind kind</argument>,
<argument>Expr *op</argument>, <argument>unsigned BasePathSize</argument>, <argument>bool HasFPFeatures</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>SC</name></expr></argument>, <argument><expr><name>ty</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <macro><name>Op</name><argument_list>(<argument>op</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CastExprBits</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>kind</name></expr>;
<expr><name><name>CastExprBits</name><operator>.</operator><name>PartOfExplicitCast</name></name> <operator>=</operator> <name>false</name></expr>;
<expr><name><name>CastExprBits</name><operator>.</operator><name>BasePathSize</name></name> <operator>=</operator> <name>BasePathSize</name></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>CastExprBits</name><operator>.</operator><name>BasePathSize</name></name> <operator>==</operator> <name>BasePathSize</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"BasePathSize overflow!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>CastConsistency</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name><name>CastExprBits</name><operator>.</operator><name>HasFPFeatures</name></name> <operator>=</operator> <name>HasFPFeatures</name></expr>;
}</block>


<macro><name>CastExpr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>EmptyShell Empty</argument>, <argument>unsigned BasePathSize</argument>,
<argument>bool HasFPFeatures</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>SC</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{
<expr><name><name>CastExprBits</name><operator>.</operator><name>PartOfExplicitCast</name></name> <operator>=</operator> <name>false</name></expr>;
<expr><name><name>CastExprBits</name><operator>.</operator><name>BasePathSize</name></name> <operator>=</operator> <name>BasePathSize</name></expr>;
<expr><name><name>CastExprBits</name><operator>.</operator><name>HasFPFeatures</name></name> <operator>=</operator> <name>HasFPFeatures</name></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>CastExprBits</name><operator>.</operator><name>BasePathSize</name></name> <operator>==</operator> <name>BasePathSize</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"BasePathSize overflow!"</literal></expr></argument>)</argument_list></call></expr>;
}</block>



<name>FPOptionsOverride</name> <operator>*</operator><call><name>getTrailingFPFeatures</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>FPOptionsOverride</name> <operator>*</operator><macro><name>getTrailingFPFeatures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CastExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getTrailingFPFeatures</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>CastKind</name> <macro><name>getCastKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>CastKind</name><operator>)</operator> <name><name>CastExprBits</name><operator>.</operator><name>Kind</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setCastKind</name><argument_list>(<argument>CastKind K</argument>)</argument_list></macro> <block>{ <expr><name><name>CastExprBits</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>K</name></expr>; }</block>

<specifier>static</specifier> <specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getCastKindName</name><argument_list>(<argument>CastKind CK</argument>)</argument_list></macro></expr>;
<expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getCastKindName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getCastKindName</name><argument_list>(<argument><expr><call><name>getCastKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setSubExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>Op</name> <operator>=</operator> <name>E</name></expr>; }</block>




<name>Expr</name> <operator>*</operator><call><name>getSubExprAsWritten</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getSubExprAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CastExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getSubExprAsWritten</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>NamedDecl</name> <operator>*</operator><macro><name>getConversionFunction</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<typedef>typedef <type><name>CXXBaseSpecifier</name> <modifier>*</modifier><modifier>*</modifier></type><name>path_iterator</name>;</typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <type><specifier>const</specifier> <name>CXXBaseSpecifier</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>path_const_iterator</name>;</typedef>
<expr_stmt><expr><name>bool</name> <macro><name>path_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>path_size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>path_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CastExprBits</name><operator>.</operator><name>BasePathSize</name></name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>path_iterator</name></type> <name>path_begin</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>path_buffer</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>path_iterator</name></type> <name>path_end</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>path_buffer</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>path_size</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><name>path_const_iterator</name> <macro><name>path_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>path_buffer</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>path_const_iterator</name> <macro><name>path_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>path_buffer</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>path_size</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>path_iterator</name></expr></argument>&gt;</argument_list></name> <macro><name>path</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>make_range</name><argument_list>(<argument><expr><call><name>path_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>path_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>path_const_iterator</name></expr></argument>&gt;</argument_list></name> <macro><name>path</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>make_range</name><argument_list>(<argument><expr><call><name>path_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>path_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><macro><name>getTargetUnionField</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getCastKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>CK_ToUnion</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getTargetFieldForToUnionCast</name><argument_list>(<argument><expr><call><name>getType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getSubExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasStoredFPFeatures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CastExprBits</name><operator>.</operator><name>HasFPFeatures</name></name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>FPOptionsOverride</name> <macro><name>getStoredFPFeatures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasStoredFPFeatures</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><call><name>getTrailingFPFeatures</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>FPOptions</name></type> <name>getFPFeaturesInEffect</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><name>LO</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>hasStoredFPFeatures</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getStoredFPFeatures</name><argument_list>()</argument_list></call><operator>.</operator><call><name>applyOverrides</name><argument_list>(<argument><expr><name>LO</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>FPOptions</name><operator>::</operator><call><name>defaultWithoutTrailingStorage</name><argument_list>(<argument><expr><name>LO</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>FPOptionsOverride</name> <macro><name>getFPFeatures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasStoredFPFeatures</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getStoredFPFeatures</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>FPOptionsOverride</name><argument_list>()</argument_list></call></expr>;</return>
}

static <function_decl><type><specifier>const</specifier> <name>FieldDecl</name> <modifier>*</modifier></type><name>getTargetFieldForToUnionCast</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>unionType</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>opType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FieldDecl</name> <modifier>*</modifier></type><name>getTargetFieldForToUnionCast</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>opType</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>firstCastExprConstant</name> <operator>&amp;&amp;</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>lastCastExprConstant</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>child_range</name></type> <name>children</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Op</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Op</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
};





















<decl_stmt><decl><type><name>class</name> <name>ImplicitCastExpr</name></type> <name>final</name>
<range>: <expr><name>public</name> <name>CastExpr</name></expr></range></decl>,
<decl><type ref="prev"/><name>private</name> <name>llvm</name>::<name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ImplicitCastExpr</name></expr></argument>, <argument><expr><name>CXXBaseSpecifier</name> <modifier>*</modifier></expr></argument>,
<argument><expr><name>FPOptionsOverride</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>

<macro><name>ImplicitCastExpr</name><argument_list>(<argument>QualType ty</argument>, <argument>CastKind kind</argument>, <argument>Expr *op</argument>,
<argument>unsigned BasePathLength</argument>, <argument>FPOptionsOverride FPO</argument>,
<argument>ExprValueKind VK</argument>)</argument_list></macro>
: <macro><name>CastExpr</name><argument_list>(<argument>ImplicitCastExprClass</argument>, <argument>ty</argument>, <argument>VK</argument>, <argument>kind</argument>, <argument>op</argument>, <argument>BasePathLength</argument>,
<argument>FPO.requiresTrailingStorage()</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>hasStoredFPFeatures</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><call><name>getTrailingFPFeatures</name><argument_list>()</argument_list></call> <operator>=</operator> <name>FPO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>


<macro><name>explicit</name></macro> <macro><name>ImplicitCastExpr</name><argument_list>(<argument>EmptyShell Shell</argument>, <argument>unsigned PathSize</argument>,
<argument>bool HasFPFeatures</argument>)</argument_list></macro>
: <macro><name>CastExpr</name><argument_list>(<argument>ImplicitCastExprClass</argument>, <argument>Shell</argument>, <argument>PathSize</argument>, <argument>HasFPFeatures</argument>)</argument_list></macro> <block>{<block_content/>}</block>

<decl_stmt><decl><type><name>unsigned</name></type> <name>numTrailingObjects</name><argument_list>(<argument><expr><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>CXXBaseSpecifier</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>path_size</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>public</name>:</label>
<enum>enum <name>OnStack_t</name> <block>{ <decl><name>OnStack</name></decl> }</block>;</enum>
<macro><name>ImplicitCastExpr</name><argument_list>(<argument>OnStack_t _</argument>, <argument>QualType ty</argument>, <argument>CastKind kind</argument>, <argument>Expr *op</argument>,
<argument>ExprValueKind VK</argument>, <argument>FPOptionsOverride FPO</argument>)</argument_list></macro>
: <macro><name>CastExpr</name><argument_list>(<argument>ImplicitCastExprClass</argument>, <argument>ty</argument>, <argument>VK</argument>, <argument>kind</argument>, <argument>op</argument>, <argument><literal type="number">0</literal></argument>,
<argument>FPO.requiresTrailingStorage()</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>hasStoredFPFeatures</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><call><name>getTrailingFPFeatures</name><argument_list>()</argument_list></call> <operator>=</operator> <name>FPO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>

<expr_stmt><expr><name>bool</name> <macro><name>isPartOfExplicitCast</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CastExprBits</name><operator>.</operator><name>PartOfExplicitCast</name></name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setIsPartOfExplicitCast</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>PartOfExplicitCast</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>CastExprBits</name><operator>.</operator><name>PartOfExplicitCast</name></name> <operator>=</operator> <name>PartOfExplicitCast</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>ImplicitCastExpr</name> <modifier>*</modifier></type><name>Create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>CastKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Operand</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXCastPath</name> <modifier>*</modifier></type><name>BasePath</name></decl></parameter>,
<parameter><decl><type><name>ExprValueKind</name></type> <name>Cat</name></decl></parameter>, <parameter><decl><type><name>FPOptionsOverride</name></type> <name>FPO</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>ImplicitCastExpr</name> <modifier>*</modifier></type><name>CreateEmpty</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>PathSize</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>HasFPFeatures</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getSubExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getSubExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ImplicitCastExprClass</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>friend</name></type> <name>TrailingObjects</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CastExpr</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

















<decl_stmt><decl><type><name>class</name></type> <name>ExplicitCastExpr</name> <range>: <expr><name>public</name> <name>CastExpr</name> <block>{


<expr><name>TypeSourceInfo</name> <operator>*</operator><name>TInfo</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>ExplicitCastExpr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>QualType exprTy</argument>, <argument>ExprValueKind VK</argument>,
<argument>CastKind kind</argument>, <argument>Expr *op</argument>, <argument>unsigned PathSize</argument>,
<argument>bool HasFPFeatures</argument>, <argument>TypeSourceInfo *writtenTy</argument>)</argument_list></macro>
<operator>:</operator> <call><name>CastExpr</name><argument_list>(<argument><expr><name>SC</name></expr></argument>, <argument><expr><name>exprTy</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>PathSize</name></expr></argument>, <argument><expr><name>HasFPFeatures</name></expr></argument>)</argument_list></call></expr>,
<macro><name>TInfo</name><argument_list>(<argument>writtenTy</argument>)</argument_list></macro> <expr><block>{}</block>


<macro><name>ExplicitCastExpr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>EmptyShell Shell</argument>, <argument>unsigned PathSize</argument>,
<argument>bool HasFPFeatures</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CastExpr</name><argument_list>(<argument>SC</argument>, <argument>Shell</argument>, <argument>PathSize</argument>, <argument>HasFPFeatures</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>


<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeInfoAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TInfo</name></expr>;</return> }</block>
<name>void</name> <macro><name>setTypeInfoAsWritten</name><argument_list>(<argument>TypeSourceInfo *writtenTy</argument>)</argument_list></macro> <block>{ <expr><name>TInfo</name> <operator>=</operator> <name>writtenTy</name></expr>; }</block>



<name>QualType</name> <macro><name>getTypeAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>TInfo</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>firstExplicitCastExprConstant</name> <operator>&amp;&amp;</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>lastExplicitCastExprConstant</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>CStyleCastExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>ExplicitCastExpr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>CStyleCastExpr</name></expr></argument>, <argument><expr><name>CXXBaseSpecifier</name> <operator>*</operator></expr></argument>,
<argument><expr><name>FPOptionsOverride</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>SourceLocation</name> <name>LPLoc</name></expr>;
<expr><name>SourceLocation</name> <name>RPLoc</name></expr>;

<macro><name>CStyleCastExpr</name><argument_list>(<argument>QualType exprTy</argument>, <argument>ExprValueKind vk</argument>, <argument>CastKind kind</argument>, <argument>Expr *op</argument>,
<argument>unsigned PathSize</argument>, <argument>FPOptionsOverride FPO</argument>,
<argument>TypeSourceInfo *writtenTy</argument>, <argument>SourceLocation l</argument>, <argument>SourceLocation r</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>ExplicitCastExpr</name><argument_list>(<argument><expr><name>CStyleCastExprClass</name></expr></argument>, <argument><expr><name>exprTy</name></expr></argument>, <argument><expr><name>vk</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>PathSize</name></expr></argument>,
<argument><expr><call><name><name>FPO</name><operator>.</operator><name>requiresTrailingStorage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>writtenTy</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LPLoc</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>, <macro><name>RPLoc</name><argument_list>(<argument>r</argument>)</argument_list></macro> <expr><block>{
<if_stmt><if>if <condition>(<expr><call><name>hasStoredFPFeatures</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><call><name>getTrailingFPFeatures</name><argument_list>()</argument_list></call> <operator>=</operator> <name>FPO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>


<name>explicit</name> <macro><name>CStyleCastExpr</name><argument_list>(<argument>EmptyShell Shell</argument>, <argument>unsigned PathSize</argument>,
<argument>bool HasFPFeatures</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>ExplicitCastExpr</name><argument_list>(<argument>CStyleCastExprClass</argument>, <argument>Shell</argument>, <argument>PathSize</argument>, <argument>HasFPFeatures</argument>)</argument_list></macro> <block>{}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;CXXBaseSpecifier *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>path_size</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>CStyleCastExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>QualType T</argument>, <argument>ExprValueKind VK</argument>, <argument>CastKind K</argument>,
<argument>Expr *Op</argument>, <argument>const CXXCastPath *BasePath</argument>, <argument>FPOptionsOverride FPO</argument>,
<argument>TypeSourceInfo *WrittenTy</argument>, <argument>SourceLocation L</argument>, <argument>SourceLocation R</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>CStyleCastExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Context</argument>,
<argument>unsigned PathSize</argument>, <argument>bool HasFPFeatures</argument>)</argument_list></macro></expr>;

<expr><name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LPLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>LPLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RPLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RPLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>LPLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getSubExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CStyleCastExprClass</name></expr>;</return>
}</block>

<name>friend</name> <name>TrailingObjects</name></expr>;
<expr><name>friend</name> <name>class</name> <name>CastExpr</name></expr>;
}</block></expr>;



















<expr><name>class</name> <name>BinaryOperator</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
enum <expr><block>{ <expr><name>LHS</name></expr>, <expr><name>RHS</name></expr>, <expr><name>END_EXPR</name></expr> }</block></expr>;
<expr><name>Stmt</name> <operator>*</operator><name><name>SubExprs</name><index>[<expr><name>END_EXPR</name></expr>]</index></name></expr>;

<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <type><name>BinaryOperatorKind</name></type> <name>Opcode</name>;</typedef>

<name>protected</name><operator>:</operator>
<name>size_t</name> <macro><name>offsetOfTrailingStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier></block></expr>;


<expr><name>FPOptionsOverride</name> <operator>*</operator><macro><name>getTrailingFPFeatures</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>BinaryOperatorBits</name><operator>.</operator><name>HasFPFeatures</name></name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>FPOptionsOverride</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>char</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>offsetOfTrailingStorage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>FPOptionsOverride</name> <operator>*</operator><macro><name>getTrailingFPFeatures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>BinaryOperatorBits</name><operator>.</operator><name>HasFPFeatures</name></name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>FPOptionsOverride</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>offsetOfTrailingStorage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<macro><name>BinaryOperator</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>Expr *lhs</argument>, <argument>Expr *rhs</argument>, <argument>Opcode opc</argument>,
<argument>QualType ResTy</argument>, <argument>ExprValueKind VK</argument>, <argument>ExprObjectKind OK</argument>,
<argument>SourceLocation opLoc</argument>, <argument>FPOptionsOverride FPFeatures</argument>)</argument_list></macro></expr>;


<expr><name>explicit</name> <macro><name>BinaryOperator</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>BinaryOperatorClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{
<expr><name><name>BinaryOperatorBits</name><operator>.</operator><name>Opc</name></name> <operator>=</operator> <name>BO_Comma</name></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>BinaryOperator</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>bool hasFPFeatures</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>BinaryOperator</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>Expr *lhs</argument>, <argument>Expr *rhs</argument>,
<argument>Opcode opc</argument>, <argument>QualType ResTy</argument>, <argument>ExprValueKind VK</argument>,
<argument>ExprObjectKind OK</argument>, <argument>SourceLocation opLoc</argument>,
<argument>FPOptionsOverride FPFeatures</argument>)</argument_list></macro></expr>;
<expr><name>SourceLocation</name> <macro><name>getExprLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getOperatorLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getOperatorLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>BinaryOperatorBits</name><operator>.</operator><name>OpLoc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setOperatorLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>BinaryOperatorBits</name><operator>.</operator><name>OpLoc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>Opcode</name> <macro><name>getOpcode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Opcode</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>BinaryOperatorBits</name><operator>.</operator><name>Opc</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>setOpcode</name><argument_list>(<argument>Opcode Opc</argument>)</argument_list></macro> <block>{ <expr><name><name>BinaryOperatorBits</name><operator>.</operator><name>Opc</name></name> <operator>=</operator> <name>Opc</name></expr>; }</block>

<name>Expr</name> <operator>*</operator><macro><name>getLHS</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>LHS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setLHS</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>LHS</name></expr>]</index></name> <operator>=</operator> <name>E</name></expr>; }</block>
<name>Expr</name> <operator>*</operator><macro><name>getRHS</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>RHS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setRHS</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>RHS</name></expr>]</index></name> <operator>=</operator> <name>E</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getLHS</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getRHS</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<specifier>static</specifier> <name>StringRef</name> <macro><name>getOpcodeStr</name><argument_list>(<argument>Opcode Op</argument>)</argument_list></macro></expr>;

<expr><name>StringRef</name> <macro><name>getOpcodeStr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getOpcodeStr</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>



<specifier>static</specifier> <name>Opcode</name> <macro><name>getOverloadedOpcode</name><argument_list>(<argument>OverloadedOperatorKind OO</argument>)</argument_list></macro></expr>;



<expr><specifier>static</specifier> <name>OverloadedOperatorKind</name> <macro><name>getOverloadedOperator</name><argument_list>(<argument>Opcode Opc</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>bool</name> <macro><name>isPtrMemOp</name><argument_list>(<argument>Opcode Opc</argument>)</argument_list></macro> <block>{
<return>return <expr><name>Opc</name> <operator>==</operator> <name>BO_PtrMemD</name> <operator>||</operator> <name>Opc</name> <operator>==</operator> <name>BO_PtrMemI</name></expr>;</return>
}</block>
<name>bool</name> <macro><name>isPtrMemOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isPtrMemOp</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isMultiplicativeOp</name><argument_list>(<argument>Opcode Opc</argument>)</argument_list></macro> <block>{
<return>return <expr><name>Opc</name> <operator>&gt;=</operator> <name>BO_Mul</name> <operator>&amp;&amp;</operator> <name>Opc</name> <operator>&lt;=</operator> <name>BO_Rem</name></expr>;</return>
}</block>
<name>bool</name> <macro><name>isMultiplicativeOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isMultiplicativeOp</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>isAdditiveOp</name><argument_list>(<argument>Opcode Opc</argument>)</argument_list></macro> <block>{ <return>return <expr><name>Opc</name> <operator>==</operator> <name>BO_Add</name> <operator>||</operator> <name>Opc</name><operator>==</operator><name>BO_Sub</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isAdditiveOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isAdditiveOp</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>isShiftOp</name><argument_list>(<argument>Opcode Opc</argument>)</argument_list></macro> <block>{ <return>return <expr><name>Opc</name> <operator>==</operator> <name>BO_Shl</name> <operator>||</operator> <name>Opc</name> <operator>==</operator> <name>BO_Shr</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isShiftOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isShiftOp</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isBitwiseOp</name><argument_list>(<argument>Opcode Opc</argument>)</argument_list></macro> <block>{ <return>return <expr><name>Opc</name> <operator>&gt;=</operator> <name>BO_And</name> <operator>&amp;&amp;</operator> <name>Opc</name> <operator>&lt;=</operator> <name>BO_Or</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isBitwiseOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isBitwiseOp</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isRelationalOp</name><argument_list>(<argument>Opcode Opc</argument>)</argument_list></macro> <block>{ <return>return <expr><name>Opc</name> <operator>&gt;=</operator> <name>BO_LT</name> <operator>&amp;&amp;</operator> <name>Opc</name><operator>&lt;=</operator><name>BO_GE</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isRelationalOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isRelationalOp</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isEqualityOp</name><argument_list>(<argument>Opcode Opc</argument>)</argument_list></macro> <block>{ <return>return <expr><name>Opc</name> <operator>==</operator> <name>BO_EQ</name> <operator>||</operator> <name>Opc</name> <operator>==</operator> <name>BO_NE</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isEqualityOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isEqualityOp</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isComparisonOp</name><argument_list>(<argument>Opcode Opc</argument>)</argument_list></macro> <block>{ <return>return <expr><name>Opc</name> <operator>&gt;=</operator> <name>BO_Cmp</name> <operator>&amp;&amp;</operator> <name>Opc</name><operator>&lt;=</operator><name>BO_NE</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isComparisonOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isComparisonOp</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isCommaOp</name><argument_list>(<argument>Opcode Opc</argument>)</argument_list></macro> <block>{ <return>return <expr><name>Opc</name> <operator>==</operator> <name>BO_Comma</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isCommaOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isCommaOp</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>Opcode</name> <macro><name>negateComparisonOp</name><argument_list>(<argument>Opcode Opc</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><name>Opc</name></expr>)</condition> <block>{<block_content>
<default>default:</default>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Not a comparison operator."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><name>BO_LT</name></expr>:</case> <return>return <expr><name>BO_GE</name></expr>;</return>
<case>case <expr><name>BO_GT</name></expr>:</case> <return>return <expr><name>BO_LE</name></expr>;</return>
<case>case <expr><name>BO_LE</name></expr>:</case> <return>return <expr><name>BO_GT</name></expr>;</return>
<case>case <expr><name>BO_GE</name></expr>:</case> <return>return <expr><name>BO_LT</name></expr>;</return>
<case>case <expr><name>BO_EQ</name></expr>:</case> <return>return <expr><name>BO_NE</name></expr>;</return>
<case>case <expr><name>BO_NE</name></expr>:</case> <return>return <expr><name>BO_EQ</name></expr>;</return>
<expr_stmt/>}</block_content>
}

static Opcode reverseComparisonOp(Opcode Opc</block></switch>) <block>{
<switch>switch <condition>(<expr><name>Opc</name></expr>)</condition> <block>{<block_content>
<default>default:</default>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Not a comparison operator."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><name>BO_LT</name></expr>:</case> <return>return <expr><name>BO_GT</name></expr>;</return>
<case>case <expr><name>BO_GT</name></expr>:</case> <return>return <expr><name>BO_LT</name></expr>;</return>
<case>case <expr><name>BO_LE</name></expr>:</case> <return>return <expr><name>BO_GE</name></expr>;</return>
<case>case <expr><name>BO_GE</name></expr>:</case> <return>return <expr><name>BO_LE</name></expr>;</return>
<case>case <expr><name>BO_EQ</name></expr>:</case>
<case>case <expr><name>BO_NE</name></expr>:</case>
<return>return <expr><name>Opc</name></expr>;</return>
<expr_stmt/>}</block_content>
}

static bool isLogicalOp(Opcode Opc</block></switch>) <block>{ <return>return <expr><name>Opc</name> <operator>==</operator> <name>BO_LAnd</name> <operator>||</operator> <name>Opc</name><operator>==</operator><name>BO_LOr</name></expr>;</return> }</block></block></block>
<name>bool</name> <macro><name>isLogicalOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isLogicalOp</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isAssignmentOp</name><argument_list>(<argument>Opcode Opc</argument>)</argument_list></macro> <block>{
<return>return <expr><name>Opc</name> <operator>&gt;=</operator> <name>BO_Assign</name> <operator>&amp;&amp;</operator> <name>Opc</name> <operator>&lt;=</operator> <name>BO_OrAssign</name></expr>;</return>
}</block>
<name>bool</name> <macro><name>isAssignmentOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isAssignmentOp</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isCompoundAssignmentOp</name><argument_list>(<argument>Opcode Opc</argument>)</argument_list></macro> <block>{
<return>return <expr><name>Opc</name> <operator>&gt;</operator> <name>BO_Assign</name> <operator>&amp;&amp;</operator> <name>Opc</name> <operator>&lt;=</operator> <name>BO_OrAssign</name></expr>;</return>
}</block>
<name>bool</name> <macro><name>isCompoundAssignmentOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isCompoundAssignmentOp</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>Opcode</name> <macro><name>getOpForCompoundAssignment</name><argument_list>(<argument>Opcode Opc</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isCompoundAssignmentOp</name><argument_list>(<argument><expr><name>Opc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>Opc</name> <operator>&gt;=</operator> <name>BO_AndAssign</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>Opcode</name><argument_list>(<argument><expr><call><name>unsigned</name><argument_list>(<argument><expr><name>Opc</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>BO_AndAssign</name> <operator>+</operator> <name>BO_And</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>Opcode</name><argument_list>(<argument><expr><call><name>unsigned</name><argument_list>(<argument><expr><name>Opc</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>BO_MulAssign</name> <operator>+</operator> <name>BO_Mul</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isShiftAssignOp</name><argument_list>(<argument>Opcode Opc</argument>)</argument_list></macro> <block>{
<return>return <expr><name>Opc</name> <operator>==</operator> <name>BO_ShlAssign</name> <operator>||</operator> <name>Opc</name> <operator>==</operator> <name>BO_ShrAssign</name></expr>;</return>
}</block>
<name>bool</name> <macro><name>isShiftAssignOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isShiftAssignOp</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<specifier>static</specifier> <name>bool</name> <macro><name>isNullPointerArithmeticExtension</name><argument_list>(<argument>ASTContext &amp;Ctx</argument>, <argument>Opcode Opc</argument>,
<argument>Expr *LHS</argument>, <argument>Expr *RHS</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *S</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>S</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>firstBinaryOperatorConstant</name> <operator>&amp;&amp;</operator>
<call><name><name>S</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>lastBinaryOperatorConstant</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><name>END_EXPR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>END_EXPR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>void</name> <macro><name>setHasStoredFPFeatures</name><argument_list>(<argument>bool B</argument>)</argument_list></macro> <block>{ <expr><name><name>BinaryOperatorBits</name><operator>.</operator><name>HasFPFeatures</name></name> <operator>=</operator> <name>B</name></expr>; }</block>
<name>bool</name> <macro><name>hasStoredFPFeatures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>BinaryOperatorBits</name><operator>.</operator><name>HasFPFeatures</name></name></expr>;</return> }</block>


<name>FPOptionsOverride</name> <macro><name>getStoredFPFeatures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasStoredFPFeatures</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><call><name>getTrailingFPFeatures</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setStoredFPFeatures</name><argument_list>(<argument>FPOptionsOverride F</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>BinaryOperatorBits</name><operator>.</operator><name>HasFPFeatures</name></name></expr></argument>)</argument_list></call></expr>;
<expr><operator>*</operator><call><name>getTrailingFPFeatures</name><argument_list>()</argument_list></call> <operator>=</operator> <name>F</name></expr>;
}</block>



<name>FPOptions</name> <macro><name>getFPFeaturesInEffect</name><argument_list>(<argument>const LangOptions &amp;LO</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name><name>BinaryOperatorBits</name><operator>.</operator><name>HasFPFeatures</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getStoredFPFeatures</name><argument_list>()</argument_list></call><operator>.</operator><call><name>applyOverrides</name><argument_list>(<argument><expr><name>LO</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>FPOptions</name><operator>::</operator><call><name>defaultWithoutTrailingStorage</name><argument_list>(<argument><expr><name>LO</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>


<decl_stmt><decl><type><name>FPOptionsOverride</name></type> <name>getFPFeatures</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><name>LO</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>BinaryOperatorBits</name><operator>.</operator><name>HasFPFeatures</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getStoredFPFeatures</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>FPOptionsOverride</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isFPContractableWithinStatement</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><name>LO</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getFPFeaturesInEffect</name><argument_list>(<argument><expr><name>LO</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>allowFPContractWithinStatement</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isFEnvAccessOn</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><name>LO</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getFPFeaturesInEffect</name><argument_list>(<argument><expr><name>LO</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getAllowFEnvAccess</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>protected</name>:</label>
<macro><name>BinaryOperator</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>Expr *lhs</argument>, <argument>Expr *rhs</argument>, <argument>Opcode opc</argument>,
<argument>QualType ResTy</argument>, <argument>ExprValueKind VK</argument>, <argument>ExprObjectKind OK</argument>,
<argument>SourceLocation opLoc</argument>, <argument>FPOptionsOverride FPFeatures</argument>,
<argument>bool dead2</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<macro><name>BinaryOperator</name><argument_list>(<argument>StmtClass SC</argument>, <argument>EmptyShell Empty</argument>)</argument_list></macro> : <macro><name>Expr</name><argument_list>(<argument>SC</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name><name>BinaryOperatorBits</name><operator>.</operator><name>Opc</name></name> <operator>=</operator> <name>BO_MulAssign</name></expr>;</expr_stmt>
</block_content>}</block>



<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>sizeOfTrailingObjects</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>HasFPFeatures</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>HasFPFeatures</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FPOptionsOverride</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>
};







<decl_stmt><decl><type><name>class</name></type> <name>CompoundAssignOperator</name> <range>: <expr><name>public</name> <name>BinaryOperator</name> <block>{
<expr><name>QualType</name> <name>ComputationLHSType</name></expr>;
<expr><name>QualType</name> <name>ComputationResultType</name></expr>;


<expr><name>explicit</name> <macro><name>CompoundAssignOperator</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>EmptyShell Empty</argument>,
<argument>bool hasFPFeatures</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>BinaryOperator</name><argument_list>(<argument>CompoundAssignOperatorClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>protected</name><operator>:</operator>
<macro><name>CompoundAssignOperator</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>Expr *lhs</argument>, <argument>Expr *rhs</argument>, <argument>Opcode opc</argument>,
<argument>QualType ResType</argument>, <argument>ExprValueKind VK</argument>, <argument>ExprObjectKind OK</argument>,
<argument>SourceLocation OpLoc</argument>, <argument>FPOptionsOverride FPFeatures</argument>,
<argument>QualType CompLHSType</argument>, <argument>QualType CompResultType</argument>)</argument_list></macro>
<operator>:</operator> <call><name>BinaryOperator</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>opc</name></expr></argument>, <argument><expr><name>ResType</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>OK</name></expr></argument>, <argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>FPFeatures</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ComputationLHSType</name><argument_list>(<argument><expr><name>CompLHSType</name></expr></argument>)</argument_list></call></expr>, <macro><name>ComputationResultType</name><argument_list>(<argument>CompResultType</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isCompoundAssignmentOp</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Only should be used for compound assignments"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>CompoundAssignOperator</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>bool hasFPFeatures</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>CompoundAssignOperator</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>Expr *lhs</argument>, <argument>Expr *rhs</argument>, <argument>Opcode opc</argument>, <argument>QualType ResTy</argument>,
<argument>ExprValueKind VK</argument>, <argument>ExprObjectKind OK</argument>, <argument>SourceLocation opLoc</argument>,
<argument>FPOptionsOverride FPFeatures</argument>, <argument>QualType CompLHSType = QualType()</argument>,
<argument>QualType CompResultType = QualType()</argument>)</argument_list></macro></expr>;




<expr><name>QualType</name> <macro><name>getComputationLHSType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ComputationLHSType</name></expr>;</return> }</block>
<name>void</name> <macro><name>setComputationLHSType</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <block>{ <expr><name>ComputationLHSType</name> <operator>=</operator> <name>T</name></expr>; }</block>

<name>QualType</name> <macro><name>getComputationResultType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ComputationResultType</name></expr>;</return> }</block>
<name>void</name> <macro><name>setComputationResultType</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <block>{ <expr><name>ComputationResultType</name> <operator>=</operator> <name>T</name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *S</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>S</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CompoundAssignOperatorClass</name></expr>;</return>
}</block>
}</expr>;

<expr><specifier>inline</specifier> <name>size_t</name> <name>BinaryOperator</name><operator>::</operator><macro><name>offsetOfTrailingStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>BinaryOperatorBits</name><operator>.</operator><name>HasFPFeatures</name></name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><ternary><condition><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>CompoundAssignOperator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>CompoundAssignOperator</name></expr></argument>)</argument_list></sizeof></expr>
</then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><name>BinaryOperator</name></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr>;</return>
}</block>



<name>class</name> <name>AbstractConditionalOperator</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>SourceLocation</name> <name>QuestionLoc</name></expr>, <expr><name>ColonLoc</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>AbstractConditionalOperator</name><argument_list>(<argument>StmtClass SC</argument>, <argument>QualType T</argument>, <argument>ExprValueKind VK</argument>,
<argument>ExprObjectKind OK</argument>, <argument>SourceLocation qloc</argument>,
<argument>SourceLocation cloc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>SC</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>OK</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>QuestionLoc</name><argument_list>(<argument><expr><name>qloc</name></expr></argument>)</argument_list></call></expr>, <macro><name>ColonLoc</name><argument_list>(<argument>cloc</argument>)</argument_list></macro> <expr><block>{}</block>

<macro><name>AbstractConditionalOperator</name><argument_list>(<argument>StmtClass SC</argument>, <argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>SC</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>

<name>public</name><operator>:</operator>


<name>Expr</name> <operator>*</operator><macro><name>getCond</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>Expr</name> <operator>*</operator><macro><name>getTrueExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>Expr</name> <operator>*</operator><macro><name>getFalseExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>SourceLocation</name> <macro><name>getQuestionLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QuestionLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColonLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ConditionalOperatorClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>BinaryConditionalOperatorClass</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>ConditionalOperator</name> <operator>:</operator> <name>public</name> <name>AbstractConditionalOperator</name> <block>{
enum <expr><block>{ <expr><name>COND</name></expr>, <expr><name>LHS</name></expr>, <expr><name>RHS</name></expr>, <expr><name>END_EXPR</name></expr> }</block></expr>;
<expr><name>Stmt</name><operator>*</operator> <name><name>SubExprs</name><index>[<expr><name>END_EXPR</name></expr>]</index></name></expr>;

<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>public</name><operator>:</operator>
<macro><name>ConditionalOperator</name><argument_list>(<argument>Expr *cond</argument>, <argument>SourceLocation QLoc</argument>, <argument>Expr *lhs</argument>,
<argument>SourceLocation CLoc</argument>, <argument>Expr *rhs</argument>, <argument>QualType t</argument>,
<argument>ExprValueKind VK</argument>, <argument>ExprObjectKind OK</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>AbstractConditionalOperator</name><argument_list>(<argument>ConditionalOperatorClass</argument>, <argument>t</argument>, <argument>VK</argument>, <argument>OK</argument>, <argument>QLoc</argument>,
<argument>CLoc</argument>)</argument_list></macro> <block>{
<expr><name><name>SubExprs</name><index>[<expr><name>COND</name></expr>]</index></name> <operator>=</operator> <name>cond</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>LHS</name></expr>]</index></name> <operator>=</operator> <name>lhs</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>RHS</name></expr>]</index></name> <operator>=</operator> <name>rhs</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>ConditionalOperator</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>AbstractConditionalOperator</name><argument_list>(<argument>ConditionalOperatorClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>



<name>Expr</name> <operator>*</operator><macro><name>getCond</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>COND</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>



<name>Expr</name> <operator>*</operator><macro><name>getTrueExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>LHS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>




<name>Expr</name> <operator>*</operator><macro><name>getFalseExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>RHS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getLHS</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>LHS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>Expr</name> <operator>*</operator><macro><name>getRHS</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>RHS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getCond</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getRHS</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ConditionalOperatorClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><name>END_EXPR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>END_EXPR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;






<expr><name>class</name> <name>BinaryConditionalOperator</name> <operator>:</operator> <name>public</name> <name>AbstractConditionalOperator</name> <block>{
enum <expr><block>{ <expr><name>COMMON</name></expr>, <expr><name>COND</name></expr>, <expr><name>LHS</name></expr>, <expr><name>RHS</name></expr>, <expr><name>NUM_SUBEXPRS</name></expr> }</block></expr>;






<expr><name>Stmt</name> <operator>*</operator><name><name>SubExprs</name><index>[<expr><name>NUM_SUBEXPRS</name></expr>]</index></name></expr>;
<expr><name>OpaqueValueExpr</name> <operator>*</operator><name>OpaqueValue</name></expr>;

<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>public</name><operator>:</operator>
<macro><name>BinaryConditionalOperator</name><argument_list>(<argument>Expr *common</argument>, <argument>OpaqueValueExpr *opaqueValue</argument>,
<argument>Expr *cond</argument>, <argument>Expr *lhs</argument>, <argument>Expr *rhs</argument>,
<argument>SourceLocation qloc</argument>, <argument>SourceLocation cloc</argument>,
<argument>QualType t</argument>, <argument>ExprValueKind VK</argument>, <argument>ExprObjectKind OK</argument>)</argument_list></macro>
<operator>:</operator> <call><name>AbstractConditionalOperator</name><argument_list>(<argument><expr><name>BinaryConditionalOperatorClass</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>OK</name></expr></argument>,
<argument><expr><name>qloc</name></expr></argument>, <argument><expr><name>cloc</name></expr></argument>)</argument_list></call></expr>,
<macro><name>OpaqueValue</name><argument_list>(<argument>opaqueValue</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>SubExprs</name><index>[<expr><name>COMMON</name></expr>]</index></name> <operator>=</operator> <name>common</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>COND</name></expr>]</index></name> <operator>=</operator> <name>cond</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>LHS</name></expr>]</index></name> <operator>=</operator> <name>lhs</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>RHS</name></expr>]</index></name> <operator>=</operator> <name>rhs</name></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>OpaqueValue</name><operator>-&gt;</operator><name>getSourceExpr</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>common</name> <operator>&amp;&amp;</operator> <literal type="string">"Wrong opaque value"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>BinaryConditionalOperator</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>AbstractConditionalOperator</name><argument_list>(<argument>BinaryConditionalOperatorClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>




<name>Expr</name> <operator>*</operator><macro><name>getCommon</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>COMMON</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>


<name>OpaqueValueExpr</name> <operator>*</operator><macro><name>getOpaqueValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OpaqueValue</name></expr>;</return> }</block>



<name>Expr</name> <operator>*</operator><macro><name>getCond</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>COND</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>




<name>Expr</name> <operator>*</operator><macro><name>getTrueExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>LHS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>Expr</name> <operator>*</operator><macro><name>getFalseExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>RHS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getCommon</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getFalseExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>BinaryConditionalOperatorClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><name>SubExprs</name> <operator>+</operator> <name>NUM_SUBEXPRS</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><name>SubExprs</name> <operator>+</operator> <name>NUM_SUBEXPRS</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><specifier>inline</specifier> <name>Expr</name> <operator>*</operator><name>AbstractConditionalOperator</name><operator>::</operator><macro><name>getCond</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>ConditionalOperator</name> <modifier>*</modifier></type><name>co</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ConditionalOperator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>co</name><operator>-&gt;</operator><name>getCond</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>BinaryConditionalOperator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getCond</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>Expr</name> <operator>*</operator><name>AbstractConditionalOperator</name><operator>::</operator><macro><name>getTrueExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>ConditionalOperator</name> <modifier>*</modifier></type><name>co</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ConditionalOperator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>co</name><operator>-&gt;</operator><name>getTrueExpr</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>BinaryConditionalOperator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getTrueExpr</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>Expr</name> <operator>*</operator><name>AbstractConditionalOperator</name><operator>::</operator><macro><name>getFalseExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>ConditionalOperator</name> <modifier>*</modifier></type><name>co</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ConditionalOperator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>co</name><operator>-&gt;</operator><name>getFalseExpr</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>BinaryConditionalOperator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getFalseExpr</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>class</name> <name>AddrLabelExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>SourceLocation</name> <name>AmpAmpLoc</name></expr>, <expr><name>LabelLoc</name></expr>;
<expr><name>LabelDecl</name> <operator>*</operator><name>Label</name></expr>;
<expr><name>public</name><operator>:</operator>
<macro><name>AddrLabelExpr</name><argument_list>(<argument>SourceLocation AALoc</argument>, <argument>SourceLocation LLoc</argument>, <argument>LabelDecl *L</argument>,
<argument>QualType t</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>AddrLabelExprClass</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>AmpAmpLoc</name><argument_list>(<argument><expr><name>AALoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LabelLoc</name><argument_list>(<argument><expr><name>LLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>Label</name><argument_list>(<argument>L</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><name>ExprDependence</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>AddrLabelExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>AddrLabelExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>

<name>SourceLocation</name> <macro><name>getAmpAmpLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AmpAmpLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setAmpAmpLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>AmpAmpLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getLabelLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LabelLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLabelLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>LabelLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>AmpAmpLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>LabelLoc</name></expr>;</return> }</block>

<name>LabelDecl</name> <operator>*</operator><macro><name>getLabel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Label</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLabel</name><argument_list>(<argument>LabelDecl *L</argument>)</argument_list></macro> <block>{ <expr><name>Label</name> <operator>=</operator> <name>L</name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>AddrLabelExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>StmtExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>Stmt</name> <operator>*</operator><name>SubStmt</name></expr>;
<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>, <expr><name>RParenLoc</name></expr>;
<expr><name>public</name><operator>:</operator>
<macro><name>StmtExpr</name><argument_list>(<argument>CompoundStmt *SubStmt</argument>, <argument>QualType T</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation RParenLoc</argument>, <argument>unsigned TemplateDepth</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>StmtExprClass</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>SubStmt</name><argument_list>(<argument><expr><name>SubStmt</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>RParenLoc</name><argument_list>(<argument>RParenLoc</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>TemplateDepth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;


<expr><name><name>StmtExprBits</name><operator>.</operator><name>TemplateDepth</name></name> <operator>=</operator> <name>TemplateDepth</name></expr>;
}</block>


<name>explicit</name> <macro><name>StmtExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>StmtExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>

<name>CompoundStmt</name> <operator>*</operator><macro><name>getSubStmt</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CompoundStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SubStmt</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>CompoundStmt</name> <operator>*</operator><macro><name>getSubStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CompoundStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SubStmt</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setSubStmt</name><argument_list>(<argument>CompoundStmt *S</argument>)</argument_list></macro> <block>{ <expr><name>SubStmt</name> <operator>=</operator> <name>S</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>unsigned</name> <macro><name>getTemplateDepth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>StmtExprBits</name><operator>.</operator><name>TemplateDepth</name></name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>StmtExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubStmt</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubStmt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>ShuffleVectorExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>SourceLocation</name> <name>BuiltinLoc</name></expr>, <expr><name>RParenLoc</name></expr>;





<expr><name>Stmt</name> <operator>*</operator><operator>*</operator><name>SubExprs</name></expr>;
<expr><name>unsigned</name> <name>NumExprs</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>ShuffleVectorExpr</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>ArrayRef&lt;Expr*&gt; args</argument>, <argument>QualType Type</argument>,
<argument>SourceLocation BLoc</argument>, <argument>SourceLocation RP</argument>)</argument_list></macro></expr>;


<expr><name>explicit</name> <macro><name>ShuffleVectorExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ShuffleVectorExprClass</name></expr></argument>, <argument><expr><name>Empty</name></expr></argument>)</argument_list></call></expr>, <macro><name>SubExprs</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{ }</block>

<name>SourceLocation</name> <macro><name>getBuiltinLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BuiltinLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setBuiltinLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>BuiltinLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>BuiltinLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ShuffleVectorExprClass</name></expr>;</return>
}</block>




<name>unsigned</name> <macro><name>getNumSubExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumExprs</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><operator>*</operator><macro><name>getSubExprs</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SubExprs</name></expr></argument>)</argument_list></call></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getExpr</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>Index</name> <operator>&lt;</operator> <name>NumExprs</name><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Arg access out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>Index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getExpr</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>Index</name> <operator>&lt;</operator> <name>NumExprs</name><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Arg access out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>Index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <call><name>setExprs</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Exprs</name></expr></argument>)</argument_list></call></expr>;

<expr><name>llvm</name><operator>::</operator><name>APSInt</name> <macro><name>getShuffleMaskIdx</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>unsigned N</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>N</name> <operator>&lt;</operator> <name>NumExprs</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Shuffle idx out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getExpr</name><argument_list>(<argument><expr><name>N</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>EvaluateKnownConstInt</name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><name>NumExprs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>NumExprs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>ConvertVectorExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>private</name><operator>:</operator>
<name>Stmt</name> <operator>*</operator><name>SrcExpr</name></expr>;
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>TInfo</name></expr>;
<expr><name>SourceLocation</name> <name>BuiltinLoc</name></expr>, <expr><name>RParenLoc</name></expr>;

<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>explicit</name> <macro><name>ConvertVectorExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ConvertVectorExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<macro><name>ConvertVectorExpr</name><argument_list>(<argument>Expr *SrcExpr</argument>, <argument>TypeSourceInfo *TI</argument>, <argument>QualType DstType</argument>,
<argument>ExprValueKind VK</argument>, <argument>ExprObjectKind OK</argument>,
<argument>SourceLocation BuiltinLoc</argument>, <argument>SourceLocation RParenLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ConvertVectorExprClass</name></expr></argument>, <argument><expr><name>DstType</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>OK</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>SrcExpr</name><argument_list>(<argument><expr><name>SrcExpr</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TInfo</name><argument_list>(<argument><expr><name>TI</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>BuiltinLoc</name><argument_list>(<argument><expr><name>BuiltinLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>RParenLoc</name><argument_list>(<argument>RParenLoc</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<name>Expr</name> <operator>*</operator><macro><name>getSrcExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SrcExpr</name></expr></argument>)</argument_list></call></expr>;</return> }</block>


<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TInfo</name></expr>;</return>
}</block>
<name>void</name> <macro><name>setTypeSourceInfo</name><argument_list>(<argument>TypeSourceInfo *ti</argument>)</argument_list></macro> <block>{
<expr><name>TInfo</name> <operator>=</operator> <name>ti</name></expr>;
}</block>


<name>SourceLocation</name> <macro><name>getBuiltinLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BuiltinLoc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>BuiltinLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ConvertVectorExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SrcExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SrcExpr</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SrcExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SrcExpr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>ChooseExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
enum <expr><block>{ <expr><name>COND</name></expr>, <expr><name>LHS</name></expr>, <expr><name>RHS</name></expr>, <expr><name>END_EXPR</name></expr> }</block></expr>;
<expr><name>Stmt</name><operator>*</operator> <name><name>SubExprs</name><index>[<expr><name>END_EXPR</name></expr>]</index></name></expr>;
<expr><name>SourceLocation</name> <name>BuiltinLoc</name></expr>, <expr><name>RParenLoc</name></expr>;
<expr><name>bool</name> <name>CondIsTrue</name></expr>;
<expr><name>public</name><operator>:</operator>
<macro><name>ChooseExpr</name><argument_list>(<argument>SourceLocation BLoc</argument>, <argument>Expr *cond</argument>, <argument>Expr *lhs</argument>, <argument>Expr *rhs</argument>, <argument>QualType t</argument>,
<argument>ExprValueKind VK</argument>, <argument>ExprObjectKind OK</argument>, <argument>SourceLocation RP</argument>,
<argument>bool condIsTrue</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ChooseExprClass</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>OK</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>BuiltinLoc</name><argument_list>(<argument><expr><name>BLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>RParenLoc</name><argument_list>(<argument><expr><name>RP</name></expr></argument>)</argument_list></call></expr>,
<macro><name>CondIsTrue</name><argument_list>(<argument>condIsTrue</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>SubExprs</name><index>[<expr><name>COND</name></expr>]</index></name> <operator>=</operator> <name>cond</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>LHS</name></expr>]</index></name> <operator>=</operator> <name>lhs</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>RHS</name></expr>]</index></name> <operator>=</operator> <name>rhs</name></expr>;

<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>ChooseExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ChooseExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>



<name>bool</name> <macro><name>isConditionTrue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isConditionDependent</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Dependent condition isn't true or false"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>CondIsTrue</name></expr>;</return>
}</block>
<name>void</name> <macro><name>setIsConditionTrue</name><argument_list>(<argument>bool isTrue</argument>)</argument_list></macro> <block>{ <expr><name>CondIsTrue</name> <operator>=</operator> <name>isTrue</name></expr>; }</block>

<name>bool</name> <macro><name>isConditionDependent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCond</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isTypeDependent</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>getCond</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isValueDependent</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>Expr</name> <operator>*</operator><macro><name>getChosenSubExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isConditionTrue</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name>getLHS</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>getRHS</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getCond</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>COND</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setCond</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>COND</name></expr>]</index></name> <operator>=</operator> <name>E</name></expr>; }</block>
<name>Expr</name> <operator>*</operator><macro><name>getLHS</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>LHS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setLHS</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>LHS</name></expr>]</index></name> <operator>=</operator> <name>E</name></expr>; }</block>
<name>Expr</name> <operator>*</operator><macro><name>getRHS</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>RHS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setRHS</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>RHS</name></expr>]</index></name> <operator>=</operator> <name>E</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBuiltinLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BuiltinLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setBuiltinLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>BuiltinLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>BuiltinLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ChooseExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><name>END_EXPR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>END_EXPR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>GNUNullExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{

<expr><name>SourceLocation</name> <name>TokenLoc</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>GNUNullExpr</name><argument_list>(<argument>QualType Ty</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>GNUNullExprClass</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <macro><name>TokenLoc</name><argument_list>(<argument>Loc</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><name>ExprDependence</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>GNUNullExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>GNUNullExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>


<name>SourceLocation</name> <macro><name>getTokenLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TokenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setTokenLocation</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>TokenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>TokenLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>TokenLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>GNUNullExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>VAArgExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>Stmt</name> <operator>*</operator><name>Val</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>TInfo</name></expr>;
<expr><name>SourceLocation</name> <name>BuiltinLoc</name></expr>, <expr><name>RParenLoc</name></expr>;
<expr><name>public</name><operator>:</operator>
<macro><name>VAArgExpr</name><argument_list>(<argument>SourceLocation BLoc</argument>, <argument>Expr *e</argument>, <argument>TypeSourceInfo *TInfo</argument>,
<argument>SourceLocation RPLoc</argument>, <argument>QualType t</argument>, <argument>bool IsMS</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>VAArgExprClass</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Val</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TInfo</name><argument_list>(<argument><expr><name>TInfo</name></expr></argument>, <argument><expr><name>IsMS</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>BuiltinLoc</name><argument_list>(<argument><expr><name>BLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>RParenLoc</name><argument_list>(<argument>RPLoc</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>VAArgExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>VAArgExprClass</name></expr></argument>, <argument><expr><name>Empty</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Val</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>, <macro><name>TInfo</name><argument_list>(<argument>nullptr</argument>, <argument>false</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setSubExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>Val</name> <operator>=</operator> <name>E</name></expr>; }</block>


<name>bool</name> <macro><name>isMicrosoftABI</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>TInfo</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setIsMicrosoftABI</name><argument_list>(<argument>bool IsMS</argument>)</argument_list></macro> <block>{ <expr><call><name><name>TInfo</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>IsMS</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getWrittenTypeInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>TInfo</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setWrittenTypeInfo</name><argument_list>(<argument>TypeSourceInfo *TI</argument>)</argument_list></macro> <block>{ <expr><call><name><name>TInfo</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><name>TI</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBuiltinLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BuiltinLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setBuiltinLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>BuiltinLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>BuiltinLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>VAArgExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Val</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Val</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>SourceLocExpr</name> <name>final</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>SourceLocation</name> <name>BuiltinLoc</name></expr>, <expr><name>RParenLoc</name></expr>;
<expr><name>DeclContext</name> <operator>*</operator><name>ParentContext</name></expr>;

<expr><name>public</name><operator>:</operator>
enum <name>IdentKind</name> <block>{ <expr><name>Function</name></expr>, <expr><name>File</name></expr>, <expr><name>Line</name></expr>, <expr><name>Column</name></expr> }</block></expr>;

<macro><name>SourceLocExpr</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>IdentKind Type</argument>, <argument>SourceLocation BLoc</argument>,
<argument>SourceLocation RParenLoc</argument>, <argument>DeclContext *Context</argument>)</argument_list></macro>;


<expr><name>explicit</name> <macro><name>SourceLocExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>SourceLocExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>



<name>APValue</name> <macro><name>EvaluateInContext</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>,
<argument>const Expr *DefaultExpr</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>StringRef</name> <macro><name>getBuiltinStr</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>IdentKind</name> <macro><name>getIdentKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>IdentKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SourceLocExprBits</name><operator>.</operator><name>Kind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isStringType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<switch>switch <condition>(<expr><call><name>getIdentKind</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>File</name></expr>:</case>
<case>case <expr><name>Function</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>
<case>case <expr><name>Line</name></expr>:</case>
<case>case <expr><name>Column</name></expr>:</case>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/>}</block_content>
llvm_unreachable("unknown source location expression kind"</block></switch>)</block></expr>;
}</block>
<name>bool</name> <macro><name>isIntType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><operator>!</operator><call><name>isStringType</name><argument_list>()</argument_list></call></expr>;</return> }</block>



<specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>getParentContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ParentContext</name></expr>;</return> }</block>
<name>DeclContext</name> <operator>*</operator><macro><name>getParentContext</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>ParentContext</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BuiltinLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BuiltinLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SourceLocExprClass</name></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
}</block></expr>;














































<expr><name>class</name> <name>InitListExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{

<typedef>typedef <type><name><name>ASTVector</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></type> <name>InitExprsTy</name>;</typedef>
<name>InitExprsTy</name> <name>InitExprs</name></block></expr>;
<expr><name>SourceLocation</name> <name>LBraceLoc</name></expr>, <expr><name>RBraceLoc</name></expr>;






<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>InitListExpr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>AltForm</name></expr>;








<expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><name>FieldDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ArrayFillerOrUnionFieldInit</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>InitListExpr</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation lbraceloc</argument>,
<argument>ArrayRef&lt;Expr*&gt; initExprs</argument>, <argument>SourceLocation rbraceloc</argument>)</argument_list></macro></expr>;


<expr><name>explicit</name> <macro><name>InitListExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>InitListExprClass</name></expr></argument>, <argument><expr><name>Empty</name></expr></argument>)</argument_list></call></expr>, <macro><name>AltForm</name><argument_list>(<argument>nullptr</argument>, <argument>true</argument>)</argument_list></macro> <expr><block>{ }</block>

<name>unsigned</name> <macro><name>getNumInits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>InitExprs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><operator>*</operator><macro><name>getInits</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>InitExprs</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><macro><name>getInits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>InitExprs</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>inits</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getInits</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNumInits</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>inits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getInits</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNumInits</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getInit</name><argument_list>(<argument>unsigned Init</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Init</name> <operator>&lt;</operator> <call><name>getNumInits</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Initializer access out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>InitExprs</name><index>[<expr><name>Init</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getInit</name><argument_list>(<argument>unsigned Init</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Init</name> <operator>&lt;</operator> <call><name>getNumInits</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Initializer access out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>InitExprs</name><index>[<expr><name>Init</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setInit</name><argument_list>(<argument>unsigned Init</argument>, <argument>Expr *expr</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Init</name> <operator>&lt;</operator> <call><name>getNumInits</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Initializer access out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>InitExprs</name><index>[<expr><name>Init</name></expr>]</index></name> <operator>=</operator> <name>expr</name></expr>;

<if_stmt><if>if <condition>(<expr><name>expr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>getDependence</name><argument_list>()</argument_list></call> <operator>|</operator> <call><name><name>expr</name><operator>-&gt;</operator><name>getDependence</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>



<name>void</name> <macro><name>markError</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isSemanticForm</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>getDependence</name><argument_list>()</argument_list></call> <operator>|</operator> <name>ExprDependence</name><operator>::</operator><name>ErrorDependent</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>void</name> <macro><name>reserveInits</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumInits</argument>)</argument_list></macro></expr>;







<expr><name>void</name> <macro><name>resizeInits</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>unsigned NumInits</argument>)</argument_list></macro></expr>;








<expr><name>Expr</name> <operator>*</operator><macro><name>updateInit</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned Init</argument>, <argument>Expr *expr</argument>)</argument_list></macro></expr>;




<expr><name>Expr</name> <operator>*</operator><macro><name>getArrayFiller</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name><name>ArrayFillerOrUnionFieldInit</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>Expr</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getArrayFiller</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>InitListExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getArrayFiller</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>void</name> <call><name>setArrayFiller</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>filler</name></expr></argument>)</argument_list></call></expr>;



<expr><name>bool</name> <macro><name>hasArrayFiller</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getArrayFiller</name><argument_list>()</argument_list></call></expr>;</return> }</block>







<name>FieldDecl</name> <operator>*</operator><macro><name>getInitializedFieldInUnion</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name><name>ArrayFillerOrUnionFieldInit</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>FieldDecl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>
<specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><macro><name>getInitializedFieldInUnion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>InitListExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getInitializedFieldInUnion</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>setInitializedFieldInUnion</name><argument_list>(<argument>FieldDecl *FD</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>FD</name> <operator>==</operator> <name>nullptr</name>
<operator>||</operator> <call><name>getInitializedFieldInUnion</name><argument_list>()</argument_list></call> <operator>==</operator> <name>nullptr</name>
<operator>||</operator> <call><name>getInitializedFieldInUnion</name><argument_list>()</argument_list></call> <operator>==</operator> <name>FD</name><operator>)</operator>
<operator>&amp;&amp;</operator> <literal type="string">"Only one field of a union may be initialized at a time!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>ArrayFillerOrUnionFieldInit</name> <operator>=</operator> <name>FD</name></expr>;
}</block>





<name>bool</name> <macro><name>isExplicit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>LBraceLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>RBraceLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isStringLiteralInit</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>bool</name> <macro><name>isTransparent</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isIdiomaticZeroInitializer</name><argument_list>(<argument>const LangOptions &amp;LangOpts</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>SourceLocation</name> <macro><name>getLBraceLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LBraceLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLBraceLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LBraceLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getRBraceLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RBraceLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRBraceLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>RBraceLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>bool</name> <macro><name>isSemanticForm</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>AltForm</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>InitListExpr</name> <operator>*</operator><macro><name>getSemanticForm</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isSemanticForm</name><argument_list>()</argument_list></call> <operator>?</operator> <name>nullptr</name> <operator>:</operator> <call><name><name>AltForm</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>bool</name> <macro><name>isSyntacticForm</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name><name>AltForm</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>AltForm</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>InitListExpr</name> <operator>*</operator><macro><name>getSyntacticForm</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>isSemanticForm</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>AltForm</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<name>void</name> <macro><name>setSyntacticForm</name><argument_list>(<argument>InitListExpr *Init</argument>)</argument_list></macro> <block>{
<expr><call><name><name>AltForm</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>AltForm</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Init</name><operator>-&gt;</operator><name>AltForm</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Init</name><operator>-&gt;</operator><name>AltForm</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>bool</name> <macro><name>hadArrayRangeDesignator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>InitListExprBits</name><operator>.</operator><name>HadArrayRangeDesignator</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
}</block>
<name>void</name> <macro><name>sawArrayRangeDesignator</name><argument_list>(<argument>bool ARD = true</argument>)</argument_list></macro> <block>{
<expr><name><name>InitListExprBits</name><operator>.</operator><name>HadArrayRangeDesignator</name></name> <operator>=</operator> <name>ARD</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;
<expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>InitListExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<expr><name>const_child_range</name> <name>CCR</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>InitListExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>cast_away_const</name><argument_list>(<argument><expr><call><name><name>CCR</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>cast_away_const</name><argument_list>(<argument><expr><call><name><name>CCR</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{

<if_stmt><if>if <condition>(<expr><call><name><name>InitExprs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>InitExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>InitExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <call><name><name>InitExprs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr>

<typedef>typedef <expr_stmt><expr><name>InitExprsTy</name><operator>::</operator><name>iterator</name> <name>iterator</name></expr>;</expr_stmt></typedef></block></expr>
<typedef>typedef <expr_stmt><expr><name>InitExprsTy</name><operator>::</operator><name>const_iterator</name> <name>const_iterator</name></expr>;</expr_stmt></typedef></block></expr>
<typedef>typedef <expr_stmt><expr><name>InitExprsTy</name><operator>::</operator><name>reverse_iterator</name> <name>reverse_iterator</name></expr>;</expr_stmt></typedef></block></expr>
<typedef>typedef <expr_stmt><expr><name>InitExprsTy</name><operator>::</operator><name>const_reverse_iterator</name> <name>const_reverse_iterator</name></expr>;</expr_stmt></typedef>

<name>iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>InitExprs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></block>
<name>const_iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>InitExprs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>InitExprs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>InitExprs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>reverse_iterator</name> <macro><name>rbegin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>InitExprs</name><operator>.</operator><name>rbegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_reverse_iterator</name> <macro><name>rbegin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>InitExprs</name><operator>.</operator><name>rbegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>reverse_iterator</name> <macro><name>rend</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>InitExprs</name><operator>.</operator><name>rend</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_reverse_iterator</name> <macro><name>rend</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>InitExprs</name><operator>.</operator><name>rend</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;
}</block></expr>;





















<expr><name>class</name> <name>DesignatedInitExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>DesignatedInitExpr</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>

<name>class</name> <name>Designator</name></expr>;

<expr><name>private</name><operator>:</operator>


<name>SourceLocation</name> <name>EqualOrColonLoc</name></expr>;



<expr><name>unsigned</name> <name>GNUSyntax</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>unsigned</name> <name>NumDesignators</name> <operator>:</operator> <literal type="number">15</literal></expr>;




<expr><name>unsigned</name> <name>NumSubExprs</name> <operator>:</operator> <literal type="number">16</literal></expr>;



<expr><name>Designator</name> <operator>*</operator><name>Designators</name></expr>;

<macro><name>DesignatedInitExpr</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>QualType Ty</argument>,
<argument>llvm::ArrayRef&lt;Designator&gt; Designators</argument>,
<argument>SourceLocation EqualOrColonLoc</argument>, <argument>bool GNUSyntax</argument>,
<argument>ArrayRef&lt;Expr *&gt; IndexExprs</argument>, <argument>Expr *Init</argument>)</argument_list></macro>;

<expr><name>explicit</name> <macro><name>DesignatedInitExpr</name><argument_list>(<argument>unsigned NumSubExprs</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>DesignatedInitExprClass</name></expr></argument>, <argument><expr><call><name>EmptyShell</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>NumDesignators</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>NumSubExprs</name><argument_list>(<argument><expr><name>NumSubExprs</name></expr></argument>)</argument_list></call></expr>, <macro><name>Designators</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{ }</block>

<name>public</name><operator>:</operator>

struct <name>FieldDesignator</name> <block>{






<expr><name>uintptr_t</name> <name>NameOrField</name></expr>;


<expr><name>SourceLocation</name> <name>DotLoc</name></expr>;


<expr><name>SourceLocation</name> <name>FieldLoc</name></expr>;
}</block></expr>;


struct <expr><name>ArrayOrRangeDesignator</name> <block>{


<expr><name>unsigned</name> <name>Index</name></expr>;

<expr><name>SourceLocation</name> <name>LBracketLoc</name></expr>;


<expr><name>SourceLocation</name> <name>EllipsisLoc</name></expr>;

<expr><name>SourceLocation</name> <name>RBracketLoc</name></expr>;
}</block></expr>;







<expr><name>class</name> <name>Designator</name> <block>{

enum <expr><block>{
<expr><name>FieldDesignator</name></expr>,
<expr><name>ArrayDesignator</name></expr>,
<expr><name>ArrayRangeDesignator</name></expr>
}</block> <name>Kind</name></expr>;

<expr>union <block>{

struct <expr><name>FieldDesignator</name> <name>Field</name></expr>;

struct <expr><name>ArrayOrRangeDesignator</name> <name>ArrayOrRange</name></expr>;
}</block></expr>;
<expr><name>friend</name> <name>class</name> <name>DesignatedInitExpr</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>Designator</name><argument_list>()</argument_list></macro> <block>{}</block>


<macro><name>Designator</name><argument_list>(<argument>const IdentifierInfo *FieldName</argument>, <argument>SourceLocation DotLoc</argument>,
<argument>SourceLocation FieldLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Kind</name><argument_list>(<argument>FieldDesignator</argument>)</argument_list></macro> <block>{
<macro><name>new</name> <argument_list>(<argument>&amp;Field</argument>)</argument_list></macro> <expr><name>DesignatedInitExpr</name><operator>::</operator><name>FieldDesignator</name></expr>;
<expr><name><name>Field</name><operator>.</operator><name>NameOrField</name></name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>uintptr_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>FieldName</name></expr></argument>)</argument_list></call> <operator>|</operator> <literal type="number">0x01</literal></expr>;
<expr><name><name>Field</name><operator>.</operator><name>DotLoc</name></name> <operator>=</operator> <name>DotLoc</name></expr>;
<expr><name><name>Field</name><operator>.</operator><name>FieldLoc</name></name> <operator>=</operator> <name>FieldLoc</name></expr>;
}</block>


<macro><name>Designator</name><argument_list>(<argument>unsigned Index</argument>, <argument>SourceLocation LBracketLoc</argument>,
<argument>SourceLocation RBracketLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Kind</name><argument_list>(<argument>ArrayDesignator</argument>)</argument_list></macro> <block>{
<macro><name>new</name> <argument_list>(<argument>&amp;ArrayOrRange</argument>)</argument_list></macro> <expr><name>DesignatedInitExpr</name><operator>::</operator><name>ArrayOrRangeDesignator</name></expr>;
<expr><name><name>ArrayOrRange</name><operator>.</operator><name>Index</name></name> <operator>=</operator> <name>Index</name></expr>;
<expr><name><name>ArrayOrRange</name><operator>.</operator><name>LBracketLoc</name></name> <operator>=</operator> <name>LBracketLoc</name></expr>;
<expr><name><name>ArrayOrRange</name><operator>.</operator><name>EllipsisLoc</name></name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;
<expr><name><name>ArrayOrRange</name><operator>.</operator><name>RBracketLoc</name></name> <operator>=</operator> <name>RBracketLoc</name></expr>;
}</block>


<macro><name>Designator</name><argument_list>(<argument>unsigned Index</argument>, <argument>SourceLocation LBracketLoc</argument>,
<argument>SourceLocation EllipsisLoc</argument>, <argument>SourceLocation RBracketLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Kind</name><argument_list>(<argument>ArrayRangeDesignator</argument>)</argument_list></macro> <block>{
<macro><name>new</name> <argument_list>(<argument>&amp;ArrayOrRange</argument>)</argument_list></macro> <expr><name>DesignatedInitExpr</name><operator>::</operator><name>ArrayOrRangeDesignator</name></expr>;
<expr><name><name>ArrayOrRange</name><operator>.</operator><name>Index</name></name> <operator>=</operator> <name>Index</name></expr>;
<expr><name><name>ArrayOrRange</name><operator>.</operator><name>LBracketLoc</name></name> <operator>=</operator> <name>LBracketLoc</name></expr>;
<expr><name><name>ArrayOrRange</name><operator>.</operator><name>EllipsisLoc</name></name> <operator>=</operator> <name>EllipsisLoc</name></expr>;
<expr><name><name>ArrayOrRange</name><operator>.</operator><name>RBracketLoc</name></name> <operator>=</operator> <name>RBracketLoc</name></expr>;
}</block>

<name>bool</name> <macro><name>isFieldDesignator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>FieldDesignator</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isArrayDesignator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>ArrayDesignator</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isArrayRangeDesignator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>ArrayRangeDesignator</name></expr>;</return> }</block>

<name>IdentifierInfo</name> <operator>*</operator><macro><name>getFieldName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>FieldDecl</name> <operator>*</operator><macro><name>getField</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Kind</name> <operator>==</operator> <name>FieldDesignator</name> <operator>&amp;&amp;</operator> <literal type="string">"Only valid on a field designator"</literal></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name><name>Field</name><operator>.</operator><name>NameOrField</name></name> <operator>&amp;</operator> <literal type="number">0x01</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>FieldDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>Field</name><operator>.</operator><name>NameOrField</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block>

<name>void</name> <macro><name>setField</name><argument_list>(<argument>FieldDecl *FD</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Kind</name> <operator>==</operator> <name>FieldDesignator</name> <operator>&amp;&amp;</operator> <literal type="string">"Only valid on a field designator"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>Field</name><operator>.</operator><name>NameOrField</name></name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>uintptr_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>FD</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getDotLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Kind</name> <operator>==</operator> <name>FieldDesignator</name> <operator>&amp;&amp;</operator> <literal type="string">"Only valid on a field designator"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>Field</name><operator>.</operator><name>DotLoc</name></name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getFieldLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Kind</name> <operator>==</operator> <name>FieldDesignator</name> <operator>&amp;&amp;</operator> <literal type="string">"Only valid on a field designator"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>Field</name><operator>.</operator><name>FieldLoc</name></name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getLBracketLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>Kind</name> <operator>==</operator> <name>ArrayDesignator</name> <operator>||</operator> <name>Kind</name> <operator>==</operator> <name>ArrayRangeDesignator</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Only valid on an array or array-range designator"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>ArrayOrRange</name><operator>.</operator><name>LBracketLoc</name></name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getRBracketLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>Kind</name> <operator>==</operator> <name>ArrayDesignator</name> <operator>||</operator> <name>Kind</name> <operator>==</operator> <name>ArrayRangeDesignator</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Only valid on an array or array-range designator"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>ArrayOrRange</name><operator>.</operator><name>RBracketLoc</name></name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getEllipsisLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Kind</name> <operator>==</operator> <name>ArrayRangeDesignator</name> <operator>&amp;&amp;</operator>
<literal type="string">"Only valid on an array-range designator"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>ArrayOrRange</name><operator>.</operator><name>EllipsisLoc</name></name></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getFirstExprIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>Kind</name> <operator>==</operator> <name>ArrayDesignator</name> <operator>||</operator> <name>Kind</name> <operator>==</operator> <name>ArrayRangeDesignator</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Only valid on an array or array-range designator"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>ArrayOrRange</name><operator>.</operator><name>Index</name></name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<expr><name>Kind</name> <operator>==</operator> <name>FieldDesignator</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getDotLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isInvalid</name><argument_list>()</argument_list></call><operator>?</operator> <call><name>getFieldLoc</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>getDotLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>getLBracketLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><ternary><condition><expr><name>Kind</name> <operator>==</operator> <name>FieldDesignator</name></expr> ?</condition><then> <expr><call><name>getFieldLoc</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>getRBracketLoc</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>
<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><specifier>static</specifier> <name>DesignatedInitExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>llvm::ArrayRef&lt;Designator&gt; Designators</argument>,
<argument>ArrayRef&lt;Expr*&gt; IndexExprs</argument>,
<argument>SourceLocation EqualOrColonLoc</argument>,
<argument>bool GNUSyntax</argument>, <argument>Expr *Init</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>DesignatedInitExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumIndexExprs</argument>)</argument_list></macro></expr>;


<expr><name>unsigned</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumDesignators</name></expr>;</return> }</block>


<name>llvm</name><operator>::</operator><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Designator</name></expr></argument>&gt;</argument_list></name> <macro><name>designators</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><block>{<expr><name>Designators</name></expr>, <expr><name>NumDesignators</name></expr>}</block></expr>;</return>
}</block>

<name>llvm</name><operator>::</operator><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Designator</name></expr></argument>&gt;</argument_list></name> <macro><name>designators</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><name>Designators</name></expr>, <expr><name>NumDesignators</name></expr>}</block></expr>;</return>
}</block>

<name>Designator</name> <operator>*</operator><macro><name>getDesignator</name><argument_list>(<argument>unsigned Idx</argument>)</argument_list></macro> <block>{ <return>return <expr><operator>&amp;</operator><call><name>designators</name><argument_list>()</argument_list></call><index>[<expr><name>Idx</name></expr>]</index></expr>;</return> }</block>
<specifier>const</specifier> <name>Designator</name> <operator>*</operator><macro><name>getDesignator</name><argument_list>(<argument>unsigned Idx</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>&amp;</operator><call><name>designators</name><argument_list>()</argument_list></call><index>[<expr><name>Idx</name></expr>]</index></expr>;</return>
}</block>

<name>void</name> <macro><name>setDesignators</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>const Designator *Desigs</argument>,
<argument>unsigned NumDesigs</argument>)</argument_list></macro></expr>;

<expr><name>Expr</name> <operator>*</operator><macro><name>getArrayIndex</name><argument_list>(<argument>const Designator &amp;D</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>Expr</name> <operator>*</operator><macro><name>getArrayRangeStart</name><argument_list>(<argument>const Designator &amp;D</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>Expr</name> <operator>*</operator><macro><name>getArrayRangeEnd</name><argument_list>(<argument>const Designator &amp;D</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>SourceLocation</name> <macro><name>getEqualOrColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>EqualOrColonLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setEqualOrColonLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>EqualOrColonLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>



<name>bool</name> <macro><name>isDirectInit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>EqualOrColonLoc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>bool</name> <macro><name>usesGNUSyntax</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>GNUSyntax</name></expr>;</return> }</block>
<name>void</name> <macro><name>setGNUSyntax</name><argument_list>(<argument>bool GNU</argument>)</argument_list></macro> <block>{ <expr><name>GNUSyntax</name> <operator>=</operator> <name>GNU</name></expr>; }</block>


<name>Expr</name> <operator>*</operator><macro><name>getInit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DesignatedInitExpr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>child_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setInit</name><argument_list>(<argument>Expr *init</argument>)</argument_list></macro> <block>{
<expr><operator>*</operator><call><name>child_begin</name><argument_list>()</argument_list></call> <operator>=</operator> <name>init</name></expr>;
}</block>





<name>unsigned</name> <macro><name>getNumSubExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumSubExprs</name></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>(<argument>unsigned Idx</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Idx</name> <operator>&lt;</operator> <name>NumSubExprs</name> <operator>&amp;&amp;</operator> <literal type="string">"Subscript out of range"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>Idx</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setSubExpr</name><argument_list>(<argument>unsigned Idx</argument>, <argument>Expr *E</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Idx</name> <operator>&lt;</operator> <name>NumSubExprs</name> <operator>&amp;&amp;</operator> <literal type="string">"Subscript out of range"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>Idx</name></expr>]</index> <operator>=</operator> <name>E</name></expr>;
}</block>



<name>void</name> <macro><name>ExpandDesignator</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned Idx</argument>,
<argument>const Designator *First</argument>, <argument>const Designator *Last</argument>)</argument_list></macro></expr>;

<expr><name>SourceRange</name> <macro><name>getDesignatorsSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;
<expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DesignatedInitExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<expr><name>Stmt</name> <operator>*</operator><operator>*</operator><name>begin</name> <operator>=</operator> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>begin</name> <operator>+</operator> <name>NumSubExprs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>Stmt</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><name>begin</name> <operator>=</operator> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>begin</name> <operator>+</operator> <name>NumSubExprs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>friend</name> <name>TrailingObjects</name></expr>;
}</block></expr>;










<expr><name>class</name> <name>NoInitExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <macro><name>NoInitExpr</name><argument_list>(<argument>QualType ty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>NoInitExprClass</argument>, <argument>ty</argument>, <argument>VK_PRValue</argument>, <argument>OK_Ordinary</argument>)</argument_list></macro> <block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>explicit</name> <macro><name>NoInitExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>NoInitExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NoInitExprClass</name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;












<expr><name>class</name> <name>DesignatedInitUpdateExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{


<expr><name>Stmt</name> <operator>*</operator><name><name>BaseAndUpdaterExprs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>DesignatedInitUpdateExpr</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation lBraceLoc</argument>,
<argument>Expr *baseExprs</argument>, <argument>SourceLocation rBraceLoc</argument>)</argument_list></macro></expr>;

<expr><name>explicit</name> <macro><name>DesignatedInitUpdateExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>DesignatedInitUpdateExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;
<expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DesignatedInitUpdateExprClass</name></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>BaseAndUpdaterExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setBase</name><argument_list>(<argument>Expr *Base</argument>)</argument_list></macro> <block>{ <expr><name><name>BaseAndUpdaterExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>Base</name></expr>; }</block>

<name>InitListExpr</name> <operator>*</operator><macro><name>getUpdater</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>InitListExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>BaseAndUpdaterExprs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>setUpdater</name><argument_list>(<argument>Expr *Updater</argument>)</argument_list></macro> <block>{ <expr><name><name>BaseAndUpdaterExprs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>Updater</name></expr>; }</block>



<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>BaseAndUpdaterExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>BaseAndUpdaterExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>BaseAndUpdaterExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>BaseAndUpdaterExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

















<expr><name>class</name> <name>ArrayInitLoopExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>Stmt</name> <operator>*</operator><name><name>SubExprs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;

<expr><name>explicit</name> <macro><name>ArrayInitLoopExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ArrayInitLoopExprClass</name></expr></argument>, <argument><expr><name>Empty</name></expr></argument>)</argument_list></call></expr>, <expr><name>SubExprs</name><block>{}</block> <block>{}</block>

<name>public</name><operator>:</operator>
<name>explicit</name> <macro><name>ArrayInitLoopExpr</name><argument_list>(<argument>QualType T</argument>, <argument>Expr *CommonInit</argument>, <argument>Expr *ElementInit</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ArrayInitLoopExprClass</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>,
<expr><name>SubExprs</name><block>{<expr><name>CommonInit</name></expr>, <expr><name>ElementInit</name></expr>}</block> <block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>



<name>OpaqueValueExpr</name> <operator>*</operator><macro><name>getCommonExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>OpaqueValueExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>llvm</name><operator>::</operator><name>APInt</name> <macro><name>getArraySize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ConstantArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>castAsArrayTypeUnsafe</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>getSize</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *S</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>S</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ArrayInitLoopExprClass</name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getCommonExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getCommonExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><name>SubExprs</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><name>SubExprs</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;
}</block></expr>;




<expr><name>class</name> <name>ArrayInitIndexExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>explicit</name> <macro><name>ArrayInitIndexExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ArrayInitIndexExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<name>explicit</name> <macro><name>ArrayInitIndexExpr</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ArrayInitIndexExprClass</argument>, <argument>T</argument>, <argument>VK_PRValue</argument>, <argument>OK_Ordinary</argument>)</argument_list></macro> <block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><name>ExprDependence</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *S</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>S</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ArrayInitIndexExprClass</name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
}</block></expr>;









<expr><name>class</name> <name>ImplicitValueInitExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <macro><name>ImplicitValueInitExpr</name><argument_list>(<argument>QualType ty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ImplicitValueInitExprClass</argument>, <argument>ty</argument>, <argument>VK_PRValue</argument>, <argument>OK_Ordinary</argument>)</argument_list></macro> <block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>ImplicitValueInitExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ImplicitValueInitExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ImplicitValueInitExprClass</name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>ParenListExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ParenListExpr</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>, <expr><name>RParenLoc</name></expr>;


<macro><name>ParenListExpr</name><argument_list>(<argument>SourceLocation LParenLoc</argument>, <argument>ArrayRef&lt;Expr *&gt; Exprs</argument>,
<argument>SourceLocation RParenLoc</argument>)</argument_list></macro>;


<macro><name>ParenListExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>unsigned NumExprs</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>

<specifier>static</specifier> <name>ParenListExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>ArrayRef&lt;Expr *&gt; Exprs</argument>,
<argument>SourceLocation RParenLoc</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>ParenListExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>unsigned NumExprs</argument>)</argument_list></macro></expr>;


<expr><name>unsigned</name> <macro><name>getNumExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ParenListExprBits</name><operator>.</operator><name>NumExprs</name></name></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getExpr</name><argument_list>(<argument>unsigned Init</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Init</name> <operator>&lt;</operator> <call><name>getNumExprs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Initializer access out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getExprs</name><argument_list>()</argument_list></call><index>[<expr><name>Init</name></expr>]</index></expr>;</return>
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getExpr</name><argument_list>(<argument>unsigned Init</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ParenListExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getExpr</name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><operator>*</operator><macro><name>getExprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>exprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getExprs</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getNumExprs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLParenLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getRParenLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ParenListExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumExprs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumExprs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;



























<expr><name>class</name> <name>GenericSelectionExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>GenericSelectionExpr</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>,
<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;





<expr><name>unsigned</name> <name>NumAssocs</name></expr>, <expr><name>ResultIndex</name></expr>;
enum <operator>:</operator> <expr><name>unsigned</name> <block>{
<expr><name>ResultDependentIndex</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>max</name><argument_list>()</argument_list></call></expr>,
<expr><name>ControllingIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><name>AssocExprStartIndex</name> <operator>=</operator> <literal type="number">1</literal></expr>
}</block></expr>;


<expr><name>SourceLocation</name> <name>DefaultLoc</name></expr>, <expr><name>RParenLoc</name></expr>;








<expr><name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;Stmt *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{


<return>return <expr><literal type="number">1</literal> <operator>+</operator> <call><name>getNumAssocs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;TypeSourceInfo *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNumAssocs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>Const</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>AssociationIteratorTy</name></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>Const</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>AssociationTy</name> <block>{
<expr><name>friend</name> <name>class</name> <name>GenericSelectionExpr</name></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>OtherConst</name></expr></argument>&gt;</argument_list></name> <name>friend</name> <name>class</name> <name>AssociationIteratorTy</name></expr>;
<expr><name>using</name> <name>ExprPtrTy</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>conditional_t</name><argument_list type="generic">&lt;<argument><expr><name>Const</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>TSIPtrTy</name> <operator>=</operator>
<name>std</name><operator>::</operator><name><name>conditional_t</name><argument_list type="generic">&lt;<argument><expr><name>Const</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>TypeSourceInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>ExprPtrTy</name> <name>E</name></expr>;
<expr><name>TSIPtrTy</name> <name>TSI</name></expr>;
<expr><name>bool</name> <name>Selected</name></expr>;
<macro><name>AssociationTy</name><argument_list>(<argument>ExprPtrTy E</argument>, <argument>TSIPtrTy TSI</argument>, <argument>bool Selected</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>E</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>TSI</name><argument_list>(<argument><expr><name>TSI</name></expr></argument>)</argument_list></call></expr>, <macro><name>Selected</name><argument_list>(<argument>Selected</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>ExprPtrTy</name> <macro><name>getAssociationExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>E</name></expr>;</return> }</block>
<name>TSIPtrTy</name> <macro><name>getTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TSI</name></expr>;</return> }</block>
<name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><ternary><condition><expr><name>TSI</name></expr> ?</condition><then> <expr><call><name><name>TSI</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return> }</block>
<name>bool</name> <macro><name>isSelected</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Selected</name></expr>;</return> }</block>
<name>AssociationTy</name> <operator>*</operator><name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr>) <block>{ <return>return <expr><name>this</name></expr>;</return> }</block></block>
<specifier>const</specifier> <name>AssociationTy</name> <operator>*</operator><name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr>) <specifier>const</specifier> <block>{ <return>return <expr><name>this</name></expr>;</return> }</block></block>
}</expr>;





<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>Const</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>AssociationIteratorTy</name>
<operator>:</operator> <name>public</name> <name>llvm</name><operator>::</operator><name><name>iterator_facade_base</name><argument_list type="generic">&lt;
<argument><expr><name><name>AssociationIteratorTy</name><argument_list type="generic">&lt;<argument><expr><name>Const</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>input_iterator_tag</name></expr></argument>,
<argument><expr><name><name>AssociationTy</name><argument_list type="generic">&lt;<argument><expr><name>Const</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>ptrdiff_t</name></expr></argument>, <argument><expr><name><name>AssociationTy</name><argument_list type="generic">&lt;<argument><expr><name>Const</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name><name>AssociationTy</name><argument_list type="generic">&lt;<argument><expr><name>Const</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>GenericSelectionExpr</name></expr>;













<expr><name>using</name> <name>BaseTy</name> <operator>=</operator> <name>typename</name> <name>AssociationIteratorTy</name><operator>::</operator><name>iterator_facade_base</name></expr>;
<expr><name>using</name> <name>StmtPtrPtrTy</name> <operator>=</operator>
<name>std</name><operator>::</operator><name><name>conditional_t</name><argument_list type="generic">&lt;<argument><expr><name>Const</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>TSIPtrPtrTy</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>conditional_t</name><argument_list type="generic">&lt;<argument><expr><name>Const</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>TypeSourceInfo</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>,
<argument><expr><name>TypeSourceInfo</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>StmtPtrPtrTy</name> <name>E</name></expr>;
<expr><name>TSIPtrPtrTy</name> <name>TSI</name></expr>;
<expr><name>unsigned</name> <name>Offset</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><name>SelectedOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<macro><name>AssociationIteratorTy</name><argument_list>(<argument>StmtPtrPtrTy E</argument>, <argument>TSIPtrPtrTy TSI</argument>, <argument>unsigned Offset</argument>,
<argument>unsigned SelectedOffset</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>E</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>TSI</name><argument_list>(<argument><expr><name>TSI</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Offset</name><argument_list>(<argument><expr><name>Offset</name></expr></argument>)</argument_list></call></expr>, <macro><name>SelectedOffset</name><argument_list>(<argument>SelectedOffset</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<call><name>AssociationIteratorTy</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>E</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>, <macro><name>TSI</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{}</block>
<name>typename</name> <name>BaseTy</name><operator>::</operator><name>reference</name> <name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>AssociationTy</name><argument_list type="generic">&lt;<argument><expr><name>Const</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>TSI</name></expr></argument>,
<argument><expr><name>Offset</name> <operator>==</operator> <name>SelectedOffset</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>typename</name> <name>BaseTy</name><operator>::</operator><name>pointer</name> <name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr>) <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><operator>*</operator><name>this</name></expr>;</return> }</block></block>
<name>using</name> <name>BaseTy</name><operator>::</operator><name>operator</name><operator>++</operator></expr>;
<expr><name>AssociationIteratorTy</name> <operator>&amp;</operator><name>operator</name><operator>++</operator><operator>(</operator><operator>)</operator> <block>{
<expr><operator>++</operator><name>E</name></expr>;
<expr><operator>++</operator><name>TSI</name></expr>;
<expr><operator>++</operator><name>Offset</name></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block>
<name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><name>AssociationIteratorTy</name> <name>Other</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>E</name> <operator>==</operator> <name><name>Other</name><operator>.</operator><name>E</name></name></expr>;</return> }</block>
}</expr>;


<macro><name>GenericSelectionExpr</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>SourceLocation GenericLoc</argument>,
<argument>Expr *ControllingExpr</argument>,
<argument>ArrayRef&lt;TypeSourceInfo *&gt; AssocTypes</argument>,
<argument>ArrayRef&lt;Expr *&gt; AssocExprs</argument>, <argument>SourceLocation DefaultLoc</argument>,
<argument>SourceLocation RParenLoc</argument>,
<argument>bool ContainsUnexpandedParameterPack</argument>,
<argument>unsigned ResultIndex</argument>)</argument_list></macro>;


<macro><name>GenericSelectionExpr</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>SourceLocation GenericLoc</argument>,
<argument>Expr *ControllingExpr</argument>,
<argument>ArrayRef&lt;TypeSourceInfo *&gt; AssocTypes</argument>,
<argument>ArrayRef&lt;Expr *&gt; AssocExprs</argument>, <argument>SourceLocation DefaultLoc</argument>,
<argument>SourceLocation RParenLoc</argument>,
<argument>bool ContainsUnexpandedParameterPack</argument>)</argument_list></macro>;


<expr><name>explicit</name> <macro><name>GenericSelectionExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>unsigned NumAssocs</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>

<specifier>static</specifier> <name>GenericSelectionExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>SourceLocation GenericLoc</argument>,
<argument>Expr *ControllingExpr</argument>, <argument>ArrayRef&lt;TypeSourceInfo *&gt; AssocTypes</argument>,
<argument>ArrayRef&lt;Expr *&gt; AssocExprs</argument>, <argument>SourceLocation DefaultLoc</argument>,
<argument>SourceLocation RParenLoc</argument>, <argument>bool ContainsUnexpandedParameterPack</argument>,
<argument>unsigned ResultIndex</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>GenericSelectionExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>SourceLocation GenericLoc</argument>,
<argument>Expr *ControllingExpr</argument>, <argument>ArrayRef&lt;TypeSourceInfo *&gt; AssocTypes</argument>,
<argument>ArrayRef&lt;Expr *&gt; AssocExprs</argument>, <argument>SourceLocation DefaultLoc</argument>,
<argument>SourceLocation RParenLoc</argument>, <argument>bool ContainsUnexpandedParameterPack</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>GenericSelectionExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Context</argument>,
<argument>unsigned NumAssocs</argument>)</argument_list></macro></expr>;

<expr><name>using</name> <name>Association</name> <operator>=</operator> <name><name>AssociationTy</name><argument_list type="generic">&lt;<argument><expr><name>false</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>ConstAssociation</name> <operator>=</operator> <name><name>AssociationTy</name><argument_list type="generic">&lt;<argument><expr><name>true</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>AssociationIterator</name> <operator>=</operator> <name><name>AssociationIteratorTy</name><argument_list type="generic">&lt;<argument><expr><name>false</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>ConstAssociationIterator</name> <operator>=</operator> <name><name>AssociationIteratorTy</name><argument_list type="generic">&lt;<argument><expr><name>true</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>association_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>AssociationIterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>const_association_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>ConstAssociationIterator</name></expr></argument>&gt;</argument_list></name></expr>;


<expr><name>unsigned</name> <macro><name>getNumAssocs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumAssocs</name></expr>;</return> }</block>




<name>unsigned</name> <macro><name>getResultIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isResultDependent</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Generic selection is result-dependent but getResultIndex called!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>ResultIndex</name></expr>;</return>
}</block>


<name>bool</name> <macro><name>isResultDependent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ResultIndex</name> <operator>==</operator> <name>ResultDependentIndex</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getControllingExpr</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>ControllingIndex</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getControllingExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>ControllingIndex</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>Expr</name> <operator>*</operator><macro><name>getResultExpr</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>AssocExprStartIndex</name> <operator>+</operator> <call><name>getResultIndex</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getResultExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>AssocExprStartIndex</name> <operator>+</operator> <call><name>getResultIndex</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getAssocExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<name>AssocExprStartIndex</name></expr></argument>)</argument_list></call></expr>,
<expr><name>NumAssocs</name></expr>}</block></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getAssocTypeSourceInfos</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>, <expr><name>NumAssocs</name></expr>}</block></expr>;</return>
}</block>



<name>Association</name> <macro><name>getAssociation</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <call><name>getNumAssocs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Out-of-range index in GenericSelectionExpr::getAssociation!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>Association</name><argument_list>(
<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>AssocExprStartIndex</name> <operator>+</operator> <name>I</name></expr>]</index></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index></expr></argument>,
<argument><expr><operator>!</operator><call><name>isResultDependent</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>getResultIndex</name><argument_list>()</argument_list></call> <operator>==</operator> <name>I</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>ConstAssociation</name> <macro><name>getAssociation</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <call><name>getNumAssocs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Out-of-range index in GenericSelectionExpr::getAssociation!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>ConstAssociation</name><argument_list>(
<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>AssocExprStartIndex</name> <operator>+</operator> <name>I</name></expr>]</index></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index></expr></argument>,
<argument><expr><operator>!</operator><call><name>isResultDependent</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>getResultIndex</name><argument_list>()</argument_list></call> <operator>==</operator> <name>I</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>association_range</name> <macro><name>associations</name><argument_list>()</argument_list></macro> <block>{
<expr><name>AssociationIterator</name> <call><name>Begin</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<name>AssocExprStartIndex</name></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ResultIndex</name></expr></argument>)</argument_list></call></expr>;
<expr><name>AssociationIterator</name> <call><name>End</name><argument_list>(<argument><expr><name><name>Begin</name><operator>.</operator><name>E</name></name> <operator>+</operator> <name>NumAssocs</name></expr></argument>, <argument><expr><name><name>Begin</name><operator>.</operator><name>TSI</name></name> <operator>+</operator> <name>NumAssocs</name></expr></argument>,
<argument><expr><name>NumAssocs</name></expr></argument>, <argument><expr><name>ResultIndex</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>llvm</name><operator>::</operator><call><name>make_range</name><argument_list>(<argument><expr><name>Begin</name></expr></argument>, <argument><expr><name>End</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_association_range</name> <macro><name>associations</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>ConstAssociationIterator</name> <call><name>Begin</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<name>AssocExprStartIndex</name></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ResultIndex</name></expr></argument>)</argument_list></call></expr>;
<expr><name>ConstAssociationIterator</name> <call><name>End</name><argument_list>(<argument><expr><name><name>Begin</name><operator>.</operator><name>E</name></name> <operator>+</operator> <name>NumAssocs</name></expr></argument>, <argument><expr><name><name>Begin</name><operator>.</operator><name>TSI</name></name> <operator>+</operator> <name>NumAssocs</name></expr></argument>,
<argument><expr><name>NumAssocs</name></expr></argument>, <argument><expr><name>ResultIndex</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>llvm</name><operator>::</operator><call><name>make_range</name><argument_list>(<argument><expr><name>Begin</name></expr></argument>, <argument><expr><name>End</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getGenericLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>GenericSelectionExprBits</name><operator>.</operator><name>GenericLoc</name></name></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getDefaultLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DefaultLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getGenericLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getRParenLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>GenericSelectionExprClass</name></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<call><name>numTrailingObjects</name><argument_list>(<argument><expr><call><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<call><name>numTrailingObjects</name><argument_list>(<argument><expr><call><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;












<expr><name>class</name> <name>ExtVectorElementExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>Stmt</name> <operator>*</operator><name>Base</name></expr>;
<expr><name>IdentifierInfo</name> <operator>*</operator><name>Accessor</name></expr>;
<expr><name>SourceLocation</name> <name>AccessorLoc</name></expr>;
<expr><name>public</name><operator>:</operator>
<macro><name>ExtVectorElementExpr</name><argument_list>(<argument>QualType ty</argument>, <argument>ExprValueKind VK</argument>, <argument>Expr *base</argument>,
<argument>IdentifierInfo &amp;accessor</argument>, <argument>SourceLocation loc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ExtVectorElementExprClass</name></expr></argument>, <argument><expr><name>ty</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><name>VK</name> <operator>==</operator> <name>VK_PRValue</name></expr> ?</condition><then> <expr><name>OK_Ordinary</name></expr> </then><else>: <expr><name>OK_VectorComponent</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Base</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Accessor</name><argument_list>(<argument><expr><operator>&amp;</operator><name>accessor</name></expr></argument>)</argument_list></call></expr>, <macro><name>AccessorLoc</name><argument_list>(<argument>loc</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>ExtVectorElementExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>ExtVectorElementExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Base</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Base</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setBase</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>Base</name> <operator>=</operator> <name>E</name></expr>; }</block>

<name>IdentifierInfo</name> <operator>&amp;</operator><macro><name>getAccessor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>Accessor</name></expr>;</return> }</block>
<name>void</name> <macro><name>setAccessor</name><argument_list>(<argument>IdentifierInfo *II</argument>)</argument_list></macro> <block>{ <expr><name>Accessor</name> <operator>=</operator> <name>II</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getAccessorLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AccessorLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setAccessorLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>AccessorLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>


<name>unsigned</name> <macro><name>getNumElements</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>containsDuplicateElements</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>void</name> <macro><name>getEncodedElementAccess</name><argument_list>(<argument>SmallVectorImpl&lt;uint32_t&gt; &amp;Elts</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getBase</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>AccessorLoc</name></expr>;</return> }</block>



<name>bool</name> <macro><name>isArrow</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ExtVectorElementExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Base</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Base</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>BlockExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>protected</name><operator>:</operator>
<name>BlockDecl</name> <operator>*</operator><name>TheBlock</name></expr>;
<expr><name>public</name><operator>:</operator>
<macro><name>BlockExpr</name><argument_list>(<argument>BlockDecl *BD</argument>, <argument>QualType ty</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>BlockExprClass</name></expr></argument>, <argument><expr><name>ty</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <macro><name>TheBlock</name><argument_list>(<argument>BD</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>BlockExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>BlockExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>

<specifier>const</specifier> <name>BlockDecl</name> <operator>*</operator><macro><name>getBlockDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TheBlock</name></expr>;</return> }</block>
<name>BlockDecl</name> <operator>*</operator><macro><name>getBlockDecl</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>TheBlock</name></expr>;</return> }</block>
<name>void</name> <macro><name>setBlockDecl</name><argument_list>(<argument>BlockDecl *BD</argument>)</argument_list></macro> <block>{ <expr><name>TheBlock</name> <operator>=</operator> <name>BD</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getCaretLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>Stmt</name> <operator>*</operator><call><name>getBody</name><argument_list>()</argument_list></call></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getCaretLocation</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getBody</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<specifier>const</specifier> <name>FunctionProtoType</name> <operator>*</operator><macro><name>getFunctionType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>BlockExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;



struct <expr><name>BlockVarCopyInit</name> <block>{
<expr><call><name>BlockVarCopyInit</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<macro><name>BlockVarCopyInit</name><argument_list>(<argument>Expr *CopyExpr</argument>, <argument>bool CanThrow</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>ExprAndFlag</name><argument_list>(<argument>CopyExpr</argument>, <argument>CanThrow</argument>)</argument_list></macro> <expr><block>{}</block>
<name>void</name> <macro><name>setExprAndFlag</name><argument_list>(<argument>Expr *CopyExpr</argument>, <argument>bool CanThrow</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ExprAndFlag</name><operator>.</operator><name>setPointerAndInt</name></name><argument_list>(<argument><expr><name>CopyExpr</name></expr></argument>, <argument><expr><name>CanThrow</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>Expr</name> <operator>*</operator><macro><name>getCopyExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>ExprAndFlag</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>canThrow</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>ExprAndFlag</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>ExprAndFlag</name></expr>;
}</block></expr>;




<expr><name>class</name> <name>AsTypeExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>private</name><operator>:</operator>
<name>Stmt</name> <operator>*</operator><name>SrcExpr</name></expr>;
<expr><name>SourceLocation</name> <name>BuiltinLoc</name></expr>, <expr><name>RParenLoc</name></expr>;

<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>explicit</name> <macro><name>AsTypeExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>AsTypeExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<macro><name>AsTypeExpr</name><argument_list>(<argument>Expr *SrcExpr</argument>, <argument>QualType DstType</argument>, <argument>ExprValueKind VK</argument>,
<argument>ExprObjectKind OK</argument>, <argument>SourceLocation BuiltinLoc</argument>,
<argument>SourceLocation RParenLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>AsTypeExprClass</name></expr></argument>, <argument><expr><name>DstType</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>OK</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>SrcExpr</name><argument_list>(<argument><expr><name>SrcExpr</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>BuiltinLoc</name><argument_list>(<argument><expr><name>BuiltinLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>RParenLoc</name><argument_list>(<argument>RParenLoc</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<name>Expr</name> <operator>*</operator><macro><name>getSrcExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SrcExpr</name></expr></argument>)</argument_list></call></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getBuiltinLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BuiltinLoc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>BuiltinLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>AsTypeExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SrcExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SrcExpr</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SrcExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SrcExpr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;





























<expr><name>class</name> <name>PseudoObjectExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>PseudoObjectExpr</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{











<expr><name>Expr</name> <operator>*</operator><operator>*</operator><macro><name>getSubExprsBuffer</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><macro><name>getSubExprsBuffer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<macro><name>PseudoObjectExpr</name><argument_list>(<argument>QualType type</argument>, <argument>ExprValueKind VK</argument>,
<argument>Expr *syntactic</argument>, <argument>ArrayRef&lt;Expr*&gt; semantic</argument>,
<argument>unsigned resultIndex</argument>)</argument_list></macro></expr>;

<macro><name>PseudoObjectExpr</name><argument_list>(<argument>EmptyShell shell</argument>, <argument>unsigned numSemanticExprs</argument>)</argument_list></macro>;

<expr><name>unsigned</name> <macro><name>getNumSubExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>PseudoObjectExprBits</name><operator>.</operator><name>NumSubExprs</name></name></expr>;</return>
}</block>

<name>public</name><operator>:</operator>


enum <operator>:</operator> <name>unsigned</name> <block>{ <expr><name>NoResult</name> <operator>=</operator> <operator>~</operator><literal type="number">0U</literal></expr> }</block></expr>;

<expr><specifier>static</specifier> <name>PseudoObjectExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>Expr *syntactic</argument>,
<argument>ArrayRef&lt;Expr*&gt; semantic</argument>,
<argument>unsigned resultIndex</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>PseudoObjectExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>EmptyShell shell</argument>,
<argument>unsigned numSemanticExprs</argument>)</argument_list></macro></expr>;




<expr><name>Expr</name> <operator>*</operator><macro><name>getSyntacticForm</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>getSubExprsBuffer</name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getSyntacticForm</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getSubExprsBuffer</name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</return> }</block>



<name>unsigned</name> <macro><name>getResultExprIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name><name>PseudoObjectExprBits</name><operator>.</operator><name>ResultIndex</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NoResult</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name><name>PseudoObjectExprBits</name><operator>.</operator><name>ResultIndex</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
}</block>


<name>Expr</name> <operator>*</operator><macro><name>getResultExpr</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name><name>PseudoObjectExprBits</name><operator>.</operator><name>ResultIndex</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getSubExprsBuffer</name><argument_list>()</argument_list></call><index>[<expr><name><name>PseudoObjectExprBits</name><operator>.</operator><name>ResultIndex</name></name></expr>]</index></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getResultExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>PseudoObjectExpr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getResultExpr</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumSemanticExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getNumSubExprs</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</return> }</block></expr>

<typedef>typedef <type><name>Expr</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>semantics_iterator</name>;</typedef></block></expr>
<typedef>typedef <type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>const_semantics_iterator</name>;</typedef>
<name>semantics_iterator</name> <macro><name>semantics_begin</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>getSubExprsBuffer</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
}</block></block>
<name>const_semantics_iterator</name> <macro><name>semantics_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getSubExprsBuffer</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
}</block>
<name>semantics_iterator</name> <macro><name>semantics_end</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>getSubExprsBuffer</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumSubExprs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>const_semantics_iterator</name> <macro><name>semantics_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getSubExprsBuffer</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumSubExprs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>semantics_iterator</name></expr></argument>&gt;</argument_list></name> <macro><name>semantics</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>make_range</name><argument_list>(<argument><expr><call><name>semantics_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>semantics_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_semantics_iterator</name></expr></argument>&gt;</argument_list></name> <macro><name>semantics</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>make_range</name><argument_list>(<argument><expr><call><name>semantics_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>semantics_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getSemanticExpr</name><argument_list>(<argument>unsigned index</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>index</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <call><name>getNumSubExprs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getSubExprsBuffer</name><argument_list>()</argument_list></call><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getSemanticExpr</name><argument_list>(<argument>unsigned index</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>PseudoObjectExpr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getSemanticExpr</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getExprLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getSyntacticForm</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getExprLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getSyntacticForm</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getSyntacticForm</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<expr><name>const_child_range</name> <name>CCR</name> <operator>=</operator>
<call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>PseudoObjectExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>cast_away_const</name><argument_list>(<argument><expr><call><name><name>CCR</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>cast_away_const</name><argument_list>(<argument><expr><call><name><name>CCR</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>Stmt</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><name>cs</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getSubExprsBuffer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>cs</name> <operator>+</operator> <call><name>getNumSubExprs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PseudoObjectExprClass</name></expr>;</return>
}</block>

<name>friend</name> <name>TrailingObjects</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
}</block></expr>;








<expr><name>class</name> <name>AtomicExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>public</name><operator>:</operator>
enum <name>AtomicOp</name> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUILTIN</name><parameter_list>(<parameter><type><name>ID</name></type></parameter>, <parameter><type><name>TYPE</name></type></parameter>, <parameter><type><name>ATTRS</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATOMIC_BUILTIN</name><parameter_list>(<parameter><type><name>ID</name></type></parameter>, <parameter><type><name>TYPE</name></type></parameter>, <parameter><type><name>ATTRS</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>AO ##ID,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Builtins.def"</cpp:file></cpp:include>

<expr><name>BI_First</name> <operator>=</operator> <literal type="number">0</literal></expr>
}</block></expr>;

<expr><name>private</name><operator>:</operator>



enum <block>{ <expr><name>PTR</name></expr>, <expr><name>ORDER</name></expr>, <expr><name>VAL1</name></expr>, <expr><name>ORDER_FAIL</name></expr>, <expr><name>VAL2</name></expr>, <expr><name>WEAK</name></expr>, <expr><name>END_EXPR</name></expr> }</block></expr>;
<expr><name>Stmt</name> <operator>*</operator><name><name>SubExprs</name><index>[<expr><name>END_EXPR</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;
<expr><name>unsigned</name> <name>NumSubExprs</name></expr>;
<expr><name>SourceLocation</name> <name>BuiltinLoc</name></expr>, <expr><name>RParenLoc</name></expr>;
<expr><name>AtomicOp</name> <name>Op</name></expr>;

<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>public</name><operator>:</operator>
<macro><name>AtomicExpr</name><argument_list>(<argument>SourceLocation BLoc</argument>, <argument>ArrayRef&lt;Expr*&gt; args</argument>, <argument>QualType t</argument>,
<argument>AtomicOp op</argument>, <argument>SourceLocation RP</argument>)</argument_list></macro></expr>;



<expr><specifier>static</specifier> <name>unsigned</name> <macro><name>getNumSubExprs</name><argument_list>(<argument>AtomicOp Op</argument>)</argument_list></macro></expr>;


<expr><name>explicit</name> <macro><name>AtomicExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>AtomicExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{ }</block>

<name>Expr</name> <operator>*</operator><macro><name>getPtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>PTR</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>Expr</name> <operator>*</operator><macro><name>getOrder</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>ORDER</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>Expr</name> <operator>*</operator><macro><name>getScope</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getScopeModel</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"No scope"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>NumSubExprs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>Expr</name> <operator>*</operator><macro><name>getVal1</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>Op</name> <operator>==</operator> <name>AO__c11_atomic_init</name> <operator>||</operator> <name>Op</name> <operator>==</operator> <name>AO__opencl_atomic_init</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>ORDER</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<call><name>assert</name><argument_list>(<argument><expr><name>NumSubExprs</name> <operator>&gt;</operator> <name>VAL1</name></expr></argument>)</argument_list></call></block></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>VAL1</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>Expr</name> <operator>*</operator><macro><name>getOrderFail</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>NumSubExprs</name> <operator>&gt;</operator> <name>ORDER_FAIL</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>ORDER_FAIL</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>Expr</name> <operator>*</operator><macro><name>getVal2</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>Op</name> <operator>==</operator> <name>AO__atomic_exchange</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>ORDER_FAIL</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<call><name>assert</name><argument_list>(<argument><expr><name>NumSubExprs</name> <operator>&gt;</operator> <name>VAL2</name></expr></argument>)</argument_list></call></block></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>VAL2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>Expr</name> <operator>*</operator><macro><name>getWeak</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>NumSubExprs</name> <operator>&gt;</operator> <name>WEAK</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>WEAK</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>QualType</name> <macro><name>getValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>AtomicOp</name> <macro><name>getOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Op</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>getNumSubExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumSubExprs</name></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><operator>*</operator><macro><name>getSubExprs</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SubExprs</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><macro><name>getSubExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SubExprs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isVolatile</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getPtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getPointeeType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isVolatileQualified</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isCmpXChg</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getOp</name><argument_list>()</argument_list></call> <operator>==</operator> <name>AO__c11_atomic_compare_exchange_strong</name> <operator>||</operator>
<call><name>getOp</name><argument_list>()</argument_list></call> <operator>==</operator> <name>AO__c11_atomic_compare_exchange_weak</name> <operator>||</operator>
<call><name>getOp</name><argument_list>()</argument_list></call> <operator>==</operator> <name>AO__opencl_atomic_compare_exchange_strong</name> <operator>||</operator>
<call><name>getOp</name><argument_list>()</argument_list></call> <operator>==</operator> <name>AO__opencl_atomic_compare_exchange_weak</name> <operator>||</operator>
<call><name>getOp</name><argument_list>()</argument_list></call> <operator>==</operator> <name>AO__atomic_compare_exchange</name> <operator>||</operator>
<call><name>getOp</name><argument_list>()</argument_list></call> <operator>==</operator> <name>AO__atomic_compare_exchange_n</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isOpenCL</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getOp</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>AO__opencl_atomic_init</name> <operator>&amp;&amp;</operator>
<call><name>getOp</name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>AO__opencl_atomic_fetch_max</name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBuiltinLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BuiltinLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>BuiltinLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>AtomicExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><name>SubExprs</name><operator>+</operator><name>NumSubExprs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><name>SubExprs</name> <operator>+</operator> <name>NumSubExprs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<specifier>static</specifier> <name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>AtomicScopeModel</name></expr></argument>&gt;</argument_list></name> <macro><name>getScopeModel</name><argument_list>(<argument>AtomicOp Op</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Kind</name> <operator>=</operator>
<operator>(</operator><name>Op</name> <operator>&gt;=</operator> <name>AO__opencl_atomic_load</name> <operator>&amp;&amp;</operator> <name>Op</name> <operator>&lt;=</operator> <name>AO__opencl_atomic_fetch_max</name><operator>)</operator>
<operator>?</operator> <name>AtomicScopeModelKind</name><operator>::</operator><name>OpenCL</name>
<operator>:</operator> <name>AtomicScopeModelKind</name><operator>::</operator><name>None</name></expr>;
<return>return <expr><name>AtomicScopeModel</name><operator>::</operator><call><name>create</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>AtomicScopeModel</name></expr></argument>&gt;</argument_list></name> <macro><name>getScopeModel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getScopeModel</name><argument_list>(<argument><expr><call><name>getOp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>TypoExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{

<expr><name>SourceLocation</name> <name>TypoLoc</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>TypoExpr</name><argument_list>(<argument>QualType T</argument>, <argument>SourceLocation TypoLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>TypoExprClass</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK_LValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <macro><name>TypoLoc</name><argument_list>(<argument>TypoLoc</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>isDependentType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"TypoExpr given a non-dependent type"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><name>ExprDependence</name><operator>::</operator><name>TypeValueInstantiation</name> <operator>|</operator>
<name>ExprDependence</name><operator>::</operator><name>Error</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>TypoLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>TypoLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>TypoExprClass</name></expr>;</return>
}</block>

}</expr>;



























<expr><name>class</name> <name>RecoveryExpr</name> <name>final</name> <operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>RecoveryExpr</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>RecoveryExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;Ctx</argument>, <argument>QualType T</argument>,
<argument>SourceLocation BeginLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;Expr *&gt; SubExprs</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>RecoveryExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>ASTContext &amp;Ctx</argument>, <argument>unsigned NumSubExprs</argument>)</argument_list></macro></expr>;

<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>subExpressions</name><argument_list>()</argument_list></macro> <block>{
<expr><name>auto</name> <operator>*</operator><name>B</name> <operator>=</operator> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><name>B</name> <operator>+</operator> <name>NumExprs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>subExpressions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>RecoveryExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>subExpressions</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<expr><name>Stmt</name> <operator>*</operator><operator>*</operator><name>B</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><name>B</name> <operator>+</operator> <name>NumExprs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BeginLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>EndLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>RecoveryExprClass</name></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<macro><name>RecoveryExpr</name><argument_list>(<argument>ASTContext &amp;Ctx</argument>, <argument>QualType T</argument>, <argument>SourceLocation BeginLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>ArrayRef&lt;Expr *&gt; SubExprs</argument>)</argument_list></macro></expr>;
<macro><name>RecoveryExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>unsigned NumSubExprs</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Expr</name><argument_list>(<argument><expr><name>RecoveryExprClass</name></expr></argument>, <argument><expr><name>Empty</name></expr></argument>)</argument_list></call></expr>, <macro><name>NumExprs</name><argument_list>(<argument>NumSubExprs</argument>)</argument_list></macro> <expr><block>{}</block>

<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;Stmt *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumExprs</name></expr>;</return> }</block>

<name>SourceLocation</name> <name>BeginLoc</name></expr>, <expr><name>EndLoc</name></expr>;
<expr><name>unsigned</name> <name>NumExprs</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;
}</block></expr>;

}</block></expr></block></expr></block></expr></block></expr></block></expr></range></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
