<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Analysis/PathDiagnostic.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_STATICANALYZER_CORE_BUGREPORTER_PATHDIAGNOSTIC_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Stmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/AnalysisDeclContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/FoldingSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerUnion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Allocator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;deque&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iterator&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;list&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;map&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;set&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>AnalysisDeclContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BinaryOperator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CallEnter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CallExitEnd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CallExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ConditionalOperator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Decl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LocationContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MemberExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ProgramPoint</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SourceManager</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>ento</name> <block>{<block_content>





<decl_stmt><decl><type><name>class</name></type> <name>PathDiagnostic</name></decl>;</decl_stmt>



<struct>struct <name>PathDiagnosticConsumerOptions</name> <block>{


<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>ToolInvocation</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>ShouldDisplayMacroExpansions</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>ShouldSerializeStats</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>









<decl_stmt><decl><type><name>bool</name></type> <name>ShouldWriteStableReportFilename</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>ShouldDisplayWarningsAsErrors</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>ShouldApplyFixIts</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>ShouldDisplayDiagnosticName</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name>class</name></type> <name>PathDiagnosticConsumer</name> <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><name>class</name></type> <name>PDFileEntry</name> <range>: <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PDFileEntry</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>NodeID</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>NodeID</name><argument_list>(<argument>NodeID</argument>)</argument_list></macro> <block>{}</block>

<name>using</name> <name>ConsumerFiles</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>, <argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr>;


<expr><name>ConsumerFiles</name> <name>files</name></expr>;


<expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <name>NodeID</name></expr>;


<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{ <expr><name>ID</name> <operator>=</operator> <name>NodeID</name></expr>; }</block></expr>
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>FilesMade</name> <block>{<block_content>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name> <name>Alloc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>PDFileEntry</name></expr></argument>&gt;</argument_list></name> <name>Set</name></expr>;</expr_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><operator>~</operator><call><name>FilesMade</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Set</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<function_decl><type><name>void</name></type> <name>addDiagnostic</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PathDiagnostic</name> <modifier>&amp;</modifier></type><name>PD</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>ConsumerName</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>fileName</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>PDFileEntry</name><operator>::</operator><name>ConsumerFiles</name> <operator>*</operator><call><name>getFiles</name><argument_list>(<argument><expr><specifier>const</specifier> <name>PathDiagnostic</name> <operator>&amp;</operator><name>PD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<label><name>private</name>:</label>
<function_decl><type><name>virtual</name> <name>void</name></type> <name>anchor</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>PathDiagnosticConsumer</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>PathDiagnosticConsumer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>FlushDiagnostics</name><parameter_list>(<parameter><decl><type><name>FilesMade</name> <modifier>*</modifier></type><name>FilesMade</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>FlushDiagnosticsImpl</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>PathDiagnostic</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Diags</name></expr></argument>,
<argument><expr><name>FilesMade</name> <operator>*</operator><name>filesMade</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>virtual</name> <name>StringRef</name> <macro><name>getName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>HandlePathDiagnostic</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PathDiagnostic</name></expr></argument>&gt;</argument_list></name> <name>D</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<enum>enum <name>PathGenerationScheme</name> <block>{

<decl><name>None</name></decl>,


<decl><name>Minimal</name></decl>,


<decl><name>Extensive</name></decl>,
}</block>;</enum>

<expr_stmt><expr><name>virtual</name> <name>PathGenerationScheme</name> <macro><name>getGenerationScheme</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Minimal</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>shouldGenerateDiagnostics</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getGenerationScheme</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>None</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>shouldAddPathEdges</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getGenerationScheme</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Extensive</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>supportsLogicalOpControlFlow</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>supportsCrossFileDiagnostics</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>protected</name>:</label>
<decl_stmt><decl><type><name>bool</name></type> <name>flushed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>PathDiagnostic</name></expr></argument>&gt;</argument_list></name> <name>Diags</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>





<decl_stmt><decl><type><name>class</name></type> <name>PathDiagnosticRange</name> <range>: <expr><name>public</name> <name>SourceRange</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>bool</name> <name>isPoint</name> <operator>=</operator> <name>false</name></expr>;

<macro><name>PathDiagnosticRange</name><argument_list>(<argument>SourceRange R</argument>, <argument>bool isP = false</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>, <macro><name>isPoint</name><argument_list>(<argument>isP</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>PathDiagnosticRange</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>LocationOrAnalysisDeclContext</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator></expr></argument>, <argument><expr><name>AnalysisDeclContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>PathDiagnosticLocation</name> <block>{<block_content>
<label><name>private</name>:</label>
<enum>enum <name>Kind</name> <block>{ <decl><name>RangeK</name></decl>, <decl><name>SingleLocK</name></decl>, <decl><name>StmtK</name></decl>, <decl><name>DeclK</name></decl> }</block> <decl><name>K</name> <init>= <expr><name>SingleLocK</name></expr></init></decl>;</enum>

<decl_stmt><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>SourceManager</name> <modifier>*</modifier></type><name>SM</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FullSourceLoc</name></type> <name>Loc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PathDiagnosticRange</name></type> <name>Range</name></decl>;</decl_stmt>

<macro><name>PathDiagnosticLocation</name><argument_list>(<argument>SourceLocation L</argument>, <argument>const SourceManager &amp;sm</argument>, <argument>Kind kind</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>K</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>SM</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sm</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Loc</name><argument_list>(<argument><expr><call><name>genLocation</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Range</name><argument_list>(<argument>genRange()</argument>)</argument_list></macro> <expr><block>{}</block>

<name>FullSourceLoc</name> <macro><name>genLocation</name><argument_list>(
<argument>SourceLocation L = SourceLocation()</argument>,
<argument>LocationOrAnalysisDeclContext LAC = (AnalysisDeclContext *)nullptr</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<decl_stmt><decl><type><name>PathDiagnosticRange</name></type> <name>genRange</name><argument_list>(
<argument><expr><name>LocationOrAnalysisDeclContext</name> <name>LAC</name> <operator>=</operator> <operator>(</operator><name>AnalysisDeclContext</name> <operator>*</operator><operator>)</operator><name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<label><name>public</name>:</label>

<expr_stmt><expr><call><name>PathDiagnosticLocation</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>


<macro><name>PathDiagnosticLocation</name><argument_list>(<argument>const Stmt *s</argument>, <argument>const SourceManager &amp;sm</argument>,
<argument>LocationOrAnalysisDeclContext lac</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>K</name><argument_list>(<argument><expr><ternary><condition><expr><call><name><name>s</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>StmtK</name></expr> </then><else>: <expr><name>SingleLocK</name></expr></else></ternary></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>S</name><argument_list>(<argument><expr><ternary><condition><expr><name>K</name> <operator>==</operator> <name>StmtK</name></expr> ?</condition><then> <expr><name>s</name></expr> </then><else>: <expr><name>nullptr</name></expr></else></ternary></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>SM</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sm</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>Loc</name><argument_list>(<argument><expr><call><name>genLocation</name><argument_list>(<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>lac</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Range</name><argument_list>(<argument>genRange(lac)</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>K</name> <operator>==</operator> <name>SingleLocK</name> <operator>||</operator> <name>S</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>K</name> <operator>==</operator> <name>SingleLocK</name> <operator>||</operator> <call><name><name>Loc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>K</name> <operator>==</operator> <name>SingleLocK</name> <operator>||</operator> <call><name><name>Range</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<call><name>PathDiagnosticLocation</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>d</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>SourceManager</name> <operator>&amp;</operator><name>sm</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>K</name><argument_list>(<argument><expr><name>DeclK</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>D</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>SM</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sm</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Loc</name><argument_list>(<argument><expr><call><name>genLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Range</name><argument_list>(<argument>genRange()</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Loc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Range</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>




<macro><name>PathDiagnosticLocation</name><argument_list>(<argument>SourceLocation loc</argument>, <argument>const SourceManager &amp;sm</argument>)</argument_list></macro>
<operator>:</operator> <call><name>SM</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sm</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Loc</name><argument_list>(<argument><expr><name>loc</name></expr></argument>, <argument><expr><name>sm</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Range</name><argument_list>(<argument>genRange()</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Loc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Range</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<specifier>static</specifier> <name>PathDiagnosticLocation</name> <macro><name>create</name><argument_list>(<argument>const Decl *D</argument>,
<argument>const SourceManager &amp;SM</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>PathDiagnosticLocation</name><argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr><name>SM</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function_decl><type><specifier>static</specifier> <name>PathDiagnosticLocation</name></type> <name>createBegin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>SourceManager</name> <modifier>&amp;</modifier></type><name>SM</name></decl></parameter>)</parameter_list>;</function_decl>




<function><type><specifier>static</specifier> <name>PathDiagnosticLocation</name></type>
<name>createBegin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SourceManager</name> <modifier>&amp;</modifier></type><name>SM</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LocationOrAnalysisDeclContext</name></type> <name>LAC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>createBegin</name><argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr><name>SM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function_decl><type><specifier>static</specifier> <name>PathDiagnosticLocation</name></type> <name>createBegin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>SourceManager</name> <modifier>&amp;</modifier></type><name>SM</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LocationOrAnalysisDeclContext</name></type> <name>LAC</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><specifier>static</specifier> <name>PathDiagnosticLocation</name></type> <name>createEnd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>SourceManager</name> <modifier>&amp;</modifier></type><name>SM</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LocationOrAnalysisDeclContext</name></type> <name>LAC</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><specifier>static</specifier> <name>PathDiagnosticLocation</name></type> <name>createOperatorLoc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BinaryOperator</name> <modifier>*</modifier></type><name>BO</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>SourceManager</name> <modifier>&amp;</modifier></type><name>SM</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PathDiagnosticLocation</name></type> <name>createConditionalColonLoc</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>ConditionalOperator</name> <modifier>*</modifier></type><name>CO</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>SourceManager</name> <modifier>&amp;</modifier></type><name>SM</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><specifier>static</specifier> <name>PathDiagnosticLocation</name></type> <name>createMemberLoc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MemberExpr</name> <modifier>*</modifier></type><name>ME</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>SourceManager</name> <modifier>&amp;</modifier></type><name>SM</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><specifier>static</specifier> <name>PathDiagnosticLocation</name></type> <name>createBeginBrace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CompoundStmt</name> <modifier>*</modifier></type><name>CS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>SourceManager</name> <modifier>&amp;</modifier></type><name>SM</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><specifier>static</specifier> <name>PathDiagnosticLocation</name></type> <name>createEndBrace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CompoundStmt</name> <modifier>*</modifier></type><name>CS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>SourceManager</name> <modifier>&amp;</modifier></type><name>SM</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><specifier>static</specifier> <name>PathDiagnosticLocation</name></type> <name>createDeclBegin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LocationContext</name> <modifier>*</modifier></type><name>LC</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>SourceManager</name> <modifier>&amp;</modifier></type><name>SM</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><specifier>static</specifier> <name>PathDiagnosticLocation</name></type> <name>createDeclEnd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LocationContext</name> <modifier>*</modifier></type><name>LC</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>SourceManager</name> <modifier>&amp;</modifier></type><name>SM</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>PathDiagnosticLocation</name></type> <name>create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ProgramPoint</name> <modifier>&amp;</modifier></type><name>P</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>SourceManager</name> <modifier>&amp;</modifier></type><name>SMng</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>PathDiagnosticLocation</name></type> <name>createSingleLocation</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>PathDiagnosticLocation</name> <modifier>&amp;</modifier></type><name>PDL</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><specifier>static</specifier> <name>SourceLocation</name></type>
<name>getValidSourceLocation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>LocationOrAnalysisDeclContext</name></type> <name>LAC</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>UseEndOfStatement</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>PathDiagnosticLocation</name> <operator>&amp;</operator><name>X</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>K</name> <operator>==</operator> <name><name>X</name><operator>.</operator><name>K</name></name> <operator>&amp;&amp;</operator> <name>Loc</name> <operator>==</operator> <name><name>X</name><operator>.</operator><name>Loc</name></name> <operator>&amp;&amp;</operator> <name>Range</name> <operator>==</operator> <name><name>X</name><operator>.</operator><name>Range</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>PathDiagnosticLocation</name> <operator>&amp;</operator><name>X</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><operator>*</operator><name>this</name> <operator>==</operator> <name>X</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isValid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>SM</name> <operator>!=</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>FullSourceLoc</name> <macro><name>asLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Loc</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>PathDiagnosticRange</name> <macro><name>asRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Range</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>asStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isValid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>; <return>return <expr><name>S</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getStmtOrNull</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>asStmt</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>asDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isValid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>; <return>return <expr><name>D</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>StmtK</name> <operator>||</operator> <name>K</name> <operator>==</operator> <name>RangeK</name> <operator>||</operator> <name>K</name> <operator>==</operator> <name>DeclK</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasValidLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>asLocation</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>invalidate</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <call><name>PathDiagnosticLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>flatten</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><specifier>const</specifier> <name>SourceManager</name><operator>&amp;</operator> <macro><name>getManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isValid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>; <return>return <expr><operator>*</operator><name>SM</name></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>PathDiagnosticLocationPair</name> <block>{<block_content>
<label><name>private</name>:</label>
<decl_stmt><decl><type><name>PathDiagnosticLocation</name></type> <name>Start</name></decl>, <decl><type ref="prev"/><name>End</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>PathDiagnosticLocationPair</name><argument_list>(<argument><expr><specifier>const</specifier> <name>PathDiagnosticLocation</name> <operator>&amp;</operator><name>start</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PathDiagnosticLocation</name> <operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Start</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>End</name><argument_list>(<argument>end</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>const</specifier> <name>PathDiagnosticLocation</name> <operator>&amp;</operator><macro><name>getStart</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Start</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>PathDiagnosticLocation</name> <operator>&amp;</operator><macro><name>getEnd</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>End</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setStart</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PathDiagnosticLocation</name> <modifier>&amp;</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Start</name> <operator>=</operator> <name>L</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setEnd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PathDiagnosticLocation</name> <modifier>&amp;</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>End</name> <operator>=</operator> <name>L</name></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>void</name></type> <name>flatten</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>Start</name><operator>.</operator><name>flatten</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>End</name><operator>.</operator><name>flatten</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name>void</name></type> <name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name><name>Start</name><operator>.</operator><name>Profile</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>End</name><operator>.</operator><name>Profile</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>





<decl_stmt><decl><type><name>class</name></type> <name>PathDiagnosticPiece</name><range>: <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>public</name><operator>:</operator>
enum <name>Kind</name> <block>{ <expr><name>ControlFlow</name></expr>, <expr><name>Event</name></expr>, <expr><name>Macro</name></expr>, <expr><name>Call</name></expr>, <expr><name>Note</name></expr>, <expr><name>PopUp</name></expr> }</block></expr>;
enum <expr><name>DisplayHint</name> <block>{ <expr><name>Above</name></expr>, <expr><name>Below</name></expr> }</block></expr>;

<expr><name>private</name><operator>:</operator>
<specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <name>str</name></expr>;
<expr><specifier>const</specifier> <name>Kind</name> <name>kind</name></expr>;
<expr><specifier>const</specifier> <name>DisplayHint</name> <name>Hint</name></expr>;



<expr><name>bool</name> <name>LastInMainSourceFile</name> <operator>=</operator> <name>false</name></expr>;





<expr><name>StringRef</name> <name>Tag</name></expr>;

<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>SourceRange</name></expr></argument>&gt;</argument_list></name> <name>ranges</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>FixItHint</name></expr></argument>&gt;</argument_list></name> <name>fixits</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>PathDiagnosticPiece</name><argument_list>(<argument>StringRef s</argument>, <argument>Kind k</argument>, <argument>DisplayHint hint = Below</argument>)</argument_list></macro></expr>;
<macro><name>PathDiagnosticPiece</name><argument_list>(<argument>Kind k</argument>, <argument>DisplayHint hint = Below</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<call><name>PathDiagnosticPiece</name><argument_list>()</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><call><name>PathDiagnosticPiece</name><argument_list>(<argument><expr><specifier>const</specifier> <name>PathDiagnosticPiece</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><name>PathDiagnosticPiece</name> <operator>&amp;</operator><name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>PathDiagnosticPiece</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr>;
<expr><name>virtual</name> <operator>~</operator><call><name>PathDiagnosticPiece</name><argument_list>()</argument_list></call></expr>;

<expr><name>StringRef</name> <macro><name>getString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>str</name></expr>;</return> }</block>


<name>void</name> <macro><name>setTag</name><argument_list>(<argument>const char *tag</argument>)</argument_list></macro> <block>{ <expr><name>Tag</name> <operator>=</operator> <name>tag</name></expr>; }</block>


<specifier>const</specifier> <name>void</name> <operator>*</operator><macro><name>getTag</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Tag</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>StringRef</name> <macro><name>getTagStr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Tag</name></expr>;</return> }</block>



<name>DisplayHint</name> <macro><name>getDisplayHint</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Hint</name></expr>;</return> }</block>

<name>virtual</name> <name>PathDiagnosticLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>virtual</name> <name>void</name> <call><name>flattenLocations</name><argument_list>()</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>kind</name></expr>;</return> }</block>

<name>void</name> <macro><name>addRange</name><argument_list>(<argument>SourceRange R</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>R</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<call><name><name>ranges</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></block></expr>;
}</block>

<name>void</name> <macro><name>addRange</name><argument_list>(<argument>SourceLocation B</argument>, <argument>SourceLocation E</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>B</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>E</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<call><name><name>ranges</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>B</name></expr></argument>,<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></block></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type> <name>addFixit</name><parameter_list>(<parameter><decl><type><name>FixItHint</name></type> <name>F</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>fixits</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>F</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceRange</name></expr></argument>&gt;</argument_list></name> <macro><name>getRanges</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ranges</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>FixItHint</name></expr></argument>&gt;</argument_list></name> <macro><name>getFixits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>fixits</name></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function><type><name>void</name></type> <name>setAsLastInMainSourceFile</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>LastInMainSourceFile</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>isLastInMainSourceFile</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>LastInMainSourceFile</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
};

<decl_stmt><decl><type><name>using</name></type> <name>PathDiagnosticPieceRef</name> <init>= <expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PathDiagnosticPiece</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>PathPieces</name> <range>: <expr><name>public</name> <name>std</name><operator>::</operator><name><name>list</name><argument_list type="generic">&lt;<argument><expr><name>PathDiagnosticPieceRef</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>void</name> <macro><name>flattenTo</name><argument_list>(<argument>PathPieces &amp;Primary</argument>, <argument>PathPieces &amp;Current</argument>,
<argument>bool ShouldFlattenMacros</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>public</name><operator>:</operator>
<name>PathPieces</name> <macro><name>flatten</name><argument_list>(<argument>bool ShouldFlattenMacros</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>PathPieces</name> <name>Result</name></expr>;
<expr><call><name>flattenTo</name><argument_list>(<argument><expr><name>Result</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>, <argument><expr><name>ShouldFlattenMacros</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Result</name></expr>;</return>
}</block>

<name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>PathDiagnosticSpotPiece</name> <range>: <expr><name>public</name> <name>PathDiagnosticPiece</name> <block>{
<expr><name>private</name><operator>:</operator>
<name>PathDiagnosticLocation</name> <name>Pos</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>PathDiagnosticSpotPiece</name><argument_list>(<argument>const PathDiagnosticLocation &amp;pos</argument>,
<argument>StringRef s</argument>,
<argument>PathDiagnosticPiece::Kind k</argument>,
<argument>bool addPosRange = true</argument>)</argument_list></macro>
<operator>:</operator> <call><name>PathDiagnosticPiece</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>, <macro><name>Pos</name><argument_list>(<argument>pos</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Pos</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Pos</name><operator>.</operator><name>hasValidLocation</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"PathDiagnosticSpotPiece's must have a valid location."</literal></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>addPosRange</name> <operator>&amp;&amp;</operator> <call><name><name>Pos</name><operator>.</operator><name>hasRange</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addRange</name><argument_list>(<argument><expr><call><name><name>Pos</name><operator>.</operator><name>asRange</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<name>PathDiagnosticLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>Pos</name></expr>;</return> }</block>
<name>void</name> <macro><name>flattenLocations</name><argument_list>()</argument_list></macro> <name>override</name> <block>{ <expr><call><name><name>Pos</name><operator>.</operator><name>flatten</name></name><argument_list>()</argument_list></call></expr>; }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const PathDiagnosticPiece *P</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>P</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Event</name> <operator>||</operator> <call><name><name>P</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Macro</name> <operator>||</operator>
<call><name><name>P</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Note</name> <operator>||</operator> <call><name><name>P</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PopUp</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>PathDiagnosticEventPiece</name> <operator>:</operator> <name>public</name> <name>PathDiagnosticSpotPiece</name> <block>{
<expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>IsPrunable</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>PathDiagnosticEventPiece</name><argument_list>(<argument>const PathDiagnosticLocation &amp;pos</argument>,
<argument>StringRef s</argument>, <argument>bool addPosRange = true</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>PathDiagnosticSpotPiece</name><argument_list>(<argument>pos</argument>, <argument>s</argument>, <argument>Event</argument>, <argument>addPosRange</argument>)</argument_list></macro> <block>{}</block>
<operator>~</operator><macro><name>PathDiagnosticEventPiece</name><argument_list>()</argument_list></macro> <name>override</name></expr>;




<expr><name>void</name> <macro><name>setPrunable</name><argument_list>(<argument>bool isPrunable</argument>, <argument>bool override = false</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>IsPrunable</name><operator>.</operator><name>hasValue</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>override</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<name>IsPrunable</name> <operator>=</operator> <name>isPrunable</name></block></expr>;
}</block>


<name>bool</name> <macro><name>isPrunable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>IsPrunable</name><operator>.</operator><name>hasValue</name></name><argument_list>()</argument_list></call> <operator>?</operator> <call><name><name>IsPrunable</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call> <operator>:</operator> <name>false</name></expr>;</return>
}</block>

<name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const PathDiagnosticPiece *P</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>P</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Event</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>PathDiagnosticCallPiece</name> <operator>:</operator> <name>public</name> <name>PathDiagnosticPiece</name> <block>{
<expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>Caller</name></expr>;
<expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>Callee</name> <operator>=</operator> <name>nullptr</name></expr>;



<expr><name>bool</name> <name>NoExit</name></expr>;



<expr><name>bool</name> <name>IsCalleeAnAutosynthesizedPropertyAccessor</name> <operator>=</operator> <name>false</name></expr>;



<expr><name>std</name><operator>::</operator><name>string</name> <name>CallStackMessage</name></expr>;

<expr><call><name>PathDiagnosticCallPiece</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>callerD</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PathDiagnosticLocation</name> <operator>&amp;</operator><name>callReturnPos</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>PathDiagnosticPiece</name><argument_list>(<argument><expr><name>Call</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Caller</name><argument_list>(<argument><expr><name>callerD</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NoExit</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>,
<macro><name>callReturn</name><argument_list>(<argument>callReturnPos</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>PathDiagnosticCallPiece</name><argument_list>(<argument><expr><name>PathPieces</name> <operator>&amp;</operator><name>oldPath</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>caller</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>PathDiagnosticPiece</name><argument_list>(<argument><expr><name>Call</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Caller</name><argument_list>(<argument><expr><name>caller</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NoExit</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>,
<macro><name>path</name><argument_list>(<argument>oldPath</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>PathDiagnosticLocation</name> <name>callEnter</name></expr>;
<expr><name>PathDiagnosticLocation</name> <name>callEnterWithin</name></expr>;
<expr><name>PathDiagnosticLocation</name> <name>callReturn</name></expr>;
<expr><name>PathPieces</name> <name>path</name></expr>;

<expr><operator>~</operator><macro><name>PathDiagnosticCallPiece</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getCaller</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Caller</name></expr>;</return> }</block>

<specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getCallee</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Callee</name></expr>;</return> }</block>
<name>void</name> <call><name>setCallee</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CallEnter</name> <operator>&amp;</operator><name>CE</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>SourceManager</name> <operator>&amp;</operator><name>SM</name></expr></argument>)</argument_list></call></expr>;

<expr><name>bool</name> <macro><name>hasCallStackMessage</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><operator>!</operator><call><name><name>CallStackMessage</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setCallStackMessage</name><argument_list>(<argument>StringRef st</argument>)</argument_list></macro> <block>{ <expr><name>CallStackMessage</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>PathDiagnosticLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>callEnter</name></expr>;</return> }</block>

<name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PathDiagnosticEventPiece</name></expr></argument>&gt;</argument_list></name> <macro><name>getCallEnterEvent</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PathDiagnosticEventPiece</name></expr></argument>&gt;</argument_list></name>
<macro><name>getCallEnterWithinCallerEvent</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PathDiagnosticEventPiece</name></expr></argument>&gt;</argument_list></name> <macro><name>getCallExitEvent</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>void</name> <macro><name>flattenLocations</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>callEnter</name><operator>.</operator><name>flatten</name></name><argument_list>()</argument_list></call></expr>;
<expr><call><name><name>callReturn</name><operator>.</operator><name>flatten</name></name><argument_list>()</argument_list></call></expr>;
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>I</name> <range>: <expr><name>path</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>I</name><operator>-&gt;</operator><name>flattenLocations</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
}</block>

<specifier>static</specifier> <name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PathDiagnosticCallPiece</name></expr></argument>&gt;</argument_list></name>
<call><name>construct</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CallExitEnd</name> <operator>&amp;</operator><name>CE</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>SourceManager</name> <operator>&amp;</operator><name>SM</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>PathDiagnosticCallPiece</name> <operator>*</operator><call><name>construct</name><argument_list>(<argument><expr><name>PathPieces</name> <operator>&amp;</operator><name>pieces</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>caller</name></expr></argument>)</argument_list></call></expr>;

<expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const PathDiagnosticPiece *P</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>P</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Call</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>PathDiagnosticControlFlowPiece</name> <operator>:</operator> <name>public</name> <name>PathDiagnosticPiece</name> <block>{
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>PathDiagnosticLocationPair</name></expr></argument>&gt;</argument_list></name> <name>LPairs</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>PathDiagnosticControlFlowPiece</name><argument_list>(<argument>const PathDiagnosticLocation &amp;startPos</argument>,
<argument>const PathDiagnosticLocation &amp;endPos</argument>,
<argument>StringRef s</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>PathDiagnosticPiece</name><argument_list>(<argument>s</argument>, <argument>ControlFlow</argument>)</argument_list></macro> <block>{
<expr><call><name><name>LPairs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>PathDiagnosticLocationPair</name><argument_list>(<argument><expr><name>startPos</name></expr></argument>, <argument><expr><name>endPos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>PathDiagnosticControlFlowPiece</name><argument_list>(<argument><expr><specifier>const</specifier> <name>PathDiagnosticLocation</name> <operator>&amp;</operator><name>startPos</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PathDiagnosticLocation</name> <operator>&amp;</operator><name>endPos</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>PathDiagnosticPiece</name><argument_list>(<argument>ControlFlow</argument>)</argument_list></macro> <block>{
<expr><call><name><name>LPairs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>PathDiagnosticLocationPair</name><argument_list>(<argument><expr><name>startPos</name></expr></argument>, <argument><expr><name>endPos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<operator>~</operator><macro><name>PathDiagnosticControlFlowPiece</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>PathDiagnosticLocation</name> <macro><name>getStartLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>LPairs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"PathDiagnosticControlFlowPiece needs at least one location."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>LPairs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>getStart</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>PathDiagnosticLocation</name> <macro><name>getEndLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>LPairs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"PathDiagnosticControlFlowPiece needs at least one location."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>LPairs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>getEnd</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setStartLocation</name><argument_list>(<argument>const PathDiagnosticLocation &amp;L</argument>)</argument_list></macro> <block>{
<expr><name><name>LPairs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>setStart</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>setEndLocation</name><argument_list>(<argument>const PathDiagnosticLocation &amp;L</argument>)</argument_list></macro> <block>{
<expr><name><name>LPairs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>setEnd</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>push_back</name><argument_list>(<argument>const PathDiagnosticLocationPair &amp;X</argument>)</argument_list></macro> <block>{ <expr><call><name><name>LPairs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>PathDiagnosticLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getStartLocation</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>iterator</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>PathDiagnosticLocationPair</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;

<expr><name>iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>LPairs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>LPairs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>flattenLocations</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<for>for <control>(<init><expr><name>auto</name> <operator>&amp;</operator><name>I</name> <operator>:</operator> <operator>*</operator><name>this</name></expr></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>I</name><operator>.</operator><name>flatten</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
}</block>

<name>using</name> <name>const_iterator</name> <operator>=</operator>
<name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>PathDiagnosticLocationPair</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name></expr>;

<expr><name>const_iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>LPairs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>LPairs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const PathDiagnosticPiece *P</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>P</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ControlFlow</name></expr>;</return>
}</block>

<name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>PathDiagnosticMacroPiece</name> <operator>:</operator> <name>public</name> <name>PathDiagnosticSpotPiece</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PathDiagnosticMacroPiece</name><argument_list>(<argument><expr><specifier>const</specifier> <name>PathDiagnosticLocation</name> <operator>&amp;</operator><name>pos</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>PathDiagnosticSpotPiece</name><argument_list>(<argument>pos</argument>, <argument><literal type="string">""</literal></argument>, <argument>Macro</argument>)</argument_list></macro> <block>{}</block>
<operator>~</operator><macro><name>PathDiagnosticMacroPiece</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>PathPieces</name> <name>subPieces</name></expr>;

<expr><name>void</name> <macro><name>flattenLocations</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<expr><name>PathDiagnosticSpotPiece</name><operator>::</operator><call><name>flattenLocations</name><argument_list>()</argument_list></call></expr>;
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>I</name> <range>: <expr><name>subPieces</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>I</name><operator>-&gt;</operator><name>flattenLocations</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const PathDiagnosticPiece *P</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>P</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Macro</name></expr>;</return>
}</block>

<name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>PathDiagnosticNotePiece</name><operator>:</operator> <name>public</name> <name>PathDiagnosticSpotPiece</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>PathDiagnosticNotePiece</name><argument_list>(<argument>const PathDiagnosticLocation &amp;Pos</argument>, <argument>StringRef S</argument>,
<argument>bool AddPosRange = true</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>PathDiagnosticSpotPiece</name><argument_list>(<argument>Pos</argument>, <argument>S</argument>, <argument>Note</argument>, <argument>AddPosRange</argument>)</argument_list></macro> <block>{}</block>
<operator>~</operator><macro><name>PathDiagnosticNotePiece</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const PathDiagnosticPiece *P</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>P</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Note</name></expr>;</return>
}</block>

<name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>PathDiagnosticPopUpPiece</name><operator>:</operator> <name>public</name> <name>PathDiagnosticSpotPiece</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>PathDiagnosticPopUpPiece</name><argument_list>(<argument>const PathDiagnosticLocation &amp;Pos</argument>, <argument>StringRef S</argument>,
<argument>bool AddPosRange = true</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>PathDiagnosticSpotPiece</name><argument_list>(<argument>Pos</argument>, <argument>S</argument>, <argument>PopUp</argument>, <argument>AddPosRange</argument>)</argument_list></macro> <block>{}</block>
<operator>~</operator><macro><name>PathDiagnosticPopUpPiece</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const PathDiagnosticPiece *P</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>P</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PopUp</name></expr>;</return>
}</block>

<name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
}</block></expr>;


<expr><name>using</name> <name>FilesToLineNumsMap</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>FileID</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr>;




<expr><name>class</name> <name>PathDiagnostic</name> <operator>:</operator> <name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>std</name><operator>::</operator><name>string</name> <name>CheckerName</name></expr>;
<expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>DeclWithIssue</name></expr>;
<expr><name>std</name><operator>::</operator><name>string</name> <name>BugType</name></expr>;
<expr><name>std</name><operator>::</operator><name>string</name> <name>VerboseDesc</name></expr>;
<expr><name>std</name><operator>::</operator><name>string</name> <name>ShortDesc</name></expr>;
<expr><name>std</name><operator>::</operator><name>string</name> <name>Category</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>deque</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>OtherDesc</name></expr>;


<expr><name>PathDiagnosticLocation</name> <name>Loc</name></expr>;

<expr><name>PathPieces</name> <name>pathImpl</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>PathPieces</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>&gt;</argument_list></name> <name>pathStack</name></expr>;



<expr><name>PathDiagnosticLocation</name> <name>UniqueingLoc</name></expr>;
<expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>UniqueingDecl</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>FilesToLineNumsMap</name></expr></argument>&gt;</argument_list></name> <name>ExecutedLines</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>PathDiagnostic</name><argument_list>()</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<macro><name>PathDiagnostic</name><argument_list>(<argument>StringRef CheckerName</argument>, <argument>const Decl *DeclWithIssue</argument>,
<argument>StringRef bugtype</argument>, <argument>StringRef verboseDesc</argument>, <argument>StringRef shortDesc</argument>,
<argument>StringRef category</argument>, <argument>PathDiagnosticLocation LocationToUnique</argument>,
<argument>const Decl *DeclToUnique</argument>,
<argument>std::unique_ptr&lt;FilesToLineNumsMap&gt; ExecutedLines</argument>)</argument_list></macro>;
<expr><operator>~</operator><call><name>PathDiagnostic</name><argument_list>()</argument_list></call></expr>;

<expr><specifier>const</specifier> <name>PathPieces</name> <operator>&amp;</operator><name>path</name></expr>;



<expr><name>PathPieces</name> <operator>&amp;</operator><macro><name>getActivePath</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>pathStack</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>pathImpl</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><operator>*</operator><call><name><name>pathStack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>PathPieces</name> <operator>&amp;</operator><macro><name>getMutablePieces</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>pathImpl</name></expr>;</return>
}</block>


<name>unsigned</name> <call><name>full_size</name><argument_list>()</argument_list></call></expr>;

<expr><name>void</name> <macro><name>pushActivePath</name><argument_list>(<argument>PathPieces *p</argument>)</argument_list></macro> <block>{ <expr><call><name><name>pathStack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>; }</block>
<name>void</name> <macro><name>popActivePath</name><argument_list>()</argument_list></macro> <block>{ <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pathStack</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>pathStack</name><operator>.</operator><name>pop_back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> }</block>

<name>bool</name> <macro><name>isWithinCall</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name><name>pathStack</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>setEndOfPath</name><argument_list>(<argument>PathDiagnosticPieceRef EndPiece</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>Loc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"End location already set!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>Loc</name> <operator>=</operator> <call><name><name>EndPiece</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Loc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid location for end-of-path piece"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getActivePath</name><argument_list>()</argument_list></call><operator>.</operator><call><name>push_back</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>EndPiece</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>appendToDesc</name><argument_list>(<argument>StringRef S</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>ShortDesc</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ShortDesc</name> <operator>+=</operator> <name>S</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<name>VerboseDesc</name> <operator>+=</operator> <name>S</name></block></expr>;
}</block>

<name>StringRef</name> <macro><name>getVerboseDescription</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>VerboseDesc</name></expr>;</return> }</block>

<name>StringRef</name> <macro><name>getShortDescription</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>ShortDesc</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>?</operator> <name>VerboseDesc</name> <operator>:</operator> <name>ShortDesc</name></expr>;</return>
}</block>

<name>StringRef</name> <macro><name>getCheckerName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CheckerName</name></expr>;</return> }</block>
<name>StringRef</name> <macro><name>getBugType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BugType</name></expr>;</return> }</block>
<name>StringRef</name> <macro><name>getCategory</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Category</name></expr>;</return> }</block>

<name>using</name> <name>meta_iterator</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>deque</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name></expr>;

<expr><name>meta_iterator</name> <macro><name>meta_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>OtherDesc</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>meta_iterator</name> <macro><name>meta_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>OtherDesc</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>addMeta</name><argument_list>(<argument>StringRef s</argument>)</argument_list></macro> <block>{ <expr><call><name><name>OtherDesc</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>; }</block>

<specifier>const</specifier> <name>FilesToLineNumsMap</name> <operator>&amp;</operator><macro><name>getExecutedLines</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>*</operator><name>ExecutedLines</name></expr>;</return>
}</block>

<name>FilesToLineNumsMap</name> <operator>&amp;</operator><macro><name>getExecutedLines</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><operator>*</operator><name>ExecutedLines</name></expr>;</return>
}</block>




<specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getDeclWithIssue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DeclWithIssue</name></expr>;</return> }</block>

<name>void</name> <macro><name>setDeclWithIssue</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclWithIssue</name> <operator>=</operator> <name>D</name></expr>;
}</block>

<name>PathDiagnosticLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Loc</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setLocation</name><argument_list>(<argument>PathDiagnosticLocation NewLoc</argument>)</argument_list></macro> <block>{
<expr><name>Loc</name> <operator>=</operator> <name>NewLoc</name></expr>;
}</block>


<name>PathDiagnosticLocation</name> <macro><name>getUniqueingLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>UniqueingLoc</name></expr>;</return>
}</block>


<specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getUniqueingDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>UniqueingDecl</name></expr>;</return>
}</block>

<name>void</name> <macro><name>flattenLocations</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name><name>Loc</name><operator>.</operator><name>flatten</name></name><argument_list>()</argument_list></call></expr>;
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>I</name> <range>: <expr><name>pathImpl</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>I</name><operator>-&gt;</operator><name>flattenLocations</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
}</block>





<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier></expr>;





<expr><name>void</name> <macro><name>FullProfile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr></range></decl>;</decl_stmt>

}
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
