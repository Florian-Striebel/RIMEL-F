<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/ExprCXX.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_EXPRCXX_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_EXPRCXX_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTConcept.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ComputeDependence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclBase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclTemplate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclarationName.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DependenceFlags.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/NestedNameSpecifier.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/OperationKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Stmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TemplateBase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/UnresolvedSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/ExceptionSpecificationType.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/ExpressionTraits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Lambda.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LangOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OperatorKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Specifiers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TypeTraits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/None.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerUnion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/TrailingObjects.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DeclAccessPair</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>IdentifierInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LambdaCapture</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>NonTypeTemplateParmDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateParameterList</name></decl>;</decl_stmt>


















<decl_stmt><decl><type><name>class</name> <name>CXXOperatorCallExpr</name></type> <name>final</name> <range>: <expr><name>public</name> <name>CallExpr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;

<expr><name>SourceRange</name> <name>Range</name></expr>;




<expr><name>SourceRange</name> <macro><name>getSourceRangeImpl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;

<macro><name>CXXOperatorCallExpr</name><argument_list>(<argument>OverloadedOperatorKind OpKind</argument>, <argument>Expr *Fn</argument>,
<argument>ArrayRef&lt;Expr *&gt; Args</argument>, <argument>QualType Ty</argument>, <argument>ExprValueKind VK</argument>,
<argument>SourceLocation OperatorLoc</argument>, <argument>FPOptionsOverride FPFeatures</argument>,
<argument>ADLCallKind UsesADL</argument>)</argument_list></macro>;

<macro><name>CXXOperatorCallExpr</name><argument_list>(<argument>unsigned NumArgs</argument>, <argument>bool HasFPFeatures</argument>, <argument>EmptyShell Empty</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>CXXOperatorCallExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>OverloadedOperatorKind OpKind</argument>, <argument>Expr *Fn</argument>,
<argument>ArrayRef&lt;Expr *&gt; Args</argument>, <argument>QualType Ty</argument>, <argument>ExprValueKind VK</argument>,
<argument>SourceLocation OperatorLoc</argument>, <argument>FPOptionsOverride FPFeatures</argument>,
<argument>ADLCallKind UsesADL = NotADL</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>CXXOperatorCallExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>,
<argument>unsigned NumArgs</argument>, <argument>bool HasFPFeatures</argument>,
<argument>EmptyShell Empty</argument>)</argument_list></macro></expr>;


<expr><name>OverloadedOperatorKind</name> <macro><name>getOperator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>OverloadedOperatorKind</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name><name>CXXOperatorCallExprBits</name><operator>.</operator><name>OperatorKind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isAssignmentOp</name><argument_list>(<argument>OverloadedOperatorKind Opc</argument>)</argument_list></macro> <block>{
<return>return <expr><name>Opc</name> <operator>==</operator> <name>OO_Equal</name> <operator>||</operator> <name>Opc</name> <operator>==</operator> <name>OO_StarEqual</name> <operator>||</operator> <name>Opc</name> <operator>==</operator> <name>OO_SlashEqual</name> <operator>||</operator>
<name>Opc</name> <operator>==</operator> <name>OO_PercentEqual</name> <operator>||</operator> <name>Opc</name> <operator>==</operator> <name>OO_PlusEqual</name> <operator>||</operator>
<name>Opc</name> <operator>==</operator> <name>OO_MinusEqual</name> <operator>||</operator> <name>Opc</name> <operator>==</operator> <name>OO_LessLessEqual</name> <operator>||</operator>
<name>Opc</name> <operator>==</operator> <name>OO_GreaterGreaterEqual</name> <operator>||</operator> <name>Opc</name> <operator>==</operator> <name>OO_AmpEqual</name> <operator>||</operator>
<name>Opc</name> <operator>==</operator> <name>OO_CaretEqual</name> <operator>||</operator> <name>Opc</name> <operator>==</operator> <name>OO_PipeEqual</name></expr>;</return>
}</block>
<name>bool</name> <macro><name>isAssignmentOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isAssignmentOp</name><argument_list>(<argument><expr><call><name>getOperator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isComparisonOp</name><argument_list>(<argument>OverloadedOperatorKind Opc</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><name>Opc</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OO_EqualEqual</name></expr>:</case>
<case>case <expr><name>OO_ExclaimEqual</name></expr>:</case>
<case>case <expr><name>OO_Greater</name></expr>:</case>
<case>case <expr><name>OO_GreaterEqual</name></expr>:</case>
<case>case <expr><name>OO_Less</name></expr>:</case>
<case>case <expr><name>OO_LessEqual</name></expr>:</case>
<case>case <expr><name>OO_Spaceship</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>
<default>default:</default>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/>}</block_content>
}
bool isComparisonOp(</block></switch>) <specifier>const</specifier> <block>{ <return>return <expr><call><name>isComparisonOp</name><argument_list>(<argument><expr><call><name>getOperator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></block>


<name>bool</name> <macro><name>isInfixBinaryOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;






<expr><name>SourceLocation</name> <macro><name>getOperatorLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getRParenLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getExprLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<expr><name>OverloadedOperatorKind</name> <name>Operator</name> <operator>=</operator> <call><name>getOperator</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><ternary><condition><expr><operator>(</operator><name>Operator</name> <operator>&lt;</operator> <name>OO_Plus</name> <operator>||</operator> <name>Operator</name> <operator>&gt;=</operator> <name>OO_Arrow</name> <operator>||</operator>
<name>Operator</name> <operator>==</operator> <name>OO_PlusPlus</name> <operator>||</operator> <name>Operator</name> <operator>==</operator> <name>OO_MinusMinus</name><operator>)</operator></expr>
?</condition><then> <expr><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>
</then><else>: <expr><call><name>getOperatorLoc</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Range</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXOperatorCallExprClass</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>CXXMemberCallExpr</name> <name>final</name> <operator>:</operator> <name>public</name> <name>CallExpr</name> <block>{



<macro><name>CXXMemberCallExpr</name><argument_list>(<argument>Expr *Fn</argument>, <argument>ArrayRef&lt;Expr *&gt; Args</argument>, <argument>QualType Ty</argument>,
<argument>ExprValueKind VK</argument>, <argument>SourceLocation RP</argument>,
<argument>FPOptionsOverride FPOptions</argument>, <argument>unsigned MinNumArgs</argument>)</argument_list></macro>;

<macro><name>CXXMemberCallExpr</name><argument_list>(<argument>unsigned NumArgs</argument>, <argument>bool HasFPFeatures</argument>, <argument>EmptyShell Empty</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>CXXMemberCallExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>Expr *Fn</argument>,
<argument>ArrayRef&lt;Expr *&gt; Args</argument>, <argument>QualType Ty</argument>,
<argument>ExprValueKind VK</argument>, <argument>SourceLocation RP</argument>,
<argument>FPOptionsOverride FPFeatures</argument>,
<argument>unsigned MinNumArgs = <literal type="number">0</literal></argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>CXXMemberCallExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>unsigned NumArgs</argument>,
<argument>bool HasFPFeatures</argument>, <argument>EmptyShell Empty</argument>)</argument_list></macro></expr>;




<expr><name>Expr</name> <operator>*</operator><macro><name>getImplicitObjectArgument</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>QualType</name> <macro><name>getObjectType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>CXXMethodDecl</name> <operator>*</operator><macro><name>getMethodDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;







<expr><name>CXXRecordDecl</name> <operator>*</operator><macro><name>getRecordDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>SourceLocation</name> <macro><name>getExprLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<expr><name>SourceLocation</name> <name>CLoc</name> <operator>=</operator> <call><name>getCallee</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getExprLoc</name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>CLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CLoc</name></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXMemberCallExprClass</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>CUDAKernelCallExpr</name> <name>final</name> <operator>:</operator> <name>public</name> <name>CallExpr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

enum <expr><block>{ <expr><name>CONFIG</name></expr>, <expr><name>END_PREARG</name></expr> }</block></expr>;




<macro><name>CUDAKernelCallExpr</name><argument_list>(<argument>Expr *Fn</argument>, <argument>CallExpr *Config</argument>, <argument>ArrayRef&lt;Expr *&gt; Args</argument>,
<argument>QualType Ty</argument>, <argument>ExprValueKind VK</argument>, <argument>SourceLocation RP</argument>,
<argument>FPOptionsOverride FPFeatures</argument>, <argument>unsigned MinNumArgs</argument>)</argument_list></macro>;

<macro><name>CUDAKernelCallExpr</name><argument_list>(<argument>unsigned NumArgs</argument>, <argument>bool HasFPFeatures</argument>, <argument>EmptyShell Empty</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>CUDAKernelCallExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>Expr *Fn</argument>,
<argument>CallExpr *Config</argument>, <argument>ArrayRef&lt;Expr *&gt; Args</argument>,
<argument>QualType Ty</argument>, <argument>ExprValueKind VK</argument>,
<argument>SourceLocation RP</argument>,
<argument>FPOptionsOverride FPFeatures</argument>,
<argument>unsigned MinNumArgs = <literal type="number">0</literal></argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>CUDAKernelCallExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>,
<argument>unsigned NumArgs</argument>, <argument>bool HasFPFeatures</argument>,
<argument>EmptyShell Empty</argument>)</argument_list></macro></expr>;

<expr><specifier>const</specifier> <name>CallExpr</name> <operator>*</operator><macro><name>getConfig</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>CallExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPreArg</name><argument_list>(<argument><expr><name>CONFIG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>CallExpr</name> <operator>*</operator><macro><name>getConfig</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>CallExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPreArg</name><argument_list>(<argument><expr><name>CONFIG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CUDAKernelCallExprClass</name></expr>;</return>
}</block>
}</expr>;

















<expr><name>class</name> <name>CXXRewrittenBinaryOperator</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>SemanticForm</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>CXXRewrittenBinaryOperator</name><argument_list>(<argument>Expr *SemanticForm</argument>, <argument>bool IsReversed</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>CXXRewrittenBinaryOperatorClass</name></expr></argument>, <argument><expr><call><name><name>SemanticForm</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>SemanticForm</name><operator>-&gt;</operator><name>getValueKind</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>SemanticForm</name><operator>-&gt;</operator><name>getObjectKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>SemanticForm</name><argument_list>(<argument>SemanticForm</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CXXRewrittenBinaryOperatorBits</name><operator>.</operator><name>IsReversed</name></name> <operator>=</operator> <name>IsReversed</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>
<macro><name>CXXRewrittenBinaryOperator</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>CXXRewrittenBinaryOperatorClass</name></expr></argument>, <argument><expr><name>Empty</name></expr></argument>)</argument_list></call></expr>, <macro><name>SemanticForm</name><argument_list>()</argument_list></macro> <expr><block>{}</block>


<name>Expr</name> <operator>*</operator><macro><name>getSemanticForm</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SemanticForm</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getSemanticForm</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SemanticForm</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

struct <name>DecomposedForm</name> <block>{

<expr><name>BinaryOperatorKind</name> <name>Opcode</name></expr>;

<expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>LHS</name></expr>;

<expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>RHS</name></expr>;

<expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>InnerBinOp</name></expr>;
}</block></expr>;


<expr><name>DecomposedForm</name> <macro><name>getDecomposedForm</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;


<expr><name>bool</name> <macro><name>isReversed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXRewrittenBinaryOperatorBits</name><operator>.</operator><name>IsReversed</name></name></expr>;</return> }</block>

<name>BinaryOperatorKind</name> <macro><name>getOperator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getDecomposedForm</name><argument_list>()</argument_list></call><operator>.</operator><name>Opcode</name></expr>;</return> }</block>
<name>BinaryOperatorKind</name> <macro><name>getOpcode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getOperator</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>StringRef</name> <macro><name>getOpcodeStr</name><argument_list>(<argument>BinaryOperatorKind Op</argument>)</argument_list></macro> <block>{
<return>return <expr><name>BinaryOperator</name><operator>::</operator><call><name>getOpcodeStr</name><argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>StringRef</name> <macro><name>getOpcodeStr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>BinaryOperator</name><operator>::</operator><call><name>getOpcodeStr</name><argument_list>(<argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>bool</name> <macro><name>isComparisonOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isAssignmentOp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getLHS</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getDecomposedForm</name><argument_list>()</argument_list></call><operator>.</operator><name>LHS</name></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getRHS</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getDecomposedForm</name><argument_list>()</argument_list></call><operator>.</operator><name>RHS</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getOperatorLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getDecomposedForm</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>InnerBinOp</name><operator>-&gt;</operator><name>getExprLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getExprLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name>getOperatorLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>





<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getDecomposedForm</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>LHS</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getDecomposedForm</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>RHS</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<expr><name>DecomposedForm</name> <name>DF</name> <operator>=</operator> <call><name>getDecomposedForm</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name><name>DF</name><operator>.</operator><name>LHS</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>DF</name><operator>.</operator><name>RHS</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SemanticForm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SemanticForm</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXRewrittenBinaryOperatorClass</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>CXXNamedCastExpr</name> <operator>:</operator> <name>public</name> <name>ExplicitCastExpr</name> <block>{
<expr><name>private</name><operator>:</operator>

<name>SourceLocation</name> <name>Loc</name></expr>;


<expr><name>SourceLocation</name> <name>RParenLoc</name></expr>;


<expr><name>SourceRange</name> <name>AngleBrackets</name></expr>;

<expr><name>protected</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<macro><name>CXXNamedCastExpr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>QualType ty</argument>, <argument>ExprValueKind VK</argument>, <argument>CastKind kind</argument>,
<argument>Expr *op</argument>, <argument>unsigned PathSize</argument>, <argument>bool HasFPFeatures</argument>,
<argument>TypeSourceInfo *writtenTy</argument>, <argument>SourceLocation l</argument>,
<argument>SourceLocation RParenLoc</argument>, <argument>SourceRange AngleBrackets</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>ExplicitCastExpr</name><argument_list>(<argument><expr><name>SC</name></expr></argument>, <argument><expr><name>ty</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>PathSize</name></expr></argument>, <argument><expr><name>HasFPFeatures</name></expr></argument>,
<argument><expr><name>writtenTy</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Loc</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>RParenLoc</name><argument_list>(<argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>AngleBrackets</name><argument_list>(<argument>AngleBrackets</argument>)</argument_list></macro> <expr><block>{}</block>

<name>explicit</name> <macro><name>CXXNamedCastExpr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>EmptyShell Shell</argument>, <argument>unsigned PathSize</argument>,
<argument>bool HasFPFeatures</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>ExplicitCastExpr</name><argument_list>(<argument>SC</argument>, <argument>Shell</argument>, <argument>PathSize</argument>, <argument>HasFPFeatures</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getCastName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>SourceLocation</name> <macro><name>getOperatorLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>SourceRange</name> <macro><name>getAngleBrackets</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>AngleBrackets</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CXXStaticCastExprClass</name></expr>:</case>
<case>case <expr><name>CXXDynamicCastExprClass</name></expr>:</case>
<case>case <expr><name>CXXReinterpretCastExprClass</name></expr>:</case>
<case>case <expr><name>CXXConstCastExprClass</name></expr>:</case>
<case>case <expr><name>CXXAddrspaceCastExprClass</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>
<default>default:</default>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/>}</block_content>
}
}</block><empty_stmt>;</empty_stmt></switch>





<expr><name>class</name> <name>CXXStaticCastExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>CXXNamedCastExpr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>CXXStaticCastExpr</name></expr></argument>, <argument><expr><name>CXXBaseSpecifier</name> <operator>*</operator></expr></argument>,
<argument><expr><name>FPOptionsOverride</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>CXXStaticCastExpr</name><argument_list>(<argument>QualType ty</argument>, <argument>ExprValueKind vk</argument>, <argument>CastKind kind</argument>, <argument>Expr *op</argument>,
<argument>unsigned pathSize</argument>, <argument>TypeSourceInfo *writtenTy</argument>,
<argument>FPOptionsOverride FPO</argument>, <argument>SourceLocation l</argument>,
<argument>SourceLocation RParenLoc</argument>, <argument>SourceRange AngleBrackets</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CXXNamedCastExpr</name><argument_list>(<argument>CXXStaticCastExprClass</argument>, <argument>ty</argument>, <argument>vk</argument>, <argument>kind</argument>, <argument>op</argument>, <argument>pathSize</argument>,
<argument>FPO.requiresTrailingStorage()</argument>, <argument>writtenTy</argument>, <argument>l</argument>, <argument>RParenLoc</argument>,
<argument>AngleBrackets</argument>)</argument_list></macro> <expr><block>{
<if_stmt><if>if <condition>(<expr><call><name>hasStoredFPFeatures</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><call><name>getTrailingFPFeatures</name><argument_list>()</argument_list></call> <operator>=</operator> <name>FPO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<name>explicit</name> <macro><name>CXXStaticCastExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>unsigned PathSize</argument>,
<argument>bool HasFPFeatures</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CXXNamedCastExpr</name><argument_list>(<argument>CXXStaticCastExprClass</argument>, <argument>Empty</argument>, <argument>PathSize</argument>,
<argument>HasFPFeatures</argument>)</argument_list></macro> <block>{}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;CXXBaseSpecifier *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>path_size</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CastExpr</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;

<expr><specifier>static</specifier> <name>CXXStaticCastExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>QualType T</argument>, <argument>ExprValueKind VK</argument>, <argument>CastKind K</argument>,
<argument>Expr *Op</argument>, <argument>const CXXCastPath *Path</argument>, <argument>TypeSourceInfo *Written</argument>,
<argument>FPOptionsOverride FPO</argument>, <argument>SourceLocation L</argument>, <argument>SourceLocation RParenLoc</argument>,
<argument>SourceRange AngleBrackets</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>CXXStaticCastExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Context</argument>,
<argument>unsigned PathSize</argument>, <argument>bool hasFPFeatures</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXStaticCastExprClass</name></expr>;</return>
}</block>
}</expr>;






<expr><name>class</name> <name>CXXDynamicCastExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>CXXNamedCastExpr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>CXXDynamicCastExpr</name></expr></argument>, <argument><expr><name>CXXBaseSpecifier</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>CXXDynamicCastExpr</name><argument_list>(<argument>QualType ty</argument>, <argument>ExprValueKind VK</argument>, <argument>CastKind kind</argument>, <argument>Expr *op</argument>,
<argument>unsigned pathSize</argument>, <argument>TypeSourceInfo *writtenTy</argument>,
<argument>SourceLocation l</argument>, <argument>SourceLocation RParenLoc</argument>,
<argument>SourceRange AngleBrackets</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CXXNamedCastExpr</name><argument_list>(<argument>CXXDynamicCastExprClass</argument>, <argument>ty</argument>, <argument>VK</argument>, <argument>kind</argument>, <argument>op</argument>, <argument>pathSize</argument>,
<argument>false</argument>, <argument>writtenTy</argument>, <argument>l</argument>, <argument>RParenLoc</argument>,
<argument>AngleBrackets</argument>)</argument_list></macro> <expr><block>{}</block>

<name>explicit</name> <macro><name>CXXDynamicCastExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>unsigned pathSize</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CXXNamedCastExpr</name><argument_list>(<argument>CXXDynamicCastExprClass</argument>, <argument>Empty</argument>, <argument>pathSize</argument>,
<argument>false</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CastExpr</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;

<expr><specifier>static</specifier> <name>CXXDynamicCastExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>QualType T</argument>,
<argument>ExprValueKind VK</argument>, <argument>CastKind Kind</argument>, <argument>Expr *Op</argument>,
<argument>const CXXCastPath *Path</argument>,
<argument>TypeSourceInfo *Written</argument>, <argument>SourceLocation L</argument>,
<argument>SourceLocation RParenLoc</argument>,
<argument>SourceRange AngleBrackets</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>CXXDynamicCastExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Context</argument>,
<argument>unsigned pathSize</argument>)</argument_list></macro></expr>;

<expr><name>bool</name> <macro><name>isAlwaysNull</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXDynamicCastExprClass</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>CXXReinterpretCastExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>CXXNamedCastExpr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>CXXReinterpretCastExpr</name></expr></argument>,
<argument><expr><name>CXXBaseSpecifier</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>CXXReinterpretCastExpr</name><argument_list>(<argument>QualType ty</argument>, <argument>ExprValueKind vk</argument>, <argument>CastKind kind</argument>, <argument>Expr *op</argument>,
<argument>unsigned pathSize</argument>, <argument>TypeSourceInfo *writtenTy</argument>,
<argument>SourceLocation l</argument>, <argument>SourceLocation RParenLoc</argument>,
<argument>SourceRange AngleBrackets</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CXXNamedCastExpr</name><argument_list>(<argument>CXXReinterpretCastExprClass</argument>, <argument>ty</argument>, <argument>vk</argument>, <argument>kind</argument>, <argument>op</argument>,
<argument>pathSize</argument>, <argument>false</argument>, <argument>writtenTy</argument>, <argument>l</argument>,
<argument>RParenLoc</argument>, <argument>AngleBrackets</argument>)</argument_list></macro> <expr><block>{}</block>

<macro><name>CXXReinterpretCastExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>unsigned pathSize</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CXXNamedCastExpr</name><argument_list>(<argument>CXXReinterpretCastExprClass</argument>, <argument>Empty</argument>, <argument>pathSize</argument>,
<argument>false</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CastExpr</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;

<expr><specifier>static</specifier> <name>CXXReinterpretCastExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>QualType T</argument>,
<argument>ExprValueKind VK</argument>, <argument>CastKind Kind</argument>,
<argument>Expr *Op</argument>, <argument>const CXXCastPath *Path</argument>,
<argument>TypeSourceInfo *WrittenTy</argument>, <argument>SourceLocation L</argument>,
<argument>SourceLocation RParenLoc</argument>,
<argument>SourceRange AngleBrackets</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>CXXReinterpretCastExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Context</argument>,
<argument>unsigned pathSize</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXReinterpretCastExprClass</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>CXXConstCastExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>CXXNamedCastExpr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstCastExpr</name></expr></argument>, <argument><expr><name>CXXBaseSpecifier</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>CXXConstCastExpr</name><argument_list>(<argument>QualType ty</argument>, <argument>ExprValueKind VK</argument>, <argument>Expr *op</argument>,
<argument>TypeSourceInfo *writtenTy</argument>, <argument>SourceLocation l</argument>,
<argument>SourceLocation RParenLoc</argument>, <argument>SourceRange AngleBrackets</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CXXNamedCastExpr</name><argument_list>(<argument>CXXConstCastExprClass</argument>, <argument>ty</argument>, <argument>VK</argument>, <argument>CK_NoOp</argument>, <argument>op</argument>, <argument><literal type="number">0</literal></argument>,
<argument>false</argument>, <argument>writtenTy</argument>, <argument>l</argument>, <argument>RParenLoc</argument>,
<argument>AngleBrackets</argument>)</argument_list></macro> <expr><block>{}</block>

<name>explicit</name> <macro><name>CXXConstCastExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CXXNamedCastExpr</name><argument_list>(<argument>CXXConstCastExprClass</argument>, <argument>Empty</argument>, <argument><literal type="number">0</literal></argument>,
<argument>false</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CastExpr</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;

<expr><specifier>static</specifier> <name>CXXConstCastExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>QualType T</argument>,
<argument>ExprValueKind VK</argument>, <argument>Expr *Op</argument>,
<argument>TypeSourceInfo *WrittenTy</argument>, <argument>SourceLocation L</argument>,
<argument>SourceLocation RParenLoc</argument>,
<argument>SourceRange AngleBrackets</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>CXXConstCastExpr</name> <operator>*</operator><call><name>CreateEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXConstCastExprClass</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>CXXAddrspaceCastExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>CXXNamedCastExpr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>CXXAddrspaceCastExpr</name></expr></argument>, <argument><expr><name>CXXBaseSpecifier</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>CXXAddrspaceCastExpr</name><argument_list>(<argument>QualType ty</argument>, <argument>ExprValueKind VK</argument>, <argument>CastKind Kind</argument>, <argument>Expr *op</argument>,
<argument>TypeSourceInfo *writtenTy</argument>, <argument>SourceLocation l</argument>,
<argument>SourceLocation RParenLoc</argument>, <argument>SourceRange AngleBrackets</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CXXNamedCastExpr</name><argument_list>(<argument>CXXAddrspaceCastExprClass</argument>, <argument>ty</argument>, <argument>VK</argument>, <argument>Kind</argument>, <argument>op</argument>, <argument><literal type="number">0</literal></argument>,
<argument>false</argument>, <argument>writtenTy</argument>, <argument>l</argument>, <argument>RParenLoc</argument>,
<argument>AngleBrackets</argument>)</argument_list></macro> <expr><block>{}</block>

<name>explicit</name> <macro><name>CXXAddrspaceCastExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CXXNamedCastExpr</name><argument_list>(<argument>CXXAddrspaceCastExprClass</argument>, <argument>Empty</argument>, <argument><literal type="number">0</literal></argument>,
<argument>false</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CastExpr</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;

<expr><specifier>static</specifier> <name>CXXAddrspaceCastExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>QualType T</argument>, <argument>ExprValueKind VK</argument>, <argument>CastKind Kind</argument>,
<argument>Expr *Op</argument>, <argument>TypeSourceInfo *WrittenTy</argument>, <argument>SourceLocation L</argument>,
<argument>SourceLocation RParenLoc</argument>, <argument>SourceRange AngleBrackets</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>CXXAddrspaceCastExpr</name> <operator>*</operator><call><name>CreateEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXAddrspaceCastExprClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>UserDefinedLiteral</name> <name>final</name> <operator>:</operator> <name>public</name> <name>CallExpr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;


<expr><name>SourceLocation</name> <name>UDSuffixLoc</name></expr>;




<macro><name>UserDefinedLiteral</name><argument_list>(<argument>Expr *Fn</argument>, <argument>ArrayRef&lt;Expr *&gt; Args</argument>, <argument>QualType Ty</argument>,
<argument>ExprValueKind VK</argument>, <argument>SourceLocation LitEndLoc</argument>,
<argument>SourceLocation SuffixLoc</argument>, <argument>FPOptionsOverride FPFeatures</argument>)</argument_list></macro>;

<macro><name>UserDefinedLiteral</name><argument_list>(<argument>unsigned NumArgs</argument>, <argument>bool HasFPFeatures</argument>, <argument>EmptyShell Empty</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>UserDefinedLiteral</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>Expr *Fn</argument>,
<argument>ArrayRef&lt;Expr *&gt; Args</argument>, <argument>QualType Ty</argument>,
<argument>ExprValueKind VK</argument>, <argument>SourceLocation LitEndLoc</argument>,
<argument>SourceLocation SuffixLoc</argument>,
<argument>FPOptionsOverride FPFeatures</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>UserDefinedLiteral</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>,
<argument>unsigned NumArgs</argument>, <argument>bool HasFPOptions</argument>,
<argument>EmptyShell Empty</argument>)</argument_list></macro></expr>;


enum <expr><name>LiteralOperatorKind</name> <block>{

<expr><name>LOK_Raw</name></expr>,


<expr><name>LOK_Template</name></expr>,


<expr><name>LOK_Integer</name></expr>,


<expr><name>LOK_Floating</name></expr>,


<expr><name>LOK_String</name></expr>,


<expr><name>LOK_Character</name></expr>
}</block></expr>;



<expr><name>LiteralOperatorKind</name> <macro><name>getLiteralOperatorKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>Expr</name> <operator>*</operator><call><name>getCookedLiteral</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getCookedLiteral</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>UserDefinedLiteral</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getCookedLiteral</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getLiteralOperatorKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>LOK_Template</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getRParenLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getArg</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getRParenLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>





<name>SourceLocation</name> <macro><name>getUDSuffixLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>UDSuffixLoc</name></expr>;</return> }</block>


<specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><macro><name>getUDSuffix</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *S</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>S</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>UserDefinedLiteralClass</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>CXXBoolLiteralExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>CXXBoolLiteralExpr</name><argument_list>(<argument>bool Val</argument>, <argument>QualType Ty</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CXXBoolLiteralExprClass</argument>, <argument>Ty</argument>, <argument>VK_PRValue</argument>, <argument>OK_Ordinary</argument>)</argument_list></macro> <block>{
<expr><name><name>CXXBoolLiteralExprBits</name><operator>.</operator><name>Value</name></name> <operator>=</operator> <name>Val</name></expr>;
<expr><name><name>CXXBoolLiteralExprBits</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>Loc</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><name>ExprDependence</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>explicit</name> <macro><name>CXXBoolLiteralExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CXXBoolLiteralExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <macro><name>getValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXBoolLiteralExprBits</name><operator>.</operator><name>Value</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setValue</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{ <expr><name><name>CXXBoolLiteralExprBits</name><operator>.</operator><name>Value</name></name> <operator>=</operator> <name>V</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXBoolLiteralExprBits</name><operator>.</operator><name>Loc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setLocation</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>CXXBoolLiteralExprBits</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXBoolLiteralExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>CXXNullPtrLiteralExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>CXXNullPtrLiteralExpr</name><argument_list>(<argument>QualType Ty</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CXXNullPtrLiteralExprClass</argument>, <argument>Ty</argument>, <argument>VK_PRValue</argument>, <argument>OK_Ordinary</argument>)</argument_list></macro> <block>{
<expr><name><name>CXXNullPtrLiteralExprBits</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>Loc</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><name>ExprDependence</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>explicit</name> <macro><name>CXXNullPtrLiteralExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CXXNullPtrLiteralExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXNullPtrLiteralExprBits</name><operator>.</operator><name>Loc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setLocation</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>CXXNullPtrLiteralExprBits</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXNullPtrLiteralExprClass</name></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>CXXStdInitializerListExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>Stmt</name> <operator>*</operator><name>SubExpr</name> <operator>=</operator> <name>nullptr</name></expr>;

<macro><name>CXXStdInitializerListExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CXXStdInitializerListExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<macro><name>CXXStdInitializerListExpr</name><argument_list>(<argument>QualType Ty</argument>, <argument>Expr *SubExpr</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Expr</name><argument_list>(<argument><expr><name>CXXStdInitializerListExprClass</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>,
<macro><name>SubExpr</name><argument_list>(<argument>SubExpr</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SubExpr</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SubExpr</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>SubExpr</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>SubExpr</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>SubExpr</name><operator>-&gt;</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *S</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>S</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXStdInitializerListExprClass</name></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubExpr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubExpr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;






<expr><name>class</name> <name>CXXTypeidExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>, <argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Operand</name></expr>;
<expr><name>SourceRange</name> <name>Range</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>CXXTypeidExpr</name><argument_list>(<argument>QualType Ty</argument>, <argument>TypeSourceInfo *Operand</argument>, <argument>SourceRange R</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>CXXTypeidExprClass</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>VK_LValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Operand</name><argument_list>(<argument><expr><name>Operand</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Range</name><argument_list>(<argument>R</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>CXXTypeidExpr</name><argument_list>(<argument>QualType Ty</argument>, <argument>Expr *Operand</argument>, <argument>SourceRange R</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>CXXTypeidExprClass</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>VK_LValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Operand</name><argument_list>(<argument><expr><name>Operand</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Range</name><argument_list>(<argument>R</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>CXXTypeidExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>bool isExpr</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CXXTypeidExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>isExpr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Operand</name> <operator>=</operator> <operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator><name>nullptr</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>Operand</name> <operator>=</operator> <operator>(</operator><name>TypeSourceInfo</name><operator>*</operator><operator>)</operator><name>nullptr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
}</block>



<name>bool</name> <macro><name>isPotentiallyEvaluated</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isMostDerived</name><argument_list>(<argument>ASTContext &amp;Context</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>isTypeOperand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Operand</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>TypeSourceInfo</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block>



<name>QualType</name> <macro><name>getTypeOperand</name><argument_list>(<argument>ASTContext &amp;Context</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeOperandSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isTypeOperand</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Cannot call getTypeOperand for typeid(expr)"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>Operand</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>TypeSourceInfo</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>
<name>Expr</name> <operator>*</operator><macro><name>getExprOperand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isTypeOperand</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Cannot call getExprOperand for typeid(type)"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>Operand</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>Stmt</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Range</name></expr>;</return> }</block>
<name>void</name> <macro><name>setSourceRange</name><argument_list>(<argument>SourceRange R</argument>)</argument_list></macro> <block>{ <expr><name>Range</name> <operator>=</operator> <name>R</name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXTypeidExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isTypeOperand</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<name>auto</name> <operator>*</operator><operator>*</operator><name>begin</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Operand</name></expr></argument>)</argument_list></call></block></expr>;
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>begin</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isTypeOperand</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>auto</name> <operator>*</operator><operator>*</operator><name>begin</name> <operator>=</operator>
<call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXTypeidExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>Operand</name></expr></argument>)</argument_list></call></block></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>begin</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;






<expr><name>class</name> <name>MSPropertyRefExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>Expr</name> <operator>*</operator><name>BaseExpr</name></expr>;
<expr><name>MSPropertyDecl</name> <operator>*</operator><name>TheDecl</name></expr>;
<expr><name>SourceLocation</name> <name>MemberLoc</name></expr>;
<expr><name>bool</name> <name>IsArrow</name></expr>;
<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<macro><name>MSPropertyRefExpr</name><argument_list>(<argument>Expr *baseExpr</argument>, <argument>MSPropertyDecl *decl</argument>, <argument>bool isArrow</argument>,
<argument>QualType ty</argument>, <argument>ExprValueKind VK</argument>,
<argument>NestedNameSpecifierLoc qualifierLoc</argument>, <argument>SourceLocation nameLoc</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Expr</name><argument_list>(<argument><expr><name>MSPropertyRefExprClass</name></expr></argument>, <argument><expr><name>ty</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>BaseExpr</name><argument_list>(<argument><expr><name>baseExpr</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TheDecl</name><argument_list>(<argument><expr><name>decl</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>MemberLoc</name><argument_list>(<argument><expr><name>nameLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>IsArrow</name><argument_list>(<argument><expr><name>isArrow</name></expr></argument>)</argument_list></call></expr>,
<macro><name>QualifierLoc</name><argument_list>(<argument>qualifierLoc</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>MSPropertyRefExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>MSPropertyRefExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isImplicitAccess</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getBaseExpr</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>getBaseExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isImplicitCXXThis</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isImplicitAccess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>BaseExpr</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>QualifierLoc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>MemberLoc</name></expr>;</return></block_content></block></else></if_stmt>
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getMemberLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>(</operator><name>Stmt</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>BaseExpr</name></expr></argument>, <argument><expr><operator>(</operator><name>Stmt</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>BaseExpr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>MSPropertyRefExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>MSPropertyRefExprClass</name></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getBaseExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BaseExpr</name></expr>;</return> }</block>
<name>MSPropertyDecl</name> <operator>*</operator><macro><name>getPropertyDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TheDecl</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isArrow</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsArrow</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getMemberLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MemberLoc</name></expr>;</return> }</block>
<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QualifierLoc</name></expr>;</return> }</block>
}</expr>;












<expr><name>class</name> <name>MSPropertySubscriptExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

enum <expr><block>{ <expr><name>BASE_EXPR</name></expr>, <expr><name>IDX_EXPR</name></expr>, <expr><name>NUM_SUBEXPRS</name> <operator>=</operator> <literal type="number">2</literal></expr> }</block></expr>;

<expr><name>Stmt</name> <operator>*</operator><name><name>SubExprs</name><index>[<expr><name>NUM_SUBEXPRS</name></expr>]</index></name></expr>;
<expr><name>SourceLocation</name> <name>RBracketLoc</name></expr>;

<expr><name>void</name> <macro><name>setBase</name><argument_list>(<argument>Expr *Base</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>BASE_EXPR</name></expr>]</index></name> <operator>=</operator> <name>Base</name></expr>; }</block>
<name>void</name> <macro><name>setIdx</name><argument_list>(<argument>Expr *Idx</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>IDX_EXPR</name></expr>]</index></name> <operator>=</operator> <name>Idx</name></expr>; }</block>

<name>public</name><operator>:</operator>
<macro><name>MSPropertySubscriptExpr</name><argument_list>(<argument>Expr *Base</argument>, <argument>Expr *Idx</argument>, <argument>QualType Ty</argument>, <argument>ExprValueKind VK</argument>,
<argument>ExprObjectKind OK</argument>, <argument>SourceLocation RBracketLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>MSPropertySubscriptExprClass</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>OK</name></expr></argument>)</argument_list></call></expr>,
<macro><name>RBracketLoc</name><argument_list>(<argument>RBracketLoc</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>SubExprs</name><index>[<expr><name>BASE_EXPR</name></expr>]</index></name> <operator>=</operator> <name>Base</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>IDX_EXPR</name></expr>]</index></name> <operator>=</operator> <name>Idx</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>MSPropertySubscriptExpr</name><argument_list>(<argument>EmptyShell Shell</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>MSPropertySubscriptExprClass</argument>, <argument>Shell</argument>)</argument_list></macro> <block>{}</block>

<name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>BASE_EXPR</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>BASE_EXPR</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getIdx</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>IDX_EXPR</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getIdx</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>IDX_EXPR</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getBase</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RBracketLoc</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getRBracketLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RBracketLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRBracketLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RBracketLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getExprLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getBase</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getExprLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>MSPropertySubscriptExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>NUM_SUBEXPRS</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>NUM_SUBEXPRS</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;





<expr><name>class</name> <name>CXXUuidofExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>, <argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Operand</name></expr>;
<expr><name>MSGuidDecl</name> <operator>*</operator><name>Guid</name></expr>;
<expr><name>SourceRange</name> <name>Range</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>CXXUuidofExpr</name><argument_list>(<argument>QualType Ty</argument>, <argument>TypeSourceInfo *Operand</argument>, <argument>MSGuidDecl *Guid</argument>,
<argument>SourceRange R</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>CXXUuidofExprClass</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>VK_LValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Operand</name><argument_list>(<argument><expr><name>Operand</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Guid</name><argument_list>(<argument><expr><name>Guid</name></expr></argument>)</argument_list></call></expr>, <macro><name>Range</name><argument_list>(<argument>R</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>CXXUuidofExpr</name><argument_list>(<argument>QualType Ty</argument>, <argument>Expr *Operand</argument>, <argument>MSGuidDecl *Guid</argument>, <argument>SourceRange R</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>CXXUuidofExprClass</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>VK_LValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Operand</name><argument_list>(<argument><expr><name>Operand</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Guid</name><argument_list>(<argument><expr><name>Guid</name></expr></argument>)</argument_list></call></expr>, <macro><name>Range</name><argument_list>(<argument>R</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>CXXUuidofExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>bool isExpr</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CXXUuidofExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>isExpr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Operand</name> <operator>=</operator> <operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator><name>nullptr</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>Operand</name> <operator>=</operator> <operator>(</operator><name>TypeSourceInfo</name><operator>*</operator><operator>)</operator><name>nullptr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
}</block>

<name>bool</name> <macro><name>isTypeOperand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Operand</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>TypeSourceInfo</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block>



<name>QualType</name> <macro><name>getTypeOperand</name><argument_list>(<argument>ASTContext &amp;Context</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeOperandSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isTypeOperand</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Cannot call getTypeOperand for __uuidof(expr)"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>Operand</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>TypeSourceInfo</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>
<name>Expr</name> <operator>*</operator><macro><name>getExprOperand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isTypeOperand</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Cannot call getExprOperand for __uuidof(type)"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>Operand</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>Stmt</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>MSGuidDecl</name> <operator>*</operator><macro><name>getGuidDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Guid</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Range</name></expr>;</return> }</block>
<name>void</name> <macro><name>setSourceRange</name><argument_list>(<argument>SourceRange R</argument>)</argument_list></macro> <block>{ <expr><name>Range</name> <operator>=</operator> <name>R</name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXUuidofExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isTypeOperand</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<name>auto</name> <operator>*</operator><operator>*</operator><name>begin</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Operand</name></expr></argument>)</argument_list></call></block></expr>;
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>begin</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isTypeOperand</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<name>auto</name> <operator>*</operator><operator>*</operator><name>begin</name> <operator>=</operator>
<call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXUuidofExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>Operand</name></expr></argument>)</argument_list></call></block></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>begin</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;













<expr><name>class</name> <name>CXXThisExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>CXXThisExpr</name><argument_list>(<argument>SourceLocation L</argument>, <argument>QualType Ty</argument>, <argument>bool IsImplicit</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CXXThisExprClass</argument>, <argument>Ty</argument>, <argument>VK_PRValue</argument>, <argument>OK_Ordinary</argument>)</argument_list></macro> <block>{
<expr><name><name>CXXThisExprBits</name><operator>.</operator><name>IsImplicit</name></name> <operator>=</operator> <name>IsImplicit</name></expr>;
<expr><name><name>CXXThisExprBits</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>L</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>CXXThisExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CXXThisExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXThisExprBits</name><operator>.</operator><name>Loc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setLocation</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>CXXThisExprBits</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>isImplicit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXThisExprBits</name><operator>.</operator><name>IsImplicit</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setImplicit</name><argument_list>(<argument>bool I</argument>)</argument_list></macro> <block>{ <expr><name><name>CXXThisExprBits</name><operator>.</operator><name>IsImplicit</name></name> <operator>=</operator> <name>I</name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXThisExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;






<expr><name>class</name> <name>CXXThrowExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>Operand</name></expr>;

<expr><name>public</name><operator>:</operator>




<macro><name>CXXThrowExpr</name><argument_list>(<argument>Expr *Operand</argument>, <argument>QualType Ty</argument>, <argument>SourceLocation Loc</argument>,
<argument>bool IsThrownVariableInScope</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>CXXThrowExprClass</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <macro><name>Operand</name><argument_list>(<argument>Operand</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CXXThrowExprBits</name><operator>.</operator><name>ThrowLoc</name></name> <operator>=</operator> <name>Loc</name></expr>;
<expr><name><name>CXXThrowExprBits</name><operator>.</operator><name>IsThrownVariableInScope</name></name> <operator>=</operator> <name>IsThrownVariableInScope</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>
<macro><name>CXXThrowExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CXXThrowExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Operand</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Operand</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getThrowLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXThrowExprBits</name><operator>.</operator><name>ThrowLoc</name></name></expr>;</return> }</block>






<name>bool</name> <macro><name>isThrownVariableInScope</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CXXThrowExprBits</name><operator>.</operator><name>IsThrownVariableInScope</name></name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getThrowLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getSubExpr</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getThrowLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getSubExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXThrowExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Operand</name></expr></argument>, <argument><expr><name>Operand</name> <operator>?</operator> <operator>&amp;</operator><name>Operand</name> <operator>+</operator> <literal type="number">1</literal> <operator>:</operator> <operator>&amp;</operator><name>Operand</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Operand</name></expr></argument>, <argument><expr><ternary><condition><expr><name>Operand</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>Operand</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><operator>&amp;</operator><name>Operand</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;






<expr><name>class</name> <name>CXXDefaultArgExpr</name> <name>final</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;


<expr><name>ParmVarDecl</name> <operator>*</operator><name>Param</name></expr>;


<expr><name>DeclContext</name> <operator>*</operator><name>UsedContext</name></expr>;

<macro><name>CXXDefaultArgExpr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>SourceLocation Loc</argument>, <argument>ParmVarDecl *Param</argument>,
<argument>DeclContext *UsedContext</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Expr</name><argument_list>(<argument><expr><name>SC</name></expr></argument>,
<argument><expr><ternary><condition><expr><call><name><name>Param</name><operator>-&gt;</operator><name>hasUnparsedDefaultArg</name></name><argument_list>()</argument_list></call></expr>
?</condition><then> <expr><call><name><name>Param</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getNonReferenceType</name><argument_list>()</argument_list></call></expr>
</then><else>: <expr><call><name><name>Param</name><operator>-&gt;</operator><name>getDefaultArg</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>,
<argument><expr><call><name><name>Param</name><operator>-&gt;</operator><name>getDefaultArg</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueKind</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Param</name><operator>-&gt;</operator><name>getDefaultArg</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getObjectKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Param</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>, <macro><name>UsedContext</name><argument_list>(<argument>UsedContext</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CXXDefaultArgExprBits</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>Loc</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<macro><name>CXXDefaultArgExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CXXDefaultArgExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>



<specifier>static</specifier> <name>CXXDefaultArgExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation Loc</argument>,
<argument>ParmVarDecl *Param</argument>,
<argument>DeclContext *UsedContext</argument>)</argument_list></macro> <block>{
<return>return <macro><name>new</name> <argument_list>(<argument>C</argument>)</argument_list></macro>
<expr><call><name>CXXDefaultArgExpr</name><argument_list>(<argument><expr><name>CXXDefaultArgExprClass</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>, <argument><expr><name>UsedContext</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<specifier>const</specifier> <name>ParmVarDecl</name> <operator>*</operator><macro><name>getParam</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Param</name></expr>;</return> }</block>
<name>ParmVarDecl</name> <operator>*</operator><macro><name>getParam</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Param</name></expr>;</return> }</block>


<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getParam</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getDefaultArg</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>Expr</name> <operator>*</operator><macro><name>getExpr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>getParam</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getDefaultArg</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>getUsedContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>UsedContext</name></expr>;</return> }</block>
<name>DeclContext</name> <operator>*</operator><macro><name>getUsedContext</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>UsedContext</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getUsedLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXDefaultArgExprBits</name><operator>.</operator><name>Loc</name></name></expr>;</return> }</block>



<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getExprLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getUsedLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXDefaultArgExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>CXXDefaultInitExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;


<expr><name>FieldDecl</name> <operator>*</operator><name>Field</name></expr>;


<expr><name>DeclContext</name> <operator>*</operator><name>UsedContext</name></expr>;

<macro><name>CXXDefaultInitExpr</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>SourceLocation Loc</argument>,
<argument>FieldDecl *Field</argument>, <argument>QualType Ty</argument>, <argument>DeclContext *UsedContext</argument>)</argument_list></macro>;

<macro><name>CXXDefaultInitExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CXXDefaultInitExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>


<specifier>static</specifier> <name>CXXDefaultInitExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>SourceLocation Loc</argument>,
<argument>FieldDecl *Field</argument>, <argument>DeclContext *UsedContext</argument>)</argument_list></macro> <block>{
<return>return <macro><name>new</name> <argument_list>(<argument>Ctx</argument>)</argument_list></macro> <expr><call><name>CXXDefaultInitExpr</name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Field</name></expr></argument>, <argument><expr><call><name><name>Field</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>UsedContext</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>FieldDecl</name> <operator>*</operator><macro><name>getField</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Field</name></expr>;</return> }</block>
<specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><macro><name>getField</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Field</name></expr>;</return> }</block>


<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Field</name><operator>-&gt;</operator><name>getInClassInitializer</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"initializer hasn't been parsed"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Field</name><operator>-&gt;</operator><name>getInClassInitializer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>Expr</name> <operator>*</operator><macro><name>getExpr</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Field</name><operator>-&gt;</operator><name>getInClassInitializer</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"initializer hasn't been parsed"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Field</name><operator>-&gt;</operator><name>getInClassInitializer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>getUsedContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>UsedContext</name></expr>;</return> }</block>
<name>DeclContext</name> <operator>*</operator><macro><name>getUsedContext</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>UsedContext</name></expr>;</return> }</block>



<name>SourceLocation</name> <macro><name>getUsedLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXDefaultInitExprBits</name><operator>.</operator><name>Loc</name></name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXDefaultInitExprBits</name><operator>.</operator><name>Loc</name></name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXDefaultInitExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>CXXTemporary</name> <block>{

<expr><specifier>const</specifier> <name>CXXDestructorDecl</name> <operator>*</operator><name>Destructor</name></expr>;

<expr><name>explicit</name> <call><name>CXXTemporary</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXDestructorDecl</name> <operator>*</operator><name>destructor</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>Destructor</name><argument_list>(<argument>destructor</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>CXXTemporary</name> <operator>*</operator><call><name>Create</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CXXDestructorDecl</name> <operator>*</operator><name>Destructor</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>const</specifier> <name>CXXDestructorDecl</name> <operator>*</operator><macro><name>getDestructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Destructor</name></expr>;</return> }</block>

<name>void</name> <macro><name>setDestructor</name><argument_list>(<argument>const CXXDestructorDecl *Dtor</argument>)</argument_list></macro> <block>{
<expr><name>Destructor</name> <operator>=</operator> <name>Dtor</name></expr>;
}</block>
}</expr>;















<expr><name>class</name> <name>CXXBindTemporaryExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>CXXTemporary</name> <operator>*</operator><name>Temp</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>Stmt</name> <operator>*</operator><name>SubExpr</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><call><name>CXXBindTemporaryExpr</name><argument_list>(<argument><expr><name>CXXTemporary</name> <operator>*</operator><name>temp</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>SubExpr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>CXXBindTemporaryExprClass</name></expr></argument>, <argument><expr><call><name><name>SubExpr</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>,
<argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Temp</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>, <macro><name>SubExpr</name><argument_list>(<argument>SubExpr</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<macro><name>CXXBindTemporaryExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CXXBindTemporaryExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<specifier>static</specifier> <name>CXXBindTemporaryExpr</name> <operator>*</operator><call><name>Create</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>CXXTemporary</name> <operator>*</operator><name>Temp</name></expr></argument>,
<argument><expr><name>Expr</name><operator>*</operator> <name>SubExpr</name></expr></argument>)</argument_list></call></expr>;

<expr><name>CXXTemporary</name> <operator>*</operator><macro><name>getTemporary</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Temp</name></expr>;</return> }</block>
<specifier>const</specifier> <name>CXXTemporary</name> <operator>*</operator><macro><name>getTemporary</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Temp</name></expr>;</return> }</block>
<name>void</name> <macro><name>setTemporary</name><argument_list>(<argument>CXXTemporary *T</argument>)</argument_list></macro> <block>{ <expr><name>Temp</name> <operator>=</operator> <name>T</name></expr>; }</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SubExpr</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SubExpr</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setSubExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>SubExpr</name> <operator>=</operator> <name>E</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>SubExpr</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>SubExpr</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXBindTemporaryExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubExpr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubExpr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>CXXConstructExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>public</name><operator>:</operator>
enum <name>ConstructionKind</name> <block>{
<expr><name>CK_Complete</name></expr>,
<expr><name>CK_NonVirtualBase</name></expr>,
<expr><name>CK_VirtualBase</name></expr>,
<expr><name>CK_Delegating</name></expr>
}</block></expr>;

<expr><name>private</name><operator>:</operator>

<name>CXXConstructorDecl</name> <operator>*</operator><name>Constructor</name></expr>;

<expr><name>SourceRange</name> <name>ParenOrBraceRange</name></expr>;


<expr><name>unsigned</name> <name>NumArgs</name></expr>;

















<expr><specifier>inline</specifier> <name>Stmt</name> <operator>*</operator><operator>*</operator><call><name>getTrailingArgs</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><macro><name>getTrailingArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getTrailingArgs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>protected</name><operator>:</operator>

<macro><name>CXXConstructExpr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>QualType Ty</argument>, <argument>SourceLocation Loc</argument>,
<argument>CXXConstructorDecl *Ctor</argument>, <argument>bool Elidable</argument>,
<argument>ArrayRef&lt;Expr *&gt; Args</argument>, <argument>bool HadMultipleCandidates</argument>,
<argument>bool ListInitialization</argument>, <argument>bool StdInitListInitialization</argument>,
<argument>bool ZeroInitialization</argument>, <argument>ConstructionKind ConstructKind</argument>,
<argument>SourceRange ParenOrBraceRange</argument>)</argument_list></macro></expr>;


<macro><name>CXXConstructExpr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>EmptyShell Empty</argument>, <argument>unsigned NumArgs</argument>)</argument_list></macro>;



<expr><specifier>static</specifier> <name>unsigned</name> <macro><name>sizeOfTrailingObjects</name><argument_list>(<argument>unsigned NumArgs</argument>)</argument_list></macro> <block>{
<return>return <expr><name>NumArgs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</return>
}</block>

<name>public</name><operator>:</operator>

<specifier>static</specifier> <name>CXXConstructExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>QualType Ty</argument>, <argument>SourceLocation Loc</argument>,
<argument>CXXConstructorDecl *Ctor</argument>, <argument>bool Elidable</argument>, <argument>ArrayRef&lt;Expr *&gt; Args</argument>,
<argument>bool HadMultipleCandidates</argument>, <argument>bool ListInitialization</argument>,
<argument>bool StdInitListInitialization</argument>, <argument>bool ZeroInitialization</argument>,
<argument>ConstructionKind ConstructKind</argument>, <argument>SourceRange ParenOrBraceRange</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>CXXConstructExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>unsigned NumArgs</argument>)</argument_list></macro></expr>;


<expr><name>CXXConstructorDecl</name> <operator>*</operator><macro><name>getConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Constructor</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXConstructExprBits</name><operator>.</operator><name>Loc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setLocation</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name><name>CXXConstructExprBits</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>bool</name> <macro><name>isElidable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXConstructExprBits</name><operator>.</operator><name>Elidable</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setElidable</name><argument_list>(<argument>bool E</argument>)</argument_list></macro> <block>{ <expr><name><name>CXXConstructExprBits</name><operator>.</operator><name>Elidable</name></name> <operator>=</operator> <name>E</name></expr>; }</block>



<name>bool</name> <macro><name>hadMultipleCandidates</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CXXConstructExprBits</name><operator>.</operator><name>HadMultipleCandidates</name></name></expr>;</return>
}</block>
<name>void</name> <macro><name>setHadMultipleCandidates</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{
<expr><name><name>CXXConstructExprBits</name><operator>.</operator><name>HadMultipleCandidates</name></name> <operator>=</operator> <name>V</name></expr>;
}</block>


<name>bool</name> <macro><name>isListInitialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CXXConstructExprBits</name><operator>.</operator><name>ListInitialization</name></name></expr>;</return>
}</block>
<name>void</name> <macro><name>setListInitialization</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{
<expr><name><name>CXXConstructExprBits</name><operator>.</operator><name>ListInitialization</name></name> <operator>=</operator> <name>V</name></expr>;
}</block>





<name>bool</name> <macro><name>isStdInitListInitialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CXXConstructExprBits</name><operator>.</operator><name>StdInitListInitialization</name></name></expr>;</return>
}</block>
<name>void</name> <macro><name>setStdInitListInitialization</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{
<expr><name><name>CXXConstructExprBits</name><operator>.</operator><name>StdInitListInitialization</name></name> <operator>=</operator> <name>V</name></expr>;
}</block>



<name>bool</name> <macro><name>requiresZeroInitialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CXXConstructExprBits</name><operator>.</operator><name>ZeroInitialization</name></name></expr>;</return>
}</block>
<name>void</name> <macro><name>setRequiresZeroInitialization</name><argument_list>(<argument>bool ZeroInit</argument>)</argument_list></macro> <block>{
<expr><name><name>CXXConstructExprBits</name><operator>.</operator><name>ZeroInitialization</name></name> <operator>=</operator> <name>ZeroInit</name></expr>;
}</block>



<name>ConstructionKind</name> <macro><name>getConstructionKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ConstructionKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>CXXConstructExprBits</name><operator>.</operator><name>ConstructionKind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>setConstructionKind</name><argument_list>(<argument>ConstructionKind CK</argument>)</argument_list></macro> <block>{
<expr><name><name>CXXConstructExprBits</name><operator>.</operator><name>ConstructionKind</name></name> <operator>=</operator> <name>CK</name></expr>;
}</block>

<name>using</name> <name>arg_iterator</name> <operator>=</operator> <name>ExprIterator</name></expr>;
<expr><name>using</name> <name>const_arg_iterator</name> <operator>=</operator> <name>ConstExprIterator</name></expr>;
<expr><name>using</name> <name>arg_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>arg_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>const_arg_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_arg_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>arg_range</name> <macro><name>arguments</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>arg_range</name><argument_list>(<argument><expr><call><name>arg_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>arg_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>const_arg_range</name> <macro><name>arguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_arg_range</name><argument_list>(<argument><expr><call><name>arg_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>arg_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>arg_iterator</name> <macro><name>arg_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>getTrailingArgs</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>arg_iterator</name> <macro><name>arg_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>arg_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_arg_iterator</name> <macro><name>arg_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTrailingArgs</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_arg_iterator</name> <macro><name>arg_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>arg_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><operator>*</operator><macro><name>getArgs</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getTrailingArgs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><macro><name>getArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getTrailingArgs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumArgs</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getArg</name><argument_list>(<argument>unsigned Arg</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Arg</name> <operator>&lt;</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Arg access out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getArgs</name><argument_list>()</argument_list></call><index>[<expr><name>Arg</name></expr>]</index></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getArg</name><argument_list>(<argument>unsigned Arg</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Arg</name> <operator>&lt;</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Arg access out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getArgs</name><argument_list>()</argument_list></call><index>[<expr><name>Arg</name></expr>]</index></expr>;</return>
}</block>


<name>void</name> <macro><name>setArg</name><argument_list>(<argument>unsigned Arg</argument>, <argument>Expr *ArgExpr</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Arg</name> <operator>&lt;</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Arg access out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getArgs</name><argument_list>()</argument_list></call><index>[<expr><name>Arg</name></expr>]</index> <operator>=</operator> <name>ArgExpr</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;
<expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;
<expr><name>SourceRange</name> <macro><name>getParenOrBraceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ParenOrBraceRange</name></expr>;</return> }</block>
<name>void</name> <macro><name>setParenOrBraceRange</name><argument_list>(<argument>SourceRange Range</argument>)</argument_list></macro> <block>{ <expr><name>ParenOrBraceRange</name> <operator>=</operator> <name>Range</name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXConstructExprClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXTemporaryObjectExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>getTrailingArgs</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getTrailingArgs</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;





<expr><name>class</name> <name>CXXInheritedCtorInitExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>private</name><operator>:</operator>
<name>CXXConstructorDecl</name> <operator>*</operator><name>Constructor</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>SourceLocation</name> <name>Loc</name></expr>;


<expr><name>unsigned</name> <name>ConstructsVirtualBase</name> <operator>:</operator> <literal type="number">1</literal></expr>;



<expr><name>unsigned</name> <name>InheritedFromVirtualBase</name> <operator>:</operator> <literal type="number">1</literal></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;


<macro><name>CXXInheritedCtorInitExpr</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>QualType T</argument>,
<argument>CXXConstructorDecl *Ctor</argument>, <argument>bool ConstructsVirtualBase</argument>,
<argument>bool InheritedFromVirtualBase</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Expr</name><argument_list>(<argument><expr><name>CXXInheritedCtorInitExprClass</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Constructor</name><argument_list>(<argument><expr><name>Ctor</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Loc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ConstructsVirtualBase</name><argument_list>(<argument><expr><name>ConstructsVirtualBase</name></expr></argument>)</argument_list></call></expr>,
<macro><name>InheritedFromVirtualBase</name><argument_list>(<argument>InheritedFromVirtualBase</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>T</name><operator>-&gt;</operator><name>isDependentType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><name>ExprDependence</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>CXXInheritedCtorInitExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>CXXInheritedCtorInitExprClass</name></expr></argument>, <argument><expr><name>Empty</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ConstructsVirtualBase</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>, <macro><name>InheritedFromVirtualBase</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>


<name>CXXConstructorDecl</name> <operator>*</operator><macro><name>getConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Constructor</name></expr>;</return> }</block>



<name>bool</name> <macro><name>constructsVBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ConstructsVirtualBase</name></expr>;</return> }</block>
<name>CXXConstructExpr</name><operator>::</operator><name>ConstructionKind</name> <macro><name>getConstructionKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><name>ConstructsVirtualBase</name></expr> ?</condition><then> <expr><name>CXXConstructExpr</name><operator>::</operator><name>CK_VirtualBase</name></expr>
</then><else>: <expr><name>CXXConstructExpr</name><operator>::</operator><name>CK_NonVirtualBase</name></expr></else></ternary></expr>;</return>
}</block>





<name>bool</name> <macro><name>inheritedFromVBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>InheritedFromVirtualBase</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXInheritedCtorInitExprClass</name></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>CXXFunctionalCastExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>ExplicitCastExpr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>CXXFunctionalCastExpr</name></expr></argument>, <argument><expr><name>CXXBaseSpecifier</name> <operator>*</operator></expr></argument>,
<argument><expr><name>FPOptionsOverride</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;
<expr><name>SourceLocation</name> <name>RParenLoc</name></expr>;

<macro><name>CXXFunctionalCastExpr</name><argument_list>(<argument>QualType ty</argument>, <argument>ExprValueKind VK</argument>,
<argument>TypeSourceInfo *writtenTy</argument>, <argument>CastKind kind</argument>,
<argument>Expr *castExpr</argument>, <argument>unsigned pathSize</argument>,
<argument>FPOptionsOverride FPO</argument>, <argument>SourceLocation lParenLoc</argument>,
<argument>SourceLocation rParenLoc</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>ExplicitCastExpr</name><argument_list>(<argument><expr><name>CXXFunctionalCastExprClass</name></expr></argument>, <argument><expr><name>ty</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>castExpr</name></expr></argument>,
<argument><expr><name>pathSize</name></expr></argument>, <argument><expr><call><name><name>FPO</name><operator>.</operator><name>requiresTrailingStorage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>writtenTy</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>lParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>RParenLoc</name><argument_list>(<argument>rParenLoc</argument>)</argument_list></macro> <expr><block>{
<if_stmt><if>if <condition>(<expr><call><name>hasStoredFPFeatures</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><call><name>getTrailingFPFeatures</name><argument_list>()</argument_list></call> <operator>=</operator> <name>FPO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<name>explicit</name> <macro><name>CXXFunctionalCastExpr</name><argument_list>(<argument>EmptyShell Shell</argument>, <argument>unsigned PathSize</argument>,
<argument>bool HasFPFeatures</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>ExplicitCastExpr</name><argument_list>(<argument>CXXFunctionalCastExprClass</argument>, <argument>Shell</argument>, <argument>PathSize</argument>,
<argument>HasFPFeatures</argument>)</argument_list></macro> <block>{}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;CXXBaseSpecifier *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>path_size</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CastExpr</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;

<expr><specifier>static</specifier> <name>CXXFunctionalCastExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>QualType T</argument>, <argument>ExprValueKind VK</argument>,
<argument>TypeSourceInfo *Written</argument>, <argument>CastKind Kind</argument>, <argument>Expr *Op</argument>,
<argument>const CXXCastPath *Path</argument>, <argument>FPOptionsOverride FPO</argument>, <argument>SourceLocation LPLoc</argument>,
<argument>SourceLocation RPLoc</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>CXXFunctionalCastExpr</name> <operator>*</operator>
<macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>unsigned PathSize</argument>, <argument>bool HasFPFeatures</argument>)</argument_list></macro></expr>;

<expr><name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>


<name>bool</name> <macro><name>isListInitialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>LParenLoc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;
<expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXFunctionalCastExprClass</name></expr>;</return>
}</block>
}</expr>;
















<expr><name>class</name> <name>CXXTemporaryObjectExpr</name> <name>final</name> <operator>:</operator> <name>public</name> <name>CXXConstructExpr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;





<expr><name>TypeSourceInfo</name> <operator>*</operator><name>TSI</name></expr>;

<macro><name>CXXTemporaryObjectExpr</name><argument_list>(<argument>CXXConstructorDecl *Cons</argument>, <argument>QualType Ty</argument>,
<argument>TypeSourceInfo *TSI</argument>, <argument>ArrayRef&lt;Expr *&gt; Args</argument>,
<argument>SourceRange ParenOrBraceRange</argument>,
<argument>bool HadMultipleCandidates</argument>, <argument>bool ListInitialization</argument>,
<argument>bool StdInitListInitialization</argument>,
<argument>bool ZeroInitialization</argument>)</argument_list></macro>;

<macro><name>CXXTemporaryObjectExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>unsigned NumArgs</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>CXXTemporaryObjectExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>CXXConstructorDecl *Cons</argument>, <argument>QualType Ty</argument>,
<argument>TypeSourceInfo *TSI</argument>, <argument>ArrayRef&lt;Expr *&gt; Args</argument>,
<argument>SourceRange ParenOrBraceRange</argument>, <argument>bool HadMultipleCandidates</argument>,
<argument>bool ListInitialization</argument>, <argument>bool StdInitListInitialization</argument>,
<argument>bool ZeroInitialization</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>CXXTemporaryObjectExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>,
<argument>unsigned NumArgs</argument>)</argument_list></macro></expr>;

<expr><name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TSI</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;
<expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXTemporaryObjectExprClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>Stmt</name> <operator>*</operator><operator>*</operator><name>CXXConstructExpr</name><operator>::</operator><macro><name>getTrailingArgs</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>E</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXTemporaryObjectExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>getStmtClass</name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXConstructExprClass</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected class deriving from CXXConstructExpr!"</literal></expr></argument>)</argument_list></call></block></expr>;
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>






















<name>class</name> <name>LambdaExpr</name> <name>final</name> <operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>LambdaExpr</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{



<expr><name>SourceRange</name> <name>IntroducerRange</name></expr>;


<expr><name>SourceLocation</name> <name>CaptureDefaultLoc</name></expr>;









<expr><name>SourceLocation</name> <name>ClosingBrace</name></expr>;


<macro><name>LambdaExpr</name><argument_list>(<argument>QualType T</argument>, <argument>SourceRange IntroducerRange</argument>,
<argument>LambdaCaptureDefault CaptureDefault</argument>,
<argument>SourceLocation CaptureDefaultLoc</argument>, <argument>bool ExplicitParams</argument>,
<argument>bool ExplicitResultType</argument>, <argument>ArrayRef&lt;Expr *&gt; CaptureInits</argument>,
<argument>SourceLocation ClosingBrace</argument>, <argument>bool ContainsUnexpandedParameterPack</argument>)</argument_list></macro>;


<macro><name>LambdaExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>unsigned NumCaptures</argument>)</argument_list></macro>;

<expr><name>Stmt</name> <operator>*</operator><operator>*</operator><macro><name>getStoredStmts</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>Stmt</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><macro><name>getStoredStmts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>initBodyIfNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><specifier>static</specifier> <name>LambdaExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>CXXRecordDecl *Class</argument>, <argument>SourceRange IntroducerRange</argument>,
<argument>LambdaCaptureDefault CaptureDefault</argument>, <argument>SourceLocation CaptureDefaultLoc</argument>,
<argument>bool ExplicitParams</argument>, <argument>bool ExplicitResultType</argument>,
<argument>ArrayRef&lt;Expr *&gt; CaptureInits</argument>, <argument>SourceLocation ClosingBrace</argument>,
<argument>bool ContainsUnexpandedParameterPack</argument>)</argument_list></macro></expr>;



<expr><specifier>static</specifier> <name>LambdaExpr</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumCaptures</argument>)</argument_list></macro></expr>;


<expr><name>LambdaCaptureDefault</name> <macro><name>getCaptureDefault</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>LambdaCaptureDefault</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>LambdaExprBits</name><operator>.</operator><name>CaptureDefault</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getCaptureDefaultLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CaptureDefaultLoc</name></expr>;</return> }</block>


<name>bool</name> <macro><name>isInitCapture</name><argument_list>(<argument>const LambdaCapture *Capture</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>using</name> <name>capture_iterator</name> <operator>=</operator> <specifier>const</specifier> <name>LambdaCapture</name> <operator>*</operator></expr>;


<expr><name>using</name> <name>capture_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>capture_iterator</name></expr></argument>&gt;</argument_list></name></expr>;


<expr><name>capture_range</name> <macro><name>captures</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>capture_iterator</name> <macro><name>capture_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>capture_iterator</name> <macro><name>capture_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>unsigned</name> <macro><name>capture_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>LambdaExprBits</name><operator>.</operator><name>NumCaptures</name></name></expr>;</return> }</block>


<name>capture_range</name> <macro><name>explicit_captures</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>capture_iterator</name> <macro><name>explicit_capture_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>capture_iterator</name> <macro><name>explicit_capture_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>capture_range</name> <macro><name>implicit_captures</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>capture_iterator</name> <macro><name>implicit_capture_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>capture_iterator</name> <macro><name>implicit_capture_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>using</name> <name>capture_init_iterator</name> <operator>=</operator> <name>Expr</name> <operator>*</operator><operator>*</operator></expr>;




<expr><name>using</name> <name>const_capture_init_iterator</name> <operator>=</operator> <name>Expr</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>capture_init_iterator</name></expr></argument>&gt;</argument_list></name> <macro><name>capture_inits</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>make_range</name><argument_list>(<argument><expr><call><name>capture_init_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>capture_init_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_capture_init_iterator</name></expr></argument>&gt;</argument_list></name> <macro><name>capture_inits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>make_range</name><argument_list>(<argument><expr><call><name>capture_init_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>capture_init_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>capture_init_iterator</name> <macro><name>capture_init_begin</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getStoredStmts</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>const_capture_init_iterator</name> <macro><name>capture_init_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getStoredStmts</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>capture_init_iterator</name> <macro><name>capture_init_end</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>capture_init_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>capture_size</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>const_capture_init_iterator</name> <macro><name>capture_init_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>capture_init_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>capture_size</name><argument_list>()</argument_list></call></expr>;</return>
}</block>




<name>SourceRange</name> <macro><name>getIntroducerRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IntroducerRange</name></expr>;</return> }</block>






<name>CXXRecordDecl</name> <operator>*</operator><macro><name>getLambdaClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>CXXMethodDecl</name> <operator>*</operator><macro><name>getCallOperator</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>FunctionTemplateDecl</name> <operator>*</operator><macro><name>getDependentCallOperator</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>TemplateParameterList</name> <operator>*</operator><macro><name>getTemplateParameterList</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getExplicitTemplateParameters</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>Expr</name> <operator>*</operator><macro><name>getTrailingRequiresClause</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isGenericLambda</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTemplateParameterList</name><argument_list>()</argument_list></call></expr>;</return> }</block>





<name>Stmt</name> <operator>*</operator><macro><name>getBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><specifier>const</specifier> <name>CompoundStmt</name> <operator>*</operator><macro><name>getCompoundStmtBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>CompoundStmt</name> <operator>*</operator><macro><name>getCompoundStmtBody</name><argument_list>()</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>auto</name> <operator>*</operator><name>ConstThis</name> <operator>=</operator> <name>this</name></expr>;
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CompoundStmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>ConstThis</name><operator>-&gt;</operator><name>getCompoundStmtBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isMutable</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>hasExplicitParameters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>LambdaExprBits</name><operator>.</operator><name>ExplicitParams</name></name></expr>;</return> }</block>


<name>bool</name> <macro><name>hasExplicitResultType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>LambdaExprBits</name><operator>.</operator><name>ExplicitResultType</name></name></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>LambdaExprClass</name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>IntroducerRange</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>ClosingBrace</name></expr>;</return> }</block>


<name>child_range</name> <call><name>children</name><argument_list>()</argument_list></call></expr>;
<expr><name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr>;



<expr><name>class</name> <name>CXXScalarValueInitExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>TypeSourceInfo</name> <operator>*</operator><name>TypeInfo</name></expr>;

<expr><name>public</name><operator>:</operator>


<macro><name>CXXScalarValueInitExpr</name><argument_list>(<argument>QualType Type</argument>, <argument>TypeSourceInfo *TypeInfo</argument>,
<argument>SourceLocation RParenLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>CXXScalarValueInitExprClass</name></expr></argument>, <argument><expr><name>Type</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>,
<macro><name>TypeInfo</name><argument_list>(<argument>TypeInfo</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CXXScalarValueInitExprBits</name><operator>.</operator><name>RParenLoc</name></name> <operator>=</operator> <name>RParenLoc</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>explicit</name> <macro><name>CXXScalarValueInitExpr</name><argument_list>(<argument>EmptyShell Shell</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CXXScalarValueInitExprClass</argument>, <argument>Shell</argument>)</argument_list></macro> <block>{}</block>

<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TypeInfo</name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CXXScalarValueInitExprBits</name><operator>.</operator><name>RParenLoc</name></name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;
<expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getRParenLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXScalarValueInitExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>CXXNewExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>CXXNewExpr</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>, <argument><expr><name>SourceRange</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>FunctionDecl</name> <operator>*</operator><name>OperatorNew</name></expr>;


<expr><name>FunctionDecl</name> <operator>*</operator><name>OperatorDelete</name></expr>;


<expr><name>TypeSourceInfo</name> <operator>*</operator><name>AllocatedTypeInfo</name></expr>;


<expr><name>SourceRange</name> <name>Range</name></expr>;


<expr><name>SourceRange</name> <name>DirectInitRange</name></expr>;
















<expr><name>unsigned</name> <macro><name>arraySizeOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><literal type="number">0</literal></expr>;</return> }</block>
<name>unsigned</name> <macro><name>initExprOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>arraySizeOffset</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>isArray</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>unsigned</name> <macro><name>placementNewArgsOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>initExprOffset</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>hasInitializer</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;Stmt *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isArray</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>hasInitializer</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumPlacementArgs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;SourceRange&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isParenTypeId</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
enum <name>InitializationStyle</name> <block>{

<expr><name>NoInit</name></expr>,


<expr><name>CallInit</name></expr>,


<expr><name>ListInit</name></expr>
}</block></expr>;

<expr><name>private</name><operator>:</operator>

<macro><name>CXXNewExpr</name><argument_list>(<argument>bool IsGlobalNew</argument>, <argument>FunctionDecl *OperatorNew</argument>,
<argument>FunctionDecl *OperatorDelete</argument>, <argument>bool ShouldPassAlignment</argument>,
<argument>bool UsualArrayDeleteWantsSize</argument>, <argument>ArrayRef&lt;Expr *&gt; PlacementArgs</argument>,
<argument>SourceRange TypeIdParens</argument>, <argument>Optional&lt;Expr *&gt; ArraySize</argument>,
<argument>InitializationStyle InitializationStyle</argument>, <argument>Expr *Initializer</argument>,
<argument>QualType Ty</argument>, <argument>TypeSourceInfo *AllocatedTypeInfo</argument>, <argument>SourceRange Range</argument>,
<argument>SourceRange DirectInitRange</argument>)</argument_list></macro></expr>;


<macro><name>CXXNewExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>bool IsArray</argument>, <argument>unsigned NumPlacementArgs</argument>,
<argument>bool IsParenTypeId</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>

<specifier>static</specifier> <name>CXXNewExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>bool IsGlobalNew</argument>, <argument>FunctionDecl *OperatorNew</argument>,
<argument>FunctionDecl *OperatorDelete</argument>, <argument>bool ShouldPassAlignment</argument>,
<argument>bool UsualArrayDeleteWantsSize</argument>, <argument>ArrayRef&lt;Expr *&gt; PlacementArgs</argument>,
<argument>SourceRange TypeIdParens</argument>, <argument>Optional&lt;Expr *&gt; ArraySize</argument>,
<argument>InitializationStyle InitializationStyle</argument>, <argument>Expr *Initializer</argument>,
<argument>QualType Ty</argument>, <argument>TypeSourceInfo *AllocatedTypeInfo</argument>, <argument>SourceRange Range</argument>,
<argument>SourceRange DirectInitRange</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>CXXNewExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>bool IsArray</argument>,
<argument>bool HasInit</argument>, <argument>unsigned NumPlacementArgs</argument>,
<argument>bool IsParenTypeId</argument>)</argument_list></macro></expr>;

<expr><name>QualType</name> <macro><name>getAllocatedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>castAs</name><argument_list type="generic">&lt;<argument><expr><name>PointerType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getPointeeType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getAllocatedTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>AllocatedTypeInfo</name></expr>;</return>
}</block>
















<name>bool</name> <macro><name>shouldNullCheckAllocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>FunctionDecl</name> <operator>*</operator><macro><name>getOperatorNew</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OperatorNew</name></expr>;</return> }</block>
<name>void</name> <macro><name>setOperatorNew</name><argument_list>(<argument>FunctionDecl *D</argument>)</argument_list></macro> <block>{ <expr><name>OperatorNew</name> <operator>=</operator> <name>D</name></expr>; }</block>
<name>FunctionDecl</name> <operator>*</operator><macro><name>getOperatorDelete</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OperatorDelete</name></expr>;</return> }</block>
<name>void</name> <macro><name>setOperatorDelete</name><argument_list>(<argument>FunctionDecl *D</argument>)</argument_list></macro> <block>{ <expr><name>OperatorDelete</name> <operator>=</operator> <name>D</name></expr>; }</block>

<name>bool</name> <macro><name>isArray</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXNewExprBits</name><operator>.</operator><name>IsArray</name></name></expr>;</return> }</block>

<name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getArraySize</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isArray</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>None</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>arraySizeOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getArraySize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isArray</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>None</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>arraySizeOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumPlacementArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CXXNewExprBits</name><operator>.</operator><name>NumPlacementArgs</name></name></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><operator>*</operator><macro><name>getPlacementArgs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<call><name>placementNewArgsOffset</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getPlacementArg</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>I</name> <operator>&lt;</operator> <call><name>getNumPlacementArgs</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <literal type="string">"Index out of range!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getPlacementArgs</name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getPlacementArg</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXNewExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPlacementArg</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isParenTypeId</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXNewExprBits</name><operator>.</operator><name>IsParenTypeId</name></name></expr>;</return> }</block>
<name>SourceRange</name> <macro><name>getTypeIdParens</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isParenTypeId</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>SourceRange</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index>
<operator>:</operator> <call><name>SourceRange</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isGlobalNew</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXNewExprBits</name><operator>.</operator><name>IsGlobalNew</name></name></expr>;</return> }</block>


<name>bool</name> <macro><name>hasInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CXXNewExprBits</name><operator>.</operator><name>StoredInitializationStyle</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
}</block>


<name>InitializationStyle</name> <macro><name>getInitializationStyle</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name><name>CXXNewExprBits</name><operator>.</operator><name>StoredInitializationStyle</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NoInit</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>InitializationStyle</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name><name>CXXNewExprBits</name><operator>.</operator><name>StoredInitializationStyle</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>Expr</name> <operator>*</operator><macro><name>getInitializer</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>hasInitializer</name><argument_list>()</argument_list></call>
<operator>?</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>initExprOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call>
<operator>:</operator> <name>nullptr</name></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasInitializer</name><argument_list>()</argument_list></call></expr>
?</condition><then> <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>initExprOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>


<specifier>const</specifier> <name>CXXConstructExpr</name> <operator>*</operator><macro><name>getConstructExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getInitializer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>passAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXNewExprBits</name><operator>.</operator><name>ShouldPassAlignment</name></name></expr>;</return> }</block>




<name>bool</name> <macro><name>doesUsualArrayDeleteWantSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CXXNewExprBits</name><operator>.</operator><name>UsualArrayDeleteWantsSize</name></name></expr>;</return>
}</block>

<name>using</name> <name>arg_iterator</name> <operator>=</operator> <name>ExprIterator</name></expr>;
<expr><name>using</name> <name>const_arg_iterator</name> <operator>=</operator> <name>ConstExprIterator</name></expr>;

<expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>arg_iterator</name></expr></argument>&gt;</argument_list></name> <macro><name>placement_arguments</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>make_range</name><argument_list>(<argument><expr><call><name>placement_arg_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>placement_arg_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_arg_iterator</name></expr></argument>&gt;</argument_list></name> <macro><name>placement_arguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>make_range</name><argument_list>(<argument><expr><call><name>placement_arg_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>placement_arg_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>arg_iterator</name> <macro><name>placement_arg_begin</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>placementNewArgsOffset</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>arg_iterator</name> <macro><name>placement_arg_end</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>placement_arg_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumPlacementArgs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>const_arg_iterator</name> <macro><name>placement_arg_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>placementNewArgsOffset</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>const_arg_iterator</name> <macro><name>placement_arg_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>placement_arg_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumPlacementArgs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>raw_arg_iterator</name> <operator>=</operator> <name>Stmt</name> <operator>*</operator><operator>*</operator></expr>;

<expr><name>raw_arg_iterator</name> <macro><name>raw_arg_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>raw_arg_iterator</name> <macro><name>raw_arg_end</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>raw_arg_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>numTrailingObjects</name><argument_list>(<argument><expr><call><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_arg_iterator</name> <macro><name>raw_arg_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>const_arg_iterator</name> <macro><name>raw_arg_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>raw_arg_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>numTrailingObjects</name><argument_list>(<argument><expr><call><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceRange</name> <macro><name>getDirectInitRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DirectInitRange</name></expr>;</return> }</block>
<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Range</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXNewExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>raw_arg_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>raw_arg_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXNewExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>CXXDeleteExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;


<expr><name>FunctionDecl</name> <operator>*</operator><name>OperatorDelete</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>Argument</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>CXXDeleteExpr</name><argument_list>(<argument>QualType Ty</argument>, <argument>bool GlobalDelete</argument>, <argument>bool ArrayForm</argument>,
<argument>bool ArrayFormAsWritten</argument>, <argument>bool UsualArrayDeleteWantsSize</argument>,
<argument>FunctionDecl *OperatorDelete</argument>, <argument>Expr *Arg</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>CXXDeleteExprClass</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OperatorDelete</name><argument_list>(<argument><expr><name>OperatorDelete</name></expr></argument>)</argument_list></call></expr>, <macro><name>Argument</name><argument_list>(<argument>Arg</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CXXDeleteExprBits</name><operator>.</operator><name>GlobalDelete</name></name> <operator>=</operator> <name>GlobalDelete</name></expr>;
<expr><name><name>CXXDeleteExprBits</name><operator>.</operator><name>ArrayForm</name></name> <operator>=</operator> <name>ArrayForm</name></expr>;
<expr><name><name>CXXDeleteExprBits</name><operator>.</operator><name>ArrayFormAsWritten</name></name> <operator>=</operator> <name>ArrayFormAsWritten</name></expr>;
<expr><name><name>CXXDeleteExprBits</name><operator>.</operator><name>UsualArrayDeleteWantsSize</name></name> <operator>=</operator> <name>UsualArrayDeleteWantsSize</name></expr>;
<expr><name><name>CXXDeleteExprBits</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>Loc</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>explicit</name> <macro><name>CXXDeleteExpr</name><argument_list>(<argument>EmptyShell Shell</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CXXDeleteExprClass</argument>, <argument>Shell</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <macro><name>isGlobalDelete</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXDeleteExprBits</name><operator>.</operator><name>GlobalDelete</name></name></expr>;</return> }</block>
<name>bool</name> <macro><name>isArrayForm</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXDeleteExprBits</name><operator>.</operator><name>ArrayForm</name></name></expr>;</return> }</block>
<name>bool</name> <macro><name>isArrayFormAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CXXDeleteExprBits</name><operator>.</operator><name>ArrayFormAsWritten</name></name></expr>;</return>
}</block>





<name>bool</name> <macro><name>doesUsualArrayDeleteWantSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CXXDeleteExprBits</name><operator>.</operator><name>UsualArrayDeleteWantsSize</name></name></expr>;</return>
}</block>

<name>FunctionDecl</name> <operator>*</operator><macro><name>getOperatorDelete</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OperatorDelete</name></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getArgument</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Argument</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getArgument</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Argument</name></expr></argument>)</argument_list></call></expr>;</return> }</block>





<name>QualType</name> <macro><name>getDestroyedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXDeleteExprBits</name><operator>.</operator><name>Loc</name></name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>Argument</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXDeleteExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Argument</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Argument</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Argument</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Argument</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>PseudoDestructorTypeStorage</name> <block>{


<expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Type</name></expr>;


<expr><name>SourceLocation</name> <name>Location</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>PseudoDestructorTypeStorage</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<macro><name>PseudoDestructorTypeStorage</name><argument_list>(<argument>IdentifierInfo *II</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>II</name></expr></argument>)</argument_list></call></expr>, <macro><name>Location</name><argument_list>(<argument>Loc</argument>)</argument_list></macro> <expr><block>{}</block>

<call><name>PseudoDestructorTypeStorage</name><argument_list>(<argument><expr><name>TypeSourceInfo</name> <operator>*</operator><name>Info</name></expr></argument>)</argument_list></call></expr>;

<expr><name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Type</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>TypeSourceInfo</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>

<name>IdentifierInfo</name> <operator>*</operator><macro><name>getIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Type</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>IdentifierInfo</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Location</name></expr>;</return> }</block>
}</expr>;

























<expr><name>class</name> <name>CXXPseudoDestructorExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>Base</name> <operator>=</operator> <name>nullptr</name></expr>;



<expr><name>bool</name> <name>IsArrow</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>SourceLocation</name> <name>OperatorLoc</name></expr>;


<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;



<expr><name>TypeSourceInfo</name> <operator>*</operator><name>ScopeType</name> <operator>=</operator> <name>nullptr</name></expr>;



<expr><name>SourceLocation</name> <name>ColonColonLoc</name></expr>;


<expr><name>SourceLocation</name> <name>TildeLoc</name></expr>;



<expr><name>PseudoDestructorTypeStorage</name> <name>DestroyedType</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>CXXPseudoDestructorExpr</name><argument_list>(<argument>const ASTContext &amp;Context</argument>,
<argument>Expr *Base</argument>, <argument>bool isArrow</argument>, <argument>SourceLocation OperatorLoc</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>TypeSourceInfo *ScopeType</argument>,
<argument>SourceLocation ColonColonLoc</argument>,
<argument>SourceLocation TildeLoc</argument>,
<argument>PseudoDestructorTypeStorage DestroyedType</argument>)</argument_list></macro></expr>;

<expr><name>explicit</name> <macro><name>CXXPseudoDestructorExpr</name><argument_list>(<argument>EmptyShell Shell</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>CXXPseudoDestructorExprClass</name></expr></argument>, <argument><expr><name>Shell</name></expr></argument>)</argument_list></call></expr>, <macro><name>IsArrow</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>

<name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Base</name></expr></argument>)</argument_list></call></expr>;</return> }</block>




<name>bool</name> <macro><name>hasQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>QualifierLoc</name><operator>.</operator><name>hasQualifier</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QualifierLoc</name></expr>;</return> }</block>




<name>NestedNameSpecifier</name> <operator>*</operator><macro><name>getQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isArrow</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsArrow</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getOperatorLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OperatorLoc</name></expr>;</return> }</block>










<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getScopeTypeInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ScopeType</name></expr>;</return> }</block>



<name>SourceLocation</name> <macro><name>getColonColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColonColonLoc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getTildeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TildeLoc</name></expr>;</return> }</block>








<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getDestroyedTypeInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>DestroyedType</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>




<name>IdentifierInfo</name> <operator>*</operator><macro><name>getDestroyedTypeIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>DestroyedType</name><operator>.</operator><name>getIdentifier</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>QualType</name> <macro><name>getDestroyedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>SourceLocation</name> <macro><name>getDestroyedTypeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>DestroyedType</name><operator>.</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>void</name> <macro><name>setDestroyedType</name><argument_list>(<argument>IdentifierInfo *II</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><name>DestroyedType</name> <operator>=</operator> <call><name>PseudoDestructorTypeStorage</name><argument_list>(<argument><expr><name>II</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>void</name> <macro><name>setDestroyedType</name><argument_list>(<argument>TypeSourceInfo *Info</argument>)</argument_list></macro> <block>{
<expr><name>DestroyedType</name> <operator>=</operator> <call><name>PseudoDestructorTypeStorage</name><argument_list>(<argument><expr><name>Info</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>Base</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXPseudoDestructorExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Base</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Base</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>TypeTraitExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TypeTraitExpr</name></expr></argument>, <argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{

<expr><name>SourceLocation</name> <name>Loc</name></expr>;


<expr><name>SourceLocation</name> <name>RParenLoc</name></expr>;




<macro><name>TypeTraitExpr</name><argument_list>(<argument>QualType T</argument>, <argument>SourceLocation Loc</argument>, <argument>TypeTrait Kind</argument>,
<argument>ArrayRef&lt;TypeSourceInfo *&gt; Args</argument>,
<argument>SourceLocation RParenLoc</argument>,
<argument>bool Value</argument>)</argument_list></macro>;

<macro><name>TypeTraitExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>TypeTraitExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <expr><block>{}</block>

<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;TypeSourceInfo *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNumArgs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><specifier>static</specifier> <name>TypeTraitExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>QualType T</argument>,
<argument>SourceLocation Loc</argument>, <argument>TypeTrait Kind</argument>,
<argument>ArrayRef&lt;TypeSourceInfo *&gt; Args</argument>,
<argument>SourceLocation RParenLoc</argument>,
<argument>bool Value</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>TypeTraitExpr</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumArgs</argument>)</argument_list></macro></expr>;


<expr><name>TypeTrait</name> <macro><name>getTrait</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TypeTrait</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>TypeTraitExprBits</name><operator>.</operator><name>Kind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>getValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isValueDependent</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>TypeTraitExprBits</name><operator>.</operator><name>Value</name></name></expr>;</return>
}</block>


<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>TypeTraitExprBits</name><operator>.</operator><name>NumArgs</name></name></expr>;</return> }</block>


<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getArg</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Argument out-of-range"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getArgs</name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index></expr>;</return>
}</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getNumArgs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>TypeTraitExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>ArrayTypeTraitExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{

<expr><name>unsigned</name> <name>ATT</name> <operator>:</operator> <literal type="number">2</literal></expr>;


<expr><name>uint64_t</name> <name>Value</name> <operator>=</operator> <literal type="number">0</literal></expr>;


<expr><name>Expr</name> <operator>*</operator><name>Dimension</name></expr>;


<expr><name>SourceLocation</name> <name>Loc</name></expr>;


<expr><name>SourceLocation</name> <name>RParen</name></expr>;


<expr><name>TypeSourceInfo</name> <operator>*</operator><name>QueriedType</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<macro><name>ArrayTypeTraitExpr</name><argument_list>(<argument>SourceLocation loc</argument>, <argument>ArrayTypeTrait att</argument>,
<argument>TypeSourceInfo *queried</argument>, <argument>uint64_t value</argument>, <argument>Expr *dimension</argument>,
<argument>SourceLocation rparen</argument>, <argument>QualType ty</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Expr</name><argument_list>(<argument><expr><name>ArrayTypeTraitExprClass</name></expr></argument>, <argument><expr><name>ty</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ATT</name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Value</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Dimension</name><argument_list>(<argument><expr><name>dimension</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Loc</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>RParen</name><argument_list>(<argument><expr><name>rparen</name></expr></argument>)</argument_list></call></expr>,
<macro><name>QueriedType</name><argument_list>(<argument>queried</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>att</name> <operator>&lt;=</operator> <name>ATT_Last</name> <operator>&amp;&amp;</operator> <literal type="string">"invalid enum value!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>att</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ATT</name> <operator>&amp;&amp;</operator> <literal type="string">"ATT overflow!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>explicit</name> <macro><name>ArrayTypeTraitExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ArrayTypeTraitExprClass</name></expr></argument>, <argument><expr><name>Empty</name></expr></argument>)</argument_list></call></expr>, <macro><name>ATT</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro> <expr><block>{}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParen</name></expr>;</return> }</block>

<name>ArrayTypeTrait</name> <macro><name>getTrait</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ArrayTypeTrait</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ATT</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>QualType</name> <macro><name>getQueriedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>QueriedType</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getQueriedTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QueriedType</name></expr>;</return> }</block>

<name>uint64_t</name> <macro><name>getValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isTypeDependent</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>; <return>return <expr><name>Value</name></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getDimensionExpression</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Dimension</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ArrayTypeTraitExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>ExpressionTraitExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{

<expr><name>unsigned</name> <name>ET</name> <operator>:</operator> <literal type="number">31</literal></expr>;


<expr><name>unsigned</name> <name>Value</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>SourceLocation</name> <name>Loc</name></expr>;


<expr><name>SourceLocation</name> <name>RParen</name></expr>;


<expr><name>Expr</name><operator>*</operator> <name>QueriedExpression</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<macro><name>ExpressionTraitExpr</name><argument_list>(<argument>SourceLocation loc</argument>, <argument>ExpressionTrait et</argument>, <argument>Expr *queried</argument>,
<argument>bool value</argument>, <argument>SourceLocation rparen</argument>, <argument>QualType resultType</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Expr</name><argument_list>(<argument><expr><name>ExpressionTraitExprClass</name></expr></argument>, <argument><expr><name>resultType</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ET</name><argument_list>(<argument><expr><name>et</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Value</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Loc</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>RParen</name><argument_list>(<argument><expr><name>rparen</name></expr></argument>)</argument_list></call></expr>,
<macro><name>QueriedExpression</name><argument_list>(<argument>queried</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>et</name> <operator>&lt;=</operator> <name>ET_Last</name> <operator>&amp;&amp;</operator> <literal type="string">"invalid enum value!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>et</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ET</name> <operator>&amp;&amp;</operator> <literal type="string">"ET overflow!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>explicit</name> <macro><name>ExpressionTraitExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>ExpressionTraitExprClass</name></expr></argument>, <argument><expr><name>Empty</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ET</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>, <macro><name>Value</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParen</name></expr>;</return> }</block>

<name>ExpressionTrait</name> <macro><name>getTrait</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExpressionTrait</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ET</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getQueriedExpression</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QueriedExpression</name></expr>;</return> }</block>

<name>bool</name> <macro><name>getValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Value</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ExpressionTraitExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>OverloadExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;


<expr><name>DeclarationNameInfo</name> <name>NameInfo</name></expr>;


<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>OverloadExpr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>const ASTContext &amp;Context</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>SourceLocation TemplateKWLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>,
<argument>const TemplateArgumentListInfo *TemplateArgs</argument>,
<argument>UnresolvedSetIterator Begin</argument>, <argument>UnresolvedSetIterator End</argument>,
<argument>bool KnownDependent</argument>, <argument>bool KnownInstantiationDependent</argument>,
<argument>bool KnownContainsUnexpandedParameterPack</argument>)</argument_list></macro></expr>;

<macro><name>OverloadExpr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>EmptyShell Empty</argument>, <argument>unsigned NumResults</argument>,
<argument>bool HasTemplateKWAndArgsInfo</argument>)</argument_list></macro>;


<expr><specifier>inline</specifier> <name>DeclAccessPair</name> <operator>*</operator><call><name>getTrailingResults</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>DeclAccessPair</name> <operator>*</operator><macro><name>getTrailingResults</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OverloadExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getTrailingResults</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<specifier>inline</specifier> <name>ASTTemplateKWAndArgsInfo</name> <operator>*</operator><call><name>getTrailingASTTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>ASTTemplateKWAndArgsInfo</name> <operator>*</operator><macro><name>getTrailingASTTemplateKWAndArgsInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OverloadExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>getTrailingASTTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<specifier>inline</specifier> <name>TemplateArgumentLoc</name> <operator>*</operator><call><name>getTrailingTemplateArgumentLoc</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>TemplateArgumentLoc</name> <operator>*</operator><macro><name>getTrailingTemplateArgumentLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OverloadExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getTrailingTemplateArgumentLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>OverloadExprBits</name><operator>.</operator><name>HasTemplateKWAndArgsInfo</name></name></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
struct <name>FindResult</name> <block>{
<expr><name>OverloadExpr</name> <operator>*</operator><name>Expression</name></expr>;
<expr><name>bool</name> <name>IsAddressOfOperand</name></expr>;
<expr><name>bool</name> <name>HasFormOfMemberPointer</name></expr>;
}</block></expr>;






<expr><specifier>static</specifier> <name>FindResult</name> <macro><name>find</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isSpecificBuiltinType</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>Overload</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

<expr><name>FindResult</name> <name>Result</name></expr>;

<expr><name>E</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>IgnoreParens</name></name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>UnaryOperator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UnaryOperator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getOpcode</name><argument_list>()</argument_list></call> <operator>==</operator> <name>UO_AddrOf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>E</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UnaryOperator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getSubExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>Ovl</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>OverloadExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>IgnoreParens</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>HasFormOfMemberPointer</name></name> <operator>=</operator> <operator>(</operator><name>E</name> <operator>==</operator> <name>Ovl</name> <operator>&amp;&amp;</operator> <call><name><name>Ovl</name><operator>-&gt;</operator><name>getQualifier</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>IsAddressOfOperand</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>Expression</name></name> <operator>=</operator> <name>Ovl</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content> else <block>{<block_content>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>HasFormOfMemberPointer</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>IsAddressOfOperand</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>Expression</name></name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>OverloadExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>

return Result</block></block><empty_stmt>;</empty_stmt></if></if_stmt>
}</block>



<specifier>inline</specifier> <name>CXXRecordDecl</name> <operator>*</operator><call><name>getNamingClass</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><macro><name>getNamingClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OverloadExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getNamingClass</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>decls_iterator</name> <operator>=</operator> <name>UnresolvedSetImpl</name><operator>::</operator><name>iterator</name></expr>;

<expr><name>decls_iterator</name> <macro><name>decls_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>UnresolvedSetIterator</name><argument_list>(<argument><expr><call><name>getTrailingResults</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>decls_iterator</name> <macro><name>decls_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>UnresolvedSetIterator</name><argument_list>(<argument><expr><call><name>getTrailingResults</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumDecls</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>decls_iterator</name></expr></argument>&gt;</argument_list></name> <macro><name>decls</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>make_range</name><argument_list>(<argument><expr><call><name>decls_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>decls_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>unsigned</name> <macro><name>getNumDecls</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>OverloadExprBits</name><operator>.</operator><name>NumResults</name></name></expr>;</return> }</block>


<specifier>const</specifier> <name>DeclarationNameInfo</name> <operator>&amp;</operator><macro><name>getNameInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NameInfo</name></expr>;</return> }</block>


<name>DeclarationName</name> <macro><name>getName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>NameInfo</name><operator>.</operator><name>getLoc</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>NestedNameSpecifier</name> <operator>*</operator><macro><name>getQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QualifierLoc</name></expr>;</return> }</block>



<name>SourceLocation</name> <macro><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getTrailingASTTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TemplateKWLoc</name></expr>;</return>
}</block>



<name>SourceLocation</name> <macro><name>getLAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getTrailingASTTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LAngleLoc</name></expr>;</return>
}</block>



<name>SourceLocation</name> <macro><name>getRAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getTrailingASTTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RAngleLoc</name></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasTemplateKeyword</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>bool</name> <macro><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLAngleLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>TemplateArgumentLoc</name> <specifier>const</specifier> <operator>*</operator><macro><name>getTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OverloadExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getTrailingTemplateArgumentLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name>getTrailingASTTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NumTemplateArgs</name></expr>;</return>
}</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name> <macro><name>template_arguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><call><name>getTemplateArgs</name><argument_list>()</argument_list></call></expr>, <macro><name>getNumTemplateArgs</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block>


<name>void</name> <macro><name>copyTemplateArgumentsInto</name><argument_list>(<argument>TemplateArgumentListInfo &amp;List</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>getTrailingASTTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>copyInto</name><argument_list>(<argument><expr><call><name>getTemplateArgs</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>UnresolvedLookupExprClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>UnresolvedMemberExprClass</name></expr>;</return>
}</block>
}</expr>;












<expr><name>class</name> <name>UnresolvedLookupExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>OverloadExpr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedLookupExpr</name></expr></argument>, <argument><expr><name>DeclAccessPair</name></expr></argument>,
<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>,
<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OverloadExpr</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;




<expr><name>CXXRecordDecl</name> <operator>*</operator><name>NamingClass</name></expr>;















<macro><name>UnresolvedLookupExpr</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>CXXRecordDecl *NamingClass</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>SourceLocation TemplateKWLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>, <argument>bool RequiresADL</argument>,
<argument>bool Overloaded</argument>,
<argument>const TemplateArgumentListInfo *TemplateArgs</argument>,
<argument>UnresolvedSetIterator Begin</argument>, <argument>UnresolvedSetIterator End</argument>)</argument_list></macro>;

<macro><name>UnresolvedLookupExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>unsigned NumResults</argument>,
<argument>bool HasTemplateKWAndArgsInfo</argument>)</argument_list></macro>;

<expr><name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;DeclAccessPair&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNumDecls</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;ASTTemplateKWAndArgsInfo&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>UnresolvedLookupExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>CXXRecordDecl *NamingClass</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>, <argument>bool RequiresADL</argument>, <argument>bool Overloaded</argument>,
<argument>UnresolvedSetIterator Begin</argument>, <argument>UnresolvedSetIterator End</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>UnresolvedLookupExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>CXXRecordDecl *NamingClass</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>, <argument>SourceLocation TemplateKWLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>, <argument>bool RequiresADL</argument>,
<argument>const TemplateArgumentListInfo *Args</argument>, <argument>UnresolvedSetIterator Begin</argument>,
<argument>UnresolvedSetIterator End</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>UnresolvedLookupExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Context</argument>,
<argument>unsigned NumResults</argument>,
<argument>bool HasTemplateKWAndArgsInfo</argument>,
<argument>unsigned NumTemplateArgs</argument>)</argument_list></macro></expr>;



<expr><name>bool</name> <macro><name>requiresADL</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>UnresolvedLookupExprBits</name><operator>.</operator><name>RequiresADL</name></name></expr>;</return> }</block>


<name>bool</name> <macro><name>isOverloaded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>UnresolvedLookupExprBits</name><operator>.</operator><name>Overloaded</name></name></expr>;</return> }</block>




<name>CXXRecordDecl</name> <operator>*</operator><macro><name>getNamingClass</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>NamingClass</name></expr>;</return> }</block>
<specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><macro><name>getNamingClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NamingClass</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<decl><type><name>NestedNameSpecifierLoc</name></type> <name>l</name> <init>= <expr><call><name>getQualifierLoc</name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>l</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getNameInfo</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getRAngleLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getNameInfo</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>UnresolvedLookupExprClass</name></expr>;</return>
}</block>
}</expr>;















<expr><name>class</name> <name>DependentScopeDeclRefExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>DependentScopeDeclRefExpr</name></expr></argument>,
<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>,
<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;



<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;


<expr><name>DeclarationNameInfo</name> <name>NameInfo</name></expr>;

<macro><name>DependentScopeDeclRefExpr</name><argument_list>(<argument>QualType Ty</argument>, <argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>SourceLocation TemplateKWLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>,
<argument>const TemplateArgumentListInfo *Args</argument>)</argument_list></macro>;

<expr><name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;ASTTemplateKWAndArgsInfo&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>DependentScopeDeclRefExprBits</name><operator>.</operator><name>HasTemplateKWAndArgsInfo</name></name></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>DependentScopeDeclRefExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>SourceLocation TemplateKWLoc</argument>, <argument>const DeclarationNameInfo &amp;NameInfo</argument>,
<argument>const TemplateArgumentListInfo *TemplateArgs</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>DependentScopeDeclRefExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Context</argument>,
<argument>bool HasTemplateKWAndArgsInfo</argument>,
<argument>unsigned NumTemplateArgs</argument>)</argument_list></macro></expr>;


<expr><specifier>const</specifier> <name>DeclarationNameInfo</name> <operator>&amp;</operator><macro><name>getNameInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NameInfo</name></expr>;</return> }</block>


<name>DeclarationName</name> <macro><name>getDeclName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>




<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>NameInfo</name><operator>.</operator><name>getLoc</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QualifierLoc</name></expr>;</return> }</block>



<name>NestedNameSpecifier</name> <operator>*</operator><macro><name>getQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>SourceLocation</name> <macro><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TemplateKWLoc</name></expr>;</return>
}</block>



<name>SourceLocation</name> <macro><name>getLAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LAngleLoc</name></expr>;</return>
}</block>



<name>SourceLocation</name> <macro><name>getRAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RAngleLoc</name></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasTemplateKeyword</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>bool</name> <macro><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLAngleLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>void</name> <macro><name>copyTemplateArgumentsInto</name><argument_list>(<argument>TemplateArgumentListInfo &amp;List</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>copyInto</name><argument_list>(
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<name>TemplateArgumentLoc</name> <specifier>const</specifier> <operator>*</operator><macro><name>getTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NumTemplateArgs</name></expr>;</return>
}</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name> <macro><name>template_arguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><call><name>getTemplateArgs</name><argument_list>()</argument_list></call></expr>, <macro><name>getNumTemplateArgs</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block>



<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getRAngleLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DependentScopeDeclRefExprClass</name></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;











<expr><name>class</name> <name>ExprWithCleanups</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>FullExpr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;
<argument><expr><name>ExprWithCleanups</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>BlockDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>CompoundLiteralExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>




<name>using</name> <name>CleanupObject</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>BlockDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>CompoundLiteralExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;

<macro><name>ExprWithCleanups</name><argument_list>(<argument>EmptyShell</argument>, <argument>unsigned NumObjects</argument>)</argument_list></macro>;
<macro><name>ExprWithCleanups</name><argument_list>(<argument>Expr *SubExpr</argument>, <argument>bool CleanupsHaveSideEffects</argument>,
<argument>ArrayRef&lt;CleanupObject&gt; Objects</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>ExprWithCleanups</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>EmptyShell empty</argument>,
<argument>unsigned numObjects</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>ExprWithCleanups</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>Expr *subexpr</argument>,
<argument>bool CleanupsHaveSideEffects</argument>,
<argument>ArrayRef&lt;CleanupObject&gt; objects</argument>)</argument_list></macro></expr>;

<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>CleanupObject</name></expr></argument>&gt;</argument_list></name> <macro><name>getObjects</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>CleanupObject</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getNumObjects</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumObjects</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ExprWithCleanupsBits</name><operator>.</operator><name>NumObjects</name></name></expr>;</return> }</block>

<name>CleanupObject</name> <macro><name>getObject</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getNumObjects</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Index out of range"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getObjects</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</return>
}</block>

<name>bool</name> <macro><name>cleanupsHaveSideEffects</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ExprWithCleanupsBits</name><operator>.</operator><name>CleanupsHaveSideEffects</name></name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>SubExpr</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>SubExpr</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ExprWithCleanupsClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubExpr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubExpr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;






















<expr><name>class</name> <name>CXXUnresolvedConstructExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>CXXUnresolvedConstructExpr</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>TypeSourceInfo</name> <operator>*</operator><name>TSI</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>SourceLocation</name> <name>RParenLoc</name></expr>;

<macro><name>CXXUnresolvedConstructExpr</name><argument_list>(<argument>QualType T</argument>, <argument>TypeSourceInfo *TSI</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>ArrayRef&lt;Expr *&gt; Args</argument>,
<argument>SourceLocation RParenLoc</argument>)</argument_list></macro>;

<macro><name>CXXUnresolvedConstructExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>unsigned NumArgs</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Expr</name><argument_list>(<argument><expr><name>CXXUnresolvedConstructExprClass</name></expr></argument>, <argument><expr><name>Empty</name></expr></argument>)</argument_list></call></expr>, <macro><name>TSI</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CXXUnresolvedConstructExprBits</name><operator>.</operator><name>NumArgs</name></name> <operator>=</operator> <name>NumArgs</name></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>CXXUnresolvedConstructExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>,
<argument>QualType T</argument>, <argument>TypeSourceInfo *TSI</argument>,
<argument>SourceLocation LParenLoc</argument>,
<argument>ArrayRef&lt;Expr *&gt; Args</argument>,
<argument>SourceLocation RParenLoc</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>CXXUnresolvedConstructExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Context</argument>,
<argument>unsigned NumArgs</argument>)</argument_list></macro></expr>;



<expr><name>QualType</name> <macro><name>getTypeAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>TSI</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TSI</name></expr>;</return> }</block>



<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>



<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>




<name>bool</name> <macro><name>isListInitialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>LParenLoc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXUnresolvedConstructExprBits</name><operator>.</operator><name>NumArgs</name></name></expr>;</return> }</block>

<name>using</name> <name>arg_iterator</name> <operator>=</operator> <name>Expr</name> <operator>*</operator><operator>*</operator></expr>;
<expr><name>using</name> <name>arg_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>arg_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>arg_iterator</name> <macro><name>arg_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>arg_iterator</name> <macro><name>arg_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>arg_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>arg_range</name> <macro><name>arguments</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>arg_range</name><argument_list>(<argument><expr><call><name>arg_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>arg_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>using</name> <name>const_arg_iterator</name> <operator>=</operator> <specifier>const</specifier> <name>Expr</name><operator>*</operator> <specifier>const</specifier> <operator>*</operator></expr>;
<expr><name>using</name> <name>const_arg_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_arg_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>const_arg_iterator</name> <macro><name>arg_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_arg_iterator</name> <macro><name>arg_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>arg_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_arg_range</name> <macro><name>arguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_arg_range</name><argument_list>(<argument><expr><call><name>arg_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>arg_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getArg</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Argument index out-of-range"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>arg_begin</name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index></expr>;</return>
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getArg</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Argument index out-of-range"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>arg_begin</name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index></expr>;</return>
}</block>

<name>void</name> <macro><name>setArg</name><argument_list>(<argument>unsigned I</argument>, <argument>Expr *E</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Argument index out-of-range"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>arg_begin</name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index> <operator>=</operator> <name>E</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;
<expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>RParenLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getArg</name><argument_list>(<argument><expr><call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>RParenLoc</name></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXUnresolvedConstructExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<expr><name>auto</name> <operator>*</operator><operator>*</operator><name>begin</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>arg_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>begin</name> <operator>+</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <operator>*</operator><operator>*</operator><name>begin</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXUnresolvedConstructExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>arg_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>begin</name> <operator>+</operator> <call><name>getNumArgs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>CXXDependentScopeMemberExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>CXXDependentScopeMemberExpr</name></expr></argument>,
<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>,
<argument><expr><name>TemplateArgumentLoc</name></expr></argument>, <argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;



<expr><name>Stmt</name> <operator>*</operator><name>Base</name></expr>;



<expr><name>QualType</name> <name>BaseType</name></expr>;




<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;





<expr><name>DeclarationNameInfo</name> <name>MemberNameInfo</name></expr>;
















<expr><name>bool</name> <macro><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CXXDependentScopeMemberExprBits</name><operator>.</operator><name>HasTemplateKWAndArgsInfo</name></name></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasFirstQualifierFoundInScope</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CXXDependentScopeMemberExprBits</name><operator>.</operator><name>HasFirstQualifierFoundInScope</name></name></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;ASTTemplateKWAndArgsInfo&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;TemplateArgumentLoc&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNumTemplateArgs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;NamedDecl *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasFirstQualifierFoundInScope</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<macro><name>CXXDependentScopeMemberExpr</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>Expr *Base</argument>,
<argument>QualType BaseType</argument>, <argument>bool IsArrow</argument>,
<argument>SourceLocation OperatorLoc</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>SourceLocation TemplateKWLoc</argument>,
<argument>NamedDecl *FirstQualifierFoundInScope</argument>,
<argument>DeclarationNameInfo MemberNameInfo</argument>,
<argument>const TemplateArgumentListInfo *TemplateArgs</argument>)</argument_list></macro></expr>;

<macro><name>CXXDependentScopeMemberExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>bool HasTemplateKWAndArgsInfo</argument>,
<argument>bool HasFirstQualifierFoundInScope</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>CXXDependentScopeMemberExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>Expr *Base</argument>, <argument>QualType BaseType</argument>, <argument>bool IsArrow</argument>,
<argument>SourceLocation OperatorLoc</argument>, <argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>SourceLocation TemplateKWLoc</argument>, <argument>NamedDecl *FirstQualifierFoundInScope</argument>,
<argument>DeclarationNameInfo MemberNameInfo</argument>,
<argument>const TemplateArgumentListInfo *TemplateArgs</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>CXXDependentScopeMemberExpr</name> <operator>*</operator>
<macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>bool HasTemplateKWAndArgsInfo</argument>,
<argument>unsigned NumTemplateArgs</argument>, <argument>bool HasFirstQualifierFoundInScope</argument>)</argument_list></macro></expr>;




<expr><name>bool</name> <macro><name>isImplicitAccess</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Base</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Base</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>isImplicitCXXThis</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isImplicitAccess</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Base</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>QualType</name> <macro><name>getBaseType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BaseType</name></expr>;</return> }</block>



<name>bool</name> <macro><name>isArrow</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXDependentScopeMemberExprBits</name><operator>.</operator><name>IsArrow</name></name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getOperatorLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CXXDependentScopeMemberExprBits</name><operator>.</operator><name>OperatorLoc</name></name></expr>;</return>
}</block>


<name>NestedNameSpecifier</name> <operator>*</operator><macro><name>getQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QualifierLoc</name></expr>;</return> }</block>












<name>NamedDecl</name> <operator>*</operator><macro><name>getFirstQualifierFoundInScope</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasFirstQualifierFoundInScope</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<specifier>const</specifier> <name>DeclarationNameInfo</name> <operator>&amp;</operator><macro><name>getMemberNameInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>MemberNameInfo</name></expr>;</return>
}</block>


<name>DeclarationName</name> <macro><name>getMember</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>MemberNameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>SourceLocation</name> <macro><name>getMemberLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>MemberNameInfo</name><operator>.</operator><name>getLoc</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>SourceLocation</name> <macro><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TemplateKWLoc</name></expr>;</return>
}</block>



<name>SourceLocation</name> <macro><name>getLAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LAngleLoc</name></expr>;</return>
}</block>



<name>SourceLocation</name> <macro><name>getRAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>RAngleLoc</name></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasTemplateKeyword</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>bool</name> <macro><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLAngleLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>void</name> <macro><name>copyTemplateArgumentsInto</name><argument_list>(<argument>TemplateArgumentListInfo &amp;List</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>copyInto</name><argument_list>(
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>



<specifier>const</specifier> <name>TemplateArgumentLoc</name> <operator>*</operator><macro><name>getTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>unsigned</name> <macro><name>getNumTemplateArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NumTemplateArgs</name></expr>;</return>
}</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name> <macro><name>template_arguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><call><name>getTemplateArgs</name><argument_list>()</argument_list></call></expr>, <macro><name>getNumTemplateArgs</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isImplicitAccess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Base</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<expr><call><name>getQualifier</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getQualifierLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>MemberNameInfo</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getRAngleLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>MemberNameInfo</name><operator>.</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXDependentScopeMemberExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isImplicitAccess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Base</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isImplicitAccess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Base</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;
















<expr><name>class</name> <name>UnresolvedMemberExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>OverloadExpr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedMemberExpr</name></expr></argument>, <argument><expr><name>DeclAccessPair</name></expr></argument>,
<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>,
<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OverloadExpr</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;





<expr><name>Stmt</name> <operator>*</operator><name>Base</name></expr>;


<expr><name>QualType</name> <name>BaseType</name></expr>;


<expr><name>SourceLocation</name> <name>OperatorLoc</name></expr>;















<macro><name>UnresolvedMemberExpr</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>bool HasUnresolvedUsing</argument>,
<argument>Expr *Base</argument>, <argument>QualType BaseType</argument>, <argument>bool IsArrow</argument>,
<argument>SourceLocation OperatorLoc</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>SourceLocation TemplateKWLoc</argument>,
<argument>const DeclarationNameInfo &amp;MemberNameInfo</argument>,
<argument>const TemplateArgumentListInfo *TemplateArgs</argument>,
<argument>UnresolvedSetIterator Begin</argument>, <argument>UnresolvedSetIterator End</argument>)</argument_list></macro>;

<macro><name>UnresolvedMemberExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>unsigned NumResults</argument>,
<argument>bool HasTemplateKWAndArgsInfo</argument>)</argument_list></macro>;

<expr><name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;DeclAccessPair&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNumDecls</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;ASTTemplateKWAndArgsInfo&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>UnresolvedMemberExpr</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>bool HasUnresolvedUsing</argument>, <argument>Expr *Base</argument>,
<argument>QualType BaseType</argument>, <argument>bool IsArrow</argument>, <argument>SourceLocation OperatorLoc</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>, <argument>SourceLocation TemplateKWLoc</argument>,
<argument>const DeclarationNameInfo &amp;MemberNameInfo</argument>,
<argument>const TemplateArgumentListInfo *TemplateArgs</argument>,
<argument>UnresolvedSetIterator Begin</argument>, <argument>UnresolvedSetIterator End</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>UnresolvedMemberExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Context</argument>,
<argument>unsigned NumResults</argument>,
<argument>bool HasTemplateKWAndArgsInfo</argument>,
<argument>unsigned NumTemplateArgs</argument>)</argument_list></macro></expr>;





<expr><name>bool</name> <macro><name>isImplicitAccess</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isImplicitAccess</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Base</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isImplicitAccess</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Base</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>QualType</name> <macro><name>getBaseType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BaseType</name></expr>;</return> }</block>



<name>bool</name> <macro><name>hasUnresolvedUsing</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>UnresolvedMemberExprBits</name><operator>.</operator><name>HasUnresolvedUsing</name></name></expr>;</return>
}</block>



<name>bool</name> <macro><name>isArrow</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>UnresolvedMemberExprBits</name><operator>.</operator><name>IsArrow</name></name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getOperatorLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OperatorLoc</name></expr>;</return> }</block>


<name>CXXRecordDecl</name> <operator>*</operator><call><name>getNamingClass</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><macro><name>getNamingClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedMemberExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getNamingClass</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<specifier>const</specifier> <name>DeclarationNameInfo</name> <operator>&amp;</operator><macro><name>getMemberNameInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getNameInfo</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>DeclarationName</name> <macro><name>getMemberName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getName</name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>SourceLocation</name> <macro><name>getMemberLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getNameLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>SourceLocation</name> <macro><name>getExprLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name>getMemberLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isImplicitAccess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Base</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<decl><type><name>NestedNameSpecifierLoc</name></type> <name>l</name> <init>= <expr><call><name>getQualifierLoc</name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>l</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getMemberNameInfo</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasExplicitTemplateArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getRAngleLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getMemberNameInfo</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>UnresolvedMemberExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isImplicitAccess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Base</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isImplicitAccess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Base</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name>DeclAccessPair</name> <operator>*</operator><name>OverloadExpr</name><operator>::</operator><macro><name>getTrailingResults</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>ULE</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedLookupExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>ULE</name><operator>-&gt;</operator><name>getTrailingObjects</name></name><operator>&lt;</operator><name>DeclAccessPair</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedMemberExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>DeclAccessPair</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ASTTemplateKWAndArgsInfo</name> <operator>*</operator><name>OverloadExpr</name><operator>::</operator><macro><name>getTrailingASTTemplateKWAndArgsInfo</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasTemplateKWAndArgsInfo</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr>

<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>ULE</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedLookupExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>ULE</name><operator>-&gt;</operator><name>getTrailingObjects</name></name><operator>&lt;</operator><name>ASTTemplateKWAndArgsInfo</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block></expr></range></decl></decl_stmt>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedMemberExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ASTTemplateKWAndArgsInfo</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>TemplateArgumentLoc</name> <operator>*</operator><name>OverloadExpr</name><operator>::</operator><macro><name>getTrailingTemplateArgumentLoc</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>ULE</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedLookupExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>ULE</name><operator>-&gt;</operator><name>getTrailingObjects</name></name><operator>&lt;</operator><name>TemplateArgumentLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedMemberExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}

CXXRecordDecl <expr_stmt><expr><operator>*</operator><name>OverloadExpr</name><operator>::</operator><macro><name>getNamingClass</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>ULE</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedLookupExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>ULE</name><operator>-&gt;</operator><name>getNamingClass</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedMemberExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getNamingClass</name><argument_list>()</argument_list></call></expr>;</return>
}





class <label><name>CXXNoexceptExpr</name> :</label> <decl_stmt><decl><type><name>public</name></type> <name>Expr</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Operand</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceRange</name></type> <name>Range</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>CXXNoexceptExpr</name><argument_list>(<argument>QualType Ty</argument>, <argument>Expr *Operand</argument>, <argument>CanThrowResult Val</argument>,
<argument>SourceLocation Keyword</argument>, <argument>SourceLocation RParen</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Expr</name><argument_list>(<argument><expr><name>CXXNoexceptExprClass</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>Operand</name><argument_list>(<argument><expr><name>Operand</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Range</name><argument_list>(<argument>Keyword</argument>, <argument>RParen</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CXXNoexceptExprBits</name><operator>.</operator><name>Value</name></name> <operator>=</operator> <name>Val</name> <operator>==</operator> <name>CT_Cannot</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>CXXNoexceptExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CXXNoexceptExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>Expr</name> <operator>*</operator><macro><name>getOperand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Operand</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Range</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>getValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CXXNoexceptExprBits</name><operator>.</operator><name>Value</name></name></expr>;</return> }</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXNoexceptExprClass</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>child_range</name></type> <name>children</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Operand</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Operand</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Operand</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Operand</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


















<decl_stmt><decl><type><name>class</name></type> <name>PackExpansionExpr</name> <range>: <expr><name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;

<expr><name>SourceLocation</name> <name>EllipsisLoc</name></expr>;






<expr><name>unsigned</name> <name>NumExpansions</name></expr>;

<expr><name>Stmt</name> <operator>*</operator><name>Pattern</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>PackExpansionExpr</name><argument_list>(<argument>QualType T</argument>, <argument>Expr *Pattern</argument>, <argument>SourceLocation EllipsisLoc</argument>,
<argument>Optional&lt;unsigned&gt; NumExpansions</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>PackExpansionExprClass</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><call><name><name>Pattern</name><operator>-&gt;</operator><name>getValueKind</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Pattern</name><operator>-&gt;</operator><name>getObjectKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>EllipsisLoc</name><argument_list>(<argument><expr><name>EllipsisLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>NumExpansions</name><argument_list>(<argument><expr><ternary><condition><expr><name>NumExpansions</name></expr> ?</condition><then> <expr><operator>*</operator><name>NumExpansions</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>,
<macro><name>Pattern</name><argument_list>(<argument>Pattern</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>PackExpansionExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>PackExpansionExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>


<name>Expr</name> <operator>*</operator><macro><name>getPattern</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>)</argument_list></call></expr>;</return> }</block>


<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getPattern</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>)</argument_list></call></expr>;</return> }</block>



<name>SourceLocation</name> <macro><name>getEllipsisLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>EllipsisLoc</name></expr>;</return> }</block>



<name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <macro><name>getNumExpansions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>NumExpansions</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NumExpansions</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><name>None</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>Pattern</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>EllipsisLoc</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PackExpansionExprClass</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>child_range</name></type> <name>children</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Pattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Pattern</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Pattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Pattern</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
};










<decl_stmt><decl><type><name>class</name> <name>SizeOfPackExpr</name></type> <name>final</name>
<range>: <expr><name>public</name> <name>Expr</name></expr></range></decl>,
<decl><type ref="prev"/><name>private</name> <name>llvm</name>::<name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>SizeOfPackExpr</name></expr></argument>, <argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtWriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name></type> <name>TrailingObjects</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>OperatorLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>PackLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl>;</decl_stmt>











<decl_stmt><decl><type><name>unsigned</name></type> <name>Length</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Pack</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>



<macro><name>SizeOfPackExpr</name><argument_list>(<argument>QualType SizeType</argument>, <argument>SourceLocation OperatorLoc</argument>, <argument>NamedDecl *Pack</argument>,
<argument>SourceLocation PackLoc</argument>, <argument>SourceLocation RParenLoc</argument>,
<argument>Optional&lt;unsigned&gt; Length</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; PartialArgs</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Expr</name><argument_list>(<argument><expr><name>SizeOfPackExprClass</name></expr></argument>, <argument><expr><name>SizeType</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>OperatorLoc</name><argument_list>(<argument><expr><name>OperatorLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>PackLoc</name><argument_list>(<argument><expr><name>PackLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>RParenLoc</name><argument_list>(<argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>Length</name><argument_list>(<argument><expr><ternary><condition><expr><name>Length</name></expr> ?</condition><then> <expr><operator>*</operator><name>Length</name></expr> </then><else>: <expr><call><name><name>PartialArgs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Pack</name><argument_list>(<argument>Pack</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>!</operator><name>Length</name> <operator>||</operator> <call><name><name>PartialArgs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"have partial args for non-dependent sizeof... expression"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <operator>*</operator><name>Args</name> <operator>=</operator> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;
<expr><name>std</name><operator>::</operator><call><name>uninitialized_copy</name><argument_list>(<argument><expr><call><name><name>PartialArgs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>PartialArgs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Args</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><ternary><condition><expr><name>Length</name></expr> ?</condition><then> <expr><name>ExprDependence</name><operator>::</operator><name>None</name></expr>
</then><else>: <expr><name>ExprDependence</name><operator>::</operator><name>ValueInstantiation</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;
}</block>


<macro><name>SizeOfPackExpr</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>unsigned NumPartialArgs</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>SizeOfPackExprClass</name></expr></argument>, <argument><expr><name>Empty</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Length</name><argument_list>(<argument>NumPartialArgs</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>SizeOfPackExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>SourceLocation OperatorLoc</argument>,
<argument>NamedDecl *Pack</argument>, <argument>SourceLocation PackLoc</argument>,
<argument>SourceLocation RParenLoc</argument>,
<argument>Optional&lt;unsigned&gt; Length = None</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; PartialArgs = None</argument>)</argument_list></macro></expr>;</expr_stmt>
<function_decl><type><specifier>static</specifier> <name>SizeOfPackExpr</name> <modifier>*</modifier></type><name>CreateDeserialized</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NumPartialArgs</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getOperatorLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OperatorLoc</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getPackLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PackLoc</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>NamedDecl</name> <operator>*</operator><macro><name>getPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Pack</name></expr>;</return> }</block></expr></expr_stmt>





<expr_stmt><expr><name>unsigned</name> <macro><name>getPackLength</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isValueDependent</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Cannot get the length of a value-dependent pack size expression"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Length</name></expr>;</return>
}</block></expr></expr_stmt>






<expr_stmt><expr><name>bool</name> <macro><name>isPartiallySubstituted</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isValueDependent</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>Length</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <macro><name>getPartialArguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isPartiallySubstituted</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>auto</name> <operator>*</operator><name>Args</name> <operator>=</operator> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><name>Args</name></expr></argument>, <argument><expr><name>Args</name> <operator>+</operator> <name>Length</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>OperatorLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SizeOfPackExprClass</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>child_range</name></type> <name>children</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>SubstNonTypeTemplateParmExpr</name> <range>: <expr><name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;




<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>NonTypeTemplateParmDecl</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>ParamAndRef</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>Replacement</name></expr>;

<expr><name>explicit</name> <macro><name>SubstNonTypeTemplateParmExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>SubstNonTypeTemplateParmExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<macro><name>SubstNonTypeTemplateParmExpr</name><argument_list>(<argument>QualType Ty</argument>, <argument>ExprValueKind ValueKind</argument>,
<argument>SourceLocation Loc</argument>,
<argument>NonTypeTemplateParmDecl *Param</argument>, <argument>bool RefParam</argument>,
<argument>Expr *Replacement</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>SubstNonTypeTemplateParmExprClass</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>ValueKind</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ParamAndRef</name><argument_list>(<argument><expr><name>Param</name></expr></argument>, <argument><expr><name>RefParam</name></expr></argument>)</argument_list></call></expr>, <macro><name>Replacement</name><argument_list>(<argument>Replacement</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>SubstNonTypeTemplateParmExprBits</name><operator>.</operator><name>NameLoc</name></name> <operator>=</operator> <name>Loc</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>SubstNonTypeTemplateParmExprBits</name><operator>.</operator><name>NameLoc</name></name></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getNameLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getNameLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getReplacement</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Replacement</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>NonTypeTemplateParmDecl</name> <operator>*</operator><macro><name>getParameter</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>ParamAndRef</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isReferenceParameter</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>ParamAndRef</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>QualType</name> <macro><name>getParameterType</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *s</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>s</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SubstNonTypeTemplateParmExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Replacement</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Replacement</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Replacement</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Replacement</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;













<expr><name>class</name> <name>SubstNonTypeTemplateParmPackExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;


<expr><name>NonTypeTemplateParmDecl</name> <operator>*</operator><name>Param</name></expr>;



<expr><specifier>const</specifier> <name>TemplateArgument</name> <operator>*</operator><name>Arguments</name></expr>;


<expr><name>unsigned</name> <name>NumArguments</name></expr>;


<expr><name>SourceLocation</name> <name>NameLoc</name></expr>;

<expr><name>explicit</name> <macro><name>SubstNonTypeTemplateParmPackExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>SubstNonTypeTemplateParmPackExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<macro><name>SubstNonTypeTemplateParmPackExpr</name><argument_list>(<argument>QualType T</argument>,
<argument>ExprValueKind ValueKind</argument>,
<argument>NonTypeTemplateParmDecl *Param</argument>,
<argument>SourceLocation NameLoc</argument>,
<argument>const TemplateArgument &amp;ArgPack</argument>)</argument_list></macro></expr>;


<expr><name>NonTypeTemplateParmDecl</name> <operator>*</operator><macro><name>getParameterPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Param</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getParameterPackLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NameLoc</name></expr>;</return> }</block>



<name>TemplateArgument</name> <macro><name>getArgumentPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>NameLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>NameLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SubstNonTypeTemplateParmPackExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;















<expr><name>class</name> <name>FunctionParmPackExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Expr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>FunctionParmPackExpr</name></expr></argument>, <argument><expr><name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>VarDecl</name> <operator>*</operator><name>ParamPack</name></expr>;


<expr><name>SourceLocation</name> <name>NameLoc</name></expr>;


<expr><name>unsigned</name> <name>NumParameters</name></expr>;

<macro><name>FunctionParmPackExpr</name><argument_list>(<argument>QualType T</argument>, <argument>VarDecl *ParamPack</argument>,
<argument>SourceLocation NameLoc</argument>, <argument>unsigned NumParams</argument>,
<argument>VarDecl *const *Params</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>FunctionParmPackExpr</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>QualType T</argument>,
<argument>VarDecl *ParamPack</argument>,
<argument>SourceLocation NameLoc</argument>,
<argument>ArrayRef&lt;VarDecl *&gt; Params</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>FunctionParmPackExpr</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Context</argument>,
<argument>unsigned NumParams</argument>)</argument_list></macro></expr>;


<expr><name>VarDecl</name> <operator>*</operator><macro><name>getParameterPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ParamPack</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getParameterPackLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NameLoc</name></expr>;</return> }</block>



<name>using</name> <name>iterator</name> <operator>=</operator> <name>VarDecl</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator></expr>;
<expr><name>iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>begin</name><argument_list>()</argument_list></call> <operator>+</operator> <name>NumParameters</name></expr>;</return> }</block>


<name>unsigned</name> <macro><name>getNumExpansions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumParameters</name></expr>;</return> }</block>


<name>VarDecl</name> <operator>*</operator><macro><name>getExpansion</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>begin</name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>NameLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>NameLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>FunctionParmPackExprClass</name></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;





















<expr><name>class</name> <name>MaterializeTemporaryExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;

<expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>, <argument><expr><name>LifetimeExtendedTemporaryDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>State</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>MaterializeTemporaryExpr</name><argument_list>(<argument>QualType T</argument>, <argument>Expr *Temporary</argument>,
<argument>bool BoundToLvalueReference</argument>,
<argument>LifetimeExtendedTemporaryDecl *MTD = nullptr</argument>)</argument_list></macro></expr>;

<macro><name>MaterializeTemporaryExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>MaterializeTemporaryExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <expr><block>{}</block>



<name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name><name>State</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>Stmt</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator>
<operator>?</operator> <name><name>State</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>Stmt</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator>
<operator>:</operator> <name><name>State</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>LifetimeExtendedTemporaryDecl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>-&gt;</operator><call><name>getTemporaryExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>StorageDuration</name> <macro><name>getStorageDuration</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><name><name>State</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>Stmt</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr> ?</condition><then> <expr><name>SD_FullExpression</name></expr>
</then><else>: <expr><name><name>State</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>LifetimeExtendedTemporaryDecl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator>
<operator>-&gt;</operator><call><name>getStorageDuration</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>



<name>APValue</name> <operator>*</operator><macro><name>getOrCreateValue</name><argument_list>(<argument>bool MayCreate</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>LifetimeExtendedTemporaryDecl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"the temporary has not been lifetime extended"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>State</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>LifetimeExtendedTemporaryDecl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>-&gt;</operator><call><name>getOrCreateValue</name><argument_list>(
<argument><expr><name>MayCreate</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>LifetimeExtendedTemporaryDecl</name> <operator>*</operator><macro><name>getLifetimeExtendedTemporaryDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name><name>State</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>LifetimeExtendedTemporaryDecl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>
<specifier>const</specifier> <name>LifetimeExtendedTemporaryDecl</name> <operator>*</operator>
<macro><name>getLifetimeExtendedTemporaryDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>State</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>LifetimeExtendedTemporaryDecl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>



<name>ValueDecl</name> <operator>*</operator><macro><name>getExtendingDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><ternary><condition><expr><name><name>State</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>Stmt</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr> ?</condition><then> <expr><name>nullptr</name></expr>
</then><else>: <expr><name><name>State</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>LifetimeExtendedTemporaryDecl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator>
<operator>-&gt;</operator><call><name>getExtendingDecl</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>
<specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><macro><name>getExtendingDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>MaterializeTemporaryExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getExtendingDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setExtendingDecl</name><argument_list>(<argument>ValueDecl *ExtendedBy</argument>, <argument>unsigned ManglingNumber</argument>)</argument_list></macro></expr>;

<expr><name>unsigned</name> <macro><name>getManglingNumber</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><name><name>State</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>Stmt</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr>
</then><else>: <expr><name><name>State</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>LifetimeExtendedTemporaryDecl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator>
<operator>-&gt;</operator><call><name>getManglingNumber</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>



<name>bool</name> <macro><name>isBoundToLvalueReference</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isLValue</name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>bool</name> <macro><name>isUsableInConstantExpressions</name><argument_list>(<argument>const ASTContext &amp;Context</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getSubExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getSubExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>MaterializeTemporaryExprClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><ternary><condition><expr><name><name>State</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>Stmt</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>
?</condition><then> <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>State</name><operator>.</operator><name>getAddrOfPtr1</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>State</name><operator>.</operator><name>getAddrOfPtr1</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><name><name>State</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>LifetimeExtendedTemporaryDecl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>-&gt;</operator><call><name>childrenExpr</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><name><name>State</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>Stmt</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>
?</condition><then> <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>State</name><operator>.</operator><name>getAddrOfPtr1</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>State</name><operator>.</operator><name>getAddrOfPtr1</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>LifetimeExtendedTemporaryDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name><name>State</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>LifetimeExtendedTemporaryDecl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>childrenExpr</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>CXXFoldExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;

enum <expr><name>SubExpr</name> <block>{ <expr><name>Callee</name></expr>, <expr><name>LHS</name></expr>, <expr><name>RHS</name></expr>, <expr><name>Count</name></expr> }</block></expr>;

<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;
<expr><name>SourceLocation</name> <name>EllipsisLoc</name></expr>;
<expr><name>SourceLocation</name> <name>RParenLoc</name></expr>;


<expr><name>unsigned</name> <name>NumExpansions</name></expr>;
<expr><name>Stmt</name> <operator>*</operator><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Count</name></expr>]</index></name></expr>;
<expr><name>BinaryOperatorKind</name> <name>Opcode</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>CXXFoldExpr</name><argument_list>(<argument>QualType T</argument>, <argument>UnresolvedLookupExpr *Callee</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>Expr *LHS</argument>, <argument>BinaryOperatorKind Opcode</argument>,
<argument>SourceLocation EllipsisLoc</argument>, <argument>Expr *RHS</argument>, <argument>SourceLocation RParenLoc</argument>,
<argument>Optional&lt;unsigned&gt; NumExpansions</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>CXXFoldExprClass</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>EllipsisLoc</name><argument_list>(<argument><expr><name>EllipsisLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>RParenLoc</name><argument_list>(<argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>NumExpansions</name><argument_list>(<argument><expr><ternary><condition><expr><name>NumExpansions</name></expr> ?</condition><then> <expr><operator>*</operator><name>NumExpansions</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>, <macro><name>Opcode</name><argument_list>(<argument>Opcode</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Callee</name></expr>]</index></name> <operator>=</operator> <name>Callee</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>LHS</name></expr>]</index></name> <operator>=</operator> <name>LHS</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>RHS</name></expr>]</index></name> <operator>=</operator> <name>RHS</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>CXXFoldExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>CXXFoldExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>UnresolvedLookupExpr</name> <operator>*</operator><macro><name>getCallee</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedLookupExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Callee</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>Expr</name> <operator>*</operator><macro><name>getLHS</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>LHS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>Expr</name> <operator>*</operator><macro><name>getRHS</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>RHS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>


<name>bool</name> <macro><name>isRightFold</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLHS</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>getLHS</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>containsUnexpandedParameterPack</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>isLeftFold</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>isRightFold</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getPattern</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><ternary><condition><expr><call><name>isLeftFold</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getRHS</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>getLHS</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getInit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><ternary><condition><expr><call><name>isLeftFold</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getLHS</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>getRHS</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEllipsisLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>EllipsisLoc</name></expr>;</return> }</block>
<name>BinaryOperatorKind</name> <macro><name>getOperator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Opcode</name></expr>;</return> }</block>

<name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <macro><name>getNumExpansions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>NumExpansions</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NumExpansions</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>None</name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>LParenLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>LParenLoc</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<expr><call><name>isLeftFold</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getEllipsisLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getLHS</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>RParenLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>RParenLoc</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<expr><call><name>isRightFold</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getEllipsisLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getRHS</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CXXFoldExprClass</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>child_range</name></type> <name>children</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><name>SubExprs</name> <operator>+</operator> <name>SubExpr</name><operator>::</operator><name>Count</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><name>SubExprs</name> <operator>+</operator> <name>SubExpr</name><operator>::</operator><name>Count</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
};














<decl_stmt><decl><type><name>class</name></type> <name>CoroutineSuspendExpr</name> <range>: <expr><name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>SourceLocation</name> <name>KeywordLoc</name></expr>;

enum <expr><name>SubExpr</name> <block>{ <expr><name>Common</name></expr>, <expr><name>Ready</name></expr>, <expr><name>Suspend</name></expr>, <expr><name>Resume</name></expr>, <expr><name>Count</name></expr> }</block></expr>;

<expr><name>Stmt</name> <operator>*</operator><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Count</name></expr>]</index></name></expr>;
<expr><name>OpaqueValueExpr</name> <operator>*</operator><name>OpaqueValue</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>CoroutineSuspendExpr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>SourceLocation KeywordLoc</argument>, <argument>Expr *Common</argument>,
<argument>Expr *Ready</argument>, <argument>Expr *Suspend</argument>, <argument>Expr *Resume</argument>,
<argument>OpaqueValueExpr *OpaqueValue</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>SC</name></expr></argument>, <argument><expr><call><name><name>Resume</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Resume</name><operator>-&gt;</operator><name>getValueKind</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Resume</name><operator>-&gt;</operator><name>getObjectKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>KeywordLoc</name><argument_list>(<argument><expr><name>KeywordLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>OpaqueValue</name><argument_list>(<argument>OpaqueValue</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Common</name></expr>]</index></name> <operator>=</operator> <name>Common</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Ready</name></expr>]</index></name> <operator>=</operator> <name>Ready</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Suspend</name></expr>]</index></name> <operator>=</operator> <name>Suspend</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Resume</name></expr>]</index></name> <operator>=</operator> <name>Resume</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>CoroutineSuspendExpr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>SourceLocation KeywordLoc</argument>, <argument>QualType Ty</argument>,
<argument>Expr *Common</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>SC</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>, <macro><name>KeywordLoc</name><argument_list>(<argument>KeywordLoc</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Common</name><operator>-&gt;</operator><name>isTypeDependent</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Ty</name><operator>-&gt;</operator><name>isDependentType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"wrong constructor for non-dependent co_await/co_yield expression"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Common</name></expr>]</index></name> <operator>=</operator> <name>Common</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Ready</name></expr>]</index></name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Suspend</name></expr>]</index></name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Resume</name></expr>]</index></name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>CoroutineSuspendExpr</name><argument_list>(<argument>StmtClass SC</argument>, <argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>SC</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{
<expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Common</name></expr>]</index></name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Ready</name></expr>]</index></name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Suspend</name></expr>]</index></name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Resume</name></expr>]</index></name> <operator>=</operator> <name>nullptr</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getKeywordLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>KeywordLoc</name></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getCommonExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Common</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>OpaqueValueExpr</name> <operator>*</operator><macro><name>getOpaqueValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OpaqueValue</name></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getReadyExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Ready</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getSuspendExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Suspend</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getResumeExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>SubExpr</name><operator>::</operator><name>Resume</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>KeywordLoc</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getCommonExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><name>SubExprs</name> <operator>+</operator> <name>SubExpr</name><operator>::</operator><name>Count</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><name>SubExprs</name> <operator>+</operator> <name>SubExpr</name><operator>::</operator><name>Count</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CoawaitExprClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CoyieldExprClass</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>CoawaitExpr</name> <operator>:</operator> <name>public</name> <name>CoroutineSuspendExpr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>CoawaitExpr</name><argument_list>(<argument>SourceLocation CoawaitLoc</argument>, <argument>Expr *Operand</argument>, <argument>Expr *Ready</argument>,
<argument>Expr *Suspend</argument>, <argument>Expr *Resume</argument>, <argument>OpaqueValueExpr *OpaqueValue</argument>,
<argument>bool IsImplicit = false</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CoroutineSuspendExpr</name><argument_list>(<argument>CoawaitExprClass</argument>, <argument>CoawaitLoc</argument>, <argument>Operand</argument>, <argument>Ready</argument>,
<argument>Suspend</argument>, <argument>Resume</argument>, <argument>OpaqueValue</argument>)</argument_list></macro> <block>{
<expr><name><name>CoawaitBits</name><operator>.</operator><name>IsImplicit</name></name> <operator>=</operator> <name>IsImplicit</name></expr>;
}</block>

<macro><name>CoawaitExpr</name><argument_list>(<argument>SourceLocation CoawaitLoc</argument>, <argument>QualType Ty</argument>, <argument>Expr *Operand</argument>,
<argument>bool IsImplicit = false</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CoroutineSuspendExpr</name><argument_list>(<argument>CoawaitExprClass</argument>, <argument>CoawaitLoc</argument>, <argument>Ty</argument>, <argument>Operand</argument>)</argument_list></macro> <block>{
<expr><name><name>CoawaitBits</name><operator>.</operator><name>IsImplicit</name></name> <operator>=</operator> <name>IsImplicit</name></expr>;
}</block>

<macro><name>CoawaitExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CoroutineSuspendExpr</name><argument_list>(<argument>CoawaitExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>Expr</name> <operator>*</operator><macro><name>getOperand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{

<return>return <expr><call><name>getCommonExpr</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isImplicit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CoawaitBits</name><operator>.</operator><name>IsImplicit</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setIsImplicit</name><argument_list>(<argument>bool value = true</argument>)</argument_list></macro> <block>{ <expr><name><name>CoawaitBits</name><operator>.</operator><name>IsImplicit</name></name> <operator>=</operator> <name>value</name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CoawaitExprClass</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>DependentCoawaitExpr</name> <operator>:</operator> <name>public</name> <name>Expr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>SourceLocation</name> <name>KeywordLoc</name></expr>;
<expr><name>Stmt</name> <operator>*</operator><name><name>SubExprs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>DependentCoawaitExpr</name><argument_list>(<argument>SourceLocation KeywordLoc</argument>, <argument>QualType Ty</argument>, <argument>Expr *Op</argument>,
<argument>UnresolvedLookupExpr *OpCoawait</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Expr</name><argument_list>(<argument><expr><name>DependentCoawaitExprClass</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>OK_Ordinary</name></expr></argument>)</argument_list></call></expr>,
<macro><name>KeywordLoc</name><argument_list>(<argument>KeywordLoc</argument>)</argument_list></macro> <expr><block>{


<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Ty</name><operator>-&gt;</operator><name>isDependentType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"wrong constructor for non-dependent co_await/co_yield expression"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>Op</name></expr>;
<expr><name><name>SubExprs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>OpCoawait</name></expr>;
<expr><call><name>setDependence</name><argument_list>(<argument><expr><call><name>computeDependence</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>DependentCoawaitExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Expr</name><argument_list>(<argument>DependentCoawaitExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>Expr</name> <operator>*</operator><macro><name>getOperand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>UnresolvedLookupExpr</name> <operator>*</operator><macro><name>getOperatorCoawaitLookup</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedLookupExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getKeywordLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>KeywordLoc</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>KeywordLoc</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getOperand</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><name>SubExprs</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><name>SubExprs</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DependentCoawaitExprClass</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>CoyieldExpr</name> <operator>:</operator> <name>public</name> <name>CoroutineSuspendExpr</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>CoyieldExpr</name><argument_list>(<argument>SourceLocation CoyieldLoc</argument>, <argument>Expr *Operand</argument>, <argument>Expr *Ready</argument>,
<argument>Expr *Suspend</argument>, <argument>Expr *Resume</argument>, <argument>OpaqueValueExpr *OpaqueValue</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CoroutineSuspendExpr</name><argument_list>(<argument>CoyieldExprClass</argument>, <argument>CoyieldLoc</argument>, <argument>Operand</argument>, <argument>Ready</argument>,
<argument>Suspend</argument>, <argument>Resume</argument>, <argument>OpaqueValue</argument>)</argument_list></macro> <block>{}</block>
<macro><name>CoyieldExpr</name><argument_list>(<argument>SourceLocation CoyieldLoc</argument>, <argument>QualType Ty</argument>, <argument>Expr *Operand</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CoroutineSuspendExpr</name><argument_list>(<argument>CoyieldExprClass</argument>, <argument>CoyieldLoc</argument>, <argument>Ty</argument>, <argument>Operand</argument>)</argument_list></macro> <block>{}</block>
<macro><name>CoyieldExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CoroutineSuspendExpr</name><argument_list>(<argument>CoyieldExprClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>Expr</name> <operator>*</operator><macro><name>getOperand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{

<return>return <expr><call><name>getCommonExpr</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CoyieldExprClass</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>BuiltinBitCastExpr</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>ExplicitCastExpr</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>BuiltinBitCastExpr</name></expr></argument>, <argument><expr><name>CXXBaseSpecifier</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>CastExpr</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;

<expr><name>SourceLocation</name> <name>KWLoc</name></expr>;
<expr><name>SourceLocation</name> <name>RParenLoc</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>BuiltinBitCastExpr</name><argument_list>(<argument>QualType T</argument>, <argument>ExprValueKind VK</argument>, <argument>CastKind CK</argument>, <argument>Expr *SrcExpr</argument>,
<argument>TypeSourceInfo *DstType</argument>, <argument>SourceLocation KWLoc</argument>,
<argument>SourceLocation RParenLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>ExplicitCastExpr</name><argument_list>(<argument><expr><name>BuiltinBitCastExprClass</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>VK</name></expr></argument>, <argument><expr><name>CK</name></expr></argument>, <argument><expr><name>SrcExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>,
<argument><expr><name>DstType</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>KWLoc</name><argument_list>(<argument><expr><name>KWLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>RParenLoc</name><argument_list>(<argument>RParenLoc</argument>)</argument_list></macro> <expr><block>{}</block>
<macro><name>BuiltinBitCastExpr</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>ExplicitCastExpr</name><argument_list>(<argument>BuiltinBitCastExprClass</argument>, <argument>Empty</argument>, <argument><literal type="number">0</literal></argument>, <argument>false</argument>)</argument_list></macro> <block>{}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>KWLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>BuiltinBitCastExprClass</name></expr>;</return>
}</block>
}</expr>;

}</block></expr></block></expr></block></expr></block></expr></block></expr></range></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
