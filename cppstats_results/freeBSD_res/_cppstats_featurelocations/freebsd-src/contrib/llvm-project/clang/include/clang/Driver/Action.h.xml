<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Driver/Action.h">







<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_DRIVER_ACTION_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_DRIVER_ACTION_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Driver/Types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Driver/Util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/STLExtras.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>opt</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>Arg</name></decl>;</decl_stmt>

</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>driver</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ToolChain</name></decl>;</decl_stmt>













<decl_stmt><decl><type><name>class</name></type> <name>Action</name> <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><name>using</name></type> <name>size_type</name> <init>= <expr><name>ActionList</name><operator>::</operator><name>size_type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>input_iterator</name> <init>= <expr><name>ActionList</name><operator>::</operator><name>iterator</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>input_const_iterator</name> <init>= <expr><name>ActionList</name><operator>::</operator><name>const_iterator</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>input_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>input_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>input_const_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>input_const_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<enum>enum <name>ActionClass</name> <block>{
<decl><name>InputClass</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>BindArchClass</name></decl>,
<decl><name>OffloadClass</name></decl>,
<decl><name>PreprocessJobClass</name></decl>,
<decl><name>PrecompileJobClass</name></decl>,
<decl><name>HeaderModulePrecompileJobClass</name></decl>,
<decl><name>AnalyzeJobClass</name></decl>,
<decl><name>MigrateJobClass</name></decl>,
<decl><name>CompileJobClass</name></decl>,
<decl><name>BackendJobClass</name></decl>,
<decl><name>AssembleJobClass</name></decl>,
<decl><name>LinkJobClass</name></decl>,
<decl><name>IfsMergeJobClass</name></decl>,
<decl><name>LipoJobClass</name></decl>,
<decl><name>DsymutilJobClass</name></decl>,
<decl><name>VerifyDebugInfoJobClass</name></decl>,
<decl><name>VerifyPCHJobClass</name></decl>,
<decl><name>OffloadBundlingJobClass</name></decl>,
<decl><name>OffloadUnbundlingJobClass</name></decl>,
<decl><name>OffloadWrapperJobClass</name></decl>,
<decl><name>StaticLibJobClass</name></decl>,

<decl><name>JobClassFirst</name> <init>= <expr><name>PreprocessJobClass</name></expr></init></decl>,
<decl><name>JobClassLast</name> <init>= <expr><name>StaticLibJobClass</name></expr></init></decl>
}</block>;</enum>




<enum>enum <name>OffloadKind</name> <block>{
<decl><name>OFK_None</name> <init>= <expr><literal type="number">0x00</literal></expr></init></decl>,


<decl><name>OFK_Host</name> <init>= <expr><literal type="number">0x01</literal></expr></init></decl>,


<decl><name>OFK_Cuda</name> <init>= <expr><literal type="number">0x02</literal></expr></init></decl>,
<decl><name>OFK_OpenMP</name> <init>= <expr><literal type="number">0x04</literal></expr></init></decl>,
<decl><name>OFK_HIP</name> <init>= <expr><literal type="number">0x08</literal></expr></init></decl>,
}</block>;</enum>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getClassName</name><parameter_list>(<parameter><decl><type><name>ActionClass</name></type> <name>AC</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>ActionClass</name></type> <name>Kind</name></decl>;</decl_stmt>


<expr_stmt><expr><name>types</name><operator>::</operator><name>ID</name> <name>Type</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ActionList</name></type> <name>Inputs</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>CanBeCollapsedWithNextDependentAction</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<label><name>protected</name>:</label>







<decl_stmt><decl><type><name>unsigned</name></type> <name>ActiveOffloadKindMask</name> <init>= <expr><literal type="number">0u</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>OffloadKind</name></type> <name>OffloadingDeviceKind</name> <init>= <expr><name>OFK_None</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>OffloadingArch</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<macro><name>Action</name><argument_list>(<argument>ActionClass Kind</argument>, <argument>types::ID Type</argument>)</argument_list></macro> : <macro><name>Action</name><argument_list>(<argument>Kind</argument>, <argument>ActionList()</argument>, <argument>Type</argument>)</argument_list></macro> <block>{<block_content/>}</block>
<macro><name>Action</name><argument_list>(<argument>ActionClass Kind</argument>, <argument>Action *Input</argument>, <argument>types::ID Type</argument>)</argument_list></macro>
: <macro><name>Action</name><argument_list>(<argument>Kind</argument>, <argument>ActionList({Input})</argument>, <argument>Type</argument>)</argument_list></macro> <block>{<block_content/>}</block>
<macro><name>Action</name><argument_list>(<argument>ActionClass Kind</argument>, <argument>Action *Input</argument>)</argument_list></macro>
: <macro><name>Action</name><argument_list>(<argument>Kind</argument>, <argument>ActionList({Input})</argument>, <argument>Input-&gt;getType()</argument>)</argument_list></macro> <block>{<block_content/>}</block>
<macro><name>Action</name><argument_list>(<argument>ActionClass Kind</argument>, <argument>const ActionList &amp;Inputs</argument>, <argument>types::ID Type</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Kind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><name>Type</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Inputs</name><argument_list>(<argument>Inputs</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>virtual</name> <operator>~</operator><call><name>Action</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getClassName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Action</name><operator>::</operator><call><name>getClassName</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>ActionClass</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>types</name><operator>::</operator><name>ID</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Type</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>ActionList</name> <modifier>&amp;</modifier></type><name>getInputs</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>Inputs</name></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>ActionList</name> <operator>&amp;</operator><macro><name>getInputs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Inputs</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>size_type</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Inputs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>input_iterator</name></type> <name>input_begin</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>Inputs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>input_iterator</name></type> <name>input_end</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>Inputs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>input_range</name></type> <name>inputs</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>input_range</name><argument_list>(<argument><expr><call><name>input_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>input_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><name>input_const_iterator</name> <macro><name>input_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Inputs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>input_const_iterator</name> <macro><name>input_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Inputs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>input_const_range</name> <macro><name>inputs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>input_const_range</name><argument_list>(<argument><expr><call><name>input_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>input_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setCannotBeCollapsedWithNextDependentAction</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>CanBeCollapsedWithNextDependentAction</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>isCollapsingWithNextDependentActionLegal</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>CanBeCollapsedWithNextDependentAction</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getOffloadingKindPrefix</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name>
<macro><name>GetOffloadingFileNamePrefix</name><argument_list>(<argument>OffloadKind Kind</argument>,
<argument>StringRef NormalizedTriple</argument>,
<argument>bool CreatePrefixForHost = false</argument>)</argument_list></macro></expr>;</expr_stmt>


<function_decl><type><specifier>static</specifier> <name>StringRef</name></type> <name>GetOffloadKindName</name><parameter_list>(<parameter><decl><type><name>OffloadKind</name></type> <name>Kind</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>propagateDeviceOffloadInfo</name><parameter_list>(<parameter><decl><type><name>OffloadKind</name></type> <name>OKind</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>OArch</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>propagateHostOffloadInfo</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>OKinds</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>OArch</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>propagateOffloadInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Action</name> <modifier>*</modifier></type><name>A</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>unsigned</name> <macro><name>getOffloadingHostActiveKinds</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ActiveOffloadKindMask</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>OffloadKind</name> <macro><name>getOffloadingDeviceKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OffloadingDeviceKind</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getOffloadingArch</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OffloadingArch</name></expr>;</return> }</block></expr></expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isHostOffloading</name><argument_list>(<argument><expr><name>OffloadKind</name> <name>OKind</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>ActiveOffloadKindMask</name> <operator>&amp;</operator> <name>OKind</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isDeviceOffloading</name><argument_list>(<argument><expr><name>OffloadKind</name> <name>OKind</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>OffloadingDeviceKind</name> <operator>==</operator> <name>OKind</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isOffloading</name><argument_list>(<argument><expr><name>OffloadKind</name> <name>OKind</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>isHostOffloading</name><argument_list>(<argument><expr><name>OKind</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isDeviceOffloading</name><argument_list>(<argument><expr><name>OKind</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>InputAction</name> <range>: <expr><name>public</name> <name>Action</name> <block>{
<expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>opt</name><operator>::</operator><name>Arg</name> <operator>&amp;</operator><name>Input</name></expr>;
<expr><name>std</name><operator>::</operator><name>string</name> <name>Id</name></expr>;
<expr><name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>InputAction</name><argument_list>(<argument>const llvm::opt::Arg &amp;Input</argument>, <argument>types::ID Type</argument>,
<argument>StringRef Id = StringRef()</argument>)</argument_list></macro></expr>;

<expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>opt</name><operator>::</operator><name>Arg</name> <operator>&amp;</operator><macro><name>getInputArg</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Input</name></expr>;</return> }</block>

<name>void</name> <macro><name>setId</name><argument_list>(<argument>StringRef _Id</argument>)</argument_list></macro> <block>{ <expr><name>Id</name> <operator>=</operator> <call><name><name>_Id</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>; }</block>
<name>StringRef</name> <macro><name>getId</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Id</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>InputClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>BindArchAction</name> <operator>:</operator> <name>public</name> <name>Action</name> <block>{
<expr><name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;



<expr><name>StringRef</name> <name>ArchName</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>BindArchAction</name><argument_list>(<argument>Action *Input</argument>, <argument>StringRef ArchName</argument>)</argument_list></macro></expr>;

<expr><name>StringRef</name> <macro><name>getArchName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ArchName</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>BindArchClass</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>OffloadAction</name> <name>final</name> <operator>:</operator> <name>public</name> <name>Action</name> <block>{
<expr><name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>


<name>class</name> <name>DeviceDependences</name> <name>final</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>using</name> <name>ToolChainList</name> <operator>=</operator> <name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ToolChain</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>BoundArchList</name> <operator>=</operator> <name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>OffloadKindList</name> <operator>=</operator> <name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>OffloadKind</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>private</name><operator>:</operator>






<name>ActionList</name> <name>DeviceActions</name></expr>;


<expr><name>ToolChainList</name> <name>DeviceToolChains</name></expr>;


<expr><name>BoundArchList</name> <name>DeviceBoundArchs</name></expr>;


<expr><name>OffloadKindList</name> <name>DeviceOffloadKinds</name></expr>;

<expr><name>public</name><operator>:</operator>


<name>void</name> <macro><name>add</name><argument_list>(<argument>Action &amp;A</argument>, <argument>const ToolChain &amp;TC</argument>, <argument>const char *BoundArch</argument>,
<argument>OffloadKind OKind</argument>)</argument_list></macro></expr>;


<expr><specifier>const</specifier> <name>ActionList</name> <operator>&amp;</operator><macro><name>getActions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DeviceActions</name></expr>;</return> }</block>
<specifier>const</specifier> <name>ToolChainList</name> <operator>&amp;</operator><macro><name>getToolChains</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DeviceToolChains</name></expr>;</return> }</block>
<specifier>const</specifier> <name>BoundArchList</name> <operator>&amp;</operator><macro><name>getBoundArchs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DeviceBoundArchs</name></expr>;</return> }</block>
<specifier>const</specifier> <name>OffloadKindList</name> <operator>&amp;</operator><macro><name>getOffloadKinds</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>DeviceOffloadKinds</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>HostDependence</name> <name>final</name> <block>{

<expr><name>Action</name> <operator>&amp;</operator><name>HostAction</name></expr>;


<expr><specifier>const</specifier> <name>ToolChain</name> <operator>&amp;</operator><name>HostToolChain</name></expr>;


<expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>HostBoundArch</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>unsigned</name> <name>HostOffloadKinds</name> <operator>=</operator> <literal type="number">0u</literal></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>HostDependence</name><argument_list>(<argument>Action &amp;A</argument>, <argument>const ToolChain &amp;TC</argument>, <argument>const char *BoundArch</argument>,
<argument>const unsigned OffloadKinds</argument>)</argument_list></macro>
<operator>:</operator> <call><name>HostAction</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>HostToolChain</name><argument_list>(<argument><expr><name>TC</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>HostBoundArch</name><argument_list>(<argument><expr><name>BoundArch</name></expr></argument>)</argument_list></call></expr>,
<macro><name>HostOffloadKinds</name><argument_list>(<argument>OffloadKinds</argument>)</argument_list></macro> <expr><block>{}</block>



<call><name>HostDependence</name><argument_list>(<argument><expr><name>Action</name> <operator>&amp;</operator><name>A</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ToolChain</name> <operator>&amp;</operator><name>TC</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>BoundArch</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>DeviceDependences</name> <operator>&amp;</operator><name>DDeps</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Action</name> <operator>*</operator><macro><name>getAction</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>&amp;</operator><name>HostAction</name></expr>;</return> }</block>
<specifier>const</specifier> <name>ToolChain</name> <operator>*</operator><macro><name>getToolChain</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>&amp;</operator><name>HostToolChain</name></expr>;</return> }</block>
<specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getBoundArch</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HostBoundArch</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>getOffloadKinds</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HostOffloadKinds</name></expr>;</return> }</block>
}</expr>;

<expr><name>using</name> <name>OffloadActionWorkTy</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>Action</name> <operator>*</operator>, <specifier>const</specifier> <name>ToolChain</name> <operator>*</operator>, <specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>private</name><operator>:</operator>

<specifier>const</specifier> <name>ToolChain</name> <operator>*</operator><name>HostTC</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>DeviceDependences</name><operator>::</operator><name>ToolChainList</name> <name>DevToolChains</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>OffloadAction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>HostDependence</name> <operator>&amp;</operator><name>HDep</name></expr></argument>)</argument_list></call></expr>;
<macro><name>OffloadAction</name><argument_list>(<argument>const DeviceDependences &amp;DDeps</argument>, <argument>types::ID Ty</argument>)</argument_list></macro>;
<expr><call><name>OffloadAction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>HostDependence</name> <operator>&amp;</operator><name>HDep</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>DeviceDependences</name> <operator>&amp;</operator><name>DDeps</name></expr></argument>)</argument_list></call></expr>;


<expr><name>void</name> <macro><name>doOnHostDependence</name><argument_list>(<argument>const OffloadActionWorkTy &amp;Work</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>void</name> <macro><name>doOnEachDeviceDependence</name><argument_list>(<argument>const OffloadActionWorkTy &amp;Work</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>void</name> <macro><name>doOnEachDependence</name><argument_list>(<argument>const OffloadActionWorkTy &amp;Work</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>void</name> <macro><name>doOnEachDependence</name><argument_list>(<argument>bool IsHostDependence</argument>,
<argument>const OffloadActionWorkTy &amp;Work</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>hasHostDependence</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>Action</name> <operator>*</operator><macro><name>getHostDependence</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>bool</name> <macro><name>hasSingleDeviceDependence</name><argument_list>(<argument>bool DoNotConsiderHostActions = false</argument>)</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>Action</name> <operator>*</operator>
<macro><name>getSingleDeviceDependence</name><argument_list>(<argument>bool DoNotConsiderHostActions = false</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OffloadClass</name></expr>;</return> }</block>
}</expr>;

<expr><name>class</name> <name>JobAction</name> <operator>:</operator> <name>public</name> <name>Action</name> <block>{
<expr><name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>JobAction</name><argument_list>(<argument>ActionClass Kind</argument>, <argument>Action *Input</argument>, <argument>types::ID Type</argument>)</argument_list></macro></expr>;
<macro><name>JobAction</name><argument_list>(<argument>ActionClass Kind</argument>, <argument>const ActionList &amp;Inputs</argument>, <argument>types::ID Type</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>(</operator><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>JobClassFirst</name> <operator>&amp;&amp;</operator>
<call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>JobClassLast</name><operator>)</operator></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>PreprocessJobAction</name> <operator>:</operator> <name>public</name> <name>JobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>PreprocessJobAction</name><argument_list>(<argument>Action *Input</argument>, <argument>types::ID OutputType</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PreprocessJobClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>PrecompileJobAction</name> <operator>:</operator> <name>public</name> <name>JobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>PrecompileJobAction</name><argument_list>(<argument>ActionClass Kind</argument>, <argument>Action *Input</argument>, <argument>types::ID OutputType</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>PrecompileJobAction</name><argument_list>(<argument>Action *Input</argument>, <argument>types::ID OutputType</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PrecompileJobClass</name> <operator>||</operator>
<call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>HeaderModulePrecompileJobClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>HeaderModulePrecompileJobAction</name> <operator>:</operator> <name>public</name> <name>PrecompileJobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>ModuleName</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>HeaderModulePrecompileJobAction</name><argument_list>(<argument>Action *Input</argument>, <argument>types::ID OutputType</argument>,
<argument>const char *ModuleName</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>HeaderModulePrecompileJobClass</name></expr>;</return>
}</block>

<name>void</name> <macro><name>addModuleHeaderInput</name><argument_list>(<argument>Action *Input</argument>)</argument_list></macro> <block>{
<expr><call><name>getInputs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>push_back</name><argument_list>(<argument><expr><name>Input</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getModuleName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ModuleName</name></expr>;</return> }</block>
}</expr>;

<expr><name>class</name> <name>AnalyzeJobAction</name> <operator>:</operator> <name>public</name> <name>JobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>AnalyzeJobAction</name><argument_list>(<argument>Action *Input</argument>, <argument>types::ID OutputType</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>AnalyzeJobClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>MigrateJobAction</name> <operator>:</operator> <name>public</name> <name>JobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>MigrateJobAction</name><argument_list>(<argument>Action *Input</argument>, <argument>types::ID OutputType</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>MigrateJobClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>CompileJobAction</name> <operator>:</operator> <name>public</name> <name>JobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>CompileJobAction</name><argument_list>(<argument>Action *Input</argument>, <argument>types::ID OutputType</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CompileJobClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>BackendJobAction</name> <operator>:</operator> <name>public</name> <name>JobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>BackendJobAction</name><argument_list>(<argument>Action *Input</argument>, <argument>types::ID OutputType</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>BackendJobClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>AssembleJobAction</name> <operator>:</operator> <name>public</name> <name>JobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>AssembleJobAction</name><argument_list>(<argument>Action *Input</argument>, <argument>types::ID OutputType</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>AssembleJobClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>IfsMergeJobAction</name> <operator>:</operator> <name>public</name> <name>JobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>IfsMergeJobAction</name><argument_list>(<argument>ActionList &amp;Inputs</argument>, <argument>types::ID Type</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>IfsMergeJobClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>LinkJobAction</name> <operator>:</operator> <name>public</name> <name>JobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>LinkJobAction</name><argument_list>(<argument>ActionList &amp;Inputs</argument>, <argument>types::ID Type</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>LinkJobClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>LipoJobAction</name> <operator>:</operator> <name>public</name> <name>JobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>LipoJobAction</name><argument_list>(<argument>ActionList &amp;Inputs</argument>, <argument>types::ID Type</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>LipoJobClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>DsymutilJobAction</name> <operator>:</operator> <name>public</name> <name>JobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>DsymutilJobAction</name><argument_list>(<argument>ActionList &amp;Inputs</argument>, <argument>types::ID Type</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DsymutilJobClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>VerifyJobAction</name> <operator>:</operator> <name>public</name> <name>JobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>VerifyJobAction</name><argument_list>(<argument>ActionClass Kind</argument>, <argument>Action *Input</argument>, <argument>types::ID Type</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>VerifyDebugInfoJobClass</name> <operator>||</operator>
<call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>VerifyPCHJobClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>VerifyDebugInfoJobAction</name> <operator>:</operator> <name>public</name> <name>VerifyJobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>VerifyDebugInfoJobAction</name><argument_list>(<argument>Action *Input</argument>, <argument>types::ID Type</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>VerifyDebugInfoJobClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>VerifyPCHJobAction</name> <operator>:</operator> <name>public</name> <name>VerifyJobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>VerifyPCHJobAction</name><argument_list>(<argument>Action *Input</argument>, <argument>types::ID Type</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>VerifyPCHJobClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>OffloadBundlingJobAction</name> <operator>:</operator> <name>public</name> <name>JobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>

<call><name>OffloadBundlingJobAction</name><argument_list>(<argument><expr><name>ActionList</name> <operator>&amp;</operator><name>Inputs</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OffloadBundlingJobClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>OffloadUnbundlingJobAction</name> <name>final</name> <operator>:</operator> <name>public</name> <name>JobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>


struct <name>DependentActionInfo</name> <name>final</name> <block>{

<expr><specifier>const</specifier> <name>ToolChain</name> <operator>*</operator><name>DependentToolChain</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>StringRef</name> <name>DependentBoundArch</name></expr>;


<expr><specifier>const</specifier> <name>OffloadKind</name> <name>DependentOffloadKind</name> <operator>=</operator> <name>OFK_None</name></expr>;

<macro><name>DependentActionInfo</name><argument_list>(<argument>const ToolChain *DependentToolChain</argument>,
<argument>StringRef DependentBoundArch</argument>,
<argument>const OffloadKind DependentOffloadKind</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>DependentToolChain</name><argument_list>(<argument><expr><name>DependentToolChain</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DependentBoundArch</name><argument_list>(<argument><expr><name>DependentBoundArch</name></expr></argument>)</argument_list></call></expr>,
<macro><name>DependentOffloadKind</name><argument_list>(<argument>DependentOffloadKind</argument>)</argument_list></macro> <expr><block>{}</block></expr>
}</block></expr>;

<expr><name>private</name><operator>:</operator>


<name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>DependentActionInfo</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>&gt;</argument_list></name> <name>DependentActionInfoArray</name></expr>;

<expr><name>public</name><operator>:</operator>

<call><name>OffloadUnbundlingJobAction</name><argument_list>(<argument><expr><name>Action</name> <operator>*</operator><name>Input</name></expr></argument>)</argument_list></call></expr>;


<expr><name>void</name> <macro><name>registerDependentActionInfo</name><argument_list>(<argument>const ToolChain *TC</argument>, <argument>StringRef BoundArch</argument>,
<argument>OffloadKind Kind</argument>)</argument_list></macro> <block>{
<macro><name>DependentActionInfoArray</name></macro><expr><operator>.</operator><macro><name>push_back</name><argument_list>(<argument>{TC</argument>, <argument>BoundArch</argument>, <argument>Kind}</argument>)</argument_list></macro></expr>;
}</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>DependentActionInfo</name></expr></argument>&gt;</argument_list></name> <macro><name>getDependentActionsInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>DependentActionInfoArray</name></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OffloadUnbundlingJobClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>OffloadWrapperJobAction</name> <operator>:</operator> <name>public</name> <name>JobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>OffloadWrapperJobAction</name><argument_list>(<argument>ActionList &amp;Inputs</argument>, <argument>types::ID Type</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OffloadWrapperJobClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>StaticLibJobAction</name> <operator>:</operator> <name>public</name> <name>JobAction</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>StaticLibJobAction</name><argument_list>(<argument>ActionList &amp;Inputs</argument>, <argument>types::ID Type</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Action *A</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>A</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>StaticLibJobClass</name></expr>;</return>
}</block>
}</expr>;

}</block></expr>
}</block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></range></decl></decl_stmt></block_content></block></decl></decl_stmt></block_content></block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
