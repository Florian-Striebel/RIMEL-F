<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Serialization/ASTWriter.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_SERIALIZATION_ASTWRITER_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_SERIALIZATION_ASTWRITER_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTMutationListener.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/Sema.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/SemaConsumer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Serialization/ASTBitCodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Serialization/ASTDeserializationListener.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Serialization/PCHContainerOperations.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/MapVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/STLExtras.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SetVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Bitstream/BitstreamWriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctime&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;queue&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>APFloat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>APInt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>APSInt</name></decl>;</decl_stmt>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTUnresolvedSet</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Attr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXBaseSpecifier</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXCtorInitializer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXRecordDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXTemporary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FileEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FPOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FPOptionsOverride</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>HeaderSearch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>HeaderSearchOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>IdentifierResolver</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LangOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MacroDefinitionRecord</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MacroInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Module</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>InMemoryModuleCache</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ModuleFileExtension</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ModuleFileExtensionWriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>NamedDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCInterfaceDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>PreprocessingRecord</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Preprocessor</name></decl>;</decl_stmt>
<struct_decl>struct <name>QualifierInfo</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>RecordDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Sema</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SourceManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Stmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>StoredDeclsList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SwitchCase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateParameterList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Token</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TypeSourceInfo</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>class</name></type> <name>ASTWriter</name> <range>: <expr><name>public</name> <name>ASTDeserializationListener</name></expr></range></decl>,
<decl><type ref="prev"/><name>public</name> <name>ASTMutationListener</name> <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclWriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTRecordWriter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>RecordData</name> <init>= <expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>RecordDataImpl</name> <init>= <expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>RecordDataRef</name> <init>= <expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<label><name>private</name>:</label>









<decl_stmt><decl><type><name>using</name></type> <name>TypeIdxMap</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><name>serialization</name><operator>::</operator><name>TypeIdx</name></expr></argument>,
<argument><expr><name>serialization</name><operator>::</operator><name>UnsafeQualTypeDenseMapInfo</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BitstreamWriter</name> <operator>&amp;</operator><name>Stream</name></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Buffer</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>InMemoryModuleCache</name> <modifier>&amp;</modifier></type><name>ModuleCache</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ASTContext</name> <modifier>*</modifier></type><name>Context</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Preprocessor</name> <modifier>*</modifier></type><name>PP</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ASTReader</name> <modifier>*</modifier></type><name>Chain</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>WritingModule</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>ASTBlockStartOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name> <name>ASTBlockRange</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>BaseDirectory</name></expr>;</expr_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>IncludeTimestamps</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>WritingAST</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>DoneWritingDeclsAndTypes</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>ASTHasCompilerErrors</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator></expr></argument>, <argument><expr><name>uint32_t</name></expr></argument>&gt;</argument_list></name> <name>InputFileIDs</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>DeclOrType</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>DeclOrType</name><argument_list>(<argument><expr><name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>Stored</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>IsType</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>
<macro><name>DeclOrType</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <operator>:</operator> <call><name>Stored</name><argument_list>(<argument><expr><call><name><name>T</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>IsType</name><argument_list>(<argument>true</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>isType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsType</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><name>IsType</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isType</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Not a type!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>QualType</name><operator>::</operator><call><name>getFromOpaquePtr</name><argument_list>(<argument><expr><name>Stored</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>Decl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isDecl</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Not a decl!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Stored</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>Stored</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>IsType</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>queue</name><argument_list type="generic">&lt;<argument><expr><name>DeclOrType</name></expr></argument>&gt;</argument_list></name> <name>DeclTypesToEmit</name></expr>;</expr_stmt>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>DeclID</name> <name>FirstDeclID</name> <operator>=</operator> <name>serialization</name><operator>::</operator><name>NUM_PREDEF_DECL_IDS</name></expr>;</expr_stmt>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>DeclID</name> <name>NextDeclID</name> <operator>=</operator> <name>FirstDeclID</name></expr>;</expr_stmt>







<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>&gt;</argument_list></name> <name>DeclIDs</name></expr>;</expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclOffset</name></expr></argument>&gt;</argument_list></name> <name>DeclOffsets</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>DeclTypesBlockStartOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>LocDeclIDsTy</name> <init>=
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<struct>struct <name>DeclIDInFileInfo</name> <block>{
<decl_stmt><decl><type><name>LocDeclIDsTy</name></type> <name>DeclIDs</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>FirstDeclIndex</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name>using</name></type> <name>FileDeclIDsTy</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>FileID</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>DeclIDInFileInfo</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>FileDeclIDsTy</name></type> <name>FileDeclIDs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>associateDeclWithFile</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>TypeID</name> <name>FirstTypeID</name> <operator>=</operator> <name>serialization</name><operator>::</operator><name>NUM_PREDEF_TYPE_IDS</name></expr>;</expr_stmt>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>TypeID</name> <name>NextTypeID</name> <operator>=</operator> <name>FirstTypeID</name></expr>;</expr_stmt>










<decl_stmt><decl><type><name>TypeIdxMap</name></type> <name>TypeIdxs</name></decl>;</decl_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>UnderalignedInt64</name></expr></argument>&gt;</argument_list></name> <name>TypeOffsets</name></expr>;</expr_stmt>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>IdentID</name> <name>FirstIdentID</name> <operator>=</operator> <name>serialization</name><operator>::</operator><name>NUM_PREDEF_IDENT_IDS</name></expr>;</expr_stmt>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>IdentID</name> <name>NextIdentID</name> <operator>=</operator> <name>FirstIdentID</name></expr>;</expr_stmt>







<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>serialization</name><operator>::</operator><name>IdentID</name></expr></argument>&gt;</argument_list></name> <name>IdentifierIDs</name></expr>;</expr_stmt>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>MacroID</name> <name>FirstMacroID</name> <operator>=</operator> <name>serialization</name><operator>::</operator><name>NUM_PREDEF_MACRO_IDS</name></expr>;</expr_stmt>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>MacroID</name> <name>NextMacroID</name> <operator>=</operator> <name>FirstMacroID</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>MacroInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>serialization</name><operator>::</operator><name>MacroID</name></expr></argument>&gt;</argument_list></name> <name>MacroIDs</name></expr>;</expr_stmt>

<struct>struct <name>MacroInfoToEmitData</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MacroInfo</name> <modifier>*</modifier></type><name>MI</name></decl>;</decl_stmt>
<expr_stmt><expr><name>serialization</name><operator>::</operator><name>MacroID</name> <name>ID</name></expr>;</expr_stmt>
}</block>;</struct>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>MacroInfoToEmitData</name></expr></argument>&gt;</argument_list></name> <name>MacroInfosToEmit</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>uint32_t</name></expr></argument>&gt;</argument_list></name>
<name>IdentMacroDirectivesOffsetMap</name></expr>;</expr_stmt>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseSet</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ParentStmts</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name> <name>SubStmtEntries</name></expr>;</expr_stmt>





<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>uint32_t</name></expr></argument>&gt;</argument_list></name> <name>IdentifierOffsets</name></expr>;</expr_stmt>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>SubmoduleID</name> <name>FirstSubmoduleID</name> <operator>=</operator>
<name>serialization</name><operator>::</operator><name>NUM_PREDEF_SUBMODULE_IDS</name></expr>;</expr_stmt>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>SubmoduleID</name> <name>NextSubmoduleID</name> <operator>=</operator> <name>FirstSubmoduleID</name></expr>;</expr_stmt>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>SelectorID</name> <name>FirstSelectorID</name> <operator>=</operator>
<name>serialization</name><operator>::</operator><name>NUM_PREDEF_SELECTOR_IDS</name></expr>;</expr_stmt>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>SelectorID</name> <name>NextSelectorID</name> <operator>=</operator> <name>FirstSelectorID</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>Selector</name></expr></argument>, <argument><expr><name>serialization</name><operator>::</operator><name>SelectorID</name></expr></argument>&gt;</argument_list></name> <name>SelectorIDs</name></expr>;</expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>uint32_t</name></expr></argument>&gt;</argument_list></name> <name>SelectorOffsets</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>MacroDefinitionRecord</name> <operator>*</operator></expr></argument>,
<argument><expr><name>serialization</name><operator>::</operator><name>PreprocessedEntityID</name></expr></argument>&gt;</argument_list></name> <name>MacroDefinitions</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>AnonymousDeclarationNumbers</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>DeclUpdate</name> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name></type> <name>Kind</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>Dcl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>Type</name></decl>;</decl_stmt>
<expr_stmt><expr><name>SourceLocation</name><operator>::</operator><name>UIntTy</name> <name>Loc</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>Val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>Mod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Attr</name> <modifier>*</modifier></type><name>Attribute</name></decl>;</decl_stmt>
}</block>;</union>

<label><name>public</name>:</label>
<macro><name>DeclUpdate</name><argument_list>(<argument>unsigned Kind</argument>)</argument_list></macro> : <expr_stmt><expr><call><name>Kind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Dcl</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{}</block>
<macro><name>DeclUpdate</name><argument_list>(<argument>unsigned Kind</argument>, <argument>const Decl *Dcl</argument>)</argument_list></macro> <operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Dcl</name><argument_list>(<argument>Dcl</argument>)</argument_list></macro> <expr><block>{}</block>
<macro><name>DeclUpdate</name><argument_list>(<argument>unsigned Kind</argument>, <argument>QualType Type</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Type</name><argument_list>(<argument>Type.getAsOpaquePtr()</argument>)</argument_list></macro> <expr><block>{}</block>
<macro><name>DeclUpdate</name><argument_list>(<argument>unsigned Kind</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Loc</name><argument_list>(<argument>Loc.getRawEncoding()</argument>)</argument_list></macro> <expr><block>{}</block>
<macro><name>DeclUpdate</name><argument_list>(<argument>unsigned Kind</argument>, <argument>unsigned Val</argument>)</argument_list></macro> <operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Val</name><argument_list>(<argument>Val</argument>)</argument_list></macro> <expr><block>{}</block>
<macro><name>DeclUpdate</name><argument_list>(<argument>unsigned Kind</argument>, <argument>Module *M</argument>)</argument_list></macro> <operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Mod</name><argument_list>(<argument>M</argument>)</argument_list></macro> <expr><block>{}</block>
<macro><name>DeclUpdate</name><argument_list>(<argument>unsigned Kind</argument>, <argument>const Attr *Attribute</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Attribute</name><argument_list>(<argument>Attribute</argument>)</argument_list></macro> <expr><block>{}</block>

<name>unsigned</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Dcl</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QualType</name><operator>::</operator><call><name>getFromOpaquePtr</name><argument_list>(<argument><expr><name>Type</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>SourceLocation</name><operator>::</operator><call><name>getFromRawEncoding</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>getNumber</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Val</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>Module</name> <operator>*</operator><macro><name>getModule</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Mod</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Attr</name> <operator>*</operator><macro><name>getAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Attribute</name></expr>;</return> }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>UpdateRecord</name> <init>= <expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>DeclUpdate</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>DeclUpdateMap</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>UpdateRecord</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>DeclUpdateMap</name></type> <name>DeclUpdates</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>FirstLatestDeclMap</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>FirstLatestDeclMap</name></type> <name>FirstLatestDecls</name></decl>;</decl_stmt>












<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>EagerlyDeserializedDecls</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>ModularCodegenDecls</name></decl>;</decl_stmt>








<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallSetVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>UpdatedDeclContexts</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>DeclsToEmitEvenIfUnreferenced</name></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SetVector</name><argument_list type="generic">&lt;<argument><expr><name>ObjCInterfaceDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ObjCClassesWithCategories</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Redeclarations</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>FirstLocalDeclCache</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>SwitchCase</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>SwitchCaseIDs</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumStatements</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumMacros</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumLexicalDeclContexts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumVisibleDeclContexts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Module</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>SubmoduleIDs</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ModuleFileExtensionWriter</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>ModuleFileExtensionWriters</name></expr>;</expr_stmt>


<function_decl><type><name>unsigned</name></type> <name>getSubmoduleID</name><parameter_list>(<parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>Mod</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>WriteSubStmt</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>WriteBlockInfoBlock</name><parameter_list>()</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>WriteControlBlock</name><argument_list>(<argument><expr><name>Preprocessor</name> <operator>&amp;</operator><name>PP</name></expr></argument>, <argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>,
<argument><expr><name>StringRef</name> <name>isysroot</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>OutputFile</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>ASTFileSignature</name></type> <name>writeUnhashedControlBlock</name><parameter_list>(<parameter><decl><type><name>Preprocessor</name> <modifier>&amp;</modifier></type><name>PP</name></decl></parameter>,
<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>ASTFileSignature</name></expr></argument>, <argument><expr><name>ASTFileSignature</name></expr></argument>&gt;</argument_list></name>
<macro><name>createSignature</name><argument_list>(<argument>StringRef AllBytes</argument>, <argument>StringRef ASTBlockBytes</argument>)</argument_list></macro></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>WriteInputFiles</name><parameter_list>(<parameter><decl><type><name>SourceManager</name> <modifier>&amp;</modifier></type><name>SourceMgr</name></decl></parameter>, <parameter><decl><type><name>HeaderSearchOptions</name> <modifier>&amp;</modifier></type><name>HSOpts</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Modules</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteSourceManagerBlock</name><parameter_list>(<parameter><decl><type><name>SourceManager</name> <modifier>&amp;</modifier></type><name>SourceMgr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Preprocessor</name> <modifier>&amp;</modifier></type><name>PP</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WritePreprocessor</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Preprocessor</name> <modifier>&amp;</modifier></type><name>PP</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsModule</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteHeaderSearch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>HeaderSearch</name> <modifier>&amp;</modifier></type><name>HS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WritePreprocessorDetail</name><parameter_list>(<parameter><decl><type><name>PreprocessingRecord</name> <modifier>&amp;</modifier></type><name>PPRec</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name></type> <name>MacroOffsetsBase</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteSubmodules</name><parameter_list>(<parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>WritingModule</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>WritePragmaDiagnosticMappings</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DiagnosticsEngine</name> <modifier>&amp;</modifier></type><name>Diag</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isModule</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>unsigned</name></type> <name>TypeExtQualAbbrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>TypeFunctionProtoAbbrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>WriteTypeAbbrevs</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>isLookupResultExternal</name><parameter_list>(<parameter><decl><type><name>StoredDeclsList</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isLookupResultEntirelyExternal</name><parameter_list>(<parameter><decl><type><name>StoredDeclsList</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>GenerateNameLookupTable</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><name>DC</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>LookupTable</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>uint64_t</name></type> <name>WriteDeclContextLexicalBlock</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>uint64_t</name></type> <name>WriteDeclContextVisibleBlock</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteTypeDeclOffsets</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteFileDeclIDsMap</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteComments</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteSelectors</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>SemaRef</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteReferencedSelectorsPool</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>SemaRef</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteIdentifierTable</name><parameter_list>(<parameter><decl><type><name>Preprocessor</name> <modifier>&amp;</modifier></type><name>PP</name></decl></parameter>, <parameter><decl><type><name>IdentifierResolver</name> <modifier>&amp;</modifier></type><name>IdResolver</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsModule</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteDeclUpdatesBlocks</name><parameter_list>(<parameter><decl><type><name>RecordDataImpl</name> <modifier>&amp;</modifier></type><name>OffsetsRecord</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteDeclContextVisibleUpdate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteFPPragmaOptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FPOptionsOverride</name> <modifier>&amp;</modifier></type><name>Opts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteOpenCLExtensions</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>SemaRef</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteCUDAPragmas</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>SemaRef</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteObjCCategories</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteLateParsedTemplates</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>SemaRef</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteOptimizePragmaOptions</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>SemaRef</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteMSStructPragmaOptions</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>SemaRef</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteMSPointersToMembersPragmaOptions</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>SemaRef</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WritePackPragmaOptions</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>SemaRef</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteFloatControlPragmaOptions</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>SemaRef</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteModuleFileExtension</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>SemaRef</name></decl></parameter>,
<parameter><decl><type><name>ModuleFileExtensionWriter</name> <modifier>&amp;</modifier></type><name>Writer</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>unsigned</name></type> <name>DeclParmVarAbbrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>DeclContextLexicalAbbrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>DeclContextVisibleLookupAbbrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>UpdateVisibleAbbrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>DeclRecordAbbrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>DeclTypedefAbbrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>DeclVarAbbrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>DeclFieldAbbrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>DeclEnumAbbrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>DeclObjCIvarAbbrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>DeclCXXMethodAbbrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>DeclRefExprAbbrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>CharacterLiteralAbbrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>IntegerLiteralAbbrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ExprImplicitCastAbbrev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>WriteDeclAbbrevs</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>WriteDecl</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>ASTFileSignature</name></type> <name>WriteASTCore</name><argument_list>(<argument><expr><name>Sema</name> <operator>&amp;</operator><name>SemaRef</name></expr></argument>, <argument><expr><name>StringRef</name> <name>isysroot</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>OutputFile</name></expr></argument>,
<argument><expr><name>Module</name> <operator>*</operator><name>WritingModule</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<label><name>public</name>:</label>


<macro><name>ASTWriter</name><argument_list>(<argument>llvm::BitstreamWriter &amp;Stream</argument>, <argument>SmallVectorImpl&lt;char&gt; &amp;Buffer</argument>,
<argument>InMemoryModuleCache &amp;ModuleCache</argument>,
<argument>ArrayRef&lt;std::shared_ptr&lt;ModuleFileExtension&gt;&gt; Extensions</argument>,
<argument>bool IncludeTimestamps = true</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><operator>~</operator><macro><name>ASTWriter</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ASTContext</name> <operator>&amp;</operator><macro><name>getASTContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Context</name> <operator>&amp;&amp;</operator> <literal type="string">"requested AST context when not writing AST"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>Context</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><macro><name>getLangOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<decl_stmt><decl><type><name>time_t</name></type> <name>getTimestampForOutput</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>















<decl_stmt><decl><type><name>ASTFileSignature</name></type> <name>WriteAST</name><argument_list>(<argument><expr><name>Sema</name> <operator>&amp;</operator><name>SemaRef</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>OutputFile</name></expr></argument>,
<argument><expr><name>Module</name> <operator>*</operator><name>WritingModule</name></expr></argument>, <argument><expr><name>StringRef</name> <name>isysroot</name></expr></argument>,
<argument><expr><name>bool</name> <name>hasErrors</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>bool</name> <name>ShouldCacheASTInMemory</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>AddToken</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>, <parameter><decl><type><name>RecordDataImpl</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>void</name></type> <name>AddAlignPackInfo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Sema</name><operator>::</operator><name>AlignPackInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>,
<argument><expr><name>RecordDataImpl</name> <operator>&amp;</operator><name>Record</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>AddSourceLocation</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>RecordDataImpl</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddSourceRange</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>, <parameter><decl><type><name>RecordDataImpl</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddIdentifierRef</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>RecordDataImpl</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>SelectorID</name> <macro><name>getSelectorRef</name><argument_list>(<argument>Selector Sel</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>IdentID</name> <call><name>getIdentifierRef</name><argument_list>(<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>II</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>MacroID</name> <call><name>getMacroRef</name><argument_list>(<argument><expr><name>MacroInfo</name> <operator>*</operator><name>MI</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>Name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>MacroID</name> <call><name>getMacroID</name><argument_list>(<argument><expr><name>MacroInfo</name> <operator>*</operator><name>MI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>uint32_t</name></type> <name>getMacroDirectivesOffset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddTypeRef</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>RecordDataImpl</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>TypeID</name> <macro><name>GetOrCreateTypeID</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>TypeID</name> <macro><name>getTypeID</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<function_decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>getFirstLocalDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>




<function><type><name>bool</name></type> <name>IsLocalDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>isFromASTFile</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>auto</name></type> <name>I</name> <init>= <expr><call><name><name>DeclIDs</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>I</name> <operator>==</operator> <call><name><name>DeclIDs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<name><name>I</name><operator>-&gt;</operator><name>second</name></name> <operator>&gt;=</operator> <name>serialization</name><operator>::</operator><name>NUM_PREDEF_DECL_IDS</name><operator>)</operator></expr>;</return>
</block_content>}</block></function><empty_stmt>;</empty_stmt>


<function_decl><type><name>void</name></type> <name>AddDeclRef</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>RecordDataImpl</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>DeclID</name> <call><name>GetDeclRef</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>serialization</name><operator>::</operator><name>DeclID</name> <call><name>getDeclID</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>unsigned</name></type> <name>getAnonymousDeclarationNumber</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddString</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Str</name></decl></parameter>, <parameter><decl><type><name>RecordDataImpl</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>PreparePathForOutput</name><parameter_list>(<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Path</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddPath</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Path</name></decl></parameter>, <parameter><decl><type><name>RecordDataImpl</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitRecordWithPath</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Abbrev</name></decl></parameter>, <parameter><decl><type><name>RecordDataRef</name></type> <name>Record</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Path</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddVersionTuple</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VersionTuple</name> <modifier>&amp;</modifier></type><name>Version</name></decl></parameter>, <parameter><decl><type><name>RecordDataImpl</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>unsigned</name></type> <name>getLocalOrImportedSubmoduleID</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Module</name> <modifier>*</modifier></type><name>Mod</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>SetIdentifierOffset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Offset</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>SetSelectorOffset</name><parameter_list>(<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Offset</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>unsigned</name></type> <name>RecordSwitchCaseID</name><parameter_list>(<parameter><decl><type><name>SwitchCase</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>unsigned</name></type> <name>getSwitchCaseID</name><parameter_list>(<parameter><decl><type><name>SwitchCase</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ClearSwitchCaseIDs</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>unsigned</name> <macro><name>getTypeExtQualAbbrev</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TypeExtQualAbbrev</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>getTypeFunctionProtoAbbrev</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TypeFunctionProtoAbbrev</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>getDeclParmVarAbbrev</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DeclParmVarAbbrev</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getDeclRecordAbbrev</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DeclRecordAbbrev</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getDeclTypedefAbbrev</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DeclTypedefAbbrev</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getDeclVarAbbrev</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DeclVarAbbrev</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getDeclFieldAbbrev</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DeclFieldAbbrev</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getDeclEnumAbbrev</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DeclEnumAbbrev</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getDeclObjCIvarAbbrev</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DeclObjCIvarAbbrev</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getDeclCXXMethodAbbrev</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DeclCXXMethodAbbrev</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>getDeclRefExprAbbrev</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DeclRefExprAbbrev</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getCharacterLiteralAbbrev</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CharacterLiteralAbbrev</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getIntegerLiteralAbbrev</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IntegerLiteralAbbrev</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getExprImplicitCastAbbrev</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ExprImplicitCastAbbrev</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasChain</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Chain</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>ASTReader</name> <operator>*</operator><macro><name>getChain</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Chain</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>void</name></type> <name>ReaderInitialized</name><argument_list>(<argument><expr><name>ASTReader</name> <operator>*</operator><name>Reader</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>IdentifierRead</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>IdentID</name> <name>ID</name></expr></argument>, <argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>II</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>MacroRead</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>MacroID</name> <name>ID</name></expr></argument>, <argument><expr><name>MacroInfo</name> <operator>*</operator><name>MI</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>TypeRead</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>TypeIdx</name> <name>Idx</name></expr></argument>, <argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>SelectorRead</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>SelectorID</name> <name>ID</name></expr></argument>, <argument><expr><name>Selector</name> <name>Sel</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>MacroDefinitionRead</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>PreprocessedEntityID</name> <name>ID</name></expr></argument>,
<argument><expr><name>MacroDefinitionRecord</name> <operator>*</operator><name>MD</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>ModuleRead</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>SubmoduleID</name> <name>ID</name></expr></argument>, <argument><expr><name>Module</name> <operator>*</operator><name>Mod</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>CompletedTagDefinition</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TagDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>AddedVisibleDecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><name>DC</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>AddedCXXImplicitMember</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>AddedCXXTemplateSpecialization</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>ClassTemplateDecl</name> <operator>*</operator><name>TD</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ClassTemplateSpecializationDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>AddedCXXTemplateSpecialization</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>VarTemplateDecl</name> <operator>*</operator><name>TD</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>VarTemplateSpecializationDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>AddedCXXTemplateSpecialization</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionTemplateDecl</name> <operator>*</operator><name>TD</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>ResolvedExceptionSpec</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>FD</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>DeducedReturnType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>FD</name></expr></argument>, <argument><expr><name>QualType</name> <name>ReturnType</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>ResolvedOperatorDelete</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXDestructorDecl</name> <operator>*</operator><name>DD</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>Delete</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>ThisArg</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>CompletedImplicitDefinition</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>InstantiationRequested</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>VariableDefinitionInstantiated</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>FunctionDefinitionInstantiated</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>DefaultArgumentInstantiated</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ParmVarDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>DefaultMemberInitializerInstantiated</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>AddedObjCCategoryToInterface</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCCategoryDecl</name> <operator>*</operator><name>CatD</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><name>IFD</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>DeclarationMarkedUsed</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>DeclarationMarkedOpenMPThreadPrivate</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>DeclarationMarkedOpenMPDeclareTarget</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Attr</name> <operator>*</operator><name>Attr</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>DeclarationMarkedOpenMPAllocate</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Attr</name> <operator>*</operator><name>A</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>RedefinedHiddenDefinition</name><argument_list>(<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>Module</name> <operator>*</operator><name>M</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>AddedAttributeToRecord</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Attr</name> <operator>*</operator><name>Attr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>RecordDecl</name> <operator>*</operator><name>Record</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>PCHGenerator</name> <range>: <expr><name>public</name> <name>SemaConsumer</name> <block>{
<expr><specifier>const</specifier> <name>Preprocessor</name> <operator>&amp;</operator><name>PP</name></expr>;
<expr><name>std</name><operator>::</operator><name>string</name> <name>OutputFile</name></expr>;
<expr><name>std</name><operator>::</operator><name>string</name> <name>isysroot</name></expr>;
<expr><name>Sema</name> <operator>*</operator><name>SemaPtr</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PCHBuffer</name></expr></argument>&gt;</argument_list></name> <name>Buffer</name></expr>;
<expr><name>llvm</name><operator>::</operator><name>BitstreamWriter</name> <name>Stream</name></expr>;
<expr><name>ASTWriter</name> <name>Writer</name></expr>;
<expr><name>bool</name> <name>AllowASTWithErrors</name></expr>;
<expr><name>bool</name> <name>ShouldCacheASTInMemory</name></expr>;

<expr><name>protected</name><operator>:</operator>
<name>ASTWriter</name> <operator>&amp;</operator><macro><name>getWriter</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Writer</name></expr>;</return> }</block>
<specifier>const</specifier> <name>ASTWriter</name> <operator>&amp;</operator><macro><name>getWriter</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Writer</name></expr>;</return> }</block>
<name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><macro><name>getPCH</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Buffer</name><operator>-&gt;</operator><name>Data</name></name></expr>;</return> }</block>

<name>public</name><operator>:</operator>
<macro><name>PCHGenerator</name><argument_list>(<argument>const Preprocessor &amp;PP</argument>, <argument>InMemoryModuleCache &amp;ModuleCache</argument>,
<argument>StringRef OutputFile</argument>, <argument>StringRef isysroot</argument>,
<argument>std::shared_ptr&lt;PCHBuffer&gt; Buffer</argument>,
<argument>ArrayRef&lt;std::shared_ptr&lt;ModuleFileExtension&gt;&gt; Extensions</argument>,
<argument>bool AllowASTWithErrors = false</argument>, <argument>bool IncludeTimestamps = true</argument>,
<argument>bool ShouldCacheASTInMemory = false</argument>)</argument_list></macro></expr>;
<expr><operator>~</operator><macro><name>PCHGenerator</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>void</name> <macro><name>InitializeSema</name><argument_list>(<argument>Sema &amp;S</argument>)</argument_list></macro> <name>override</name> <block>{ <expr><name>SemaPtr</name> <operator>=</operator> <operator>&amp;</operator><name>S</name></expr>; }</block>
<name>void</name> <macro><name>HandleTranslationUnit</name><argument_list>(<argument>ASTContext &amp;Ctx</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>ASTMutationListener</name> <operator>*</operator><macro><name>GetASTMutationListener</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>ASTDeserializationListener</name> <operator>*</operator><macro><name>GetASTDeserializationListener</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>hasEmittedPCH</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Buffer</name><operator>-&gt;</operator><name>IsComplete</name></name></expr>;</return> }</block>
}</expr>;

}</block></expr></range></decl></decl_stmt></block_content></block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
