<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h">










































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_ASTMATCHERS_ASTMATCHERS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_ASTMATCHERS_ASTMATCHERS_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTTypeTraits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Attr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/CXXInheritance.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclFriend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclTemplate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/LambdaCapture.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/NestedNameSpecifier.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/OpenMPClause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/OperationKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ParentMapContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Stmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtOpenMP.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TemplateBase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TemplateName.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeLoc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/ASTMatchers/ASTMatchersInternal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/ASTMatchers/ASTMatchersMacros.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/AttrKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/ExceptionSpecificationType.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/FileManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/IdentifierTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Specifiers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TypeTraits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/ErrorHandling.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Regex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iterator&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>ast_matchers</name> <block>{<block_content>








<decl_stmt><decl><type><name>class</name></type> <name>BoundNodes</name> <block>{<block_content>
<label><name>public</name>:</label>




<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>const</specifier> <name>T</name> <modifier>*</modifier></type><name>getNodeAs</name><argument_list>(<argument><expr><name>StringRef</name> <name>ID</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name><name>MyBoundNodes</name><operator>.</operator><name>getNodeAs</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>ID</name><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name>using</name></type> <name>IDToNodeMap</name> <init>= <expr><name>internal</name><operator>::</operator><name>BoundNodesMap</name><operator>::</operator><name>IDToNodeMap</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>IDToNodeMap</name> <operator>&amp;</operator><macro><name>getMap</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>MyBoundNodes</name><operator>.</operator><name>getMap</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>BoundNodesTreeBuilder</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>BoundNodes</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><name>BoundNodesMap</name> <operator>&amp;</operator><name>MyBoundNodes</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>MyBoundNodes</name><argument_list>(<argument>MyBoundNodes</argument>)</argument_list></macro> <block>{}</block>

<name>internal</name><operator>::</operator><name>BoundNodesMap</name> <name>MyBoundNodes</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<decl_stmt><decl><type><name>using</name></type> <name>DeclarationMatcher</name> <init>= <expr><name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>StatementMatcher</name> <init>= <expr><name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>TypeMatcher</name> <init>= <expr><name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>TypeLocMatcher</name> <init>= <expr><name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>TypeLoc</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>NestedNameSpecifierMatcher</name> <init>= <expr><name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>NestedNameSpecifier</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>NestedNameSpecifierLocMatcher</name> <init>= <expr><name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>NestedNameSpecifierLoc</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>CXXBaseSpecifierMatcher</name> <init>= <expr><name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>CXXBaseSpecifier</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>CXXCtorInitializerMatcher</name> <init>= <expr><name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>CXXCtorInitializer</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>TemplateArgumentMatcher</name> <init>= <expr><name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>TemplateArgumentLocMatcher</name> <init>= <expr><name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
















<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name>TrueMatcher</name> <macro><name>anything</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>internal</name><operator>::</operator><call><name>TrueMatcher</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>












<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> TranslationUnitDecl&gt;
translationUnitDecl;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> TypedefDecl&gt;
typedefDecl;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> TypedefNameDecl&gt;
typedefNameDecl;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> TypeAliasDecl&gt;
typeAliasDecl;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> TypeAliasTemplateDecl&gt;
typeAliasTemplateDecl;</extern>















<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(<argument>isExpansionInMainFile</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(Decl, Stmt, TypeLoc)</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>auto</name> <operator>&amp;</operator><name>SourceManager</name> <operator>=</operator> <call><name><name>Finder</name><operator>-&gt;</operator><name>getASTContext</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSourceManager</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>SourceManager</name><operator>.</operator><name>isInMainFile</name></name><argument_list>(
<argument><expr><call><name><name>SourceManager</name><operator>.</operator><name>getExpansionLoc</name></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>















<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(<argument>isExpansionInSystemHeader</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(Decl, Stmt, TypeLoc)</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>auto</name> <operator>&amp;</operator><name>SourceManager</name> <operator>=</operator> <call><name><name>Finder</name><operator>-&gt;</operator><name>getASTContext</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSourceManager</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>auto</name></type> <name>ExpansionLoc</name> <init>= <expr><call><name><name>SourceManager</name><operator>.</operator><name>getExpansionLoc</name></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>ExpansionLoc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name><name>SourceManager</name><operator>.</operator><name>isInSystemHeader</name></name><argument_list>(<argument><expr><name>ExpansionLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>
















<macro><name>AST_POLYMORPHIC_MATCHER_REGEX</name><argument_list>(<argument>isExpansionInFileMatching</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(Decl, Stmt,
TypeLoc)</argument>,
<argument>RegExp</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>auto</name> <operator>&amp;</operator><name>SourceManager</name> <operator>=</operator> <call><name><name>Finder</name><operator>-&gt;</operator><name>getASTContext</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSourceManager</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>auto</name></type> <name>ExpansionLoc</name> <init>= <expr><call><name><name>SourceManager</name><operator>.</operator><name>getExpansionLoc</name></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>ExpansionLoc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>auto</name></type> <name>FileEntry</name> <init>=
<expr><call><name><name>SourceManager</name><operator>.</operator><name>getFileEntryForID</name></name><argument_list>(<argument><expr><call><name><name>SourceManager</name><operator>.</operator><name>getFileID</name></name><argument_list>(<argument><expr><name>ExpansionLoc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>FileEntry</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>auto</name></type> <name>Filename</name> <init>= <expr><call><name><name>FileEntry</name><operator>-&gt;</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>RegExp</name><operator>-&gt;</operator><name>match</name></name><argument_list>(<argument><expr><name>Filename</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>





<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(<argument>isExpandedFromMacro</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(Decl, Stmt, TypeLoc)</argument>,
<argument>std::string</argument>, <argument>MacroName</argument>)</argument_list></macro> <block>{<block_content>


<expr_stmt><expr><name>auto</name><operator>&amp;</operator> <name>Context</name> <operator>=</operator> <call><name><name>Finder</name><operator>-&gt;</operator><name>getASTContext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <name>B</name> <operator>=</operator>
<name>internal</name><operator>::</operator><call><name>getExpansionLocOfMacro</name><argument_list>(<argument><expr><name>MacroName</name></expr></argument>, <argument><expr><call><name><name>Node</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>B</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <name>E</name> <operator>=</operator>
<name>internal</name><operator>::</operator><call><name>getExpansionLocOfMacro</name><argument_list>(<argument><expr><name>MacroName</name></expr></argument>, <argument><expr><call><name><name>Node</name><operator>.</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>E</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>*</operator><name>B</name> <operator>==</operator> <operator>*</operator><name>E</name></expr>;</return>
</block_content>}</block>










<extern>extern const internal::VariadicAllOfMatcher&lt;Decl&gt; decl;</extern>











<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> DecompositionDecl&gt;
decompositionDecl;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> BindingDecl&gt;
bindingDecl;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> LinkageSpecDecl&gt;
linkageSpecDecl;</extern>












<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> NamedDecl&gt; namedDecl;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> LabelDecl&gt; labelDecl;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> NamespaceDecl&gt;
namespaceDecl;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> NamespaceAliasDecl&gt;
namespaceAliasDecl;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> RecordDecl&gt; recordDecl;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> CXXRecordDecl&gt;
cxxRecordDecl;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> ClassTemplateDecl&gt;
classTemplateDecl;</extern>











<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;
Decl<operator>,</operator> ClassTemplateSpecializationDecl&gt;
classTemplateSpecializationDecl;</extern>
















<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;
Decl<operator>,</operator> ClassTemplatePartialSpecializationDecl&gt;
classTemplatePartialSpecializationDecl;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> DeclaratorDecl&gt;
declaratorDecl;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> ParmVarDecl&gt;
parmVarDecl;</extern>












<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> AccessSpecDecl&gt;
accessSpecDecl;</extern>








<extern>extern const internal::VariadicAllOfMatcher&lt;CXXBaseSpecifier&gt; cxxBaseSpecifier;</extern>










<extern>extern const internal::VariadicAllOfMatcher&lt;CXXCtorInitializer&gt;
cxxCtorInitializer;</extern>










<extern>extern const internal::VariadicAllOfMatcher&lt;TemplateArgument&gt; templateArgument;</extern>










<extern>extern const internal::VariadicAllOfMatcher&lt;TemplateArgumentLoc&gt;
templateArgumentLoc;</extern>










<extern>extern const internal::VariadicAllOfMatcher&lt;TemplateName&gt; templateName;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator>
NonTypeTemplateParmDecl&gt;
nonTypeTemplateParmDecl;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> TemplateTypeParmDecl&gt;
templateTypeParmDecl;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator>
TemplateTemplateParmDecl&gt;
templateTemplateParmDecl;</extern>


















<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(<argument>isPublic</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(Decl,
CXXBaseSpecifier)</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name>getAccessSpecifier</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AS_public</name></expr>;</return>
</block_content>}</block>

















<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(<argument>isProtected</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(Decl,
CXXBaseSpecifier)</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name>getAccessSpecifier</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AS_protected</name></expr>;</return>
</block_content>}</block>


















<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(<argument>isPrivate</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(Decl,
CXXBaseSpecifier)</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name>getAccessSpecifier</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AS_private</name></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER</name><argument_list>(<argument>FieldDecl</argument>, <argument>isBitField</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isBitField</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>














<macro><name>AST_MATCHER_P</name><argument_list>(<argument>FieldDecl</argument>, <argument>hasBitWidth</argument>, <argument>unsigned</argument>, <argument>Width</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isBitField</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Node</name><operator>.</operator><name>getBitWidthValue</name></name><argument_list>(<argument><expr><call><name><name>Finder</name><operator>-&gt;</operator><name>getASTContext</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>Width</name></expr>;</return>
</block_content>}</block>















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>FieldDecl</argument>, <argument>hasInClassInitializer</argument>, <argument>internal::Matcher&lt;Expr&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Initializer</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getInClassInitializer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>Initializer</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Initializer</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>



<macro><name>AST_MATCHER</name><argument_list>(<argument>FunctionDecl</argument>, <argument>isMain</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isMain</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER_P</name><argument_list>(<argument>ClassTemplateSpecializationDecl</argument>, <argument>hasSpecializedTemplate</argument>,
<argument>internal::Matcher&lt;ClassTemplateDecl&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ClassTemplateDecl</name><modifier>*</modifier></type> <name>Decl</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getSpecializedTemplate</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>Decl</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Decl</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>



<macro><name>AST_MATCHER</name><argument_list>(<argument>Decl</argument>, <argument>isImplicit</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isImplicit</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>






















<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(
<argument>hasAnyTemplateArgument</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(ClassTemplateSpecializationDecl,
TemplateSpecializationType,
FunctionDecl)</argument>,
<argument>internal::Matcher&lt;TemplateArgument&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name></type> <name>List</name> <init>=
<expr><name>internal</name><operator>::</operator><call><name>getTemplateSpecializationArgs</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>matchesFirstInRange</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><call><name><name>List</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>List</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>,
<argument><expr><name>Builder</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name><name>List</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>

















<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>traverse</name><argument_list>(<argument>TraversalKind TK</argument>,
<argument>const internal::Matcher&lt;T&gt; &amp;InnerMatcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><name>DynTypedMatcher</name><operator>::</operator><macro><name>constructRestrictedWrapper</name><argument_list>(
<argument>new internal::TraversalMatcher&lt;T&gt;(TK, InnerMatcher)</argument>,
<argument>InnerMatcher.getID().first</argument>)</argument_list></macro>
<operator>.</operator><name>template</name> <call><name><name>unconditionalConvertTo</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>internal</name><operator>::</operator><name><name>BindableMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name>
<macro><name>traverse</name><argument_list>(<argument>TraversalKind TK</argument>, <argument>const internal::BindableMatcher&lt;T&gt; &amp;InnerMatcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><macro><name>BindableMatcher</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator>
<name>internal</name><operator>::</operator><name>DynTypedMatcher</name><operator>::</operator><macro><name>constructRestrictedWrapper</name><argument_list>(
<argument>new internal::TraversalMatcher&lt;T&gt;(TK, InnerMatcher)</argument>,
<argument>InnerMatcher.getID().first</argument>)</argument_list></macro>
<operator>.</operator><name>template</name> <call><name><name>unconditionalConvertTo</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>internal</name><operator>::</operator><name><name>TraversalWrapper</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>VariadicOperatorMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<macro><name>traverse</name><argument_list>(<argument>TraversalKind TK</argument>,
<argument>const internal::VariadicOperatorMatcher&lt;T...&gt; &amp;InnerMatcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>TraversalWrapper</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>VariadicOperatorMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>TK</name></expr></argument>, <argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ToArg</name></expr></argument>, <argument><expr><name>typename</name> <name>FromArg</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>ArgumentAdapterT</name></expr></argument>,
<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>ToTypes</name></expr></argument>&gt;</argument_list></name>
<name>internal</name><operator>::</operator><name><name>TraversalWrapper</name><argument_list type="generic">&lt;
<argument><expr><name>internal</name><operator>::</operator><name><name>ArgumentAdaptingMatcherFuncAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>ArgumentAdapterT</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>ToTypes</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<macro><name>traverse</name><argument_list>(<argument>TraversalKind TK</argument>, <argument>const internal::ArgumentAdaptingMatcherFuncAdaptor&lt;
ArgumentAdapterT</argument>, <argument>T</argument>, <argument>ToTypes&gt; &amp;InnerMatcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>TraversalWrapper</name><argument_list type="generic">&lt;
<argument><expr><name>internal</name><operator>::</operator><name><name>ArgumentAdaptingMatcherFuncAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>ArgumentAdapterT</name></expr></argument>, <argument><expr><name>T</name></expr></argument>,
<argument><expr><name>ToTypes</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TK</name></expr></argument>, <argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>P</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>MatcherT</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>P</name></expr></argument>,
<argument><expr><name>typename</name> <name>ReturnTypesF</name></expr></argument>&gt;</argument_list></name>
<name>internal</name><operator>::</operator><name><name>TraversalWrapper</name><argument_list type="generic">&lt;
<argument><expr><name>internal</name><operator>::</operator><name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>MatcherT</name></expr></argument>, <argument><expr><name>ReturnTypesF</name></expr></argument>, <argument><expr><name>P</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<macro><name>traverse</name><argument_list>(<argument>TraversalKind TK</argument>,
<argument>const internal::PolymorphicMatcher&lt;MatcherT</argument>, <argument>ReturnTypesF</argument>, <argument>P...&gt;
&amp;InnerMatcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>TraversalWrapper</name><argument_list type="generic">&lt;
<argument><expr><name>internal</name><operator>::</operator><name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>MatcherT</name></expr></argument>, <argument><expr><name>ReturnTypesF</name></expr></argument>, <argument><expr><name>P</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TK</name></expr></argument>,
<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>GetClade</name><argument_list type="generic">&lt;<argument><expr><name>T</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Type</name></expr></argument>&gt;</argument_list></name>
<macro><name>traverse</name><argument_list>(<argument>TraversalKind TK</argument>, <argument>const internal::MapAnyOfHelper&lt;T...&gt; &amp;InnerMatcher</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>traverse</name><argument_list>(<argument><expr><name>TK</name></expr></argument>, <argument><expr><call><name><name>InnerMatcher</name><operator>.</operator><name>with</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>






















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>Expr</argument>, <argument>ignoringImplicit</argument>, <argument>internal::Matcher&lt;Expr&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>IgnoreImplicit</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>


























<macro><name>AST_MATCHER_P</name><argument_list>(<argument>Expr</argument>, <argument>ignoringImpCasts</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>IgnoreImpCasts</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>


















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>Expr</argument>, <argument>ignoringParenCasts</argument>, <argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>IgnoreParenCasts</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>






















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>Expr</argument>, <argument>ignoringParenImpCasts</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>IgnoreParenImpCasts</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER_P_OVERLOAD</name><argument_list>(<argument>QualType</argument>, <argument>ignoringParens</argument>, <argument>internal::Matcher&lt;QualType&gt;</argument>,
<argument>InnerMatcher</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>IgnoreParens</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER_P_OVERLOAD</name><argument_list>(<argument>Expr</argument>, <argument>ignoringParens</argument>, <argument>internal::Matcher&lt;Expr&gt;</argument>,
<argument>InnerMatcher</argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>IgnoreParens</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>E</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>














<macro><name>AST_MATCHER</name><argument_list>(<argument>Expr</argument>, <argument>isInstantiationDependent</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isInstantiationDependent</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>













<macro><name>AST_MATCHER</name><argument_list>(<argument>Expr</argument>, <argument>isTypeDependent</argument>)</argument_list></macro> <block>{<block_content> <return>return <expr><call><name><name>Node</name><operator>.</operator><name>isTypeDependent</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block>










<macro><name>AST_MATCHER</name><argument_list>(<argument>Expr</argument>, <argument>isValueDependent</argument>)</argument_list></macro> <block>{<block_content> <return>return <expr><call><name><name>Node</name><operator>.</operator><name>isValueDependent</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block>



















<macro><name>AST_POLYMORPHIC_MATCHER_P2</name><argument_list>(
<argument>hasTemplateArgument</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(ClassTemplateSpecializationDecl,
TemplateSpecializationType,
FunctionDecl)</argument>,
<argument>unsigned</argument>, <argument>N</argument>, <argument>internal::Matcher&lt;TemplateArgument&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name></type> <name>List</name> <init>=
<expr><name>internal</name><operator>::</operator><call><name>getTemplateSpecializationArgs</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>List</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>N</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><name><name>List</name><index>[<expr><name>N</name></expr>]</index></name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>










<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(
<argument>templateArgumentCountIs</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(ClassTemplateSpecializationDecl,
TemplateSpecializationType)</argument>,
<argument>unsigned</argument>, <argument>N</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><name>internal</name><operator>::</operator><call><name>getTemplateSpecializationArgs</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <name>N</name></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER_P</name><argument_list>(<argument>TemplateArgument</argument>, <argument>refersToType</argument>,
<argument>internal::Matcher&lt;QualType&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Node</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>TemplateArgument</name><operator>::</operator><name>Type</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getAsType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER_P</name><argument_list>(<argument>TemplateArgument</argument>, <argument>refersToTemplate</argument>,
<argument>internal::Matcher&lt;TemplateName&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Node</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>TemplateArgument</name><operator>::</operator><name>Template</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getAsTemplate</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>














<macro><name>AST_MATCHER_P</name><argument_list>(<argument>TemplateArgument</argument>, <argument>refersToDeclaration</argument>,
<argument>internal::Matcher&lt;Decl&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Node</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>TemplateArgument</name><operator>::</operator><name>Declaration</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>getAsDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>













<macro><name>AST_MATCHER_P</name><argument_list>(<argument>TemplateArgument</argument>, <argument>isExpr</argument>, <argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Node</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>TemplateArgument</name><operator>::</operator><name>Expression</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>getAsExpr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER</name><argument_list>(<argument>TemplateArgument</argument>, <argument>isIntegral</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>TemplateArgument</name><operator>::</operator><name>Integral</name></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER_P</name><argument_list>(<argument>TemplateArgument</argument>, <argument>refersToIntegralType</argument>,
<argument>internal::Matcher&lt;QualType&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Node</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>TemplateArgument</name><operator>::</operator><name>Integral</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getIntegralType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>TemplateArgument</argument>, <argument>equalsIntegralValue</argument>,
<argument>std::string</argument>, <argument>Value</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Node</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>TemplateArgument</name><operator>::</operator><name>Integral</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>toString</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getAsIntegral</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>Value</name></expr>;</return>
</block_content>}</block>











<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator>
ObjCAutoreleasePoolStmt&gt; autoreleasePoolStmt;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> ValueDecl&gt; valueDecl;</extern>












<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> CXXConstructorDecl&gt;
cxxConstructorDecl;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> CXXDestructorDecl&gt;
cxxDestructorDecl;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> EnumDecl&gt; enumDecl;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> EnumConstantDecl&gt;
enumConstantDecl;</extern>













<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> TagDecl&gt; tagDecl;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> CXXMethodDecl&gt;
cxxMethodDecl;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> CXXConversionDecl&gt;
cxxConversionDecl;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> CXXDeductionGuideDecl&gt;
cxxDeductionGuideDecl;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> VarDecl&gt; varDecl;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> FieldDecl&gt; fieldDecl;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> IndirectFieldDecl&gt;
indirectFieldDecl;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> FunctionDecl&gt;
functionDecl;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> FunctionTemplateDecl&gt;
functionTemplateDecl;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> FriendDecl&gt; friendDecl;</extern>









<extern>extern const internal::VariadicAllOfMatcher&lt;Stmt&gt; stmt;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> DeclStmt&gt; declStmt;</extern>












<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> MemberExpr&gt; memberExpr;</extern>













<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> UnresolvedMemberExpr&gt;
unresolvedMemberExpr;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator>
CXXDependentScopeMemberExpr&gt;
cxxDependentScopeMemberExpr;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CallExpr&gt; callExpr;</extern>





















<macro><name>AST_MATCHER</name><argument_list>(<argument>CallExpr</argument>, <argument>usesADL</argument>)</argument_list></macro> <block>{<block_content> <return>return <expr><call><name><name>Node</name><operator>.</operator><name>usesADL</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> LambdaExpr&gt; lambdaExpr;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXMemberCallExpr&gt;
cxxMemberCallExpr;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ObjCMessageExpr&gt;
objcMessageExpr;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> ObjCInterfaceDecl&gt;
objcInterfaceDecl;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> ObjCImplementationDecl&gt;
objcImplementationDecl;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> ObjCProtocolDecl&gt;
objcProtocolDecl;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> ObjCCategoryDecl&gt;
objcCategoryDecl;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> ObjCCategoryImplDecl&gt;
objcCategoryImplDecl;</extern>













<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> ObjCMethodDecl&gt;
objcMethodDecl;</extern>











<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> BlockDecl&gt;
blockDecl;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> ObjCIvarDecl&gt;
objcIvarDecl;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> ObjCPropertyDecl&gt;
objcPropertyDecl;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ObjCAtThrowStmt&gt;
objcThrowStmt;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ObjCAtTryStmt&gt;
objcTryStmt;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ObjCAtCatchStmt&gt;
objcCatchStmt;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ObjCAtFinallyStmt&gt;
objcFinallyStmt;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ExprWithCleanups&gt;
exprWithCleanups;</extern>











<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> InitListExpr&gt;
initListExpr;</extern>



<macro><name>AST_MATCHER_P</name><argument_list>(<argument>InitListExpr</argument>, <argument>hasSyntacticForm</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>SyntForm</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getSyntacticForm</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>SyntForm</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>SyntForm</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>












<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator>
CXXStdInitializerListExpr&gt;
cxxStdInitializerListExpr;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ImplicitValueInitExpr&gt;
implicitValueInitExpr;</extern>
















<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ParenListExpr&gt;
parenListExpr;</extern>











<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator>
SubstNonTypeTemplateParmExpr&gt;
substNonTypeTemplateParmExpr;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> UsingDecl&gt; usingDecl;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> UsingEnumDecl&gt;
usingEnumDecl;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> UsingDirectiveDecl&gt;
usingDirectiveDecl;</extern>















<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> UnresolvedLookupExpr&gt;
unresolvedLookupExpr;</extern>












<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator>
UnresolvedUsingValueDecl&gt;
unresolvedUsingValueDecl;</extern>
















<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator>
UnresolvedUsingTypenameDecl&gt;
unresolvedUsingTypenameDecl;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ConstantExpr&gt;
constantExpr;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ParenExpr&gt; parenExpr;</extern>











<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXConstructExpr&gt;
cxxConstructExpr;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator>
CXXUnresolvedConstructExpr&gt;
cxxUnresolvedConstructExpr;</extern>











<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXThisExpr&gt;
cxxThisExpr;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXBindTemporaryExpr&gt;
cxxBindTemporaryExpr;</extern>



















<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator>
MaterializeTemporaryExpr&gt;
materializeTemporaryExpr;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXNewExpr&gt; cxxNewExpr;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXDeleteExpr&gt;
cxxDeleteExpr;</extern>














<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXNoexceptExpr&gt;
cxxNoexceptExpr;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ArraySubscriptExpr&gt;
arraySubscriptExpr;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXDefaultArgExpr&gt;
cxxDefaultArgExpr;</extern>

















<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXOperatorCallExpr&gt;
cxxOperatorCallExpr;</extern>


















<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator>
CXXRewrittenBinaryOperator&gt;
cxxRewrittenBinaryOperator;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> Expr&gt; expr;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> DeclRefExpr&gt;
declRefExpr;</extern>












<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ObjCIvarRefExpr&gt;
objcIvarRefExpr;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> BlockExpr&gt; blockExpr;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> IfStmt&gt; ifStmt;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ForStmt&gt; forStmt;</extern>









<macro><name>AST_MATCHER_P</name><argument_list>(<argument>ForStmt</argument>, <argument>hasIncrement</argument>, <argument>internal::Matcher&lt;Stmt&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier><specifier>const</specifier></type> <name>Increment</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getInc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>Increment</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Increment</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>









<macro><name>AST_MATCHER_P</name><argument_list>(<argument>ForStmt</argument>, <argument>hasLoopInit</argument>, <argument>internal::Matcher&lt;Stmt&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier><specifier>const</specifier></type> <name>Init</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getInit</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>Init</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator> <call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Init</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXForRangeStmt&gt;
cxxForRangeStmt;</extern>









<macro><name>AST_MATCHER_P</name><argument_list>(<argument>CXXForRangeStmt</argument>, <argument>hasLoopVariable</argument>, <argument>internal::Matcher&lt;VarDecl&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier><specifier>const</specifier></type> <name>Var</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getLoopVariable</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>Var</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator> <call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Var</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>









<macro><name>AST_MATCHER_P</name><argument_list>(<argument>CXXForRangeStmt</argument>, <argument>hasRangeInit</argument>, <argument>internal::Matcher&lt;Expr&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier><specifier>const</specifier></type> <name>Init</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getRangeInit</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>Init</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator> <call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Init</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> WhileStmt&gt; whileStmt;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> DoStmt&gt; doStmt;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> BreakStmt&gt; breakStmt;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ContinueStmt&gt;
continueStmt;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CoreturnStmt&gt;
coreturnStmt;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ReturnStmt&gt; returnStmt;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> GotoStmt&gt; gotoStmt;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> LabelStmt&gt; labelStmt;</extern>











<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> AddrLabelExpr&gt;
addrLabelExpr;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> SwitchStmt&gt; switchStmt;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> SwitchCase&gt; switchCase;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CaseStmt&gt; caseStmt;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> DefaultStmt&gt;
defaultStmt;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CompoundStmt&gt;
compoundStmt;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXCatchStmt&gt;
cxxCatchStmt;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXTryStmt&gt; cxxTryStmt;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXThrowExpr&gt;
cxxThrowExpr;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> NullStmt&gt; nullStmt;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> AsmStmt&gt; asmStmt;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXBoolLiteralExpr&gt;
cxxBoolLiteral;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> StringLiteral&gt;
stringLiteral;</extern>











<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CharacterLiteral&gt;
characterLiteral;</extern>





<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> IntegerLiteral&gt;
integerLiteral;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> FloatingLiteral&gt;
floatLiteral;</extern>



<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ImaginaryLiteral&gt;
imaginaryLiteral;</extern>


<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> FixedPointLiteral&gt;
fixedPointLiteral;</extern>




<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> UserDefinedLiteral&gt;
userDefinedLiteral;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CompoundLiteralExpr&gt;
compoundLiteralExpr;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CoawaitExpr&gt;
coawaitExpr;</extern>

<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> DependentCoawaitExpr&gt;
dependentCoawaitExpr;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CoyieldExpr&gt;
coyieldExpr;</extern>


<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXNullPtrLiteralExpr&gt;
cxxNullPtrLiteralExpr;</extern>


<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ChooseExpr&gt;
chooseExpr;</extern>


<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> GNUNullExpr&gt;
gnuNullExpr;</extern>


<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> GenericSelectionExpr&gt;
genericSelectionExpr;</extern>






<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> AtomicExpr&gt; atomicExpr;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> StmtExpr&gt; stmtExpr;</extern>








<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> BinaryOperator&gt;
binaryOperator;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> UnaryOperator&gt;
unaryOperator;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ConditionalOperator&gt;
conditionalOperator;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator>
BinaryConditionalOperator&gt;
binaryConditionalOperator;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> OpaqueValueExpr&gt;
opaqueValueExpr;</extern>














<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Decl<operator>,</operator> StaticAssertDecl&gt;
staticAssertDecl;</extern>











<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXReinterpretCastExpr&gt;
cxxReinterpretCastExpr;</extern>














<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXStaticCastExpr&gt;
cxxStaticCastExpr;</extern>













<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXDynamicCastExpr&gt;
cxxDynamicCastExpr;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXConstCastExpr&gt;
cxxConstCastExpr;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CStyleCastExpr&gt;
cStyleCastExpr;</extern>






















<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ExplicitCastExpr&gt;
explicitCastExpr;</extern>





<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> ImplicitCastExpr&gt;
implicitCastExpr;</extern>














<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CastExpr&gt; castExpr;</extern>









<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXFunctionalCastExpr&gt;
cxxFunctionalCastExpr;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CXXTemporaryObjectExpr&gt;
cxxTemporaryObjectExpr;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> PredefinedExpr&gt;
predefinedExpr;</extern>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> DesignatedInitExpr&gt;
designatedInitExpr;</extern>












<macro><name>AST_MATCHER_P</name><argument_list>(<argument>DesignatedInitExpr</argument>, <argument>designatorCountIs</argument>, <argument>unsigned</argument>, <argument>N</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>N</name></expr>;</return>
</block_content>}</block>


<extern>extern const internal::VariadicAllOfMatcher&lt;QualType&gt; qualType;</extern>


<extern>extern const internal::VariadicAllOfMatcher&lt;Type&gt; type;</extern>


<extern>extern const internal::VariadicAllOfMatcher&lt;TypeLoc&gt; typeLoc;</extern>




















<extern>extern const internal::VariadicOperatorMatcherFunc&lt;
2<operator>,</operator> std::numeric_limits&lt;unsigned&gt;::max(</extern>)</block_content>&gt;
eachOf</block></decl>;</decl_stmt>




<extern>extern const internal::VariadicOperatorMatcherFunc&lt;
2<operator>,</operator> std::numeric_limits&lt;unsigned&gt;::max(</extern>)</block_content>&gt;
anyOf</block></decl>;</decl_stmt>




<extern>extern const internal::VariadicOperatorMatcherFunc&lt;
2<operator>,</operator> std::numeric_limits&lt;unsigned&gt;::max(</extern>)<expr_stmt><expr><operator>&gt;</operator>
<name>allOf</name></expr>;</expr_stmt>

























<extern>extern const internal::VariadicOperatorMatcherFunc&lt;1<operator>,</operator> 1&gt; optionally;</extern>










<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator>
UnaryExprOrTypeTraitExpr&gt;
unaryExprOrTypeTraitExpr;</extern>


























<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>U</name></expr></argument>&gt;</argument_list></name>
<specifier>auto</specifier></type> <name>mapAnyOf</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><name><name>VariadicDynCastAllOfMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier> <operator>&amp;</operator><operator>...</operator></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>MapAnyOfHelper</name><argument_list type="generic">&lt;<argument><expr><name>U</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>









































































<extern>extern const internal::MapAnyOfMatcher&lt;BinaryOperator<operator>,</operator> CXXOperatorCallExpr<operator>,</operator>
CXXRewrittenBinaryOperator&gt;
binaryOperation;</extern>



































<extern>extern const internal::MapAnyOfMatcher&lt;CallExpr<operator>,</operator> CXXConstructExpr&gt; invocation;</extern>









<macro><name>AST_MATCHER_P</name><argument_list>(<argument>UnaryExprOrTypeTraitExpr</argument>, <argument>hasArgumentOfType</argument>,
<argument>internal::Matcher&lt;QualType&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>QualType</name></type> <name>ArgumentType</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getTypeOfArgument</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><name>ArgumentType</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>













<macro><name>AST_MATCHER_P</name><argument_list>(<argument>UnaryExprOrTypeTraitExpr</argument>, <argument>ofKind</argument>, <argument>UnaryExprOrTypeTrait</argument>, <argument>Kind</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Kind</name></expr>;</return>
</block_content>}</block>



<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>BindableMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name></expr></argument>&gt;</argument_list></name> <macro><name>alignOfExpr</name><argument_list>(
<argument>const internal::Matcher&lt;UnaryExprOrTypeTraitExpr&gt; &amp;InnerMatcher</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>stmt</name><argument_list>(<argument><expr><call><name>unaryExprOrTypeTraitExpr</name><argument_list>(
<argument><expr><call><name>allOf</name><argument_list>(<argument><expr><call><name>anyOf</name><argument_list>(<argument><expr><call><name>ofKind</name><argument_list>(<argument><expr><name>UETT_AlignOf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ofKind</name><argument_list>(<argument><expr><name>UETT_PreferredAlignOf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>BindableMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name></expr></argument>&gt;</argument_list></name> <macro><name>sizeOfExpr</name><argument_list>(
<argument>const internal::Matcher&lt;UnaryExprOrTypeTraitExpr&gt; &amp;InnerMatcher</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>stmt</name><argument_list>(<argument><expr><call><name>unaryExprOrTypeTraitExpr</name><argument_list>(
<argument><expr><call><name>allOf</name><argument_list>(<argument><expr><call><name>ofKind</name><argument_list>(<argument><expr><name>UETT_SizeOf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
















<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name> <macro><name>hasName</name><argument_list>(<argument>StringRef Name</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><macro><name>Matcher</name></macro><operator>&lt;</operator><name>NamedDecl</name><operator>&gt;</operator><operator>(</operator>
<name>new</name> <name>internal</name><operator>::</operator><macro><name>HasNameMatcher</name><argument_list>(<argument>{std::string(Name)}</argument>)</argument_list></macro><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>











<extern>extern const internal::VariadicFunction&lt;internal::Matcher&lt;NamedDecl&gt;<operator>,</operator> StringRef<operator>,</operator>
internal::hasAnyNameFunc&gt;
hasAnyName;</extern>

















<macro><name>AST_MATCHER_REGEX</name><argument_list>(<argument>NamedDecl</argument>, <argument>matchesName</argument>, <argument>RegExp</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>FullNameString</name> <operator>=</operator> <literal type="string">"::"</literal> <operator>+</operator> <call><name><name>Node</name><operator>.</operator><name>getQualifiedNameAsString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>RegExp</name><operator>-&gt;</operator><name>match</name></name><argument_list>(<argument><expr><name>FullNameString</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>




















<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>internal</name><operator>::</operator><name>HasOverloadedOperatorNameMatcher</name></expr></argument>,
<argument><expr><name>AST_POLYMORPHIC_SUPPORTED_TYPES</name><operator>(</operator><name>CXXOperatorCallExpr</name>, <name>FunctionDecl</name><operator>)</operator></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<macro><name>hasOverloadedOperatorName</name><argument_list>(<argument>StringRef Name</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><macro><name>PolymorphicMatcher</name></macro><operator>&lt;</operator>
<name>internal</name><operator>::</operator><name>HasOverloadedOperatorNameMatcher</name></expr><operator>,</operator>
<expr><call><name>AST_POLYMORPHIC_SUPPORTED_TYPES</name><argument_list>(<argument><expr><name>CXXOperatorCallExpr</name></expr></argument>, <argument><expr><name>FunctionDecl</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>&gt;</operator><operator>(</operator><block>{<expr><name>std</name><operator>::</operator><macro><name>string</name><argument_list>(<argument>Name</argument>)</argument_list></macro></expr>}</block><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>









<extern>extern const internal::VariadicFunction&lt;
internal::PolymorphicMatcher&lt;internal::HasOverloadedOperatorNameMatcher<operator>,</operator>
AST_POLYMORPHIC_SUPPORTED_TYPES(
CXXOperatorCallExpr<operator>,</operator> FunctionDecl</extern>)<operator>,</operator>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>&gt;</operator></expr><operator>,</operator>
<expr><name>StringRef</name></expr><operator>,</operator> <expr><name>internal</name><operator>::</operator><name>hasAnyOverloadedOperatorNameFunc</name><operator>&gt;</operator>
<name>hasAnyOverloadedOperatorName</name></expr>;</expr_stmt>





















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>CXXDependentScopeMemberExpr</argument>, <argument>hasMemberName</argument>, <argument>std::string</argument>, <argument>N</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getMember</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAsString</name><argument_list>()</argument_list></call> <operator>==</operator> <name>N</name></expr>;</return>
</block_content>}</block>



































<macro><name>AST_MATCHER_P</name><argument_list>(<argument>CXXDependentScopeMemberExpr</argument>, <argument>memberHasSameNameAsBoundNode</argument>,
<argument>std::string</argument>, <argument>BindingID</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>MemberName</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getMember</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAsString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name><name>Builder</name><operator>-&gt;</operator><name>removeBindings</name></name><argument_list>(
<argument><expr><index>[<expr><name>this</name></expr><operator>,</operator> <name>MemberName</name>]</index><operator>(</operator><specifier>const</specifier> <name>BoundNodesMap</name> <operator>&amp;</operator><name>Nodes</name><operator>)</operator> <block>{
<expr><specifier>const</specifier> <name>auto</name> <operator>&amp;</operator><name>BN</name> <operator>=</operator> <call><name><name>Nodes</name><operator>.</operator><name>getNode</name></name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>BindingID</name></name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>ND</name> <init>= <expr><name><name>BN</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>NamedDecl</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>FieldDecl</name></expr></argument>, <argument><expr><name>CXXMethodDecl</name></expr></argument>, <argument><expr><name>VarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ND</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>ND</name><operator>-&gt;</operator><name>getName</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>MemberName</name></expr>;</return>
<expr_stmt/>}</block_content>
return true</block><empty_stmt>;</empty_stmt></if></if_stmt>
}</block></expr></argument></argument_list></call></expr></return>)</block_content></block><empty_stmt>;</empty_stmt>
}































AST_POLYMORPHIC_MATCHER_P<expr_stmt><expr><operator>(</operator>
<name>isDerivedFrom</name><operator>,</operator>
<call><name>AST_POLYMORPHIC_SUPPORTED_TYPES</name><argument_list>(<argument><expr><name>CXXRecordDecl</name></expr></argument>, <argument><expr><name>ObjCInterfaceDecl</name></expr></argument>)</argument_list></call><operator>,</operator>
<name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><operator>,</operator> <name>Base</name><operator>)</operator> <block>{

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>RD</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Finder</name><operator>-&gt;</operator><name>classIsDerivedFrom</name></name><argument_list>(<argument><expr><name>RD</name></expr></argument>, <argument><expr><name>Base</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<specifier>const</specifier> <name>auto</name> <operator>*</operator><name>InterfaceDecl</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCInterfaceDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<return>return <expr><call><name><name>Finder</name><operator>-&gt;</operator><name>objcClassIsDerivedFrom</name></name><argument_list>(<argument><expr><name>InterfaceDecl</name></expr></argument>, <argument><expr><name>Base</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
}


AST_POLYMORPHIC_MATCHER_P_OVERLOAD<expr_stmt><expr><operator>(</operator>
<name>isDerivedFrom</name><operator>,</operator>
<call><name>AST_POLYMORPHIC_SUPPORTED_TYPES</name><argument_list>(<argument><expr><name>CXXRecordDecl</name></expr></argument>, <argument><expr><name>ObjCInterfaceDecl</name></expr></argument>)</argument_list></call><operator>,</operator>
<name>std</name><operator>::</operator><name>string</name><operator>,</operator> <name>BaseName</name><operator>,</operator> <literal type="number">1</literal><operator>)</operator> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>BaseName</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<specifier>const</specifier> <name>auto</name> <name>M</name> <operator>=</operator> <call><name>isDerivedFrom</name><argument_list>(<argument><expr><call><name>hasName</name><argument_list>(<argument><expr><name>BaseName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>RD</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><operator>*</operator><name>RD</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>InterfaceDecl</name> <init>= <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCInterfaceDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>ObjCInterfaceDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><operator>*</operator><name>InterfaceDecl</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}
















AST_MATCHER_P<expr_stmt><expr><operator>(</operator><name>CXXRecordDecl</name><operator>,</operator> <name>hasAnyBase</name><operator>,</operator> <name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>CXXBaseSpecifier</name></expr></argument>&gt;</argument_list></name><operator>,</operator>
<name>BaseSpecMatcher</name><operator>)</operator> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name>matchesAnyBase</name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name>BaseSpecMatcher</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>













<macro><name>AST_MATCHER_P</name><argument_list>(<argument>CXXRecordDecl</argument>, <argument>hasDirectBase</argument>, <argument>internal::Matcher&lt;CXXBaseSpecifier&gt;</argument>,
<argument>BaseSpecMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>hasDefinition</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>llvm</name><operator>::</operator><call><name>any_of</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>bases</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><index>[<expr><operator>&amp;</operator></expr>]</index><operator>(</operator><specifier>const</specifier> <name>CXXBaseSpecifier</name> <operator>&amp;</operator><name>Base</name><operator>)</operator> <block>{
<return>return <expr><call><name><name>BaseSpecMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><name>Base</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></argument></argument_list></call></expr></return>)</block_content></block><empty_stmt>;</empty_stmt>
}



AST_POLYMORPHIC_MATCHER_P_OVERLOAD<expr_stmt><expr><operator>(</operator>
<name>isSameOrDerivedFrom</name><operator>,</operator>
<call><name>AST_POLYMORPHIC_SUPPORTED_TYPES</name><argument_list>(<argument><expr><name>CXXRecordDecl</name></expr></argument>, <argument><expr><name>ObjCInterfaceDecl</name></expr></argument>)</argument_list></call><operator>,</operator>
<name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><operator>,</operator> <name>Base</name><operator>,</operator> <literal type="number">0</literal><operator>)</operator> <block>{
<expr><specifier>const</specifier> <name>auto</name> <name>M</name> <operator>=</operator> <call><name>anyOf</name><argument_list>(<argument><expr><name>Base</name></expr></argument>, <argument><expr><call><name>isDerivedFrom</name><argument_list>(<argument><expr><name>Base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>RD</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><operator>*</operator><name>RD</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<specifier>const</specifier> <name>auto</name> <operator>*</operator><name>InterfaceDecl</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCInterfaceDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<return>return <expr><call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>ObjCInterfaceDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><operator>*</operator><name>InterfaceDecl</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}



AST_POLYMORPHIC_MATCHER_P_OVERLOAD<expr_stmt><expr><operator>(</operator>
<name>isSameOrDerivedFrom</name><operator>,</operator>
<call><name>AST_POLYMORPHIC_SUPPORTED_TYPES</name><argument_list>(<argument><expr><name>CXXRecordDecl</name></expr></argument>, <argument><expr><name>ObjCInterfaceDecl</name></expr></argument>)</argument_list></call><operator>,</operator>
<name>std</name><operator>::</operator><name>string</name><operator>,</operator> <name>BaseName</name><operator>,</operator> <literal type="number">1</literal><operator>)</operator> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>BaseName</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<specifier>const</specifier> <name>auto</name> <name>M</name> <operator>=</operator> <call><name>isSameOrDerivedFrom</name><argument_list>(<argument><expr><call><name>hasName</name><argument_list>(<argument><expr><name>BaseName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>RD</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><operator>*</operator><name>RD</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>InterfaceDecl</name> <init>= <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCInterfaceDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>ObjCInterfaceDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><operator>*</operator><name>InterfaceDecl</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}






















AST_POLYMORPHIC_MATCHER_P_OVERLOAD<expr_stmt><expr><operator>(</operator>
<name>isDirectlyDerivedFrom</name><operator>,</operator>
<call><name>AST_POLYMORPHIC_SUPPORTED_TYPES</name><argument_list>(<argument><expr><name>CXXRecordDecl</name></expr></argument>, <argument><expr><name>ObjCInterfaceDecl</name></expr></argument>)</argument_list></call><operator>,</operator>
<name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><operator>,</operator> <name>Base</name><operator>,</operator> <literal type="number">0</literal><operator>)</operator> <block>{

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>RD</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Finder</name><operator>-&gt;</operator><name>classIsDerivedFrom</name></name><argument_list>(<argument><expr><name>RD</name></expr></argument>, <argument><expr><name>Base</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<specifier>const</specifier> <name>auto</name> <operator>*</operator><name>InterfaceDecl</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCInterfaceDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<return>return <expr><call><name><name>Finder</name><operator>-&gt;</operator><name>objcClassIsDerivedFrom</name></name><argument_list>(<argument><expr><name>InterfaceDecl</name></expr></argument>, <argument><expr><name>Base</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
}


AST_POLYMORPHIC_MATCHER_P_OVERLOAD<expr_stmt><expr><operator>(</operator>
<name>isDirectlyDerivedFrom</name><operator>,</operator>
<call><name>AST_POLYMORPHIC_SUPPORTED_TYPES</name><argument_list>(<argument><expr><name>CXXRecordDecl</name></expr></argument>, <argument><expr><name>ObjCInterfaceDecl</name></expr></argument>)</argument_list></call><operator>,</operator>
<name>std</name><operator>::</operator><name>string</name><operator>,</operator> <name>BaseName</name><operator>,</operator> <literal type="number">1</literal><operator>)</operator> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>BaseName</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<specifier>const</specifier> <name>auto</name> <name>M</name> <operator>=</operator> <call><name>isDirectlyDerivedFrom</name><argument_list>(<argument><expr><call><name>hasName</name><argument_list>(<argument><expr><name>BaseName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>RD</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><operator>*</operator><name>RD</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>InterfaceDecl</name> <init>= <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCInterfaceDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>ObjCInterfaceDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><operator>*</operator><name>InterfaceDecl</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}











AST_MATCHER_P<expr_stmt><expr><operator>(</operator><name>CXXRecordDecl</name><operator>,</operator> <name>hasMethod</name><operator>,</operator> <name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>CXXMethodDecl</name></expr></argument>&gt;</argument_list></name><operator>,</operator>
<name>InnerMatcher</name><operator>)</operator> <block>{
<expr><name>BoundNodesTreeBuilder</name> <call><name>Result</name><argument_list>(<argument><expr><operator>*</operator><name>Builder</name></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>MatchIt</name> <operator>=</operator> <call><name>matchesFirstInPointerRange</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><call><name><name>Node</name><operator>.</operator><name>method_begin</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Node</name><operator>.</operator><name>method_end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Result</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>MatchIt</name> <operator>==</operator> <call><name><name>Node</name><operator>.</operator><name>method_end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Finder</name><operator>-&gt;</operator><name>isTraversalIgnoringImplicitNodes</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><operator>(</operator><operator>*</operator><name>MatchIt</name><operator>)</operator><operator>-&gt;</operator><name>isImplicit</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>Builder</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
}










AST_MATCHER<expr_stmt><expr><operator>(</operator><name>CXXRecordDecl</name><operator>,</operator> <name>isLambda</name><operator>)</operator> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isLambda</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



















<extern>extern const internal::ArgumentAdaptingMatcherFunc&lt;internal::HasMatcher&gt; has;</extern>















<extern>extern const internal::ArgumentAdaptingMatcherFunc&lt;
internal::HasDescendantMatcher&gt;
hasDescendant;</extern>



















<extern>extern const internal::ArgumentAdaptingMatcherFunc&lt;internal::ForEachMatcher&gt;
forEach;</extern>




























<extern>extern const internal::ArgumentAdaptingMatcherFunc&lt;
internal::ForEachDescendantMatcher&gt;
forEachDescendant;</extern>

















<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>findAll</name><argument_list>(<argument>const internal::Matcher&lt;T&gt; &amp;Matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>eachOf</name><argument_list>(<argument><expr><name>Matcher</name></expr></argument>, <argument><expr><call><name>forEachDescendant</name><argument_list>(<argument><expr><name>Matcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>











<extern>extern const internal::ArgumentAdaptingMatcherFunc&lt;
internal::HasParentMatcher<operator>,</operator>
internal::TypeList&lt;Decl<operator>,</operator> NestedNameSpecifierLoc<operator>,</operator> Stmt<operator>,</operator> TypeLoc&gt;<operator>,</operator>
internal::TypeList&lt;Decl<operator>,</operator> NestedNameSpecifierLoc<operator>,</operator> Stmt<operator>,</operator> TypeLoc&gt;&gt;
hasParent;</extern>












<extern>extern const internal::ArgumentAdaptingMatcherFunc&lt;
internal::HasAncestorMatcher<operator>,</operator>
internal::TypeList&lt;Decl<operator>,</operator> NestedNameSpecifierLoc<operator>,</operator> Stmt<operator>,</operator> TypeLoc&gt;<operator>,</operator>
internal::TypeList&lt;Decl<operator>,</operator> NestedNameSpecifierLoc<operator>,</operator> Stmt<operator>,</operator> TypeLoc&gt;&gt;
hasAncestor;</extern>










<extern>extern const internal::VariadicOperatorMatcherFunc&lt;1<operator>,</operator> 1&gt; unless;</extern>



































<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>internal</name><operator>::</operator><name>HasDeclarationMatcher</name></expr></argument>,
<argument><expr><name>void</name><operator>(</operator><name>internal</name><operator>::</operator><name>HasDeclarationSupportedTypes</name><operator>)</operator></expr></argument>, <argument><expr><name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<macro><name>hasDeclaration</name><argument_list>(<argument>const internal::Matcher&lt;Decl&gt; &amp;InnerMatcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>internal</name><operator>::</operator><name>HasDeclarationMatcher</name></expr></argument>,
<argument><expr><name>void</name><operator>(</operator><name>internal</name><operator>::</operator><name>HasDeclarationSupportedTypes</name><operator>)</operator></expr></argument>, <argument><expr><name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>












<macro><name>AST_MATCHER_P</name><argument_list>(<argument>NamedDecl</argument>, <argument>hasUnderlyingDecl</argument>, <argument>internal::Matcher&lt;NamedDecl&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>UnderlyingDecl</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getUnderlyingDecl</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><name>UnderlyingDecl</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>UnderlyingDecl</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>



















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>CXXMemberCallExpr</argument>, <argument>on</argument>, <argument>internal::Matcher&lt;Expr&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>ExprNode</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getImplicitObjectArgument</name></name><argument_list>()</argument_list></call>
<operator>-&gt;</operator><call><name>IgnoreParenImpCasts</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>ExprNode</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>ExprNode</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER_P</name><argument_list>(<argument>ObjCMessageExpr</argument>, <argument>hasReceiverType</argument>, <argument>internal::Matcher&lt;QualType&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>QualType</name></type> <name>TypeDecl</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getReceiverType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><name>TypeDecl</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>













<macro><name>AST_MATCHER</name><argument_list>(<argument>ObjCMethodDecl</argument>, <argument>isClassMethod</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isClassMethod</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>













<macro><name>AST_MATCHER</name><argument_list>(<argument>ObjCMethodDecl</argument>, <argument>isInstanceMethod</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isInstanceMethod</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>














<macro><name>AST_MATCHER</name><argument_list>(<argument>ObjCMessageExpr</argument>, <argument>isClassMessage</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isClassMessage</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>














<macro><name>AST_MATCHER</name><argument_list>(<argument>ObjCMessageExpr</argument>, <argument>isInstanceMessage</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isInstanceMessage</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER_P</name><argument_list>(<argument>ObjCMessageExpr</argument>, <argument>hasReceiver</argument>, <argument>internal::Matcher&lt;Expr&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>ReceiverNode</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getInstanceReceiver</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>ReceiverNode</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>ReceiverNode</name><operator>-&gt;</operator><name>IgnoreParenImpCasts</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>,
<argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>









<macro><name>AST_MATCHER_P</name><argument_list>(<argument>ObjCMessageExpr</argument>, <argument>hasSelector</argument>, <argument>std::string</argument>, <argument>BaseName</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>Selector</name></type> <name>Sel</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getSelector</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>BaseName</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name><name>Sel</name><operator>.</operator><name>getAsString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block>











<extern>extern const internal::VariadicFunction&lt;internal::Matcher&lt;ObjCMessageExpr&gt;<operator>,</operator>
StringRef<operator>,</operator>
internal::hasAnySelectorFunc&gt;
hasAnySelector;</extern>









<macro><name>AST_MATCHER_REGEX</name><argument_list>(<argument>ObjCMessageExpr</argument>, <argument>matchesSelector</argument>, <argument>RegExp</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>SelectorString</name> <operator>=</operator> <call><name><name>Node</name><operator>.</operator><name>getSelector</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAsString</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>RegExp</name><operator>-&gt;</operator><name>match</name></name><argument_list>(<argument><expr><name>SelectorString</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>





<macro><name>AST_MATCHER</name><argument_list>(<argument>ObjCMessageExpr</argument>, <argument>hasNullSelector</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getSelector</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>









<macro><name>AST_MATCHER</name><argument_list>(<argument>ObjCMessageExpr</argument>, <argument>hasUnarySelector</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getSelector</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isUnarySelector</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>













<macro><name>AST_MATCHER</name><argument_list>(<argument>ObjCMessageExpr</argument>, <argument>hasKeywordSelector</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getSelector</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isKeywordSelector</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER_P</name><argument_list>(<argument>ObjCMessageExpr</argument>, <argument>numSelectorArgs</argument>, <argument>unsigned</argument>, <argument>N</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getSelector</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>==</operator> <name>N</name></expr>;</return>
</block_content>}</block>

















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>CallExpr</argument>, <argument>callee</argument>, <argument>internal::Matcher&lt;Stmt&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>ExprNode</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getCallee</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>ExprNode</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>ExprNode</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>










<macro><name>AST_MATCHER_P_OVERLOAD</name><argument_list>(<argument>CallExpr</argument>, <argument>callee</argument>, <argument>internal::Matcher&lt;Decl&gt;</argument>, <argument>InnerMatcher</argument>,
<argument><literal type="number">1</literal></argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name>callExpr</name><argument_list>(<argument><expr><call><name>hasDeclaration</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

















<macro><name>AST_POLYMORPHIC_MATCHER_P_OVERLOAD</name><argument_list>(
<argument>hasType</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(Expr, FriendDecl, TypedefNameDecl,
ValueDecl, CXXBaseSpecifier)</argument>,
<argument>internal::Matcher&lt;QualType&gt;</argument>, <argument>InnerMatcher</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>QualType</name></type> <name>QT</name> <init>= <expr><name>internal</name><operator>::</operator><call><name>getUnderlyingType</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>QT</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><name>QT</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>































<macro><name>AST_POLYMORPHIC_MATCHER_P_OVERLOAD</name><argument_list>(
<argument>hasType</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(Expr, FriendDecl, ValueDecl,
CXXBaseSpecifier)</argument>,
<argument>internal::Matcher&lt;Decl&gt;</argument>, <argument>InnerMatcher</argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>QualType</name></type> <name>QT</name> <init>= <expr><name>internal</name><operator>::</operator><call><name>getUnderlyingType</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>QT</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>qualType</name><argument_list>(<argument><expr><call><name>hasDeclaration</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><name>QT</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>































<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(
<argument>hasTypeLoc</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(
BlockDecl, CXXBaseSpecifier, CXXCtorInitializer, CXXFunctionalCastExpr,
CXXNewExpr, CXXTemporaryObjectExpr, CXXUnresolvedConstructExpr,
ClassTemplateSpecializationDecl, CompoundLiteralExpr, DeclaratorDecl,
ExplicitCastExpr, ObjCPropertyDecl, TemplateArgumentLoc,
TypedefNameDecl)</argument>,
<argument>internal::Matcher&lt;TypeLoc&gt;</argument>, <argument>Inner</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>source</name> <init>= <expr><name>internal</name><operator>::</operator><call><name>GetTypeSourceInfo</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>source</name> <operator>==</operator> <name>nullptr</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name><name>Inner</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><call><name><name>source</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>










<macro><name>AST_MATCHER_P</name><argument_list>(<argument>QualType</argument>, <argument>asString</argument>, <argument>std::string</argument>, <argument>Name</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><name>Name</name> <operator>==</operator> <call><name><name>Node</name><operator>.</operator><name>getAsString</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER_P</name><argument_list>(
<argument>QualType</argument>, <argument>pointsTo</argument>, <argument>internal::Matcher&lt;QualType&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><operator>(</operator><operator>!</operator><call><name><name>Node</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Node</name><operator>-&gt;</operator><name>isAnyPointerType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>


<macro><name>AST_MATCHER_P_OVERLOAD</name><argument_list>(<argument>QualType</argument>, <argument>pointsTo</argument>, <argument>internal::Matcher&lt;Decl&gt;</argument>,
<argument>InnerMatcher</argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name>pointsTo</name><argument_list>(<argument><expr><call><name>qualType</name><argument_list>(<argument><expr><call><name>hasDeclaration</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER_P</name><argument_list>(<argument>Type</argument>, <argument>hasUnqualifiedDesugaredType</argument>, <argument>internal::Matcher&lt;Type&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>getUnqualifiedDesugaredType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>,
<argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>














<macro><name>AST_MATCHER_P</name><argument_list>(<argument>QualType</argument>, <argument>references</argument>, <argument>internal::Matcher&lt;QualType&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><operator>(</operator><operator>!</operator><call><name><name>Node</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Node</name><operator>-&gt;</operator><name>isReferenceType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>













<macro><name>AST_MATCHER_P</name><argument_list>(<argument>QualType</argument>, <argument>hasCanonicalType</argument>, <argument>internal::Matcher&lt;QualType&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Node</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getCanonicalType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>


<macro><name>AST_MATCHER_P_OVERLOAD</name><argument_list>(<argument>QualType</argument>, <argument>references</argument>, <argument>internal::Matcher&lt;Decl&gt;</argument>,
<argument>InnerMatcher</argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name>references</name><argument_list>(<argument><expr><call><name>qualType</name><argument_list>(<argument><expr><call><name>hasDeclaration</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>


















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>CXXMemberCallExpr</argument>, <argument>onImplicitObjectArgument</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>ExprNode</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getImplicitObjectArgument</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>ExprNode</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>ExprNode</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>

















<macro><name>AST_MATCHER_P_OVERLOAD</name><argument_list>(<argument>CXXMemberCallExpr</argument>, <argument>thisPointerType</argument>,
<argument>internal::Matcher&lt;QualType&gt;</argument>, <argument>InnerMatcher</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name>onImplicitObjectArgument</name><argument_list>(
<argument><expr><call><name>anyOf</name><argument_list>(<argument><expr><call><name>hasType</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>hasType</name><argument_list>(<argument><expr><call><name>pointsTo</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>


<macro><name>AST_MATCHER_P_OVERLOAD</name><argument_list>(<argument>CXXMemberCallExpr</argument>, <argument>thisPointerType</argument>,
<argument>internal::Matcher&lt;Decl&gt;</argument>, <argument>InnerMatcher</argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name>onImplicitObjectArgument</name><argument_list>(
<argument><expr><call><name>anyOf</name><argument_list>(<argument><expr><call><name>hasType</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>hasType</name><argument_list>(<argument><expr><call><name>pointsTo</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>










<macro><name>AST_MATCHER_P</name><argument_list>(<argument>DeclRefExpr</argument>, <argument>to</argument>, <argument>internal::Matcher&lt;Decl&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>DeclNode</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>DeclNode</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>DeclNode</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>DeclRefExpr</argument>, <argument>throughUsingDecl</argument>,
<argument>internal::Matcher&lt;UsingShadowDecl&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>FoundDecl</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getFoundDecl</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>UsingShadowDecl</name> <modifier>*</modifier></type><name>UsingDecl</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>UsingShadowDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>FoundDecl</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>UsingDecl</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>
















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>OverloadExpr</argument>, <argument>hasAnyDeclaration</argument>, <argument>internal::Matcher&lt;Decl&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name>matchesFirstInPointerRange</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><call><name><name>Node</name><operator>.</operator><name>decls_begin</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Node</name><operator>.</operator><name>decls_end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>,
<argument><expr><name>Builder</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name><name>Node</name><operator>.</operator><name>decls_end</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>










<macro><name>AST_MATCHER_P</name><argument_list>(<argument>DeclStmt</argument>, <argument>hasSingleDecl</argument>, <argument>internal::Matcher&lt;Decl&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Node</name><operator>.</operator><name>isSingleDecl</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>FoundDecl</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getSingleDecl</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>FoundDecl</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>









<macro><name>AST_MATCHER_P</name><argument_list>(
<argument>VarDecl</argument>, <argument>hasInitializer</argument>, <argument>internal::Matcher&lt;Expr&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Initializer</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getAnyInitializer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>Initializer</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Initializer</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER</name><argument_list>(<argument>VarDecl</argument>, <argument>isStaticLocal</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isStaticLocal</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER</name><argument_list>(<argument>VarDecl</argument>, <argument>hasLocalStorage</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>hasLocalStorage</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER</name><argument_list>(<argument>VarDecl</argument>, <argument>hasGlobalStorage</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>hasGlobalStorage</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>













<macro><name>AST_MATCHER</name><argument_list>(<argument>VarDecl</argument>, <argument>hasAutomaticStorageDuration</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getStorageDuration</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SD_Automatic</name></expr>;</return>
</block_content>}</block>

















<macro><name>AST_MATCHER</name><argument_list>(<argument>VarDecl</argument>, <argument>hasStaticStorageDuration</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getStorageDuration</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SD_Static</name></expr>;</return>
</block_content>}</block>













<macro><name>AST_MATCHER</name><argument_list>(<argument>VarDecl</argument>, <argument>hasThreadStorageDuration</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getStorageDuration</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SD_Thread</name></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER</name><argument_list>(<argument>VarDecl</argument>, <argument>isExceptionVariable</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isExceptionVariable</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>









<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(<argument>argumentCountIs</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(
CallExpr, CXXConstructExpr,
CXXUnresolvedConstructExpr, ObjCMessageExpr)</argument>,
<argument>unsigned</argument>, <argument>N</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumArgs</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Finder</name><operator>-&gt;</operator><name>isTraversalIgnoringImplicitNodes</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NumArgs</name> <operator>==</operator> <name>N</name></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>NumArgs</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>CXXDefaultArgExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getArg</name></name><argument_list>(<argument><expr><name>NumArgs</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>--</operator><name>NumArgs</name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>NumArgs</name> <operator>==</operator> <name>N</name></expr>;</return>
</block_content>}</block>









<macro><name>AST_POLYMORPHIC_MATCHER_P2</name><argument_list>(<argument>hasArgument</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(
CallExpr, CXXConstructExpr,
CXXUnresolvedConstructExpr, ObjCMessageExpr)</argument>,
<argument>unsigned</argument>, <argument>N</argument>, <argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&gt;=</operator> <call><name><name>Node</name><operator>.</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Arg</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getArg</name></name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Finder</name><operator>-&gt;</operator><name>isTraversalIgnoringImplicitNodes</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>CXXDefaultArgExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Arg</name><operator>-&gt;</operator><name>IgnoreParenImpCasts</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>








<macro><name>AST_MATCHER_P2</name><argument_list>(<argument>InitListExpr</argument>, <argument>hasInit</argument>, <argument>unsigned</argument>, <argument>N</argument>,
<argument>ast_matchers::internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><name>N</name> <operator>&lt;</operator> <call><name><name>Node</name><operator>.</operator><name>getNumInits</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>getInit</name></name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER_P</name><argument_list>(<argument>DeclStmt</argument>, <argument>declCountIs</argument>, <argument>unsigned</argument>, <argument>N</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><name>std</name><operator>::</operator><call><name>distance</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>decl_begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Node</name><operator>.</operator><name>decl_end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>N</name></expr>;</return>
</block_content>}</block>




















<macro><name>AST_MATCHER_P2</name><argument_list>(<argument>DeclStmt</argument>, <argument>containsDeclaration</argument>, <argument>unsigned</argument>, <argument>N</argument>,
<argument>internal::Matcher&lt;Decl&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>NumDecls</name> <init>= <expr><name>std</name><operator>::</operator><call><name>distance</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>decl_begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Node</name><operator>.</operator><name>decl_end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&gt;=</operator> <name>NumDecls</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>DeclStmt</name><operator>::</operator><name>const_decl_iterator</name> <name>Iterator</name> <operator>=</operator> <call><name><name>Node</name><operator>.</operator><name>decl_begin</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><call><name>advance</name><argument_list>(<argument><expr><name>Iterator</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>Iterator</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>














<macro><name>AST_MATCHER</name><argument_list>(<argument>CXXCatchStmt</argument>, <argument>isCatchAll</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getExceptionDecl</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>nullptr</name></expr>;</return>
</block_content>}</block>














<macro><name>AST_MATCHER_P</name><argument_list>(<argument>CXXConstructorDecl</argument>, <argument>hasAnyConstructorInitializer</argument>,
<argument>internal::Matcher&lt;CXXCtorInitializer&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>MatchIt</name> <init>= <expr><call><name>matchesFirstInPointerRange</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><call><name><name>Node</name><operator>.</operator><name>init_begin</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Node</name><operator>.</operator><name>init_end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>MatchIt</name> <operator>==</operator> <call><name><name>Node</name><operator>.</operator><name>init_end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><operator>(</operator><operator>*</operator><name>MatchIt</name><operator>)</operator><operator>-&gt;</operator><name>isWritten</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>Finder</name><operator>-&gt;</operator><name>isTraversalIgnoringImplicitNodes</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>














<macro><name>AST_MATCHER_P</name><argument_list>(<argument>CXXCtorInitializer</argument>, <argument>forField</argument>,
<argument>internal::Matcher&lt;FieldDecl&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>FieldDecl</name> <modifier>*</modifier></type><name>NodeAsDecl</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getAnyMember</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>NodeAsDecl</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>NodeAsDecl</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>














<macro><name>AST_MATCHER_P</name><argument_list>(<argument>CXXCtorInitializer</argument>, <argument>withInitializer</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name><modifier>*</modifier></type> <name>NodeAsExpr</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getInit</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>NodeAsExpr</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>NodeAsExpr</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>














<macro><name>AST_MATCHER</name><argument_list>(<argument>CXXCtorInitializer</argument>, <argument>isWritten</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isWritten</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>

















<macro><name>AST_MATCHER</name><argument_list>(<argument>CXXCtorInitializer</argument>, <argument>isBaseInitializer</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isBaseInitializer</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>

















<macro><name>AST_MATCHER</name><argument_list>(<argument>CXXCtorInitializer</argument>, <argument>isMemberInitializer</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isMemberInitializer</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>




















<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(<argument>hasAnyArgument</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(
CallExpr, CXXConstructExpr,
CXXUnresolvedConstructExpr, ObjCMessageExpr)</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Arg</name> <range>: <expr><call><name><name>Node</name><operator>.</operator><name>arguments</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Finder</name><operator>-&gt;</operator><name>isTraversalIgnoringImplicitNodes</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>CXXDefaultArgExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>BoundNodesTreeBuilder</name></type> <name>Result</name><argument_list>(<argument><expr><operator>*</operator><name>Builder</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Arg</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>Builder</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER_P_OVERLOAD</name><argument_list>(<argument>LambdaExpr</argument>, <argument>hasAnyCapture</argument>, <argument>internal::Matcher&lt;VarDecl&gt;</argument>,
<argument>InnerMatcher</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>LambdaCapture</name> <modifier>&amp;</modifier></type><name>Capture</name> <range>: <expr><call><name><name>Node</name><operator>.</operator><name>captures</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Capture</name><operator>.</operator><name>capturesVariable</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BoundNodesTreeBuilder</name></type> <name>Result</name><argument_list>(<argument><expr><operator>*</operator><name>Builder</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Capture</name><operator>.</operator><name>getCapturedVar</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>Builder</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>













<macro><name>AST_MATCHER_P_OVERLOAD</name><argument_list>(<argument>LambdaExpr</argument>, <argument>hasAnyCapture</argument>,
<argument>internal::Matcher&lt;CXXThisExpr&gt;</argument>, <argument>InnerMatcher</argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><name>llvm</name><operator>::</operator><call><name>any_of</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>captures</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><index>[]</index><operator>(</operator><specifier>const</specifier> <name>LambdaCapture</name> <operator>&amp;</operator><name>LC</name><operator>)</operator> <block>{
<return>return <expr><call><name><name>LC</name><operator>.</operator><name>capturesThis</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></argument></argument_list></call></expr></return>)</block_content></block><empty_stmt>;</empty_stmt>
}


AST_MATCHER<expr_stmt><expr><operator>(</operator><name>CXXConstructExpr</name><operator>,</operator> <name>isListInitialization</name><operator>)</operator> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isListInitialization</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>













<macro><name>AST_MATCHER</name><argument_list>(<argument>CXXConstructExpr</argument>, <argument>requiresZeroInitialization</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>requiresZeroInitialization</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>





















<macro><name>AST_POLYMORPHIC_MATCHER_P2</name><argument_list>(<argument>hasParameter</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,
ObjCMethodDecl,
BlockDecl)</argument>,
<argument>unsigned</argument>, <argument>N</argument>, <argument>internal::Matcher&lt;ParmVarDecl&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><operator>(</operator><name>N</name> <operator>&lt;</operator> <call><name><name>Node</name><operator>.</operator><name>parameters</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call>
<operator>&amp;&amp;</operator> <call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>parameters</name></name><argument_list>()</argument_list></call><index>[<expr><name>N</name></expr>]</index></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>



















<macro><name>AST_POLYMORPHIC_MATCHER_P2</name><argument_list>(<argument>forEachArgumentWithParam</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(CallExpr,
CXXConstructExpr)</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>ArgMatcher</argument>,
<argument>internal::Matcher&lt;ParmVarDecl&gt;</argument>, <argument>ParamMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>BoundNodesTreeBuilder</name></type> <name>Result</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>BoundNodesTreeBuilder</name></type> <name>Matches</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ArgIndex</name> <init>= <expr><ternary><condition><expr><call><name>cxxOperatorCallExpr</name><argument_list>(<argument><expr><call><name>callee</name><argument_list>(<argument><expr><call><name>cxxMethodDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Matches</name></expr></argument>)</argument_list></call></expr>
?</condition><then> <expr><literal type="number">1</literal></expr>
</then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ParamIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Matched</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>ArgIndex</name> <operator>&lt;</operator> <call><name><name>Node</name><operator>.</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>ArgIndex</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BoundNodesTreeBuilder</name></type> <name>ArgMatches</name><argument_list>(<argument><expr><operator>*</operator><name>Builder</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>ArgMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><call><name><name>Node</name><operator>.</operator><name>getArg</name></name><argument_list>(<argument><expr><name>ArgIndex</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>IgnoreParenCasts</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>,
<argument><expr><name>Finder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ArgMatches</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<function_decl><type><name>BoundNodesTreeBuilder</name></type> <name>ParamMatches</name><parameter_list>(<parameter><decl><type><name>ArgMatches</name></type></decl></parameter>)</parameter_list>;</function_decl>
<if_stmt><if>if <condition>(<expr><call><name>expr</name><argument_list>(<argument><expr><call><name>anyOf</name><argument_list>(<argument><expr><call><name>cxxConstructExpr</name><argument_list>(<argument><expr><call><name>hasDeclaration</name><argument_list>(<argument><expr><call><name>cxxConstructorDecl</name><argument_list>(
<argument><expr><call><name>hasParameter</name><argument_list>(<argument><expr><name>ParamIndex</name></expr></argument>, <argument><expr><name>ParamMatcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>callExpr</name><argument_list>(<argument><expr><call><name>callee</name><argument_list>(<argument><expr><call><name>functionDecl</name><argument_list>(
<argument><expr><call><name>hasParameter</name><argument_list>(<argument><expr><name>ParamIndex</name></expr></argument>, <argument><expr><name>ParamMatcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ParamMatches</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Result</name><operator>.</operator><name>addMatch</name></name><argument_list>(<argument><expr><name>ParamMatches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Matched</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>ParamIndex</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>Builder</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Matched</name></expr>;</return>
</block_content>}</block>


























<macro><name>AST_POLYMORPHIC_MATCHER_P2</name><argument_list>(<argument>forEachArgumentWithParamType</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(CallExpr,
CXXConstructExpr)</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>ArgMatcher</argument>,
<argument>internal::Matcher&lt;QualType&gt;</argument>, <argument>ParamMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>BoundNodesTreeBuilder</name></type> <name>Result</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>BoundNodesTreeBuilder</name></type> <name>Matches</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ArgIndex</name> <init>= <expr><ternary><condition><expr><call><name>cxxOperatorCallExpr</name><argument_list>(<argument><expr><call><name>callee</name><argument_list>(<argument><expr><call><name>cxxMethodDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Matches</name></expr></argument>)</argument_list></call></expr>
?</condition><then> <expr><literal type="number">1</literal></expr>
</then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>FProto</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>Call</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CallExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>Value</name> <init>=
<expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>ValueDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Call</name><operator>-&gt;</operator><name>getCalleeDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QualType</name></type> <name>QT</name> <init>= <expr><call><name><name>Value</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCanonicalType</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><call><name><name>QT</name><operator>-&gt;</operator><name>isFunctionPointerType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>FProto</name> <operator>=</operator> <call><name><name>QT</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>QT</name><operator>-&gt;</operator><name>isMemberFunctionPointerType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>MP</name> <init>= <expr><name><name>QT</name><operator>-&gt;</operator><name>getAs</name></name><operator>&lt;</operator><name>MemberPointerType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>MP</name> <operator>&amp;&amp;</operator> <literal type="string">"Must be member-pointer if its a memberfunctionpointer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>FProto</name> <operator>=</operator> <call><name><name>MP</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>FProto</name> <operator>&amp;&amp;</operator>
<literal type="string">"The call must have happened through a member function "</literal>
<literal type="string">"pointer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ParamIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Matched</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumArgs</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>FProto</name> <operator>&amp;&amp;</operator> <call><name><name>FProto</name><operator>-&gt;</operator><name>isVariadic</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>NumArgs</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>min</name><argument_list>(<argument><expr><name>NumArgs</name></expr></argument>, <argument><expr><call><name><name>FProto</name><operator>-&gt;</operator><name>getNumParams</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>ArgIndex</name> <operator>&lt;</operator> <name>NumArgs</name></expr>;</condition> <incr><expr><operator>++</operator><name>ArgIndex</name></expr><operator>,</operator> <expr><operator>++</operator><name>ParamIndex</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BoundNodesTreeBuilder</name></type> <name>ArgMatches</name><argument_list>(<argument><expr><operator>*</operator><name>Builder</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>ArgMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><call><name><name>Node</name><operator>.</operator><name>getArg</name></name><argument_list>(<argument><expr><name>ArgIndex</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>IgnoreParenCasts</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>, <argument><expr><name>Finder</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>ArgMatches</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<function_decl><type><name>BoundNodesTreeBuilder</name></type> <name>ParamMatches</name><parameter_list>(<parameter><decl><type><name>ArgMatches</name></type></decl></parameter>)</parameter_list>;</function_decl>



<if_stmt><if>if <condition>(<expr><name>FProto</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QualType</name></type> <name>ParamType</name> <init>= <expr><call><name><name>FProto</name><operator>-&gt;</operator><name>getParamType</name></name><argument_list>(<argument><expr><name>ParamIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>ParamMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><name>ParamType</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ParamMatches</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Result</name><operator>.</operator><name>addMatch</name></name><argument_list>(<argument><expr><name>ParamMatches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Matched</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>expr</name><argument_list>(<argument><expr><call><name>anyOf</name><argument_list>(<argument><expr><call><name>cxxConstructExpr</name><argument_list>(<argument><expr><call><name>hasDeclaration</name><argument_list>(<argument><expr><call><name>cxxConstructorDecl</name><argument_list>(
<argument><expr><call><name>hasParameter</name><argument_list>(<argument><expr><name>ParamIndex</name></expr></argument>, <argument><expr><call><name>hasType</name><argument_list>(<argument><expr><name>ParamMatcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>callExpr</name><argument_list>(<argument><expr><call><name>callee</name><argument_list>(<argument><expr><call><name>functionDecl</name><argument_list>(
<argument><expr><call><name>hasParameter</name><argument_list>(<argument><expr><name>ParamIndex</name></expr></argument>, <argument><expr><call><name>hasType</name><argument_list>(<argument><expr><name>ParamMatcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ParamMatches</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Result</name><operator>.</operator><name>addMatch</name></name><argument_list>(<argument><expr><name>ParamMatches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Matched</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>Builder</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Matched</name></expr>;</return>
</block_content>}</block>
















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>ParmVarDecl</argument>, <argument>isAtPosition</argument>, <argument>unsigned</argument>, <argument>N</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><specifier>const</specifier> <name>clang</name><operator>::</operator><name>DeclContext</name> <operator>*</operator><name>Context</name> <operator>=</operator> <call><name><name>Node</name><operator>.</operator><name>getParentFunctionOrMethod</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>Decl</name> <init>= <expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>N</name> <operator>&lt;</operator> <call><name><name>Decl</name><operator>-&gt;</operator><name>param_size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Decl</name><operator>-&gt;</operator><name>getParamDecl</name></name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>&amp;</operator><name>Node</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>Decl</name> <init>= <expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>BlockDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>N</name> <operator>&lt;</operator> <call><name><name>Decl</name><operator>-&gt;</operator><name>param_size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Decl</name><operator>-&gt;</operator><name>getParamDecl</name></name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>&amp;</operator><name>Node</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>Decl</name> <init>= <expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>N</name> <operator>&lt;</operator> <call><name><name>Decl</name><operator>-&gt;</operator><name>param_size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Decl</name><operator>-&gt;</operator><name>getParamDecl</name></name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>&amp;</operator><name>Node</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>
































<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(<argument>hasAnyParameter</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,
ObjCMethodDecl,
BlockDecl)</argument>,
<argument>internal::Matcher&lt;ParmVarDecl&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name>matchesFirstInPointerRange</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><call><name><name>Node</name><operator>.</operator><name>param_begin</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Node</name><operator>.</operator><name>param_end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>,
<argument><expr><name>Builder</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name><name>Node</name><operator>.</operator><name>param_end</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>


















<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(<argument>parameterCountIs</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,
FunctionProtoType)</argument>,
<argument>unsigned</argument>, <argument>N</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getNumParams</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>N</name></expr>;</return>
</block_content>}</block>















<macro><name>AST_MATCHER</name><argument_list>(<argument>FunctionDecl</argument>, <argument>isNoReturn</argument>)</argument_list></macro> <block>{<block_content> <return>return <expr><call><name><name>Node</name><operator>.</operator><name>isNoReturn</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block>









<macro><name>AST_MATCHER_P</name><argument_list>(<argument>FunctionDecl</argument>, <argument>returns</argument>,
<argument>internal::Matcher&lt;QualType&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getReturnType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>
















<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(<argument>isExternC</argument>, <argument>AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,
VarDecl)</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isExternC</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>















<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(<argument>isStaticStorageClass</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,
VarDecl)</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getStorageClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SC_Static</name></expr>;</return>
</block_content>}</block>










<macro><name>AST_MATCHER</name><argument_list>(<argument>FunctionDecl</argument>, <argument>isDeleted</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isDeleted</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>










<macro><name>AST_MATCHER</name><argument_list>(<argument>FunctionDecl</argument>, <argument>isDefaulted</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isDefaulted</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>










<macro><name>AST_MATCHER</name><argument_list>(<argument>FunctionDecl</argument>, <argument>isWeak</argument>)</argument_list></macro> <block>{<block_content> <return>return <expr><call><name><name>Node</name><operator>.</operator><name>isWeak</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block>
















<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(<argument>hasDynamicExceptionSpec</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,
FunctionProtoType)</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>FnTy</name> <init>= <expr><name>internal</name><operator>::</operator><call><name>getFunctionProtoType</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>FnTy</name><operator>-&gt;</operator><name>hasDynamicExceptionSpec</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>













<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(<argument>isNoThrow</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl,
FunctionProtoType)</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>FnTy</name> <init>= <expr><name>internal</name><operator>::</operator><call><name>getFunctionProtoType</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><operator>!</operator><name>FnTy</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>isUnresolvedExceptionSpec</name><argument_list>(<argument><expr><call><name><name>FnTy</name><operator>-&gt;</operator><name>getExceptionSpecType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name><name>FnTy</name><operator>-&gt;</operator><name>isNothrow</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>
















<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(<argument>isConstexpr</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(VarDecl,
FunctionDecl,
IfStmt)</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isConstexpr</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>






















<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(<argument>hasInitStatement</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(IfStmt, SwitchStmt,
CXXForRangeStmt)</argument>,
<argument>internal::Matcher&lt;Stmt&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>Init</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getInit</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>Init</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator> <call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Init</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>








<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(
<argument>hasCondition</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(IfStmt, ForStmt, WhileStmt, DoStmt,
SwitchStmt, AbstractConditionalOperator)</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier><specifier>const</specifier></type> <name>Condition</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getCond</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>Condition</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Condition</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>








<macro><name>AST_MATCHER_P</name><argument_list>(<argument>IfStmt</argument>, <argument>hasThen</argument>, <argument>internal::Matcher&lt;Stmt&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier><specifier>const</specifier></type> <name>Then</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getThen</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>Then</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator> <call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Then</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>








<macro><name>AST_MATCHER_P</name><argument_list>(<argument>IfStmt</argument>, <argument>hasElse</argument>, <argument>internal::Matcher&lt;Stmt&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier><specifier>const</specifier></type> <name>Else</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getElse</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>Else</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator> <call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Else</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>






















<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(<argument>equalsBoundNode</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(Stmt, Decl, Type,
QualType)</argument>,
<argument>std::string</argument>, <argument>ID</argument>)</argument_list></macro> <block>{<block_content>






<expr_stmt><expr><name>internal</name><operator>::</operator><name>NotEqualsBoundNodePredicate</name> <name>Predicate</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Predicate</name><operator>.</operator><name>ID</name></name> <operator>=</operator> <name>ID</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Predicate</name><operator>.</operator><name>Node</name></name> <operator>=</operator> <name>DynTypedNode</name><operator>::</operator><call><name>create</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>Builder</name><operator>-&gt;</operator><name>removeBindings</name></name><argument_list>(<argument><expr><name>Predicate</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>









<macro><name>AST_MATCHER_P</name><argument_list>(<argument>IfStmt</argument>, <argument>hasConditionVariableStatement</argument>,
<argument>internal::Matcher&lt;DeclStmt&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>DeclStmt</name><modifier>*</modifier> <specifier>const</specifier></type> <name>DeclarationStatement</name> <init>=
<expr><call><name><name>Node</name><operator>.</operator><name>getConditionVariableDeclStmt</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>DeclarationStatement</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>DeclarationStatement</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>










<macro><name>AST_MATCHER_P</name><argument_list>(<argument>ArraySubscriptExpr</argument>, <argument>hasIndex</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>Expr</name><modifier>*</modifier></type> <name>Expression</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getIdx</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Expression</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER_P</name><argument_list>(<argument>ArraySubscriptExpr</argument>, <argument>hasBase</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>Expr</name><modifier>*</modifier></type> <name>Expression</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Expression</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>


























<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(<argument>hasBody</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(DoStmt, ForStmt,
WhileStmt,
CXXForRangeStmt,
FunctionDecl)</argument>,
<argument>internal::Matcher&lt;Stmt&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Finder</name><operator>-&gt;</operator><name>isTraversalIgnoringImplicitNodes</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isDefaultedHelper</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier><specifier>const</specifier></type> <name>Statement</name> <init>= <expr><name>internal</name><operator>::</operator><name><name>GetBodyMatcher</name><argument_list type="generic">&lt;<argument><expr><name>NodeType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>get</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>Statement</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Statement</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>

















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>FunctionDecl</argument>, <argument>hasAnyBody</argument>,
<argument>internal::Matcher&lt;Stmt&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier><specifier>const</specifier></type> <name>Statement</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>Statement</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Statement</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>













<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(<argument>hasAnySubstatement</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(CompoundStmt,
StmtExpr)</argument>,
<argument>internal::Matcher&lt;Stmt&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>CompoundStmt</name> <modifier>*</modifier></type><name>CS</name> <init>= <expr><name><name>CompoundStmtMatcher</name><argument_list type="generic">&lt;<argument><expr><name>NodeType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>get</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>CS</name> <operator>&amp;&amp;</operator> <call><name>matchesFirstInPointerRange</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><call><name><name>CS</name><operator>-&gt;</operator><name>body_begin</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>CS</name><operator>-&gt;</operator><name>body_end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>,
<argument><expr><name>Builder</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name><name>CS</name><operator>-&gt;</operator><name>body_end</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER_P</name><argument_list>(<argument>CompoundStmt</argument>, <argument>statementCountIs</argument>, <argument>unsigned</argument>, <argument>N</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>N</name></expr>;</return>
</block_content>}</block>


























<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ValueT</name></expr></argument>&gt;</argument_list></name>
<name>internal</name><operator>::</operator><name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name>ValueEqualsMatcher</name></expr></argument>,
<argument><expr><name>void</name><operator>(</operator><name>internal</name><operator>::</operator><name>AllNodeBaseTypes</name><operator>)</operator></expr></argument>, <argument><expr><name>ValueT</name></expr></argument>&gt;</argument_list></name>
<macro><name>equals</name><argument_list>(<argument>const ValueT &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name>ValueEqualsMatcher</name></expr></argument>,
<argument><expr><name>void</name><operator>(</operator><name>internal</name><operator>::</operator><name>AllNodeBaseTypes</name><operator>)</operator></expr></argument>, <argument><expr><name>ValueT</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>Value</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<macro><name>AST_POLYMORPHIC_MATCHER_P_OVERLOAD</name><argument_list>(<argument>equals</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(CharacterLiteral,
CXXBoolLiteralExpr,
IntegerLiteral)</argument>,
<argument>bool</argument>, <argument>Value</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ValueEqualsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>NodeType</name></expr></argument>, <argument><expr><name>ParamT</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>matchesNode</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>AST_POLYMORPHIC_MATCHER_P_OVERLOAD</name><argument_list>(<argument>equals</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(CharacterLiteral,
CXXBoolLiteralExpr,
IntegerLiteral)</argument>,
<argument>unsigned</argument>, <argument>Value</argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ValueEqualsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>NodeType</name></expr></argument>, <argument><expr><name>ParamT</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>matchesNode</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<macro><name>AST_POLYMORPHIC_MATCHER_P_OVERLOAD</name><argument_list>(<argument>equals</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(CharacterLiteral,
CXXBoolLiteralExpr,
FloatingLiteral,
IntegerLiteral)</argument>,
<argument>double</argument>, <argument>Value</argument>, <argument><literal type="number">2</literal></argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ValueEqualsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>NodeType</name></expr></argument>, <argument><expr><name>ParamT</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>matchesNode</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>








<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(
<argument>hasOperatorName</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(BinaryOperator, CXXOperatorCallExpr,
CXXRewrittenBinaryOperator, UnaryOperator)</argument>,
<argument>std::string</argument>, <argument>Name</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name></type> <name>OpName</name> <init>= <expr><name>internal</name><operator>::</operator><call><name>getOpName</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>*</operator><name>OpName</name> <operator>==</operator> <name>Name</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>







<extern>extern const internal::VariadicFunction&lt;
internal::PolymorphicMatcher&lt;internal::HasAnyOperatorNameMatcher<operator>,</operator>
AST_POLYMORPHIC_SUPPORTED_TYPES(
BinaryOperator<operator>,</operator> CXXOperatorCallExpr<operator>,</operator>
CXXRewrittenBinaryOperator<operator>,</operator> UnaryOperator</extern>)<operator>,</operator>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>&gt;</operator></expr><operator>,</operator>
<expr><name>StringRef</name></expr><operator>,</operator> <expr><name>internal</name><operator>::</operator><name>hasAnyOperatorNameFunc</name><operator>&gt;</operator>
<name>hasAnyOperatorName</name></expr>;</expr_stmt>















<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(
<argument>isAssignmentOperator</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(BinaryOperator, CXXOperatorCallExpr,
CXXRewrittenBinaryOperator)</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isAssignmentOp</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>















<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(
<argument>isComparisonOperator</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(BinaryOperator, CXXOperatorCallExpr,
CXXRewrittenBinaryOperator)</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isComparisonOp</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>







<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(<argument>hasLHS</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(
BinaryOperator, CXXOperatorCallExpr,
CXXRewrittenBinaryOperator, ArraySubscriptExpr)</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>LeftHandSide</name> <init>= <expr><name>internal</name><operator>::</operator><call><name>getLHS</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>LeftHandSide</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>LeftHandSide</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>







<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(<argument>hasRHS</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(
BinaryOperator, CXXOperatorCallExpr,
CXXRewrittenBinaryOperator, ArraySubscriptExpr)</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>RightHandSide</name> <init>= <expr><name>internal</name><operator>::</operator><call><name>getRHS</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>RightHandSide</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>RightHandSide</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>



<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(
<argument>hasEitherOperand</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(BinaryOperator, CXXOperatorCallExpr,
CXXRewrittenBinaryOperator)</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><name>internal</name><operator>::</operator><call><call><name><name>VariadicDynCastAllOfMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name></expr></argument>, <argument><expr><name>NodeType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><argument_list>(
<argument><expr><call><name>anyOf</name><argument_list>(<argument><expr><call><name>hasLHS</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>hasRHS</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>











<macro><name>AST_POLYMORPHIC_MATCHER_P2</name><argument_list>(
<argument>hasOperands</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(BinaryOperator, CXXOperatorCallExpr,
CXXRewrittenBinaryOperator)</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>Matcher1</argument>, <argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>Matcher2</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><name>internal</name><operator>::</operator><call><call><name><name>VariadicDynCastAllOfMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name></expr></argument>, <argument><expr><name>NodeType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><argument_list>(
<argument><expr><call><name>anyOf</name><argument_list>(<argument><expr><call><name>allOf</name><argument_list>(<argument><expr><call><name>hasLHS</name><argument_list>(<argument><expr><name>Matcher1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>hasRHS</name><argument_list>(<argument><expr><name>Matcher2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>allOf</name><argument_list>(<argument><expr><call><name>hasLHS</name><argument_list>(<argument><expr><name>Matcher2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>hasRHS</name><argument_list>(<argument><expr><name>Matcher1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>matches</name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>








<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(<argument>hasUnaryOperand</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(UnaryOperator,
CXXOperatorCallExpr)</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier><specifier>const</specifier></type> <name>Operand</name> <init>= <expr><name>internal</name><operator>::</operator><call><name>getSubExpr</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>Operand</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Operand</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>
















<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(<argument>hasSourceExpression</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(CastExpr,
OpaqueValueExpr)</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier><specifier>const</specifier></type> <name>SubExpression</name> <init>=
<expr><name>internal</name><operator>::</operator><name><name>GetSourceExpressionMatcher</name><argument_list type="generic">&lt;<argument><expr><name>NodeType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>get</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>SubExpression</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>SubExpression</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER_P</name><argument_list>(<argument>CastExpr</argument>, <argument>hasCastKind</argument>, <argument>CastKind</argument>, <argument>Kind</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getCastKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Kind</name></expr>;</return>
</block_content>}</block>





<macro><name>AST_MATCHER_P</name><argument_list>(<argument>ExplicitCastExpr</argument>, <argument>hasDestinationType</argument>,
<argument>internal::Matcher&lt;QualType&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>QualType</name></type> <name>NodeType</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getTypeAsWritten</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><name>NodeType</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>





<macro><name>AST_MATCHER_P</name><argument_list>(<argument>ImplicitCastExpr</argument>, <argument>hasImplicitDestinationType</argument>,
<argument>internal::Matcher&lt;QualType&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>










<macro><name>AST_MATCHER</name><argument_list>(<argument>TagDecl</argument>, <argument>isStruct</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isStruct</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>










<macro><name>AST_MATCHER</name><argument_list>(<argument>TagDecl</argument>, <argument>isUnion</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isUnion</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>










<macro><name>AST_MATCHER</name><argument_list>(<argument>TagDecl</argument>, <argument>isClass</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isClass</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>










<macro><name>AST_MATCHER</name><argument_list>(<argument>TagDecl</argument>, <argument>isEnum</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isEnum</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER_P</name><argument_list>(<argument>AbstractConditionalOperator</argument>, <argument>hasTrueExpression</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Expression</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getTrueExpr</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>Expression</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Expression</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>









<macro><name>AST_MATCHER_P</name><argument_list>(<argument>AbstractConditionalOperator</argument>, <argument>hasFalseExpression</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Expression</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getFalseExpr</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>Expression</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Expression</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>





















<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(<argument>isDefinition</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(TagDecl, VarDecl,
ObjCMethodDecl,
FunctionDecl)</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isThisDeclarationADefinition</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER</name><argument_list>(<argument>FunctionDecl</argument>, <argument>isVariadic</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isVariadic</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>


















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>CXXMethodDecl</argument>, <argument>ofClass</argument>,
<argument>internal::Matcher&lt;CXXRecordDecl&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>

<function_decl><type><name>ASTChildrenNotSpelledInSourceScope</name></type> <name>RAII</name><parameter_list>(<parameter><decl><type><name>Finder</name></type></decl></parameter>, <parameter><decl><type><name>false</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Parent</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getParent</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>Parent</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Parent</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>

























<macro><name>AST_MATCHER_P</name><argument_list>(<argument>CXXMethodDecl</argument>, <argument>forEachOverridden</argument>,
<argument>internal::Matcher&lt;CXXMethodDecl&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>BoundNodesTreeBuilder</name></type> <name>Result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Matched</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>Overridden</name> <range>: <expr><call><name><name>Node</name><operator>.</operator><name>overridden_methods</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BoundNodesTreeBuilder</name></type> <name>OverriddenBuilder</name><argument_list>(<argument><expr><operator>*</operator><name>Builder</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>OverriddenMatched</name> <init>=
<expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Overridden</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>OverriddenBuilder</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>OverriddenMatched</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Matched</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Result</name><operator>.</operator><name>addMatch</name></name><argument_list>(<argument><expr><name>OverriddenBuilder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>Builder</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Matched</name></expr>;</return>
</block_content>}</block>




















<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(<argument>isVirtual</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(CXXMethodDecl,
CXXBaseSpecifier)</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isVirtual</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>















<macro><name>AST_MATCHER</name><argument_list>(<argument>CXXMethodDecl</argument>, <argument>isVirtualAsWritten</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isVirtualAsWritten</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>
















<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(<argument>isFinal</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(CXXRecordDecl,
CXXMethodDecl)</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><name><name>Node</name><operator>.</operator><name>template</name></name> <call><name><name>hasAttr</name><argument_list type="generic">&lt;<argument><expr><name>FinalAttr</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER</name><argument_list>(<argument>CXXMethodDecl</argument>, <argument>isPure</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isPure</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER</name><argument_list>(<argument>CXXMethodDecl</argument>, <argument>isConst</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isConst</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>














<macro><name>AST_MATCHER</name><argument_list>(<argument>CXXMethodDecl</argument>, <argument>isCopyAssignmentOperator</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isCopyAssignmentOperator</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>














<macro><name>AST_MATCHER</name><argument_list>(<argument>CXXMethodDecl</argument>, <argument>isMoveAssignmentOperator</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isMoveAssignmentOperator</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>















<macro><name>AST_MATCHER</name><argument_list>(<argument>CXXMethodDecl</argument>, <argument>isOverride</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>size_overridden_methods</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>Node</name><operator>.</operator><name>hasAttr</name></name><operator>&lt;</operator><name>OverrideAttr</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER</name><argument_list>(<argument>CXXMethodDecl</argument>, <argument>isUserProvided</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isUserProvided</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>

























<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(
<argument>isArrow</argument>, <argument>AST_POLYMORPHIC_SUPPORTED_TYPES(MemberExpr, UnresolvedMemberExpr,
CXXDependentScopeMemberExpr)</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isArrow</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER</name><argument_list>(<argument>QualType</argument>, <argument>isInteger</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>-&gt;</operator><name>isIntegerType</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER</name><argument_list>(<argument>QualType</argument>, <argument>isUnsignedInteger</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>-&gt;</operator><name>isUnsignedIntegerType</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER</name><argument_list>(<argument>QualType</argument>, <argument>isSignedInteger</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>-&gt;</operator><name>isSignedIntegerType</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER</name><argument_list>(<argument>QualType</argument>, <argument>isAnyCharacter</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>-&gt;</operator><name>isAnyCharacterType</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>

















<macro><name>AST_MATCHER</name><argument_list>(<argument>QualType</argument>, <argument>isAnyPointer</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>-&gt;</operator><name>isAnyPointerType</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>
















<macro><name>AST_MATCHER</name><argument_list>(<argument>QualType</argument>, <argument>isConstQualified</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isConstQualified</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>
















<macro><name>AST_MATCHER</name><argument_list>(<argument>QualType</argument>, <argument>isVolatileQualified</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isVolatileQualified</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>














<macro><name>AST_MATCHER</name><argument_list>(<argument>QualType</argument>, <argument>hasLocalQualifiers</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>hasLocalQualifiers</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>













<macro><name>AST_MATCHER_P</name><argument_list>(<argument>MemberExpr</argument>, <argument>member</argument>,
<argument>internal::Matcher&lt;ValueDecl&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>getMemberDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

















<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(
<argument>hasObjectExpression</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(MemberExpr, UnresolvedMemberExpr,
CXXDependentScopeMemberExpr)</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>E</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedMemberExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>isImplicitAccess</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>E</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXDependentScopeMemberExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>isImplicitAccess</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>










<macro><name>AST_MATCHER_P</name><argument_list>(<argument>BaseUsingDecl</argument>, <argument>hasAnyUsingShadowDecl</argument>,
<argument>internal::Matcher&lt;UsingShadowDecl&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name>matchesFirstInPointerRange</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><call><name><name>Node</name><operator>.</operator><name>shadow_begin</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Node</name><operator>.</operator><name>shadow_end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>,
<argument><expr><name>Builder</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name><name>Node</name><operator>.</operator><name>shadow_end</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>













<macro><name>AST_MATCHER_P</name><argument_list>(<argument>UsingShadowDecl</argument>, <argument>hasTargetDecl</argument>,
<argument>internal::Matcher&lt;NamedDecl&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>getTargetDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>




























<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(<argument>isTemplateInstantiation</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl, VarDecl,
CXXRecordDecl)</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name><name>Node</name><operator>.</operator><name>getTemplateSpecializationKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>TSK_ImplicitInstantiation</name> <operator>||</operator>
<call><name><name>Node</name><operator>.</operator><name>getTemplateSpecializationKind</name></name><argument_list>()</argument_list></call> <operator>==</operator>
<name>TSK_ExplicitInstantiationDefinition</name> <operator>||</operator>
<call><name><name>Node</name><operator>.</operator><name>getTemplateSpecializationKind</name></name><argument_list>()</argument_list></call> <operator>==</operator>
<name>TSK_ExplicitInstantiationDeclaration</name><operator>)</operator></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER_FUNCTION</name><argument_list>(<argument>internal::Matcher&lt;Decl&gt;</argument>, <argument>isInstantiated</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>IsInstantiation</name> <init>= <expr><call><name>decl</name><argument_list>(<argument><expr><call><name>anyOf</name><argument_list>(<argument><expr><call><name>cxxRecordDecl</name><argument_list>(<argument><expr><call><name>isTemplateInstantiation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>functionDecl</name><argument_list>(<argument><expr><call><name>isTemplateInstantiation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>decl</name><argument_list>(<argument><expr><call><name>anyOf</name><argument_list>(<argument><expr><name>IsInstantiation</name></expr></argument>, <argument><expr><call><name>hasAncestor</name><argument_list>(<argument><expr><name>IsInstantiation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>















<macro><name>AST_MATCHER_FUNCTION</name><argument_list>(<argument>internal::Matcher&lt;Stmt&gt;</argument>, <argument>isInTemplateInstantiation</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name>stmt</name><argument_list>(
<argument><expr><call><name>hasAncestor</name><argument_list>(<argument><expr><call><name>decl</name><argument_list>(<argument><expr><call><name>anyOf</name><argument_list>(<argument><expr><call><name>cxxRecordDecl</name><argument_list>(<argument><expr><call><name>isTemplateInstantiation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>functionDecl</name><argument_list>(<argument><expr><call><name>isTemplateInstantiation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>













<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(<argument>isExplicitTemplateSpecialization</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(FunctionDecl, VarDecl,
CXXRecordDecl)</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name><name>Node</name><operator>.</operator><name>getTemplateSpecializationKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>TSK_ExplicitSpecialization</name><operator>)</operator></expr>;</return>
</block_content>}</block>



<macro><name>AST_MATCHER_FUNCTION_P_OVERLOAD</name><argument_list>(<argument>internal::BindableMatcher&lt;TypeLoc&gt;</argument>, <argument>loc</argument>,
<argument>internal::Matcher&lt;QualType&gt;</argument>, <argument>InnerMatcher</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><name>internal</name><operator>::</operator><macro><name>BindableMatcher</name></macro><operator>&lt;</operator><name>TypeLoc</name><operator>&gt;</operator><operator>(</operator>
<name>new</name> <name>internal</name><operator>::</operator><call><name>TypeLocTypeMatcher</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>









<macro><name>AST_MATCHER</name><argument_list>(<argument>Type</argument>, <argument>booleanType</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isBooleanType</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>









<macro><name>AST_MATCHER</name><argument_list>(<argument>Type</argument>, <argument>voidType</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isVoidType</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>NodeType</name></expr></argument>&gt;</argument_list></name>
<name>using</name></type> <name>AstTypeMatcher</name> <init>= <expr><name>internal</name><operator>::</operator><name><name>VariadicDynCastAllOfMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Type</name></expr></argument>, <argument><expr><name>NodeType</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>













<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>BuiltinType</name></expr></argument>&gt;</argument_list></name></type> <name>builtinType</name></decl>;</decl_stmt>











<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>ArrayType</name></expr></argument>&gt;</argument_list></name></type> <name>arrayType</name></decl>;</decl_stmt>









<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>ComplexType</name></expr></argument>&gt;</argument_list></name></type> <name>complexType</name></decl>;</decl_stmt>










<macro><name>AST_MATCHER</name><argument_list>(<argument>Type</argument>, <argument>realFloatingPointType</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isRealFloatingType</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>














<expr_stmt><expr><call><name>AST_TYPELOC_TRAVERSE_MATCHER_DECL</name><argument_list>(<argument><expr><name>hasElementType</name></expr></argument>, <argument><expr><name>getElement</name></expr></argument>,
<argument><expr><call><name>AST_POLYMORPHIC_SUPPORTED_TYPES</name><argument_list>(<argument><expr><name>ArrayType</name></expr></argument>,
<argument><expr><name>ComplexType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>













<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>ConstantArrayType</name></expr></argument>&gt;</argument_list></name></type> <name>constantArrayType</name></decl>;</decl_stmt>
















<macro><name>AST_POLYMORPHIC_MATCHER_P</name><argument_list>(<argument>hasSize</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(ConstantArrayType,
StringLiteral)</argument>,
<argument>unsigned</argument>, <argument>N</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><name>internal</name><operator>::</operator><name><name>HasSizeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>NodeType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>hasSize</name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>












<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>DependentSizedArrayType</name></expr></argument>&gt;</argument_list></name></type> <name>dependentSizedArrayType</name></decl>;</decl_stmt>











<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>IncompleteArrayType</name></expr></argument>&gt;</argument_list></name></type> <name>incompleteArrayType</name></decl>;</decl_stmt>














<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>VariableArrayType</name></expr></argument>&gt;</argument_list></name></type> <name>variableArrayType</name></decl>;</decl_stmt>













<macro><name>AST_MATCHER_P</name><argument_list>(<argument>VariableArrayType</argument>, <argument>hasSizeExpr</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>









<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>AtomicType</name></expr></argument>&gt;</argument_list></name></type> <name>atomicType</name></decl>;</decl_stmt>












<expr_stmt><expr><call><name>AST_TYPELOC_TRAVERSE_MATCHER_DECL</name><argument_list>(<argument><expr><name>hasValueType</name></expr></argument>, <argument><expr><name>getValue</name></expr></argument>,
<argument><expr><call><name>AST_POLYMORPHIC_SUPPORTED_TYPES</name><argument_list>(<argument><expr><name>AtomicType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>











<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>AutoType</name></expr></argument>&gt;</argument_list></name></type> <name>autoType</name></decl>;</decl_stmt>











<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>DecltypeType</name></expr></argument>&gt;</argument_list></name></type> <name>decltypeType</name></decl>;</decl_stmt>















<expr_stmt><expr><call><name>AST_TYPE_TRAVERSE_MATCHER</name><argument_list>(<argument><expr><name>hasDeducedType</name></expr></argument>, <argument><expr><name>getDeducedType</name></expr></argument>,
<argument><expr><call><name>AST_POLYMORPHIC_SUPPORTED_TYPES</name><argument_list>(<argument><expr><name>AutoType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>












<expr_stmt><expr><call><name>AST_TYPE_TRAVERSE_MATCHER</name><argument_list>(<argument><expr><name>hasUnderlyingType</name></expr></argument>, <argument><expr><name>getUnderlyingType</name></expr></argument>,
<argument><expr><call><name>AST_POLYMORPHIC_SUPPORTED_TYPES</name><argument_list>(<argument><expr><name>DecltypeType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>










<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>FunctionType</name></expr></argument>&gt;</argument_list></name></type> <name>functionType</name></decl>;</decl_stmt>











<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name></expr></argument>&gt;</argument_list></name></type> <name>functionProtoType</name></decl>;</decl_stmt>











<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>ParenType</name></expr></argument>&gt;</argument_list></name></type> <name>parenType</name></decl>;</decl_stmt>













<expr_stmt><expr><call><name>AST_TYPE_TRAVERSE_MATCHER</name><argument_list>(<argument><expr><name>innerType</name></expr></argument>, <argument><expr><name>getInnerType</name></expr></argument>,
<argument><expr><call><name>AST_POLYMORPHIC_SUPPORTED_TYPES</name><argument_list>(<argument><expr><name>ParenType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>BlockPointerType</name></expr></argument>&gt;</argument_list></name></type> <name>blockPointerType</name></decl>;</decl_stmt>









<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>MemberPointerType</name></expr></argument>&gt;</argument_list></name></type> <name>memberPointerType</name></decl>;</decl_stmt>
















<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>PointerType</name></expr></argument>&gt;</argument_list></name></type> <name>pointerType</name></decl>;</decl_stmt>














<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectPointerType</name></expr></argument>&gt;</argument_list></name></type> <name>objcObjectPointerType</name></decl>;</decl_stmt>















<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>ReferenceType</name></expr></argument>&gt;</argument_list></name></type> <name>referenceType</name></decl>;</decl_stmt>
















<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>LValueReferenceType</name></expr></argument>&gt;</argument_list></name></type> <name>lValueReferenceType</name></decl>;</decl_stmt>
















<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>RValueReferenceType</name></expr></argument>&gt;</argument_list></name></type> <name>rValueReferenceType</name></decl>;</decl_stmt>















<expr_stmt><expr><call><name>AST_TYPELOC_TRAVERSE_MATCHER_DECL</name><argument_list>(
<argument><expr><name>pointee</name></expr></argument>, <argument><expr><name>getPointee</name></expr></argument>,
<argument><expr><call><name>AST_POLYMORPHIC_SUPPORTED_TYPES</name><argument_list>(<argument><expr><name>BlockPointerType</name></expr></argument>, <argument><expr><name>MemberPointerType</name></expr></argument>,
<argument><expr><name>PointerType</name></expr></argument>, <argument><expr><name>ReferenceType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>









<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>TypedefType</name></expr></argument>&gt;</argument_list></name></type> <name>typedefType</name></decl>;</decl_stmt>














<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>EnumType</name></expr></argument>&gt;</argument_list></name></type> <name>enumType</name></decl>;</decl_stmt>














<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>TemplateSpecializationType</name></expr></argument>&gt;</argument_list></name></type>
<name>templateSpecializationType</name></decl>;</decl_stmt>













<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>DeducedTemplateSpecializationType</name></expr></argument>&gt;</argument_list></name></type>
<name>deducedTemplateSpecializationType</name></decl>;</decl_stmt>









<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>UnaryTransformType</name></expr></argument>&gt;</argument_list></name></type> <name>unaryTransformType</name></decl>;</decl_stmt>














<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>RecordType</name></expr></argument>&gt;</argument_list></name></type> <name>recordType</name></decl>;</decl_stmt>














<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>TagType</name></expr></argument>&gt;</argument_list></name></type> <name>tagType</name></decl>;</decl_stmt>



















<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>ElaboratedType</name></expr></argument>&gt;</argument_list></name></type> <name>elaboratedType</name></decl>;</decl_stmt>
















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>ElaboratedType</argument>, <argument>hasQualifier</argument>,
<argument>internal::Matcher&lt;NestedNameSpecifier&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>NestedNameSpecifier</name> <modifier>*</modifier></type><name>Qualifier</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getQualifier</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Qualifier</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>
















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>ElaboratedType</argument>, <argument>namesType</argument>, <argument>internal::Matcher&lt;QualType&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getNamedType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>













<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>SubstTemplateTypeParmType</name></expr></argument>&gt;</argument_list></name></type>
<name>substTemplateTypeParmType</name></decl>;</decl_stmt>













<expr_stmt><expr><call><name>AST_TYPE_TRAVERSE_MATCHER</name><argument_list>(
<argument><expr><name>hasReplacementType</name></expr></argument>, <argument><expr><name>getReplacementType</name></expr></argument>,
<argument><expr><call><name>AST_POLYMORPHIC_SUPPORTED_TYPES</name><argument_list>(<argument><expr><name>SubstTemplateTypeParmType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>








<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>TemplateTypeParmType</name></expr></argument>&gt;</argument_list></name></type> <name>templateTypeParmType</name></decl>;</decl_stmt>











<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InjectedClassNameType</name></expr></argument>&gt;</argument_list></name></type> <name>injectedClassNameType</name></decl>;</decl_stmt>











<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>AstTypeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>DecayedType</name></expr></argument>&gt;</argument_list></name></type> <name>decayedType</name></decl>;</decl_stmt>


<macro><name>AST_MATCHER_P</name><argument_list>(<argument>DecayedType</argument>, <argument>hasDecayedType</argument>, <argument>internal::Matcher&lt;QualType&gt;</argument>,
<argument>InnerType</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>InnerType</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getDecayedType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>Decl</argument>, <argument>hasDeclContext</argument>, <argument>internal::Matcher&lt;Decl&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>DC</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getDeclContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>DC</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Decl</name><operator>::</operator><call><name>castFromDeclContext</name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>














<extern>extern const internal::VariadicAllOfMatcher&lt;NestedNameSpecifier&gt;
nestedNameSpecifier;</extern>


<extern>extern const internal::VariadicAllOfMatcher&lt;NestedNameSpecifierLoc&gt;
nestedNameSpecifierLoc;</extern>



<macro><name>AST_MATCHER_FUNCTION_P_OVERLOAD</name><argument_list>(
<argument>internal::BindableMatcher&lt;NestedNameSpecifierLoc&gt;</argument>, <argument>loc</argument>,
<argument>internal::Matcher&lt;NestedNameSpecifier&gt;</argument>, <argument>InnerMatcher</argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><name>internal</name><operator>::</operator><macro><name>BindableMatcher</name></macro><operator>&lt;</operator><name>NestedNameSpecifierLoc</name><operator>&gt;</operator><operator>(</operator>
<name>new</name> <name>internal</name><operator>::</operator><call><name><name>LocMatcher</name><argument_list type="generic">&lt;<argument><expr><name>NestedNameSpecifierLoc</name></expr></argument>, <argument><expr><name>NestedNameSpecifier</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>













<macro><name>AST_MATCHER_P</name><argument_list>(<argument>NestedNameSpecifier</argument>, <argument>specifiesType</argument>,
<argument>internal::Matcher&lt;QualType&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Node</name><operator>.</operator><name>getAsType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><call><name>QualType</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getAsType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER_P</name><argument_list>(<argument>NestedNameSpecifierLoc</argument>, <argument>specifiesTypeLoc</argument>,
<argument>internal::Matcher&lt;TypeLoc&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><name>Node</name> <operator>&amp;&amp;</operator> <call><name><name>Node</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getAsType</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>










<macro><name>AST_MATCHER_P_OVERLOAD</name><argument_list>(<argument>NestedNameSpecifier</argument>, <argument>hasPrefix</argument>,
<argument>internal::Matcher&lt;NestedNameSpecifier&gt;</argument>, <argument>InnerMatcher</argument>,
<argument><literal type="number">0</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>NestedNameSpecifier</name> <modifier>*</modifier></type><name>NextNode</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getPrefix</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NextNode</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>NextNode</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>










<macro><name>AST_MATCHER_P_OVERLOAD</name><argument_list>(<argument>NestedNameSpecifierLoc</argument>, <argument>hasPrefix</argument>,
<argument>internal::Matcher&lt;NestedNameSpecifierLoc&gt;</argument>, <argument>InnerMatcher</argument>,
<argument><literal type="number">1</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>NestedNameSpecifierLoc</name></type> <name>NextNode</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getPrefix</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NextNode</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><name>NextNode</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER_P</name><argument_list>(<argument>NestedNameSpecifier</argument>, <argument>specifiesNamespace</argument>,
<argument>internal::Matcher&lt;NamespaceDecl&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Node</name><operator>.</operator><name>getAsNamespace</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>getAsNamespace</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>








<macro><name>AST_MATCHER_P_OVERLOAD</name><argument_list>(<argument>Decl</argument>, <argument>equalsNode</argument>, <argument>const Decl*</argument>, <argument>Other</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><operator>&amp;</operator><name>Node</name> <operator>==</operator> <name>Other</name></expr>;</return>
</block_content>}</block>



<macro><name>AST_MATCHER_P_OVERLOAD</name><argument_list>(<argument>Stmt</argument>, <argument>equalsNode</argument>, <argument>const Stmt*</argument>, <argument>Other</argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><operator>&amp;</operator><name>Node</name> <operator>==</operator> <name>Other</name></expr>;</return>
</block_content>}</block>



<macro><name>AST_MATCHER_P_OVERLOAD</name><argument_list>(<argument>Type</argument>, <argument>equalsNode</argument>, <argument>const Type*</argument>, <argument>Other</argument>, <argument><literal type="number">2</literal></argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><operator>&amp;</operator><name>Node</name> <operator>==</operator> <name>Other</name></expr>;</return>
</block_content>}</block>














<macro><name>AST_MATCHER_P</name><argument_list>(<argument>SwitchStmt</argument>, <argument>forEachSwitchCase</argument>, <argument>internal::Matcher&lt;SwitchCase&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>BoundNodesTreeBuilder</name></type> <name>Result</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>Matched</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>SwitchCase</name> <modifier>*</modifier></type><name>SC</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getSwitchCaseList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>SC</name></expr>;</condition>
<incr><expr><name>SC</name> <operator>=</operator> <call><name><name>SC</name><operator>-&gt;</operator><name>getNextSwitchCase</name></name><argument_list>()</argument_list></call></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BoundNodesTreeBuilder</name></type> <name>CaseBuilder</name><argument_list>(<argument><expr><operator>*</operator><name>Builder</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>CaseMatched</name> <init>= <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>SC</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>CaseBuilder</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>CaseMatched</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Matched</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Result</name><operator>.</operator><name>addMatch</name></name><argument_list>(<argument><expr><name>CaseBuilder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>Builder</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Matched</name></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER_P</name><argument_list>(<argument>CXXConstructorDecl</argument>, <argument>forEachConstructorInitializer</argument>,
<argument>internal::Matcher&lt;CXXCtorInitializer&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>BoundNodesTreeBuilder</name></type> <name>Result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Matched</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>I</name> <range>: <expr><call><name><name>Node</name><operator>.</operator><name>inits</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Finder</name><operator>-&gt;</operator><name>isTraversalIgnoringImplicitNodes</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>I</name><operator>-&gt;</operator><name>isWritten</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>BoundNodesTreeBuilder</name></type> <name>InitBuilder</name><argument_list>(<argument><expr><operator>*</operator><name>Builder</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>I</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>InitBuilder</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Matched</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Result</name><operator>.</operator><name>addMatch</name></name><argument_list>(<argument><expr><name>InitBuilder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>Builder</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Matched</name></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER</name><argument_list>(<argument>CXXConstructorDecl</argument>, <argument>isCopyConstructor</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isCopyConstructor</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER</name><argument_list>(<argument>CXXConstructorDecl</argument>, <argument>isMoveConstructor</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isMoveConstructor</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER</name><argument_list>(<argument>CXXConstructorDecl</argument>, <argument>isDefaultConstructor</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isDefaultConstructor</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>














<macro><name>AST_MATCHER</name><argument_list>(<argument>CXXConstructorDecl</argument>, <argument>isDelegatingConstructor</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isDelegatingConstructor</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>























<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(<argument>isExplicit</argument>, <argument>AST_POLYMORPHIC_SUPPORTED_TYPES(
CXXConstructorDecl, CXXConversionDecl,
CXXDeductionGuideDecl)</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isExplicit</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>






















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>FunctionDecl</argument>, <argument>hasExplicitSpecifier</argument>, <argument>internal::Matcher&lt;Expr&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>ExplicitSpecifier</name></type> <name>ES</name> <init>= <expr><name>ExplicitSpecifier</name><operator>::</operator><call><name>getFromDecl</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>ES</name><operator>.</operator><name>getExpr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<function_decl><type><name>ASTChildrenNotSpelledInSourceScope</name></type> <name>RAII</name><parameter_list>(<parameter><decl><type><name>Finder</name></type></decl></parameter>, <parameter><decl><type><name>false</name></type></decl></parameter>)</parameter_list>;</function_decl>

<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>ES</name><operator>.</operator><name>getExpr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>














<macro><name>AST_POLYMORPHIC_MATCHER</name><argument_list>(<argument>isInline</argument>,
<argument>AST_POLYMORPHIC_SUPPORTED_TYPES(NamespaceDecl,
FunctionDecl)</argument>)</argument_list></macro> <block>{<block_content>


<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>FD</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>FD</name><operator>-&gt;</operator><name>isInlineSpecified</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>NSD</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>NamespaceDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>NSD</name><operator>-&gt;</operator><name>isInline</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Not a valid polymorphic type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>










<macro><name>AST_MATCHER</name><argument_list>(<argument>NamespaceDecl</argument>, <argument>isAnonymous</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isAnonymousNamespace</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>






















<macro><name>AST_MATCHER</name><argument_list>(<argument>Decl</argument>, <argument>isInStdNamespace</argument>)</argument_list></macro> <block>{<block_content> <return>return <expr><call><name><name>Node</name><operator>.</operator><name>isInStdNamespace</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block>










<macro><name>AST_MATCHER_P</name><argument_list>(<argument>CaseStmt</argument>, <argument>hasCaseConstant</argument>, <argument>internal::Matcher&lt;Expr&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Node</name><operator>.</operator><name>getRHS</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>getLHS</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>










<macro><name>AST_MATCHER_P</name><argument_list>(<argument>Decl</argument>, <argument>hasAttr</argument>, <argument>attr::Kind</argument>, <argument>AttrKind</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>Attr</name> <range>: <expr><call><name><name>Node</name><operator>.</operator><name>attrs</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Attr</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>AttrKind</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>











<macro><name>AST_MATCHER_P</name><argument_list>(<argument>ReturnStmt</argument>, <argument>hasReturnValue</argument>, <argument>internal::Matcher&lt;Expr&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>RetValue</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getRetValue</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>RetValue</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>







<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> CUDAKernelCallExpr&gt;
cudaKernelCallExpr;</extern>
















<macro><name>AST_MATCHER_FUNCTION</name><argument_list>(<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>nullPointerConstant</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name>anyOf</name><argument_list>(
<argument><expr><call><name>gnuNullExpr</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>cxxNullPtrLiteralExpr</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>integerLiteral</name><argument_list>(<argument><expr><call><name>equals</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>hasParent</name><argument_list>(<argument><expr><call><name>expr</name><argument_list>(<argument><expr><call><name>hasType</name><argument_list>(<argument><expr><call><name>pointerType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>



















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>BindingDecl</argument>, <argument>forDecomposition</argument>, <argument>internal::Matcher&lt;ValueDecl&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>ValueDecl</name> <modifier>*</modifier></type><name>VD</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getDecomposedDecl</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>VD</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>



















<macro><name>AST_MATCHER_P2</name><argument_list>(<argument>DecompositionDecl</argument>, <argument>hasBinding</argument>, <argument>unsigned</argument>, <argument>N</argument>,
<argument>internal::Matcher&lt;BindingDecl&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Node</name><operator>.</operator><name>bindings</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>N</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>bindings</name></name><argument_list>()</argument_list></call><index>[<expr><name>N</name></expr>]</index></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>


















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>DecompositionDecl</argument>, <argument>hasAnyBinding</argument>, <argument>internal::Matcher&lt;BindingDecl&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><name>llvm</name><operator>::</operator><call><name>any_of</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>bindings</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><index>[<expr><operator>&amp;</operator></expr>]</index><operator>(</operator><specifier>const</specifier> <name>auto</name> <operator>*</operator><name>Binding</name><operator>)</operator> <block>{
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Binding</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></argument></argument_list></call></expr></return>)</block_content></block><empty_stmt>;</empty_stmt>
}


















AST_MATCHER_P<expr_stmt><expr><operator>(</operator><name>Stmt</name><operator>,</operator> <name>forFunction</name><operator>,</operator> <name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><operator>,</operator>
<name>InnerMatcher</name><operator>)</operator> <block>{
<expr><specifier>const</specifier> <name>auto</name> <operator>&amp;</operator><name>Parents</name> <operator>=</operator> <call><name><name>Finder</name><operator>-&gt;</operator><name>getASTContext</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getParents</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;

<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>DynTypedNode</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <call><name>Stack</name><argument_list>(<argument><expr><call><name><name>Parents</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Parents</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<while>while <condition>(<expr><operator>!</operator><call><name><name>Stack</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>CurNode</name> <init>= <expr><call><name><name>Stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Stack</name><operator>.</operator><name>pop_back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>FuncDeclNode</name> <init>= <expr><name><name>CurNode</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>FunctionDecl</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>FuncDeclNode</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></while>}</block></expr></expr_stmt>
} else <if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>LambdaExprNode</name> <init>= <expr><name><name>CurNode</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>LambdaExpr</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>LambdaExprNode</name><operator>-&gt;</operator><name>getCallOperator</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>,
<argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>Parent</name> <range>: <expr><call><name><name>Finder</name><operator>-&gt;</operator><name>getASTContext</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getParents</name><argument_list>(<argument><expr><name>CurNode</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>Parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></else></if_stmt>
}
return <expr_stmt><expr><name>false</name></expr>;</expr_stmt>
}




























AST_MATCHER_P<expr_stmt><expr><operator>(</operator><name>Stmt</name><operator>,</operator> <name>forCallable</name><operator>,</operator> <name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name></expr></argument>&gt;</argument_list></name><operator>,</operator> <name>InnerMatcher</name><operator>)</operator> <block>{
<expr><specifier>const</specifier> <name>auto</name> <operator>&amp;</operator><name>Parents</name> <operator>=</operator> <call><name><name>Finder</name><operator>-&gt;</operator><name>getASTContext</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getParents</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;

<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>DynTypedNode</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <call><name>Stack</name><argument_list>(<argument><expr><call><name><name>Parents</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Parents</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<while>while <condition>(<expr><operator>!</operator><call><name><name>Stack</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>CurNode</name> <init>= <expr><call><name><name>Stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Stack</name><operator>.</operator><name>pop_back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>FuncDeclNode</name> <init>= <expr><name><name>CurNode</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>FunctionDecl</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>FuncDeclNode</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></while>}</block></expr></expr_stmt>
} else <if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>LambdaExprNode</name> <init>= <expr><name><name>CurNode</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>LambdaExpr</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>LambdaExprNode</name><operator>-&gt;</operator><name>getCallOperator</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>,
<argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>ObjCMethodDeclNode</name> <init>= <expr><name><name>CurNode</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>ObjCMethodDecl</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>ObjCMethodDeclNode</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>BlockDeclNode</name> <init>= <expr><name><name>CurNode</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>BlockDecl</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>BlockDeclNode</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>Parent</name> <range>: <expr><call><name><name>Finder</name><operator>-&gt;</operator><name>getASTContext</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getParents</name><argument_list>(<argument><expr><name>CurNode</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Stack</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>Parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></else></if_stmt>
}
return <expr_stmt><expr><name>false</name></expr>;</expr_stmt>
}





















AST_MATCHER<expr_stmt><expr><operator>(</operator><name>NamedDecl</name><operator>,</operator> <name>hasExternalFormalLinkage</name><operator>)</operator> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>hasExternalFormalLinkage</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>






















<macro><name>AST_MATCHER</name><argument_list>(<argument>ParmVarDecl</argument>, <argument>hasDefaultArgument</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>hasDefaultArg</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>









<macro><name>AST_MATCHER</name><argument_list>(<argument>CXXNewExpr</argument>, <argument>isArray</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isArray</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>









<macro><name>AST_MATCHER_P2</name><argument_list>(<argument>CXXNewExpr</argument>, <argument>hasPlacementArg</argument>, <argument>unsigned</argument>, <argument>Index</argument>,
<argument>internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getNumPlacementArgs</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>Index</name> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>getPlacementArg</name></name><argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>









<macro><name>AST_MATCHER_P</name><argument_list>(<argument>CXXNewExpr</argument>, <argument>hasAnyPlacementArg</argument>, <argument>internal::Matcher&lt;Expr&gt;</argument>,
<argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><name>llvm</name><operator>::</operator><call><name>any_of</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>placement_arguments</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><index>[<expr><operator>&amp;</operator></expr>]</index><operator>(</operator><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>Arg</name><operator>)</operator> <block>{
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>Arg</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></argument></argument_list></call></expr></return>)</block_content></block><empty_stmt>;</empty_stmt>
}









AST_MATCHER_P<expr_stmt><expr><operator>(</operator><name>CXXNewExpr</name><operator>,</operator> <name>hasArraySize</name><operator>,</operator> <name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><operator>,</operator> <name>InnerMatcher</name><operator>)</operator> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isArray</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><call><name><name>Node</name><operator>.</operator><name>getArraySize</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>getArraySize</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>








<macro><name>AST_MATCHER</name><argument_list>(<argument>CXXRecordDecl</argument>, <argument>hasDefinition</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>hasDefinition</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>








<macro><name>AST_MATCHER</name><argument_list>(<argument>EnumDecl</argument>, <argument>isScoped</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isScoped</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>








<macro><name>AST_MATCHER</name><argument_list>(<argument>FunctionDecl</argument>, <argument>hasTrailingReturn</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>F</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>F</name><operator>-&gt;</operator><name>hasTrailingReturn</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>
























<macro><name>AST_MATCHER_P</name><argument_list>(<argument>Expr</argument>, <argument>ignoringElidableConstructorCall</argument>,
<argument>ast_matchers::internal::Matcher&lt;Expr&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name> <init>= <expr><operator>&amp;</operator><name>Node</name></expr></init></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>CleanupsExpr</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExprWithCleanups</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>E</name> <operator>=</operator> <call><name><name>CleanupsExpr</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>CtorExpr</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>CtorExpr</name><operator>-&gt;</operator><name>isElidable</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>MaterializeTemp</name> <init>=
<expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>MaterializeTemporaryExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>CtorExpr</name><operator>-&gt;</operator><name>getArg</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>MaterializeTemp</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>,
<argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

















<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;Stmt<operator>,</operator> OMPExecutableDirective&gt;
ompExecutableDirective;</extern>














<macro><name>AST_MATCHER</name><argument_list>(<argument>OMPExecutableDirective</argument>, <argument>isStandaloneDirective</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isStandaloneDirective</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>
















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>OMPExecutableDirective</argument>, <argument>hasStructuredBlock</argument>,
<argument>internal::Matcher&lt;Stmt&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Node</name><operator>.</operator><name>isStandaloneDirective</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Node</name><operator>.</operator><name>getStructuredBlock</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>












<macro><name>AST_MATCHER_P</name><argument_list>(<argument>OMPExecutableDirective</argument>, <argument>hasAnyClause</argument>,
<argument>internal::Matcher&lt;OMPClause&gt;</argument>, <argument>InnerMatcher</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>clauses</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>matchesFirstInPointerRange</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><call><name><name>Clauses</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Clauses</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>,
<argument><expr><name>Builder</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name><name>Clauses</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>














<extern>extern const internal::VariadicDynCastAllOfMatcher&lt;OMPClause<operator>,</operator> OMPDefaultClause&gt;
ompDefaultClause;</extern>













<macro><name>AST_MATCHER</name><argument_list>(<argument>OMPDefaultClause</argument>, <argument>isNoneKind</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getDefaultKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMP_DEFAULT_none</name></expr>;</return>
</block_content>}</block>













<macro><name>AST_MATCHER</name><argument_list>(<argument>OMPDefaultClause</argument>, <argument>isSharedKind</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getDefaultKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMP_DEFAULT_shared</name></expr>;</return>
</block_content>}</block>















<macro><name>AST_MATCHER</name><argument_list>(<argument>OMPDefaultClause</argument>, <argument>isFirstPrivateKind</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getDefaultKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMP_DEFAULT_firstprivate</name></expr>;</return>
</block_content>}</block>


















<macro><name>AST_MATCHER_P</name><argument_list>(<argument>OMPExecutableDirective</argument>, <argument>isAllowedToContainClauseKind</argument>,
<argument>OpenMPClauseKind</argument>, <argument>CKind</argument>)</argument_list></macro> <block>{<block_content>
<return>return <expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><call><name>isAllowedClauseForDirective</name><argument_list>(
<argument><expr><call><name><name>Node</name><operator>.</operator><name>getDirectiveKind</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>CKind</name></expr></argument>,
<argument><expr><call><name><name>Finder</name><operator>-&gt;</operator><name>getASTContext</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>OpenMP</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>





}
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
