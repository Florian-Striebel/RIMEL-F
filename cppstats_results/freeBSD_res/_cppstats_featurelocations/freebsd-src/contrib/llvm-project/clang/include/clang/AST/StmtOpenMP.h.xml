<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/StmtOpenMP.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_STMTOPENMP_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_STMTOPENMP_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/OpenMPClause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Stmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenMPKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>




















































































































<decl_stmt><decl><type><name>class</name></type> <name>OMPCanonicalLoop</name> <range>: <expr><name>public</name> <name>Stmt</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;


enum <expr><block>{
<expr><name>LOOP_STMT</name></expr>,
<expr><name>DISTANCE_FUNC</name></expr>,
<expr><name>LOOPVAR_FUNC</name></expr>,
<expr><name>LOOPVAR_REF</name></expr>,
<expr><name>LastSubStmt</name> <operator>=</operator> <name>LOOPVAR_REF</name></expr>
}</block></expr>;

<expr><name>private</name><operator>:</operator>

<name>Stmt</name> <operator>*</operator><name><name>SubStmts</name><index>[<expr><name>LastSubStmt</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <block>{}</block></expr>;

<expr><call><name>OMPCanonicalLoop</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>StmtClass::OMPCanonicalLoopClass</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>

<specifier>static</specifier> <name>OMPCanonicalLoop</name> <operator>*</operator><macro><name>create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>Stmt *LoopStmt</argument>,
<argument>CapturedStmt *DistanceFunc</argument>,
<argument>CapturedStmt *LoopVarFunc</argument>,
<argument>DeclRefExpr *LoopVarRef</argument>)</argument_list></macro> <block>{
<expr><name>OMPCanonicalLoop</name> <operator>*</operator><name>S</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>Ctx</argument>)</argument_list></macro> <call><name>OMPCanonicalLoop</name><argument_list>()</argument_list></call></expr>;
<expr><call><name><name>S</name><operator>-&gt;</operator><name>setLoopStmt</name></name><argument_list>(<argument><expr><name>LoopStmt</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>S</name><operator>-&gt;</operator><name>setDistanceFunc</name></name><argument_list>(<argument><expr><name>DistanceFunc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>S</name><operator>-&gt;</operator><name>setLoopVarFunc</name></name><argument_list>(<argument><expr><name>LoopVarFunc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>S</name><operator>-&gt;</operator><name>setLoopVarRef</name></name><argument_list>(<argument><expr><name>LoopVarRef</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>S</name></expr>;</return>
}</block>


<specifier>static</specifier> <name>OMPCanonicalLoop</name> <operator>*</operator><macro><name>createEmpty</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>)</argument_list></macro> <block>{
<return>return <macro><name>new</name> <argument_list>(<argument>Ctx</argument>)</argument_list></macro> <expr><call><name>OMPCanonicalLoop</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *S</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>S</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>StmtClass</name><operator>::</operator><name>OMPCanonicalLoopClass</name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLoopStmt</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLoopStmt</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubStmts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubStmts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>LastSubStmt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubStmts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubStmts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>LastSubStmt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>Stmt</name> <operator>*</operator><macro><name>getLoopStmt</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name><name>SubStmts</name><index>[<expr><name>LOOP_STMT</name></expr>]</index></name></expr>;</return> }</block>
<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getLoopStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>SubStmts</name><index>[<expr><name>LOOP_STMT</name></expr>]</index></name></expr>;</return> }</block>
<name>void</name> <macro><name>setLoopStmt</name><argument_list>(<argument>Stmt *S</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ForStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>CXXForRangeStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Canonical loop must be a for loop (range-based or otherwise)"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>SubStmts</name><index>[<expr><name>LOOP_STMT</name></expr>]</index></name> <operator>=</operator> <name>S</name></expr>;
}</block>









<name>CapturedStmt</name> <operator>*</operator><macro><name>getDistanceFunc</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CapturedStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubStmts</name><index>[<expr><name>DISTANCE_FUNC</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>CapturedStmt</name> <operator>*</operator><macro><name>getDistanceFunc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CapturedStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubStmts</name><index>[<expr><name>DISTANCE_FUNC</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>setDistanceFunc</name><argument_list>(<argument>CapturedStmt *S</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>S</name> <operator>&amp;&amp;</operator> <literal type="string">"Expected non-null captured statement"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>SubStmts</name><index>[<expr><name>DISTANCE_FUNC</name></expr>]</index></name> <operator>=</operator> <name>S</name></expr>;
}</block>











<name>CapturedStmt</name> <operator>*</operator><macro><name>getLoopVarFunc</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CapturedStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubStmts</name><index>[<expr><name>LOOPVAR_FUNC</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>CapturedStmt</name> <operator>*</operator><macro><name>getLoopVarFunc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CapturedStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubStmts</name><index>[<expr><name>LOOPVAR_FUNC</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>setLoopVarFunc</name><argument_list>(<argument>CapturedStmt *S</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>S</name> <operator>&amp;&amp;</operator> <literal type="string">"Expected non-null captured statement"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>SubStmts</name><index>[<expr><name>LOOPVAR_FUNC</name></expr>]</index></name> <operator>=</operator> <name>S</name></expr>;
}</block>




<name>DeclRefExpr</name> <operator>*</operator><macro><name>getLoopVarRef</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclRefExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubStmts</name><index>[<expr><name>LOOPVAR_REF</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>DeclRefExpr</name> <operator>*</operator><macro><name>getLoopVarRef</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclRefExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubStmts</name><index>[<expr><name>LOOPVAR_REF</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>setLoopVarRef</name><argument_list>(<argument>DeclRefExpr *E</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>E</name> <operator>&amp;&amp;</operator> <literal type="string">"Expected non-null loop variable"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>SubStmts</name><index>[<expr><name>LOOPVAR_REF</name></expr>]</index></name> <operator>=</operator> <name>E</name></expr>;
}</block>

}</expr>;




<expr><name>class</name> <name>OMPExecutableDirective</name> <operator>:</operator> <name>public</name> <name>Stmt</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtWriter</name></expr>;


<expr><name>OpenMPDirectiveKind</name> <name>Kind</name> <operator>=</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPD_unknown</name></expr>;

<expr><name>SourceLocation</name> <name>StartLoc</name></expr>;

<expr><name>SourceLocation</name> <name>EndLoc</name></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getClauses</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Data</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>llvm</name><operator>::</operator><name>None</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getClauses</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>protected</name><operator>:</operator>

<name>OMPChildren</name> <operator>*</operator><name>Data</name> <operator>=</operator> <name>nullptr</name></expr>;








<macro><name>OMPExecutableDirective</name><argument_list>(<argument>StmtClass SC</argument>, <argument>OpenMPDirectiveKind K</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Stmt</name><argument_list>(<argument><expr><name>SC</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Kind</name><argument_list>(<argument><expr><name>K</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>StartLoc</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>StartLoc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>EndLoc</name><argument_list>(<argument>std::move(EndLoc)</argument>)</argument_list></macro> <expr><block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>Params</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>T</name> <operator>*</operator><macro><name>createDirective</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>unsigned NumChildren</argument>,
<argument>Params &amp;&amp;... P</argument>)</argument_list></macro> <block>{
<expr><name>void</name> <operator>*</operator><name>Mem</name> <operator>=</operator>
<call><name><name>C</name><operator>.</operator><name>Allocate</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>OMPChildren</name><operator>::</operator><call><name>size</name><argument_list>(<argument><expr><call><name><name>Clauses</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AssociatedStmt</name></expr></argument>,
<argument><expr><name>NumChildren</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>alignof</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

<expr><name>auto</name> <operator>*</operator><name>Data</name> <operator>=</operator> <name>OMPChildren</name><operator>::</operator><call><name>Create</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>Clauses</name></expr></argument>,
<argument><expr><name>AssociatedStmt</name></expr></argument>, <argument><expr><name>NumChildren</name></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <operator>*</operator><name>Inst</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>Mem</argument>)</argument_list></macro> <call><name>T</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>Params</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call><operator>...</operator></expr></argument>)</argument_list></call></expr>;
<expr><name><name>Inst</name><operator>-&gt;</operator><name>Data</name></name> <operator>=</operator> <name>Data</name></expr>;
<return>return <expr><name>Inst</name></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>Params</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>T</name> <operator>*</operator><macro><name>createEmptyDirective</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumClauses</argument>,
<argument>bool HasAssociatedStmt</argument>, <argument>unsigned NumChildren</argument>,
<argument>Params &amp;&amp;... P</argument>)</argument_list></macro> <block>{
<expr><name>void</name> <operator>*</operator><name>Mem</name> <operator>=</operator>
<call><name><name>C</name><operator>.</operator><name>Allocate</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>OMPChildren</name><operator>::</operator><call><name>size</name><argument_list>(<argument><expr><name>NumClauses</name></expr></argument>, <argument><expr><name>HasAssociatedStmt</name></expr></argument>,
<argument><expr><name>NumChildren</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>alignof</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <operator>*</operator><name>Data</name> <operator>=</operator>
<name>OMPChildren</name><operator>::</operator><call><name>CreateEmpty</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NumClauses</name></expr></argument>,
<argument><expr><name>HasAssociatedStmt</name></expr></argument>, <argument><expr><name>NumChildren</name></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <operator>*</operator><name>Inst</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>Mem</argument>)</argument_list></macro> <call><name>T</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>Params</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call><operator>...</operator></expr></argument>)</argument_list></call></expr>;
<expr><name><name>Inst</name><operator>-&gt;</operator><name>Data</name></name> <operator>=</operator> <name>Data</name></expr>;
<return>return <expr><name>Inst</name></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>T</name> <operator>*</operator><macro><name>createEmptyDirective</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumClauses</argument>,
<argument>bool HasAssociatedStmt = false</argument>,
<argument>unsigned NumChildren = <literal type="number">0</literal></argument>)</argument_list></macro> <block>{
<expr><name>void</name> <operator>*</operator><name>Mem</name> <operator>=</operator>
<call><name><name>C</name><operator>.</operator><name>Allocate</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>OMPChildren</name><operator>::</operator><call><name>size</name><argument_list>(<argument><expr><name>NumClauses</name></expr></argument>, <argument><expr><name>HasAssociatedStmt</name></expr></argument>,
<argument><expr><name>NumChildren</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>alignof</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <operator>*</operator><name>Data</name> <operator>=</operator>
<name>OMPChildren</name><operator>::</operator><call><name>CreateEmpty</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Mem</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NumClauses</name></expr></argument>,
<argument><expr><name>HasAssociatedStmt</name></expr></argument>, <argument><expr><name>NumChildren</name></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <operator>*</operator><name>Inst</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>Mem</argument>)</argument_list></macro> <name>T</name></expr>;
<expr><name><name>Inst</name><operator>-&gt;</operator><name>Data</name></name> <operator>=</operator> <name>Data</name></expr>;
<return>return <expr><name>Inst</name></expr>;</return>
}</block>

<name>public</name><operator>:</operator>

<name>class</name> <name>used_clauses_child_iterator</name>
<operator>:</operator> <name>public</name> <name>llvm</name><operator>::</operator><name><name>iterator_adaptor_base</name><argument_list type="generic">&lt;
<argument><expr><name>used_clauses_child_iterator</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name>forward_iterator_tag</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>, <argument><expr><name>ptrdiff_t</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name> <name>End</name></expr>;
<expr><name>OMPClause</name><operator>::</operator><name>child_iterator</name> <name>ChildI</name></expr>, <expr><name>ChildEnd</name></expr>;

<expr><name>void</name> <macro><name>MoveToNext</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>ChildI</name> <operator>!=</operator> <name>ChildEnd</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt></block></expr>
<while>while <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>I</name></name> <operator>!=</operator> <name>End</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name><name>this</name><operator>-&gt;</operator><name>I</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>I</name></name> <operator>!=</operator> <name>End</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ChildI</name> <operator>=</operator> <call><name><operator>(</operator><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>I</name></name><operator>)</operator><operator>-&gt;</operator><name>used_children</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ChildEnd</name> <operator>=</operator> <call><name><operator>(</operator><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>I</name></name><operator>)</operator><operator>-&gt;</operator><name>used_children</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ChildI</name> <operator>!=</operator> <name>ChildEnd</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt/>}</block_content>
}
}

public:
explicit used_clauses_child_iterator(ArrayRef&lt;OMPClause *&gt; Clauses</block></if></if_stmt>)</block_content>
: used_clauses_child_iterator::iterator_adaptor_base(Clauses.begin(</block></while>))</block></expr>,
<macro><name>End</name><argument_list>(<argument>Clauses.end()</argument>)</argument_list></macro> <expr><block>{
<if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>I</name></name> <operator>!=</operator> <name>End</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ChildI</name> <operator>=</operator> <call><name><operator>(</operator><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>I</name></name><operator>)</operator><operator>-&gt;</operator><name>used_children</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ChildEnd</name> <operator>=</operator> <call><name><operator>(</operator><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>I</name></name><operator>)</operator><operator>-&gt;</operator><name>used_children</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MoveToNext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}
Stmt *operator*(</block></if></if_stmt>) <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>ChildI</name></expr>;</return> }</block></block>
<name>Stmt</name> <operator>*</operator><name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr>) <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><operator>*</operator><name>this</name></expr>;</return> }</block>

<name>used_clauses_child_iterator</name> <operator>&amp;</operator><name>operator</name><operator>++</operator><operator>(</operator><operator>)</operator> <block>{
<expr><operator>++</operator><name>ChildI</name></expr>;
<if_stmt><if>if <condition>(<expr><name>ChildI</name> <operator>!=</operator> <name>ChildEnd</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return></block_content></block></if></if_stmt></block></block></expr></range></decl></decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>I</name></name> <operator>!=</operator> <name>End</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name><name>this</name><operator>-&gt;</operator><name>I</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>I</name></name> <operator>!=</operator> <name>End</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ChildI</name> <operator>=</operator> <call><name><operator>(</operator><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>I</name></name><operator>)</operator><operator>-&gt;</operator><name>used_children</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ChildEnd</name> <operator>=</operator> <call><name><operator>(</operator><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>I</name></name><operator>)</operator><operator>-&gt;</operator><name>used_children</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>MoveToNext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
};

<expr_stmt><expr><specifier>static</specifier> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>used_clauses_child_iterator</name></expr></argument>&gt;</argument_list></name>
<macro><name>used_clauses_children</name><argument_list>(<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>)</argument_list></macro> <block>{
<return>return <expr><block>{<expr><call><name>used_clauses_child_iterator</name><argument_list>(<argument><expr><name>Clauses</name></expr></argument>)</argument_list></call></expr>,
<macro><name>used_clauses_child_iterator</name><argument_list>(<argument>llvm::makeArrayRef(Clauses.end(), <literal type="number">0</literal>)</argument>)</argument_list></macro>}</block></expr>;</return>
}</block></expr></expr_stmt>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>SpecificClause</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>specific_clause_iterator</name>
<range>: <expr><name>public</name> <name>llvm</name><operator>::</operator><name><name>iterator_adaptor_base</name><argument_list type="generic">&lt;
<argument><expr><name><name>specific_clause_iterator</name><argument_list type="generic">&lt;<argument><expr><name>SpecificClause</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>forward_iterator_tag</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>SpecificClause</name> <operator>*</operator></expr></argument>, <argument><expr><name>ptrdiff_t</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>SpecificClause</name> <operator>*</operator></expr></argument>,
<argument><expr><specifier>const</specifier> <name>SpecificClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name> <name>End</name></expr>;

<expr><name>void</name> <macro><name>SkipToNextClause</name><argument_list>()</argument_list></macro> <block>{
<while>while <condition>(<expr><name><name>this</name><operator>-&gt;</operator><name>I</name></name> <operator>!=</operator> <name>End</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>SpecificClause</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>I</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name><name>this</name><operator>-&gt;</operator><name>I</name></name></expr>;</expr_stmt></block_content></block></while>
}</block>

<name>public</name><operator>:</operator>
<name>explicit</name> <call><name>specific_clause_iterator</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Clauses</name></expr></argument>)</argument_list></call>
<operator>:</operator> <name>specific_clause_iterator</name><operator>::</operator><call><name>iterator_adaptor_base</name><argument_list>(<argument><expr><call><name><name>Clauses</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>End</name><argument_list>(<argument>Clauses.end()</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>SkipToNextClause</name><argument_list>()</argument_list></call></expr>;
}</block>

<specifier>const</specifier> <name>SpecificClause</name> <operator>*</operator><name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>SpecificClause</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>I</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>SpecificClause</name> <operator>*</operator><name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr>) <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><operator>*</operator><name>this</name></expr>;</return> }</block>

<name>specific_clause_iterator</name> <operator>&amp;</operator><name>operator</name><operator>++</operator><operator>(</operator><operator>)</operator> <block>{
<expr><operator>++</operator><name><name>this</name><operator>-&gt;</operator><name>I</name></name></expr>;
<expr><call><name>SkipToNextClause</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block>
}</block></expr></range></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>SpecificClause</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name><name>specific_clause_iterator</name><argument_list type="generic">&lt;<argument><expr><name>SpecificClause</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<macro><name>getClausesOfKind</name><argument_list>(<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>)</argument_list></macro> <block>{
<return>return <expr><block>{<expr><call><name><name>specific_clause_iterator</name><argument_list type="generic">&lt;<argument><expr><name>SpecificClause</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Clauses</name></expr></argument>)</argument_list></call></expr>,
<macro><name>specific_clause_iterator</name></macro><expr><operator>&lt;</operator><name>SpecificClause</name><operator>&gt;</operator><operator>(</operator>
<name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name><name>Clauses</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>}</block></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>SpecificClause</name></expr></argument>&gt;</argument_list></name>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name><name>specific_clause_iterator</name><argument_list type="generic">&lt;<argument><expr><name>SpecificClause</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<macro><name>getClausesOfKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getClausesOfKind</name><argument_list type="generic">&lt;<argument><expr><name>SpecificClause</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>clauses</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>






<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>SpecificClause</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <specifier>const</specifier> <name>SpecificClause</name> <modifier>*</modifier></type><name>getSingleClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>ClausesOfKind</name> <init>= <expr><call><name><name>getClausesOfKind</name><argument_list type="generic">&lt;<argument><expr><name>SpecificClause</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Clauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>ClausesOfKind</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>ClausesOfKind</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>next</name><argument_list>(<argument><expr><call><name><name>ClausesOfKind</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <call><name><name>ClausesOfKind</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"There are at least 2 clauses of the specified kind"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><call><name><name>ClausesOfKind</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>nullptr</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>SpecificClause</name></expr></argument>&gt;</argument_list></name>
<specifier>const</specifier> <name>SpecificClause</name> <operator>*</operator><macro><name>getSingleClause</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getSingleClause</name><argument_list type="generic">&lt;<argument><expr><name>SpecificClause</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>clauses</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>SpecificClause</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>hasClausesOfKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Clauses</name> <operator>=</operator> <call><name><name>getClausesOfKind</name><argument_list type="generic">&lt;<argument><expr><name>SpecificClause</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name><name>Clauses</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>Clauses</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>StartLoc</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>EndLoc</name></expr>;</return> }</block></expr></expr_stmt>





<function><type><name>void</name></type> <name>setLocStart</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>StartLoc</name> <operator>=</operator> <name>Loc</name></expr>;</expr_stmt> </block_content>}</block></function>




<function><type><name>void</name></type> <name>setLocEnd</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>EndLoc</name> <operator>=</operator> <name>Loc</name></expr>;</expr_stmt> </block_content>}</block></function>


<expr_stmt><expr><name>unsigned</name> <macro><name>getNumClauses</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Data</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getNumClauses</name></name><argument_list>()</argument_list></call></expr>;</return>
}





OMPClause <expr_stmt><expr><operator>*</operator><macro><name>getClause</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>clauses</name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasAssociatedStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Data</name> <operator>&amp;&amp;</operator> <call><name><name>Data</name><operator>-&gt;</operator><name>hasAssociatedStmt</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getAssociatedStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPExecutableDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getAssociatedStmt</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>Stmt</name> <modifier>*</modifier></type><name>getAssociatedStmt</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasAssociatedStmt</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Expected directive with the associated statement."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getAssociatedStmt</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>





<decl_stmt><decl><type><specifier>const</specifier> <name>CapturedStmt</name> <modifier>*</modifier></type><name>getCapturedStmt</name><argument_list>(<argument><expr><name>OpenMPDirectiveKind</name> <name>RegionKind</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasAssociatedStmt</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Expected directive with the associated statement."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPDirectiveKind</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>CaptureRegions</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>getOpenMPCaptureRegions</name><argument_list>(<argument><expr><name>CaptureRegions</name></expr></argument>, <argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getCapturedStmt</name></name><argument_list>(<argument><expr><name>RegionKind</name></expr></argument>, <argument><expr><name>CaptureRegions</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<function><type><name>CapturedStmt</name> <modifier>*</modifier></type><name>getInnermostCapturedStmt</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasAssociatedStmt</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Expected directive with the associated statement."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPDirectiveKind</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>CaptureRegions</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>getOpenMPCaptureRegions</name><argument_list>(<argument><expr><name>CaptureRegions</name></expr></argument>, <argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getInnermostCapturedStmt</name></name><argument_list>(<argument><expr><name>CaptureRegions</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>CapturedStmt</name> <operator>*</operator><macro><name>getInnermostCapturedStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPExecutableDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>getInnermostCapturedStmt</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>OpenMPDirectiveKind</name> <macro><name>getDirectiveKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>S</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>firstOMPExecutableDirectiveConstant</name> <operator>&amp;&amp;</operator>
<call><name><name>S</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>lastOMPExecutableDirectiveConstant</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>child_range</name></type> <name>children</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Data</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getAssociatedStmtAsRange</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPExecutableDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>clauses</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Data</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>llvm</name><operator>::</operator><name>None</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getClauses</name></name><argument_list>()</argument_list></call></expr>;</return>
}





bool <macro><name>isStandaloneDirective</name><argument_list>()</argument_list></macro> <decl_stmt><decl><type><specifier>const</specifier></type></decl>;</decl_stmt>




<expr_stmt><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getStructuredBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPExecutableDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getStructuredBlock</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function_decl><type><name>Stmt</name> <modifier>*</modifier></type><name>getStructuredBlock</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getRawStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPExecutableDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getRawStmt</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>Stmt</name> <modifier>*</modifier></type><name>getRawStmt</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasAssociatedStmt</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Expected directive with the associated statement."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getRawStmt</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
};










<decl_stmt><decl><type><name>class</name></type> <name>OMPParallelDirective</name> <range>: <expr><name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;

<expr><name>bool</name> <name>HasCancel</name> <operator>=</operator> <name>false</name></expr>;






<macro><name>OMPParallelDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPParallelDirectiveClass</argument>,
<argument>llvm::omp::OMPD_parallel</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPParallelDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPParallelDirectiveClass</argument>,
<argument>llvm::omp::OMPD_parallel</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setTaskReductionRefExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>E</name></expr>; }</block>


<name>void</name> <macro><name>setHasCancel</name><argument_list>(<argument>bool Has</argument>)</argument_list></macro> <block>{ <expr><name>HasCancel</name> <operator>=</operator> <name>Has</name></expr>; }</block>

<name>public</name><operator>:</operator>











<specifier>static</specifier> <name>OMPParallelDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *AssociatedStmt</argument>, <argument>Expr *TaskRedRef</argument>,
<argument>bool HasCancel</argument>)</argument_list></macro></expr>;






<expr><specifier>static</specifier> <name>OMPParallelDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;


<expr><name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPParallelDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasCancel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasCancel</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPParallelDirectiveClass</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>OMPLoopBasedDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>protected</name><operator>:</operator>

<name>unsigned</name> <name>NumAssociatedLoops</name> <operator>=</operator> <literal type="number">0</literal></expr>;









<macro><name>OMPLoopBasedDirective</name><argument_list>(<argument>StmtClass SC</argument>, <argument>OpenMPDirectiveKind Kind</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned NumAssociatedLoops</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>OMPExecutableDirective</name><argument_list>(<argument><expr><name>SC</name></expr></argument>, <argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<macro><name>NumAssociatedLoops</name><argument_list>(<argument>NumAssociatedLoops</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>


struct <name>DistCombinedHelperExprs</name> <block>{


<expr><name>Expr</name> <operator>*</operator><name>LB</name></expr>;


<expr><name>Expr</name> <operator>*</operator><name>UB</name></expr>;


<expr><name>Expr</name> <operator>*</operator><name>EUB</name></expr>;



<expr><name>Expr</name> <operator>*</operator><name>Init</name></expr>;


<expr><name>Expr</name> <operator>*</operator><name>Cond</name></expr>;


<expr><name>Expr</name> <operator>*</operator><name>NLB</name></expr>;


<expr><name>Expr</name> <operator>*</operator><name>NUB</name></expr>;


<expr><name>Expr</name> <operator>*</operator><name>DistCond</name></expr>;



<expr><name>Expr</name> <operator>*</operator><name>ParForInDistCond</name></expr>;
}</block></expr>;



struct <expr><name>HelperExprs</name> <block>{

<expr><name>Expr</name> <operator>*</operator><name>IterationVarRef</name></expr>;

<expr><name>Expr</name> <operator>*</operator><name>LastIteration</name></expr>;

<expr><name>Expr</name> <operator>*</operator><name>NumIterations</name></expr>;

<expr><name>Expr</name> <operator>*</operator><name>CalcLastIteration</name></expr>;

<expr><name>Expr</name> <operator>*</operator><name>PreCond</name></expr>;

<expr><name>Expr</name> <operator>*</operator><name>Cond</name></expr>;

<expr><name>Expr</name> <operator>*</operator><name>Init</name></expr>;

<expr><name>Expr</name> <operator>*</operator><name>Inc</name></expr>;

<expr><name>Expr</name> <operator>*</operator><name>IL</name></expr>;

<expr><name>Expr</name> <operator>*</operator><name>LB</name></expr>;

<expr><name>Expr</name> <operator>*</operator><name>UB</name></expr>;

<expr><name>Expr</name> <operator>*</operator><name>ST</name></expr>;

<expr><name>Expr</name> <operator>*</operator><name>EUB</name></expr>;

<expr><name>Expr</name> <operator>*</operator><name>NLB</name></expr>;

<expr><name>Expr</name> <operator>*</operator><name>NUB</name></expr>;


<expr><name>Expr</name> <operator>*</operator><name>PrevLB</name></expr>;


<expr><name>Expr</name> <operator>*</operator><name>PrevUB</name></expr>;



<expr><name>Expr</name> <operator>*</operator><name>DistInc</name></expr>;





<expr><name>Expr</name> <operator>*</operator><name>PrevEUB</name></expr>;

<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>Counters</name></expr>;

<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>PrivateCounters</name></expr>;

<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>Inits</name></expr>;

<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>Updates</name></expr>;

<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>Finals</name></expr>;


<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>DependentCounters</name></expr>;


<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>DependentInits</name></expr>;


<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>FinalsConditions</name></expr>;

<expr><name>Stmt</name> <operator>*</operator><name>PreInits</name></expr>;


<expr><name>DistCombinedHelperExprs</name> <name>DistCombinedFields</name></expr>;



<expr><name>bool</name> <macro><name>builtAll</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>IterationVarRef</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator> <name>LastIteration</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<name>NumIterations</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator> <name>PreCond</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<name>Cond</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator> <name>Init</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator> <name>Inc</name> <operator>!=</operator> <name>nullptr</name></expr>;</return>
}</block>





<name>void</name> <macro><name>clear</name><argument_list>(<argument>unsigned Size</argument>)</argument_list></macro> <block>{
<expr><name>IterationVarRef</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>LastIteration</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>CalcLastIteration</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>PreCond</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>Cond</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>Init</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>Inc</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>IL</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>LB</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>UB</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>ST</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>EUB</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>NLB</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>NUB</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>NumIterations</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>PrevLB</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>PrevUB</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>DistInc</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>PrevEUB</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><call><name><name>Counters</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>PrivateCounters</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Inits</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Updates</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Finals</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>DependentCounters</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>DependentInits</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>FinalsConditions</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>&lt;</operator> <name>Size</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>Counters</name><index>[<expr><name>I</name></expr>]</index></name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>PrivateCounters</name><index>[<expr><name>I</name></expr>]</index></name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Inits</name><index>[<expr><name>I</name></expr>]</index></name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Updates</name><index>[<expr><name>I</name></expr>]</index></name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Finals</name><index>[<expr><name>I</name></expr>]</index></name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>DependentCounters</name><index>[<expr><name>I</name></expr>]</index></name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>DependentInits</name><index>[<expr><name>I</name></expr>]</index></name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>FinalsConditions</name><index>[<expr><name>I</name></expr>]</index></name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
PreInits = nullptr</block><empty_stmt>;</empty_stmt></for>
<name><name>DistCombinedFields</name><operator>.</operator><name>LB</name></name> <operator>=</operator> <name>nullptr</name></block></expr>;
<expr><name><name>DistCombinedFields</name><operator>.</operator><name>UB</name></name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name><name>DistCombinedFields</name><operator>.</operator><name>EUB</name></name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name><name>DistCombinedFields</name><operator>.</operator><name>Init</name></name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name><name>DistCombinedFields</name><operator>.</operator><name>Cond</name></name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name><name>DistCombinedFields</name><operator>.</operator><name>NLB</name></name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name><name>DistCombinedFields</name><operator>.</operator><name>NUB</name></name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name><name>DistCombinedFields</name><operator>.</operator><name>DistCond</name></name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name><name>DistCombinedFields</name><operator>.</operator><name>ParForInDistCond</name></name> <operator>=</operator> <name>nullptr</name></expr>;
}</block></expr>
}</block></expr>;


<expr><name>unsigned</name> <macro><name>getLoopsNumber</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumAssociatedLoops</name></expr>;</return> }</block>





<specifier>static</specifier> <name>Stmt</name> <operator>*</operator><macro><name>tryToFindNextInnerLoop</name><argument_list>(<argument>Stmt *CurStmt</argument>,
<argument>bool TryImperfectlyNestedLoops</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>tryToFindNextInnerLoop</name><argument_list>(<argument>const Stmt *CurStmt</argument>,
<argument>bool TryImperfectlyNestedLoops</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>tryToFindNextInnerLoop</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CurStmt</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>TryImperfectlyNestedLoops</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<specifier>static</specifier> <name>bool</name> <macro><name>doForAllLoops</name><argument_list>(<argument>Stmt *CurStmt</argument>, <argument>bool TryImperfectlyNestedLoops</argument>,
<argument>unsigned NumLoops</argument>,
<argument>llvm::function_ref&lt;bool(unsigned, Stmt *)&gt; Callback</argument>,
<argument>llvm::function_ref&lt;void(OMPLoopBasedDirective *)&gt;
OnTransformationCallback</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>bool</name>
<macro><name>doForAllLoops</name><argument_list>(<argument>const Stmt *CurStmt</argument>, <argument>bool TryImperfectlyNestedLoops</argument>,
<argument>unsigned NumLoops</argument>,
<argument>llvm::function_ref&lt;bool(unsigned, const Stmt *)&gt; Callback</argument>,
<argument>llvm::function_ref&lt;void(const OMPLoopBasedDirective *)&gt;
OnTransformationCallback</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <operator>&amp;&amp;</operator><name>NewCallback</name> <operator>=</operator> <index>[<expr><name>Callback</name></expr>]</index><operator>(</operator><name>unsigned</name> <name>Cnt</name>, <name>Stmt</name> <operator>*</operator><name>CurStmt</name><operator>)</operator> <block>{
<return>return <expr><call><name>Callback</name><argument_list>(<argument><expr><name>Cnt</name></expr></argument>, <argument><expr><name>CurStmt</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr>;
<expr><name>auto</name> <operator>&amp;&amp;</operator><name>NewTransformCb</name> <operator>=</operator>
<index>[<expr><name>OnTransformationCallback</name></expr>]</index><operator>(</operator><name>OMPLoopBasedDirective</name> <operator>*</operator><name>A</name><operator>)</operator> <block>{
<expr><call><name>OnTransformationCallback</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;
<return>return <expr><call><name>doForAllLoops</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CurStmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TryImperfectlyNestedLoops</name></expr></argument>,
<argument><expr><name>NumLoops</name></expr></argument>, <argument><expr><name>NewCallback</name></expr></argument>, <argument><expr><name>NewTransformCb</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<specifier>static</specifier> <name>bool</name>
<macro><name>doForAllLoops</name><argument_list>(<argument>Stmt *CurStmt</argument>, <argument>bool TryImperfectlyNestedLoops</argument>,
<argument>unsigned NumLoops</argument>,
<argument>llvm::function_ref&lt;bool(unsigned, Stmt *)&gt; Callback</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <operator>&amp;&amp;</operator><name>TransformCb</name> <operator>=</operator> <index>[]</index><operator>(</operator><name>OMPLoopBasedDirective</name> <operator>*</operator><operator>)</operator> <block>{}</block></expr>;
<return>return <expr><call><name>doForAllLoops</name><argument_list>(<argument><expr><name>CurStmt</name></expr></argument>, <argument><expr><name>TryImperfectlyNestedLoops</name></expr></argument>, <argument><expr><name>NumLoops</name></expr></argument>, <argument><expr><name>Callback</name></expr></argument>,
<argument><expr><name>TransformCb</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>bool</name>
<macro><name>doForAllLoops</name><argument_list>(<argument>const Stmt *CurStmt</argument>, <argument>bool TryImperfectlyNestedLoops</argument>,
<argument>unsigned NumLoops</argument>,
<argument>llvm::function_ref&lt;bool(unsigned, const Stmt *)&gt; Callback</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <operator>&amp;&amp;</operator><name>NewCallback</name> <operator>=</operator> <index>[<expr><name>Callback</name></expr>]</index><operator>(</operator><name>unsigned</name> <name>Cnt</name>, <specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>CurStmt</name><operator>)</operator> <block>{
<return>return <expr><call><name>Callback</name><argument_list>(<argument><expr><name>Cnt</name></expr></argument>, <argument><expr><name>CurStmt</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr>;
<return>return <expr><call><name>doForAllLoops</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CurStmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TryImperfectlyNestedLoops</name></expr></argument>,
<argument><expr><name>NumLoops</name></expr></argument>, <argument><expr><name>NewCallback</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<specifier>static</specifier> <name>void</name> <macro><name>doForAllLoopsBodies</name><argument_list>(
<argument>Stmt *CurStmt</argument>, <argument>bool TryImperfectlyNestedLoops</argument>, <argument>unsigned NumLoops</argument>,
<argument>llvm::function_ref&lt;void(unsigned, Stmt *, Stmt *)&gt; Callback</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>void</name> <macro><name>doForAllLoopsBodies</name><argument_list>(
<argument>const Stmt *CurStmt</argument>, <argument>bool TryImperfectlyNestedLoops</argument>, <argument>unsigned NumLoops</argument>,
<argument>llvm::function_ref&lt;void(unsigned, const Stmt *, const Stmt *)&gt; Callback</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <operator>&amp;&amp;</operator><name>NewCallback</name> <operator>=</operator> <index>[<expr><name>Callback</name></expr>]</index><operator>(</operator><name>unsigned</name> <name>Cnt</name>, <name>Stmt</name> <operator>*</operator><name>Loop</name>, <name>Stmt</name> <operator>*</operator><name>Body</name><operator>)</operator> <block>{
<expr><call><name>Callback</name><argument_list>(<argument><expr><name>Cnt</name></expr></argument>, <argument><expr><name>Loop</name></expr></argument>, <argument><expr><name>Body</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;
<expr><call><name>doForAllLoopsBodies</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CurStmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TryImperfectlyNestedLoops</name></expr></argument>,
<argument><expr><name>NumLoops</name></expr></argument>, <argument><expr><name>NewCallback</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>D</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPExecutableDirective</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>isOpenMPLoopDirective</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getDirectiveKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>
};




<decl_stmt><decl><type><name>class</name></type> <name>OMPLoopDirective</name> <range>: <expr><name>public</name> <name>OMPLoopBasedDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

















enum <expr><block>{
<expr><name>IterationVariableOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><name>LastIterationOffset</name> <operator>=</operator> <literal type="number">1</literal></expr>,
<expr><name>CalcLastIterationOffset</name> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><name>PreConditionOffset</name> <operator>=</operator> <literal type="number">3</literal></expr>,
<expr><name>CondOffset</name> <operator>=</operator> <literal type="number">4</literal></expr>,
<expr><name>InitOffset</name> <operator>=</operator> <literal type="number">5</literal></expr>,
<expr><name>IncOffset</name> <operator>=</operator> <literal type="number">6</literal></expr>,
<expr><name>PreInitsOffset</name> <operator>=</operator> <literal type="number">7</literal></expr>,




<expr><name>DefaultEnd</name> <operator>=</operator> <literal type="number">8</literal></expr>,

<expr><name>IsLastIterVariableOffset</name> <operator>=</operator> <literal type="number">8</literal></expr>,
<expr><name>LowerBoundVariableOffset</name> <operator>=</operator> <literal type="number">9</literal></expr>,
<expr><name>UpperBoundVariableOffset</name> <operator>=</operator> <literal type="number">10</literal></expr>,
<expr><name>StrideVariableOffset</name> <operator>=</operator> <literal type="number">11</literal></expr>,
<expr><name>EnsureUpperBoundOffset</name> <operator>=</operator> <literal type="number">12</literal></expr>,
<expr><name>NextLowerBoundOffset</name> <operator>=</operator> <literal type="number">13</literal></expr>,
<expr><name>NextUpperBoundOffset</name> <operator>=</operator> <literal type="number">14</literal></expr>,
<expr><name>NumIterationsOffset</name> <operator>=</operator> <literal type="number">15</literal></expr>,

<expr><name>WorksharingEnd</name> <operator>=</operator> <literal type="number">16</literal></expr>,
<expr><name>PrevLowerBoundVariableOffset</name> <operator>=</operator> <literal type="number">16</literal></expr>,
<expr><name>PrevUpperBoundVariableOffset</name> <operator>=</operator> <literal type="number">17</literal></expr>,
<expr><name>DistIncOffset</name> <operator>=</operator> <literal type="number">18</literal></expr>,
<expr><name>PrevEnsureUpperBoundOffset</name> <operator>=</operator> <literal type="number">19</literal></expr>,
<expr><name>CombinedLowerBoundVariableOffset</name> <operator>=</operator> <literal type="number">20</literal></expr>,
<expr><name>CombinedUpperBoundVariableOffset</name> <operator>=</operator> <literal type="number">21</literal></expr>,
<expr><name>CombinedEnsureUpperBoundOffset</name> <operator>=</operator> <literal type="number">22</literal></expr>,
<expr><name>CombinedInitOffset</name> <operator>=</operator> <literal type="number">23</literal></expr>,
<expr><name>CombinedConditionOffset</name> <operator>=</operator> <literal type="number">24</literal></expr>,
<expr><name>CombinedNextLowerBoundOffset</name> <operator>=</operator> <literal type="number">25</literal></expr>,
<expr><name>CombinedNextUpperBoundOffset</name> <operator>=</operator> <literal type="number">26</literal></expr>,
<expr><name>CombinedDistConditionOffset</name> <operator>=</operator> <literal type="number">27</literal></expr>,
<expr><name>CombinedParForInDistConditionOffset</name> <operator>=</operator> <literal type="number">28</literal></expr>,



<expr><name>CombinedDistributeEnd</name> <operator>=</operator> <literal type="number">29</literal></expr>,
}</block></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getCounters</name><argument_list>()</argument_list></macro> <block>{
<expr><name>auto</name> <operator>*</operator><operator>*</operator><name>Storage</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><operator>&amp;</operator><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>getArraysOffset</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeMutableArrayRef</name><argument_list>(<argument><expr><name>Storage</name></expr></argument>, <argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivateCounters</name><argument_list>()</argument_list></macro> <block>{
<expr><name>auto</name> <operator>*</operator><operator>*</operator><name>Storage</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><operator>&amp;</operator><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>getArraysOffset</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator>
<call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeMutableArrayRef</name><argument_list>(<argument><expr><name>Storage</name></expr></argument>, <argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getInits</name><argument_list>()</argument_list></macro> <block>{
<expr><name>auto</name> <operator>*</operator><operator>*</operator><name>Storage</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><operator>&amp;</operator><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>getArraysOffset</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator>
<literal type="number">2</literal> <operator>*</operator> <call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeMutableArrayRef</name><argument_list>(<argument><expr><name>Storage</name></expr></argument>, <argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getUpdates</name><argument_list>()</argument_list></macro> <block>{
<expr><name>auto</name> <operator>*</operator><operator>*</operator><name>Storage</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><operator>&amp;</operator><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>getArraysOffset</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator>
<literal type="number">3</literal> <operator>*</operator> <call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeMutableArrayRef</name><argument_list>(<argument><expr><name>Storage</name></expr></argument>, <argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getFinals</name><argument_list>()</argument_list></macro> <block>{
<expr><name>auto</name> <operator>*</operator><operator>*</operator><name>Storage</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><operator>&amp;</operator><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>getArraysOffset</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator>
<literal type="number">4</literal> <operator>*</operator> <call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeMutableArrayRef</name><argument_list>(<argument><expr><name>Storage</name></expr></argument>, <argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getDependentCounters</name><argument_list>()</argument_list></macro> <block>{
<expr><name>auto</name> <operator>*</operator><operator>*</operator><name>Storage</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><operator>&amp;</operator><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>getArraysOffset</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator>
<literal type="number">5</literal> <operator>*</operator> <call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeMutableArrayRef</name><argument_list>(<argument><expr><name>Storage</name></expr></argument>, <argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getDependentInits</name><argument_list>()</argument_list></macro> <block>{
<expr><name>auto</name> <operator>*</operator><operator>*</operator><name>Storage</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><operator>&amp;</operator><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>getArraysOffset</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator>
<literal type="number">6</literal> <operator>*</operator> <call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeMutableArrayRef</name><argument_list>(<argument><expr><name>Storage</name></expr></argument>, <argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getFinalsConditions</name><argument_list>()</argument_list></macro> <block>{
<expr><name>auto</name> <operator>*</operator><operator>*</operator><name>Storage</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><operator>&amp;</operator><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>getArraysOffset</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator>
<literal type="number">7</literal> <operator>*</operator> <call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeMutableArrayRef</name><argument_list>(<argument><expr><name>Storage</name></expr></argument>, <argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>protected</name><operator>:</operator>








<macro><name>OMPLoopDirective</name><argument_list>(<argument>StmtClass SC</argument>, <argument>OpenMPDirectiveKind Kind</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopBasedDirective</name><argument_list>(<argument>SC</argument>, <argument>Kind</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>


<specifier>static</specifier> <name>unsigned</name> <macro><name>getArraysOffset</name><argument_list>(<argument>OpenMPDirectiveKind Kind</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CombinedDistributeEnd</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<expr><call><name>isOpenMPWorksharingDirective</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isOpenMPTaskLoopDirective</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPDistributeDirective</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>WorksharingEnd</name></expr>;</return></block_content></block></if></if_stmt></block></expr></range></decl></decl_stmt>
<return>return <expr><name>DefaultEnd</name></expr>;</return>
}


static <function><type><name>unsigned</name></type> <name>numLoopChildren</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>CollapsedNum</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>Kind</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getArraysOffset</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call> <operator>+</operator>
<literal type="number">8</literal> <operator>*</operator> <name>CollapsedNum</name></expr>;</return>


</block_content>}</block></function>

<function><type><name>void</name></type> <name>setIterationVariable</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>IV</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>IterationVariableOffset</name></expr>]</index> <operator>=</operator> <name>IV</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setLastIteration</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LI</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>LastIterationOffset</name></expr>]</index> <operator>=</operator> <name>LI</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setCalcLastIteration</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>CLI</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CalcLastIterationOffset</name></expr>]</index> <operator>=</operator> <name>CLI</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setPreCond</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>PC</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>PreConditionOffset</name></expr>]</index> <operator>=</operator> <name>PC</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setCond</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Cond</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CondOffset</name></expr>]</index> <operator>=</operator> <name>Cond</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setInit</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>InitOffset</name></expr>]</index> <operator>=</operator> <name>Init</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setInc</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Inc</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>IncOffset</name></expr>]</index> <operator>=</operator> <name>Inc</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setPreInits</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>PreInits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>PreInitsOffset</name></expr>]</index> <operator>=</operator> <name>PreInits</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setIsLastIterVariable</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>IL</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isOpenMPWorksharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPTaskLoopDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPDistributeDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"expected worksharing loop directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>IsLastIterVariableOffset</name></expr>]</index> <operator>=</operator> <name>IL</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setLowerBoundVariable</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LB</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isOpenMPWorksharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPTaskLoopDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPDistributeDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"expected worksharing loop directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>LowerBoundVariableOffset</name></expr>]</index> <operator>=</operator> <name>LB</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setUpperBoundVariable</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>UB</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isOpenMPWorksharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPTaskLoopDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPDistributeDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"expected worksharing loop directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>UpperBoundVariableOffset</name></expr>]</index> <operator>=</operator> <name>UB</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setStrideVariable</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ST</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isOpenMPWorksharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPTaskLoopDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPDistributeDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"expected worksharing loop directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>StrideVariableOffset</name></expr>]</index> <operator>=</operator> <name>ST</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setEnsureUpperBound</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>EUB</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isOpenMPWorksharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPTaskLoopDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPDistributeDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"expected worksharing loop directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>EnsureUpperBoundOffset</name></expr>]</index> <operator>=</operator> <name>EUB</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setNextLowerBound</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NLB</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isOpenMPWorksharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPTaskLoopDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPDistributeDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"expected worksharing loop directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>NextLowerBoundOffset</name></expr>]</index> <operator>=</operator> <name>NLB</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setNextUpperBound</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NUB</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isOpenMPWorksharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPTaskLoopDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPDistributeDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"expected worksharing loop directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>NextUpperBoundOffset</name></expr>]</index> <operator>=</operator> <name>NUB</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setNumIterations</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NI</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isOpenMPWorksharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPTaskLoopDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPDistributeDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"expected worksharing loop directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>NumIterationsOffset</name></expr>]</index> <operator>=</operator> <name>NI</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setPrevLowerBoundVariable</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>PrevLB</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>PrevLowerBoundVariableOffset</name></expr>]</index> <operator>=</operator> <name>PrevLB</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setPrevUpperBoundVariable</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>PrevUB</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>PrevUpperBoundVariableOffset</name></expr>]</index> <operator>=</operator> <name>PrevUB</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setDistInc</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>DistInc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>DistIncOffset</name></expr>]</index> <operator>=</operator> <name>DistInc</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setPrevEnsureUpperBound</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>PrevEUB</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>PrevEnsureUpperBoundOffset</name></expr>]</index> <operator>=</operator> <name>PrevEUB</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setCombinedLowerBoundVariable</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>CombLB</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CombinedLowerBoundVariableOffset</name></expr>]</index> <operator>=</operator> <name>CombLB</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setCombinedUpperBoundVariable</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>CombUB</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CombinedUpperBoundVariableOffset</name></expr>]</index> <operator>=</operator> <name>CombUB</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setCombinedEnsureUpperBound</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>CombEUB</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CombinedEnsureUpperBoundOffset</name></expr>]</index> <operator>=</operator> <name>CombEUB</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setCombinedInit</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>CombInit</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CombinedInitOffset</name></expr>]</index> <operator>=</operator> <name>CombInit</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setCombinedCond</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>CombCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CombinedConditionOffset</name></expr>]</index> <operator>=</operator> <name>CombCond</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setCombinedNextLowerBound</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>CombNLB</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CombinedNextLowerBoundOffset</name></expr>]</index> <operator>=</operator> <name>CombNLB</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setCombinedNextUpperBound</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>CombNUB</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CombinedNextUpperBoundOffset</name></expr>]</index> <operator>=</operator> <name>CombNUB</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setCombinedDistCond</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>CombDistCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound distribute sharing directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CombinedDistConditionOffset</name></expr>]</index> <operator>=</operator> <name>CombDistCond</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setCombinedParForInDistCond</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>CombParForInDistCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound distribute sharing directive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CombinedParForInDistConditionOffset</name></expr>]</index> <operator>=</operator>
<name>CombParForInDistCond</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function_decl><type><name>void</name></type> <name>setCounters</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>A</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>setPrivateCounters</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>A</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>setInits</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>A</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>setUpdates</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>A</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>setFinals</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>A</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>setDependentCounters</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>A</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>setDependentInits</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>A</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>setFinalsConditions</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>A</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getIterationVariable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>IterationVariableOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getLastIteration</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>LastIterationOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getCalcLastIteration</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CalcLastIterationOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getPreCond</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>PreConditionOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getCond</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CondOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getInit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>InitOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getInc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>IncOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getPreInits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>PreInitsOffset</name></expr>]</index></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>Stmt</name> <modifier>*</modifier></type><name>getPreInits</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>PreInitsOffset</name></expr>]</index></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getIsLastIterVariable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isOpenMPWorksharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPTaskLoopDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPDistributeDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"expected worksharing loop directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>IsLastIterVariableOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getLowerBoundVariable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isOpenMPWorksharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPTaskLoopDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPDistributeDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"expected worksharing loop directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>LowerBoundVariableOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getUpperBoundVariable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isOpenMPWorksharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPTaskLoopDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPDistributeDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"expected worksharing loop directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>UpperBoundVariableOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getStrideVariable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isOpenMPWorksharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPTaskLoopDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPDistributeDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"expected worksharing loop directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>StrideVariableOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getEnsureUpperBound</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isOpenMPWorksharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPTaskLoopDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPDistributeDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"expected worksharing loop directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>EnsureUpperBoundOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getNextLowerBound</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isOpenMPWorksharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPTaskLoopDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPDistributeDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"expected worksharing loop directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>NextLowerBoundOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getNextUpperBound</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isOpenMPWorksharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPTaskLoopDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPDistributeDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"expected worksharing loop directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>NextUpperBoundOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getNumIterations</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>isOpenMPWorksharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPTaskLoopDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>isOpenMPDistributeDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"expected worksharing loop directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>NumIterationsOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getPrevLowerBoundVariable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>PrevLowerBoundVariableOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getPrevUpperBoundVariable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>PrevUpperBoundVariableOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getDistInc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>DistIncOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getPrevEnsureUpperBound</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>PrevEnsureUpperBoundOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getCombinedLowerBoundVariable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CombinedLowerBoundVariableOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getCombinedUpperBoundVariable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CombinedUpperBoundVariableOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getCombinedEnsureUpperBound</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CombinedEnsureUpperBoundOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getCombinedInit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CombinedInitOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getCombinedCond</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CombinedConditionOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getCombinedNextLowerBound</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CombinedNextLowerBoundOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getCombinedNextUpperBound</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound sharing directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CombinedNextUpperBoundOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getCombinedDistCond</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound distribute sharing directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CombinedDistConditionOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getCombinedParForInDistCond</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOpenMPLoopBoundSharingDirective</name><argument_list>(<argument><expr><call><name>getDirectiveKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected loop bound distribute sharing directive"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>CombinedParForInDistConditionOffset</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function_decl><type><name>Stmt</name> <modifier>*</modifier></type><name>getBody</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPLoopDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getBody</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>counters</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>getCounters</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>counters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPLoopDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getCounters</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>private_counters</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>getPrivateCounters</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>private_counters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPLoopDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPrivateCounters</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>inits</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>getInits</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>inits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPLoopDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getInits</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>updates</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>getUpdates</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>updates</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPLoopDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getUpdates</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>finals</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>getFinals</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>finals</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPLoopDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getFinals</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>dependent_counters</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>getDependentCounters</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>dependent_counters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPLoopDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getDependentCounters</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>dependent_inits</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>getDependentInits</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>dependent_inits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPLoopDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getDependentInits</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>finals_conditions</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>getFinalsConditions</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>finals_conditions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPLoopDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getFinalsConditions</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPSimdDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPForDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPForSimdDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPParallelForDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPParallelForSimdDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTaskLoopDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTaskLoopSimdDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPMasterTaskLoopDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPMasterTaskLoopSimdDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPParallelMasterTaskLoopDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPParallelMasterTaskLoopSimdDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPDistributeDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTargetParallelForDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPDistributeParallelForDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPDistributeParallelForSimdDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPDistributeSimdDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTargetParallelForSimdDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTargetSimdDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTeamsDistributeDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTeamsDistributeSimdDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator>
<name>OMPTeamsDistributeParallelForSimdDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTeamsDistributeParallelForDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator>
<name>OMPTargetTeamsDistributeParallelForDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator>
<name>OMPTargetTeamsDistributeParallelForSimdDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTargetTeamsDistributeDirectiveClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTargetTeamsDistributeSimdDirectiveClass</name></expr>;</return>
</block_content>}</block></function>
};










<decl_stmt><decl><type><name>class</name></type> <name>OMPSimdDirective</name> <range>: <expr><name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;






<macro><name>OMPSimdDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPSimdDirectiveClass</argument>, <argument>llvm::omp::OMPD_simd</argument>, <argument>StartLoc</argument>,
<argument>EndLoc</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPSimdDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPSimdDirectiveClass</argument>, <argument>llvm::omp::OMPD_simd</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPSimdDirective</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>unsigned CollapsedNum</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>,
<argument>const HelperExprs &amp;Exprs</argument>)</argument_list></macro></expr>;








<expr><specifier>static</specifier> <name>OMPSimdDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumClauses</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPSimdDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPForDirective</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;

<expr><name>bool</name> <name>HasCancel</name> <operator>=</operator> <name>false</name></expr>;







<macro><name>OMPForDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPForDirectiveClass</argument>, <argument>llvm::omp::OMPD_for</argument>, <argument>StartLoc</argument>,
<argument>EndLoc</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPForDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPForDirectiveClass</argument>, <argument>llvm::omp::OMPD_for</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setTaskReductionRefExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>numLoopChildren</name><argument_list>(<argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator></expr></argument></argument_list></call></expr></index>omp<operator>::</operator><name>OMPD_for</name></expr>)] <operator>=</operator> <name>E</name></block></expr>;
}</block>


<name>void</name> <macro><name>setHasCancel</name><argument_list>(<argument>bool Has</argument>)</argument_list></macro> <block>{ <expr><name>HasCancel</name> <operator>=</operator> <name>Has</name></expr>; }</block>

<name>public</name><operator>:</operator>













<specifier>static</specifier> <name>OMPForDirective</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>unsigned CollapsedNum</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>,
<argument>Expr *TaskRedRef</argument>, <argument>bool HasCancel</argument>)</argument_list></macro></expr>;








<expr><specifier>static</specifier> <name>OMPForDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumClauses</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;


<expr><name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>numLoopChildren</name><argument_list>(
<argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator></expr></argument></argument_list></call></expr></index>omp<operator>::</operator><name>OMPD_for</name></expr></argument>)</argument_list></call>]</expr></return>)</block></expr>;
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPForDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasCancel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasCancel</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPForDirectiveClass</name></expr>;</return>
</block_content>}</block></function>
};










<decl_stmt><decl><type><name>class</name></type> <name>OMPForSimdDirective</name> <range>: <expr><name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;






<macro><name>OMPForSimdDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPForSimdDirectiveClass</argument>, <argument>llvm::omp::OMPD_for_simd</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPForSimdDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPForSimdDirectiveClass</argument>, <argument>llvm::omp::OMPD_for_simd</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPForSimdDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>)</argument_list></macro></expr>;








<expr><specifier>static</specifier> <name>OMPForSimdDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPForSimdDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPSectionsDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;


<expr><name>bool</name> <name>HasCancel</name> <operator>=</operator> <name>false</name></expr>;






<macro><name>OMPSectionsDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPSectionsDirectiveClass</argument>,
<argument>llvm::omp::OMPD_sections</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPSectionsDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPSectionsDirectiveClass</argument>,
<argument>llvm::omp::OMPD_sections</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setTaskReductionRefExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>E</name></expr>; }</block>


<name>void</name> <macro><name>setHasCancel</name><argument_list>(<argument>bool Has</argument>)</argument_list></macro> <block>{ <expr><name>HasCancel</name> <operator>=</operator> <name>Has</name></expr>; }</block>

<name>public</name><operator>:</operator>











<specifier>static</specifier> <name>OMPSectionsDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *AssociatedStmt</argument>, <argument>Expr *TaskRedRef</argument>,
<argument>bool HasCancel</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPSectionsDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;


<expr><name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPSectionsDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasCancel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasCancel</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPSectionsDirectiveClass</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>OMPSectionDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;


<expr><name>bool</name> <name>HasCancel</name> <operator>=</operator> <name>false</name></expr>;






<macro><name>OMPSectionDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPSectionDirectiveClass</argument>,
<argument>llvm::omp::OMPD_section</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPSectionDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPSectionDirectiveClass</argument>,
<argument>llvm::omp::OMPD_section</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>








<specifier>static</specifier> <name>OMPSectionDirective</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>bool HasCancel</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPSectionDirective</name> <operator>*</operator><call><name>CreateEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>EmptyShell</name></expr></argument>)</argument_list></call></expr>;


<expr><name>void</name> <macro><name>setHasCancel</name><argument_list>(<argument>bool Has</argument>)</argument_list></macro> <block>{ <expr><name>HasCancel</name> <operator>=</operator> <name>Has</name></expr>; }</block>


<name>bool</name> <macro><name>hasCancel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasCancel</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPSectionDirectiveClass</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPSingleDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;





<macro><name>OMPSingleDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPSingleDirectiveClass</argument>, <argument>llvm::omp::OMPD_single</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPSingleDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPSingleDirectiveClass</argument>, <argument>llvm::omp::OMPD_single</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>








<specifier>static</specifier> <name>OMPSingleDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *AssociatedStmt</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPSingleDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPSingleDirectiveClass</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>OMPMasterDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;





<macro><name>OMPMasterDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPMasterDirectiveClass</argument>, <argument>llvm::omp::OMPD_master</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPMasterDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPMasterDirectiveClass</argument>, <argument>llvm::omp::OMPD_master</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>







<specifier>static</specifier> <name>OMPMasterDirective</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>Stmt *AssociatedStmt</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPMasterDirective</name> <operator>*</operator><call><name>CreateEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>EmptyShell</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPMasterDirectiveClass</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>OMPCriticalDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;

<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;






<macro><name>OMPCriticalDirective</name><argument_list>(<argument>const DeclarationNameInfo &amp;Name</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>OMPExecutableDirective</name><argument_list>(<argument><expr><name>OMPCriticalDirectiveClass</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPD_critical</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<macro><name>DirName</name><argument_list>(<argument>Name</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPCriticalDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPCriticalDirectiveClass</argument>,
<argument>llvm::omp::OMPD_critical</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>





<name>void</name> <macro><name>setDirectiveName</name><argument_list>(<argument>const DeclarationNameInfo &amp;Name</argument>)</argument_list></macro> <block>{ <expr><name>DirName</name> <operator>=</operator> <name>Name</name></expr>; }</block>

<name>public</name><operator>:</operator>









<specifier>static</specifier> <name>OMPCriticalDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>const DeclarationNameInfo &amp;Name</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *AssociatedStmt</argument>)</argument_list></macro></expr>;






<expr><specifier>static</specifier> <name>OMPCriticalDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;



<expr><name>DeclarationNameInfo</name> <macro><name>getDirectiveName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DirName</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPCriticalDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPParallelForDirective</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;


<expr><name>bool</name> <name>HasCancel</name> <operator>=</operator> <name>false</name></expr>;







<macro><name>OMPParallelForDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPParallelForDirectiveClass</argument>,
<argument>llvm::omp::OMPD_parallel_for</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>,
<argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPParallelForDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPParallelForDirectiveClass</argument>,
<argument>llvm::omp::OMPD_parallel_for</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setTaskReductionRefExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>numLoopChildren</name><argument_list>(<argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator></expr></argument></argument_list></call></expr></index>omp<operator>::</operator><name>OMPD_parallel_for</name></expr>)] <operator>=</operator> <name>E</name></block></expr>;
}</block>


<name>void</name> <macro><name>setHasCancel</name><argument_list>(<argument>bool Has</argument>)</argument_list></macro> <block>{ <expr><name>HasCancel</name> <operator>=</operator> <name>Has</name></expr>; }</block>

<name>public</name><operator>:</operator>













<specifier>static</specifier> <name>OMPParallelForDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>, <argument>Expr *TaskRedRef</argument>,
<argument>bool HasCancel</argument>)</argument_list></macro></expr>;








<expr><specifier>static</specifier> <name>OMPParallelForDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>,
<argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;


<expr><name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>numLoopChildren</name><argument_list>(
<argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator></expr></argument></argument_list></call></expr></index>omp<operator>::</operator><name>OMPD_parallel_for</name></expr></argument>)</argument_list></call>]</expr></return>)</block></expr>;
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPParallelForDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasCancel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasCancel</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPParallelForDirectiveClass</name></expr>;</return>
}</block>
}</expr>;











<expr><name>class</name> <name>OMPParallelForSimdDirective</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;






<macro><name>OMPParallelForSimdDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPParallelForSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_parallel_for_simd</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>,
<argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPParallelForSimdDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPParallelForSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_parallel_for_simd</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPParallelForSimdDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>)</argument_list></macro></expr>;








<expr><specifier>static</specifier> <name>OMPParallelForSimdDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>,
<argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPParallelForSimdDirectiveClass</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPParallelMasterDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;

<macro><name>OMPParallelMasterDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPParallelMasterDirectiveClass</argument>,
<argument>llvm::omp::OMPD_parallel_master</argument>, <argument>StartLoc</argument>,
<argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>

<name>explicit</name> <call><name>OMPParallelMasterDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPParallelMasterDirectiveClass</argument>,
<argument>llvm::omp::OMPD_parallel_master</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setTaskReductionRefExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>E</name></expr>; }</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPParallelMasterDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *AssociatedStmt</argument>, <argument>Expr *TaskRedRef</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPParallelMasterDirective</name> <operator>*</operator>
<macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;


<expr><name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPParallelMasterDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPParallelMasterDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPParallelSectionsDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;


<expr><name>bool</name> <name>HasCancel</name> <operator>=</operator> <name>false</name></expr>;






<macro><name>OMPParallelSectionsDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPParallelSectionsDirectiveClass</argument>,
<argument>llvm::omp::OMPD_parallel_sections</argument>, <argument>StartLoc</argument>,
<argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPParallelSectionsDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPParallelSectionsDirectiveClass</argument>,
<argument>llvm::omp::OMPD_parallel_sections</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setTaskReductionRefExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>E</name></expr>; }</block>


<name>void</name> <macro><name>setHasCancel</name><argument_list>(<argument>bool Has</argument>)</argument_list></macro> <block>{ <expr><name>HasCancel</name> <operator>=</operator> <name>Has</name></expr>; }</block>

<name>public</name><operator>:</operator>











<specifier>static</specifier> <name>OMPParallelSectionsDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *AssociatedStmt</argument>, <argument>Expr *TaskRedRef</argument>,
<argument>bool HasCancel</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPParallelSectionsDirective</name> <operator>*</operator>
<macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;


<expr><name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPParallelSectionsDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasCancel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasCancel</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPParallelSectionsDirectiveClass</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPTaskDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;

<expr><name>bool</name> <name>HasCancel</name> <operator>=</operator> <name>false</name></expr>;






<macro><name>OMPTaskDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTaskDirectiveClass</argument>, <argument>llvm::omp::OMPD_task</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPTaskDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTaskDirectiveClass</argument>, <argument>llvm::omp::OMPD_task</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setHasCancel</name><argument_list>(<argument>bool Has</argument>)</argument_list></macro> <block>{ <expr><name>HasCancel</name> <operator>=</operator> <name>Has</name></expr>; }</block>

<name>public</name><operator>:</operator>









<specifier>static</specifier> <name>OMPTaskDirective</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>bool HasCancel</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPTaskDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumClauses</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;


<expr><name>bool</name> <macro><name>hasCancel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasCancel</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTaskDirectiveClass</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>OMPTaskyieldDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;





<macro><name>OMPTaskyieldDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTaskyieldDirectiveClass</argument>,
<argument>llvm::omp::OMPD_taskyield</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPTaskyieldDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTaskyieldDirectiveClass</argument>,
<argument>llvm::omp::OMPD_taskyield</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>






<specifier>static</specifier> <name>OMPTaskyieldDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPTaskyieldDirective</name> <operator>*</operator><call><name>CreateEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>EmptyShell</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTaskyieldDirectiveClass</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>OMPBarrierDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;





<macro><name>OMPBarrierDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPBarrierDirectiveClass</argument>,
<argument>llvm::omp::OMPD_barrier</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPBarrierDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPBarrierDirectiveClass</argument>,
<argument>llvm::omp::OMPD_barrier</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>






<specifier>static</specifier> <name>OMPBarrierDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPBarrierDirective</name> <operator>*</operator><call><name>CreateEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>EmptyShell</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPBarrierDirectiveClass</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>OMPTaskwaitDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;





<macro><name>OMPTaskwaitDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTaskwaitDirectiveClass</argument>,
<argument>llvm::omp::OMPD_taskwait</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPTaskwaitDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTaskwaitDirectiveClass</argument>,
<argument>llvm::omp::OMPD_taskwait</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>






<specifier>static</specifier> <name>OMPTaskwaitDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPTaskwaitDirective</name> <operator>*</operator><call><name>CreateEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>EmptyShell</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTaskwaitDirectiveClass</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>OMPTaskgroupDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;





<macro><name>OMPTaskgroupDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTaskgroupDirectiveClass</argument>,
<argument>llvm::omp::OMPD_taskgroup</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPTaskgroupDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTaskgroupDirectiveClass</argument>,
<argument>llvm::omp::OMPD_taskgroup</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setReductionRef</name><argument_list>(<argument>Expr *RR</argument>)</argument_list></macro> <block>{ <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>RR</name></expr>; }</block>

<name>public</name><operator>:</operator>









<specifier>static</specifier> <name>OMPTaskgroupDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *AssociatedStmt</argument>,
<argument>Expr *ReductionRef</argument>)</argument_list></macro></expr>;






<expr><specifier>static</specifier> <name>OMPTaskgroupDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;



<expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getReductionRef</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPTaskgroupDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getReductionRef</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>Expr</name> <operator>*</operator><macro><name>getReductionRef</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTaskgroupDirectiveClass</name></expr>;</return>
}</block>
}</expr>;











<expr><name>class</name> <name>OMPFlushDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;





<macro><name>OMPFlushDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPFlushDirectiveClass</argument>, <argument>llvm::omp::OMPD_flush</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPFlushDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPFlushDirectiveClass</argument>, <argument>llvm::omp::OMPD_flush</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>








<specifier>static</specifier> <name>OMPFlushDirective</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPFlushDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPFlushDirectiveClass</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPDepobjDirective</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;






<macro><name>OMPDepobjDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPDepobjDirectiveClass</argument>, <argument>llvm::omp::OMPD_depobj</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPDepobjDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPDepobjDirectiveClass</argument>, <argument>llvm::omp::OMPD_depobj</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>







<specifier>static</specifier> <name>OMPDepobjDirective</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPDepobjDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPDepobjDirectiveClass</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>OMPOrderedDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;





<macro><name>OMPOrderedDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPOrderedDirectiveClass</argument>,
<argument>llvm::omp::OMPD_ordered</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPOrderedDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPOrderedDirectiveClass</argument>,
<argument>llvm::omp::OMPD_ordered</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>








<specifier>static</specifier> <name>OMPOrderedDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *AssociatedStmt</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPOrderedDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>,
<argument>bool IsStandalone</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPOrderedDirectiveClass</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPAtomicDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;









<expr><name>bool</name> <name>IsXLHSInRHSPart</name> <operator>=</operator> <name>false</name></expr>;








<expr><name>bool</name> <name>IsPostfixUpdate</name> <operator>=</operator> <name>false</name></expr>;






<macro><name>OMPAtomicDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPAtomicDirectiveClass</argument>, <argument>llvm::omp::OMPD_atomic</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPAtomicDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPAtomicDirectiveClass</argument>, <argument>llvm::omp::OMPD_atomic</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setX</name><argument_list>(<argument>Expr *X</argument>)</argument_list></macro> <block>{ <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>X</name></expr>; }</block>



<name>void</name> <macro><name>setUpdateExpr</name><argument_list>(<argument>Expr *UE</argument>)</argument_list></macro> <block>{ <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>=</operator> <name>UE</name></expr>; }</block>

<name>void</name> <macro><name>setV</name><argument_list>(<argument>Expr *V</argument>)</argument_list></macro> <block>{ <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index> <operator>=</operator> <name>V</name></expr>; }</block>

<name>void</name> <macro><name>setExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">3</literal></expr>]</index> <operator>=</operator> <name>E</name></expr>; }</block>

<name>public</name><operator>:</operator>



















<specifier>static</specifier> <name>OMPAtomicDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *AssociatedStmt</argument>, <argument>Expr *X</argument>, <argument>Expr *V</argument>,
<argument>Expr *E</argument>, <argument>Expr *UE</argument>, <argument>bool IsXLHSInRHSPart</argument>, <argument>bool IsPostfixUpdate</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPAtomicDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;


<expr><name>Expr</name> <operator>*</operator><macro><name>getX</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getX</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>Expr</name> <operator>*</operator><macro><name>getUpdateExpr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">1</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getUpdateExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">1</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isXLHSInRHSPart</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsXLHSInRHSPart</name></expr>;</return> }</block>


<name>bool</name> <macro><name>isPostfixUpdate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsPostfixUpdate</name></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getV</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getV</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getExpr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">3</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">3</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPAtomicDirectiveClass</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPTargetDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;





<macro><name>OMPTargetDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTargetDirectiveClass</argument>, <argument>llvm::omp::OMPD_target</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPTargetDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTargetDirectiveClass</argument>, <argument>llvm::omp::OMPD_target</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>








<specifier>static</specifier> <name>OMPTargetDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *AssociatedStmt</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPTargetDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTargetDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPTargetDataDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;





<macro><name>OMPTargetDataDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTargetDataDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_data</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPTargetDataDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTargetDataDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_data</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>








<specifier>static</specifier> <name>OMPTargetDataDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *AssociatedStmt</argument>)</argument_list></macro></expr>;






<expr><specifier>static</specifier> <name>OMPTargetDataDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTargetDataDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPTargetEnterDataDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;





<macro><name>OMPTargetEnterDataDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTargetEnterDataDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_enter_data</argument>, <argument>StartLoc</argument>,
<argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPTargetEnterDataDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTargetEnterDataDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_enter_data</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>








<specifier>static</specifier> <name>OMPTargetEnterDataDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *AssociatedStmt</argument>)</argument_list></macro></expr>;






<expr><specifier>static</specifier> <name>OMPTargetEnterDataDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned N</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTargetEnterDataDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPTargetExitDataDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;





<macro><name>OMPTargetExitDataDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTargetExitDataDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_exit_data</argument>, <argument>StartLoc</argument>,
<argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPTargetExitDataDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTargetExitDataDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_exit_data</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>








<specifier>static</specifier> <name>OMPTargetExitDataDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *AssociatedStmt</argument>)</argument_list></macro></expr>;






<expr><specifier>static</specifier> <name>OMPTargetExitDataDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned N</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTargetExitDataDirectiveClass</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPTargetParallelDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;

<expr><name>bool</name> <name>HasCancel</name> <operator>=</operator> <name>false</name></expr>;






<macro><name>OMPTargetParallelDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTargetParallelDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_parallel</argument>, <argument>StartLoc</argument>,
<argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPTargetParallelDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTargetParallelDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_parallel</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setTaskReductionRefExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>E</name></expr>; }</block>

<name>void</name> <macro><name>setHasCancel</name><argument_list>(<argument>bool Has</argument>)</argument_list></macro> <block>{ <expr><name>HasCancel</name> <operator>=</operator> <name>Has</name></expr>; }</block>

<name>public</name><operator>:</operator>











<specifier>static</specifier> <name>OMPTargetParallelDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *AssociatedStmt</argument>, <argument>Expr *TaskRedRef</argument>,
<argument>bool HasCancel</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPTargetParallelDirective</name> <operator>*</operator>
<macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;


<expr><name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPTargetParallelDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasCancel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasCancel</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTargetParallelDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPTargetParallelForDirective</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;


<expr><name>bool</name> <name>HasCancel</name> <operator>=</operator> <name>false</name></expr>;







<macro><name>OMPTargetParallelForDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTargetParallelForDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_parallel_for</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>,
<argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPTargetParallelForDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTargetParallelForDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_parallel_for</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setTaskReductionRefExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>numLoopChildren</name><argument_list>(
<argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator></expr></argument></argument_list></call></expr></index>omp<operator>::</operator><name>OMPD_target_parallel_for</name></expr>)] <operator>=</operator> <name>E</name></block></expr>;
}</block>


<name>void</name> <macro><name>setHasCancel</name><argument_list>(<argument>bool Has</argument>)</argument_list></macro> <block>{ <expr><name>HasCancel</name> <operator>=</operator> <name>Has</name></expr>; }</block>

<name>public</name><operator>:</operator>













<specifier>static</specifier> <name>OMPTargetParallelForDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>, <argument>Expr *TaskRedRef</argument>,
<argument>bool HasCancel</argument>)</argument_list></macro></expr>;








<expr><specifier>static</specifier> <name>OMPTargetParallelForDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>,
<argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;


<expr><name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>numLoopChildren</name><argument_list>(
<argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator></expr></argument></argument_list></call></expr></index>omp<operator>::</operator><name>OMPD_target_parallel_for</name></expr></argument>)</argument_list></call>]</expr></return>)</block></expr>;
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPTargetParallelForDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasCancel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasCancel</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTargetParallelForDirectiveClass</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPTeamsDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;





<macro><name>OMPTeamsDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTeamsDirectiveClass</argument>, <argument>llvm::omp::OMPD_teams</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPTeamsDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTeamsDirectiveClass</argument>, <argument>llvm::omp::OMPD_teams</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>








<specifier>static</specifier> <name>OMPTeamsDirective</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPTeamsDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTeamsDirectiveClass</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPCancellationPointDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;
<expr><name>OpenMPDirectiveKind</name> <name>CancelRegion</name> <operator>=</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPD_unknown</name></expr>;






<macro><name>OMPCancellationPointDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPCancellationPointDirectiveClass</argument>,
<argument>llvm::omp::OMPD_cancellation_point</argument>, <argument>StartLoc</argument>,
<argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>


<name>explicit</name> <call><name>OMPCancellationPointDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPCancellationPointDirectiveClass</argument>,
<argument>llvm::omp::OMPD_cancellation_point</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>



<name>void</name> <macro><name>setCancelRegion</name><argument_list>(<argument>OpenMPDirectiveKind CR</argument>)</argument_list></macro> <block>{ <expr><name>CancelRegion</name> <operator>=</operator> <name>CR</name></expr>; }</block>

<name>public</name><operator>:</operator>






<specifier>static</specifier> <name>OMPCancellationPointDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>OpenMPDirectiveKind CancelRegion</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPCancellationPointDirective</name> <operator>*</operator><call><name>CreateEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>,
<argument><expr><name>EmptyShell</name></expr></argument>)</argument_list></call></expr>;


<expr><name>OpenMPDirectiveKind</name> <macro><name>getCancelRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CancelRegion</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPCancellationPointDirectiveClass</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPCancelDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;
<expr><name>OpenMPDirectiveKind</name> <name>CancelRegion</name> <operator>=</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPD_unknown</name></expr>;





<macro><name>OMPCancelDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPCancelDirectiveClass</argument>, <argument>llvm::omp::OMPD_cancel</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPCancelDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPCancelDirectiveClass</argument>, <argument>llvm::omp::OMPD_cancel</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>



<name>void</name> <macro><name>setCancelRegion</name><argument_list>(<argument>OpenMPDirectiveKind CR</argument>)</argument_list></macro> <block>{ <expr><name>CancelRegion</name> <operator>=</operator> <name>CR</name></expr>; }</block>

<name>public</name><operator>:</operator>







<specifier>static</specifier> <name>OMPCancelDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>OpenMPDirectiveKind CancelRegion</argument>)</argument_list></macro></expr>;






<expr><specifier>static</specifier> <name>OMPCancelDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;


<expr><name>OpenMPDirectiveKind</name> <macro><name>getCancelRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CancelRegion</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPCancelDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPTaskLoopDirective</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;

<expr><name>bool</name> <name>HasCancel</name> <operator>=</operator> <name>false</name></expr>;







<macro><name>OMPTaskLoopDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTaskLoopDirectiveClass</argument>, <argument>llvm::omp::OMPD_taskloop</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPTaskLoopDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTaskLoopDirectiveClass</argument>, <argument>llvm::omp::OMPD_taskloop</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setHasCancel</name><argument_list>(<argument>bool Has</argument>)</argument_list></macro> <block>{ <expr><name>HasCancel</name> <operator>=</operator> <name>Has</name></expr>; }</block>

<name>public</name><operator>:</operator>











<specifier>static</specifier> <name>OMPTaskLoopDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>, <argument>bool HasCancel</argument>)</argument_list></macro></expr>;








<expr><specifier>static</specifier> <name>OMPTaskLoopDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;


<expr><name>bool</name> <macro><name>hasCancel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasCancel</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTaskLoopDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPTaskLoopSimdDirective</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;






<macro><name>OMPTaskLoopSimdDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTaskLoopSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_taskloop_simd</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>,
<argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPTaskLoopSimdDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTaskLoopSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_taskloop_simd</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPTaskLoopSimdDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>)</argument_list></macro></expr>;








<expr><specifier>static</specifier> <name>OMPTaskLoopSimdDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>,
<argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTaskLoopSimdDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPMasterTaskLoopDirective</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;

<expr><name>bool</name> <name>HasCancel</name> <operator>=</operator> <name>false</name></expr>;







<macro><name>OMPMasterTaskLoopDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPMasterTaskLoopDirectiveClass</argument>,
<argument>llvm::omp::OMPD_master_taskloop</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>,
<argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPMasterTaskLoopDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPMasterTaskLoopDirectiveClass</argument>,
<argument>llvm::omp::OMPD_master_taskloop</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setHasCancel</name><argument_list>(<argument>bool Has</argument>)</argument_list></macro> <block>{ <expr><name>HasCancel</name> <operator>=</operator> <name>Has</name></expr>; }</block>

<name>public</name><operator>:</operator>











<specifier>static</specifier> <name>OMPMasterTaskLoopDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>, <argument>bool HasCancel</argument>)</argument_list></macro></expr>;








<expr><specifier>static</specifier> <name>OMPMasterTaskLoopDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>,
<argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;


<expr><name>bool</name> <macro><name>hasCancel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasCancel</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPMasterTaskLoopDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPMasterTaskLoopSimdDirective</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;






<macro><name>OMPMasterTaskLoopSimdDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPMasterTaskLoopSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_master_taskloop_simd</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>,
<argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPMasterTaskLoopSimdDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPMasterTaskLoopSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_master_taskloop_simd</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPMasterTaskLoopSimdDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPMasterTaskLoopSimdDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>,
<argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPMasterTaskLoopSimdDirectiveClass</name></expr>;</return>
}</block>
}</expr>;











<expr><name>class</name> <name>OMPParallelMasterTaskLoopDirective</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;

<expr><name>bool</name> <name>HasCancel</name> <operator>=</operator> <name>false</name></expr>;







<macro><name>OMPParallelMasterTaskLoopDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPParallelMasterTaskLoopDirectiveClass</argument>,
<argument>llvm::omp::OMPD_parallel_master_taskloop</argument>, <argument>StartLoc</argument>,
<argument>EndLoc</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPParallelMasterTaskLoopDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPParallelMasterTaskLoopDirectiveClass</argument>,
<argument>llvm::omp::OMPD_parallel_master_taskloop</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setHasCancel</name><argument_list>(<argument>bool Has</argument>)</argument_list></macro> <block>{ <expr><name>HasCancel</name> <operator>=</operator> <name>Has</name></expr>; }</block>

<name>public</name><operator>:</operator>











<specifier>static</specifier> <name>OMPParallelMasterTaskLoopDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>, <argument>bool HasCancel</argument>)</argument_list></macro></expr>;








<expr><specifier>static</specifier> <name>OMPParallelMasterTaskLoopDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>,
<argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;


<expr><name>bool</name> <macro><name>hasCancel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasCancel</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPParallelMasterTaskLoopDirectiveClass</name></expr>;</return>
}</block>
}</expr>;











<expr><name>class</name> <name>OMPParallelMasterTaskLoopSimdDirective</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;






<macro><name>OMPParallelMasterTaskLoopSimdDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPParallelMasterTaskLoopSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_parallel_master_taskloop_simd</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPParallelMasterTaskLoopSimdDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPParallelMasterTaskLoopSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_parallel_master_taskloop_simd</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPParallelMasterTaskLoopSimdDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>)</argument_list></macro></expr>;








<expr><specifier>static</specifier> <name>OMPParallelMasterTaskLoopSimdDirective</name> <operator>*</operator>
<macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumClauses</argument>, <argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPParallelMasterTaskLoopSimdDirectiveClass</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPDistributeDirective</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;







<macro><name>OMPDistributeDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPDistributeDirectiveClass</argument>,
<argument>llvm::omp::OMPD_distribute</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>,
<argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPDistributeDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPDistributeDirectiveClass</argument>,
<argument>llvm::omp::OMPD_distribute</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPDistributeDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>)</argument_list></macro></expr>;








<expr><specifier>static</specifier> <name>OMPDistributeDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPDistributeDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPTargetUpdateDirective</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;





<macro><name>OMPTargetUpdateDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTargetUpdateDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_update</argument>, <argument>StartLoc</argument>,
<argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPTargetUpdateDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTargetUpdateDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_update</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>








<specifier>static</specifier> <name>OMPTargetUpdateDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *AssociatedStmt</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPTargetUpdateDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTargetUpdateDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPDistributeParallelForDirective</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;

<expr><name>bool</name> <name>HasCancel</name> <operator>=</operator> <name>false</name></expr>;







<macro><name>OMPDistributeParallelForDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPDistributeParallelForDirectiveClass</argument>,
<argument>llvm::omp::OMPD_distribute_parallel_for</argument>, <argument>StartLoc</argument>,
<argument>EndLoc</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPDistributeParallelForDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPDistributeParallelForDirectiveClass</argument>,
<argument>llvm::omp::OMPD_distribute_parallel_for</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setTaskReductionRefExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>numLoopChildren</name><argument_list>(
<argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator></expr></argument></argument_list></call></expr></index>omp<operator>::</operator><name>OMPD_distribute_parallel_for</name></expr>)] <operator>=</operator> <name>E</name></block></expr>;
}</block>


<name>void</name> <macro><name>setHasCancel</name><argument_list>(<argument>bool Has</argument>)</argument_list></macro> <block>{ <expr><name>HasCancel</name> <operator>=</operator> <name>Has</name></expr>; }</block>

<name>public</name><operator>:</operator>













<specifier>static</specifier> <name>OMPDistributeParallelForDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>, <argument>Expr *TaskRedRef</argument>,
<argument>bool HasCancel</argument>)</argument_list></macro></expr>;








<expr><specifier>static</specifier> <name>OMPDistributeParallelForDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>,
<argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;


<expr><name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>numLoopChildren</name><argument_list>(
<argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator></expr></argument></argument_list></call></expr></index>omp<operator>::</operator><name>OMPD_distribute_parallel_for</name></expr></argument>)</argument_list></call>]</expr></return>)</block></expr>;
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPDistributeParallelForDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasCancel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasCancel</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPDistributeParallelForDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPDistributeParallelForSimdDirective</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;







<macro><name>OMPDistributeParallelForSimdDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPDistributeParallelForSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_distribute_parallel_for_simd</argument>, <argument>StartLoc</argument>,
<argument>EndLoc</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPDistributeParallelForSimdDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPDistributeParallelForSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_distribute_parallel_for_simd</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPDistributeParallelForSimdDirective</name> <operator>*</operator><macro><name>Create</name><argument_list>(
<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPDistributeParallelForSimdDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(
<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumClauses</argument>, <argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPDistributeParallelForSimdDirectiveClass</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPDistributeSimdDirective</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;







<macro><name>OMPDistributeSimdDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPDistributeSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_distribute_simd</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>,
<argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPDistributeSimdDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPDistributeSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_distribute_simd</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPDistributeSimdDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPDistributeSimdDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>,
<argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPDistributeSimdDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPTargetParallelForSimdDirective</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;







<macro><name>OMPTargetParallelForSimdDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTargetParallelForSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_parallel_for_simd</argument>, <argument>StartLoc</argument>,
<argument>EndLoc</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPTargetParallelForSimdDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTargetParallelForSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_parallel_for_simd</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPTargetParallelForSimdDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPTargetParallelForSimdDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>,
<argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTargetParallelForSimdDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPTargetSimdDirective</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;







<macro><name>OMPTargetSimdDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTargetSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_simd</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>,
<argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPTargetSimdDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTargetSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_simd</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPTargetSimdDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPTargetSimdDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>,
<argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTargetSimdDirectiveClass</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPTeamsDistributeDirective</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;







<macro><name>OMPTeamsDistributeDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTeamsDistributeDirectiveClass</argument>,
<argument>llvm::omp::OMPD_teams_distribute</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>,
<argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPTeamsDistributeDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTeamsDistributeDirectiveClass</argument>,
<argument>llvm::omp::OMPD_teams_distribute</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPTeamsDistributeDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPTeamsDistributeDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>,
<argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTeamsDistributeDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPTeamsDistributeSimdDirective</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;







<macro><name>OMPTeamsDistributeSimdDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTeamsDistributeSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_teams_distribute_simd</argument>, <argument>StartLoc</argument>,
<argument>EndLoc</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPTeamsDistributeSimdDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTeamsDistributeSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_teams_distribute_simd</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPTeamsDistributeSimdDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>)</argument_list></macro></expr>;








<expr><specifier>static</specifier> <name>OMPTeamsDistributeSimdDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>,
<argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTeamsDistributeSimdDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPTeamsDistributeParallelForSimdDirective</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;







<macro><name>OMPTeamsDistributeParallelForSimdDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTeamsDistributeParallelForSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_teams_distribute_parallel_for_simd</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPTeamsDistributeParallelForSimdDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTeamsDistributeParallelForSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_teams_distribute_parallel_for_simd</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPTeamsDistributeParallelForSimdDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPTeamsDistributeParallelForSimdDirective</name> <operator>*</operator>
<macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumClauses</argument>, <argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTeamsDistributeParallelForSimdDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPTeamsDistributeParallelForDirective</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;

<expr><name>bool</name> <name>HasCancel</name> <operator>=</operator> <name>false</name></expr>;







<macro><name>OMPTeamsDistributeParallelForDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTeamsDistributeParallelForDirectiveClass</argument>,
<argument>llvm::omp::OMPD_teams_distribute_parallel_for</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPTeamsDistributeParallelForDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTeamsDistributeParallelForDirectiveClass</argument>,
<argument>llvm::omp::OMPD_teams_distribute_parallel_for</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setTaskReductionRefExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>numLoopChildren</name><argument_list>(
<argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator></expr></argument></argument_list></call></expr></index>omp<operator>::</operator><name>OMPD_teams_distribute_parallel_for</name></expr>)] <operator>=</operator> <name>E</name></block></expr>;
}</block>


<name>void</name> <macro><name>setHasCancel</name><argument_list>(<argument>bool Has</argument>)</argument_list></macro> <block>{ <expr><name>HasCancel</name> <operator>=</operator> <name>Has</name></expr>; }</block>

<name>public</name><operator>:</operator>













<specifier>static</specifier> <name>OMPTeamsDistributeParallelForDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>, <argument>Expr *TaskRedRef</argument>,
<argument>bool HasCancel</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPTeamsDistributeParallelForDirective</name> <operator>*</operator>
<macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumClauses</argument>, <argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;


<expr><name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>numLoopChildren</name><argument_list>(
<argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator></expr></argument></argument_list></call></expr></index>omp<operator>::</operator><name>OMPD_teams_distribute_parallel_for</name></expr></argument>)</argument_list></call>]</expr></return>)</block></expr>;
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPTeamsDistributeParallelForDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasCancel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasCancel</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTeamsDistributeParallelForDirectiveClass</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPTargetTeamsDirective</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;





<macro><name>OMPTargetTeamsDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTargetTeamsDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_teams</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{
}</block>



<name>explicit</name> <call><name>OMPTargetTeamsDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPTargetTeamsDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_teams</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>








<specifier>static</specifier> <name>OMPTargetTeamsDirective</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>)</argument_list></macro></expr>;






<expr><specifier>static</specifier> <name>OMPTargetTeamsDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTargetTeamsDirectiveClass</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPTargetTeamsDistributeDirective</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;







<macro><name>OMPTargetTeamsDistributeDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTargetTeamsDistributeDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_teams_distribute</argument>, <argument>StartLoc</argument>,
<argument>EndLoc</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPTargetTeamsDistributeDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTargetTeamsDistributeDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_teams_distribute</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPTargetTeamsDistributeDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPTargetTeamsDistributeDirective</name> <operator>*</operator>
<macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumClauses</argument>, <argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTargetTeamsDistributeDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPTargetTeamsDistributeParallelForDirective</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;

<expr><name>bool</name> <name>HasCancel</name> <operator>=</operator> <name>false</name></expr>;







<macro><name>OMPTargetTeamsDistributeParallelForDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTargetTeamsDistributeParallelForDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_teams_distribute_parallel_for</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPTargetTeamsDistributeParallelForDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTargetTeamsDistributeParallelForDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_teams_distribute_parallel_for</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setTaskReductionRefExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>numLoopChildren</name><argument_list>(
<argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator></expr></argument></argument_list></call></expr></index>omp<operator>::</operator><name>OMPD_target_teams_distribute_parallel_for</name></expr>)] <operator>=</operator> <name>E</name></block></expr>;
}</block>


<name>void</name> <macro><name>setHasCancel</name><argument_list>(<argument>bool Has</argument>)</argument_list></macro> <block>{ <expr><name>HasCancel</name> <operator>=</operator> <name>Has</name></expr>; }</block>

<name>public</name><operator>:</operator>













<specifier>static</specifier> <name>OMPTargetTeamsDistributeParallelForDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>, <argument>Expr *TaskRedRef</argument>,
<argument>bool HasCancel</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPTargetTeamsDistributeParallelForDirective</name> <operator>*</operator>
<macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumClauses</argument>, <argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;


<expr><name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><call><name>numLoopChildren</name><argument_list>(
<argument><expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator></expr></argument></argument_list></call></expr></index>omp<operator>::</operator><name>OMPD_target_teams_distribute_parallel_for</name></expr></argument>)</argument_list></call>]</expr></return>)</block></expr>;
}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPTargetTeamsDistributeParallelForDirective</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>getTaskReductionRefExpr</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasCancel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasCancel</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator>
<name>OMPTargetTeamsDistributeParallelForDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPTargetTeamsDistributeParallelForSimdDirective</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;







<macro><name>OMPTargetTeamsDistributeParallelForSimdDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(
<argument>OMPTargetTeamsDistributeParallelForSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_teams_distribute_parallel_for_simd</argument>, <argument>StartLoc</argument>,
<argument>EndLoc</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPTargetTeamsDistributeParallelForSimdDirective</name><argument_list>(
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(
<argument>OMPTargetTeamsDistributeParallelForSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_teams_distribute_parallel_for_simd</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPTargetTeamsDistributeParallelForSimdDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPTargetTeamsDistributeParallelForSimdDirective</name> <operator>*</operator>
<macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumClauses</argument>, <argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator>
<name>OMPTargetTeamsDistributeParallelForSimdDirectiveClass</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPTargetTeamsDistributeSimdDirective</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPLoopDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;







<macro><name>OMPTargetTeamsDistributeSimdDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTargetTeamsDistributeSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_teams_distribute_simd</argument>, <argument>StartLoc</argument>,
<argument>EndLoc</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <expr><block>{}</block>





<name>explicit</name> <macro><name>OMPTargetTeamsDistributeSimdDirective</name><argument_list>(<argument>unsigned CollapsedNum</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopDirective</name><argument_list>(<argument>OMPTargetTeamsDistributeSimdDirectiveClass</argument>,
<argument>llvm::omp::OMPD_target_teams_distribute_simd</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>, <argument>CollapsedNum</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPTargetTeamsDistributeSimdDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned CollapsedNum</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>Stmt *AssociatedStmt</argument>, <argument>const HelperExprs &amp;Exprs</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPTargetTeamsDistributeSimdDirective</name> <operator>*</operator>
<macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumClauses</argument>, <argument>unsigned CollapsedNum</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTargetTeamsDistributeSimdDirectiveClass</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>OMPTileDirective</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPLoopBasedDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;


enum <expr><block>{
<expr><name>PreInitsOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><name>TransformedStmtOffset</name></expr>,
}</block></expr>;

<expr><name>explicit</name> <macro><name>OMPTileDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned NumLoops</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopBasedDirective</name><argument_list>(<argument>OMPTileDirectiveClass</argument>, <argument>llvm::omp::OMPD_tile</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>, <argument>NumLoops</argument>)</argument_list></macro> <block>{}</block>

<name>void</name> <macro><name>setPreInits</name><argument_list>(<argument>Stmt *PreInits</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>PreInitsOffset</name></expr>]</index> <operator>=</operator> <name>PreInits</name></expr>;
}</block>

<name>void</name> <macro><name>setTransformedStmt</name><argument_list>(<argument>Stmt *S</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>TransformedStmtOffset</name></expr>]</index> <operator>=</operator> <name>S</name></expr>;
}</block>

<name>public</name><operator>:</operator>












<specifier>static</specifier> <name>OMPTileDirective</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>,
<argument>unsigned NumLoops</argument>, <argument>Stmt *AssociatedStmt</argument>,
<argument>Stmt *TransformedStmt</argument>, <argument>Stmt *PreInits</argument>)</argument_list></macro></expr>;






<expr><specifier>static</specifier> <name>OMPTileDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumClauses</argument>,
<argument>unsigned NumLoops</argument>)</argument_list></macro></expr>;

<expr><name>unsigned</name> <macro><name>getNumAssociatedLoops</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLoopsNumber</name><argument_list>()</argument_list></call></expr>;</return> }</block>












<name>Stmt</name> <operator>*</operator><macro><name>getTransformedStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>TransformedStmtOffset</name></expr>]</index></expr>;</return>
}</block>


<name>Stmt</name> <operator>*</operator><macro><name>getPreInits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>PreInitsOffset</name></expr>]</index></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPTileDirectiveClass</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>OMPUnrollDirective</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPLoopBasedDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;


enum <expr><block>{
<expr><name>PreInitsOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><name>TransformedStmtOffset</name></expr>,
}</block></expr>;

<expr><name>explicit</name> <macro><name>OMPUnrollDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPLoopBasedDirective</name><argument_list>(<argument>OMPUnrollDirectiveClass</argument>, <argument>llvm::omp::OMPD_unroll</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>, <argument><literal type="number">1</literal></argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setPreInits</name><argument_list>(<argument>Stmt *PreInits</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>PreInitsOffset</name></expr>]</index> <operator>=</operator> <name>PreInits</name></expr>;
}</block>


<name>void</name> <macro><name>setTransformedStmt</name><argument_list>(<argument>Stmt *S</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>TransformedStmtOffset</name></expr>]</index> <operator>=</operator> <name>S</name></expr>;
}</block>

<name>public</name><operator>:</operator>










<specifier>static</specifier> <name>OMPUnrollDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *AssociatedStmt</argument>,
<argument>Stmt *TransformedStmt</argument>, <argument>Stmt *PreInits</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPUnrollDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>)</argument_list></macro></expr>;








<expr><name>Stmt</name> <operator>*</operator><macro><name>getTransformedStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>TransformedStmtOffset</name></expr>]</index></expr>;</return>
}</block>


<name>Stmt</name> <operator>*</operator><macro><name>getPreInits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Data</name><operator>-&gt;</operator><name>getChildren</name></name><argument_list>()</argument_list></call><index>[<expr><name>PreInitsOffset</name></expr>]</index></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPUnrollDirectiveClass</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPScanDirective</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;





<macro><name>OMPScanDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPScanDirectiveClass</argument>, <argument>llvm::omp::OMPD_scan</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPScanDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPScanDirectiveClass</argument>, <argument>llvm::omp::OMPD_scan</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>








<specifier>static</specifier> <name>OMPScanDirective</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPScanDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumClauses</argument>,
<argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPScanDirectiveClass</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPInteropDirective</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;






<macro><name>OMPInteropDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPInteropDirectiveClass</argument>,
<argument>llvm::omp::OMPD_interop</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPInteropDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPInteropDirectiveClass</argument>,
<argument>llvm::omp::OMPD_interop</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>







<specifier>static</specifier> <name>OMPInteropDirective</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPInteropDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPInteropDirectiveClass</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPDispatchDirective</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;


<expr><name>SourceLocation</name> <name>TargetCallLoc</name></expr>;


<expr><name>void</name> <macro><name>setTargetCallLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>TargetCallLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>






<macro><name>OMPDispatchDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPDispatchDirectiveClass</argument>,
<argument>llvm::omp::OMPD_dispatch</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <block>{}</block>



<name>explicit</name> <call><name>OMPDispatchDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPDispatchDirectiveClass</argument>,
<argument>llvm::omp::OMPD_dispatch</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>









<specifier>static</specifier> <name>OMPDispatchDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *AssociatedStmt</argument>,
<argument>SourceLocation TargetCallLoc</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPDispatchDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;


<expr><name>SourceLocation</name> <macro><name>getTargetCallLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TargetCallLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPDispatchDirectiveClass</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPMaskedDirective</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPExecutableDirective</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;






<macro><name>OMPMaskedDirective</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPMaskedDirectiveClass</argument>, <argument>llvm::omp::OMPD_masked</argument>,
<argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPMaskedDirective</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPExecutableDirective</name><argument_list>(<argument>OMPMaskedDirectiveClass</argument>, <argument>llvm::omp::OMPD_masked</argument>,
<argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>







<specifier>static</specifier> <name>OMPMaskedDirective</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *AssociatedStmt</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPMaskedDirective</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>unsigned NumClauses</argument>, <argument>EmptyShell</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPMaskedDirectiveClass</name></expr>;</return>
}</block>
}</expr>;

}</block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></range></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
