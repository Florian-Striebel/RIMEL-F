<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_RECURSIVEASTVISITOR_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_RECURSIVEASTVISITOR_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Attr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclarationName.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclBase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclFriend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclOpenMP.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclTemplate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprConcepts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprOpenMP.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/LambdaCapture.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/NestedNameSpecifier.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/OpenMPClause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Stmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtOpenMP.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TemplateBase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TemplateName.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeLoc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenMPKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Specifiers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerIntPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;algorithm&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;type_traits&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRY_TO</name><parameter_list>(<parameter><type><name>CALL_EXPR</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (!getDerived().CALL_EXPR) return false; } while (false)</cpp:value></cpp:define>





<decl_stmt><decl><type><name>namespace</name></type> <name>detail</name> <block>{<block_content>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
struct</type> <name>has_same_member_pointer_type</name> <range>: <expr><name>std</name><operator>::</operator><name>false_type</name> <block>{}</block></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>U</name></expr></argument>, <argument><expr><name>typename</name> <name>R</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>P</name></expr></argument>&gt;</argument_list></name>
struct</type> <name><name>has_same_member_pointer_type</name><argument_list type="generic">&lt;<argument><expr><name>R</name> <operator>(</operator><name>T</name><operator>::</operator><operator>*</operator><operator>)</operator><operator>(</operator><name>P</name><operator>...</operator><operator>)</operator></expr></argument>, <argument><expr><name>R</name> <operator>(</operator><name>U</name><operator>::</operator><operator>*</operator><operator>)</operator><operator>(</operator><name>P</name><operator>...</operator><operator>)</operator></expr></argument>&gt;</argument_list></name>
<range>: <expr><name>std</name><operator>::</operator><name>true_type</name> <block>{}</block></expr></range></decl>;</decl_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>bool</name> <name>has_same_type</name><operator>&gt;</operator> struct <name>is_same_method_impl</name> <block>{
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>FirstMethodPtrTy</name></expr></argument>, <argument><expr><name>typename</name> <name>SecondMethodPtrTy</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>bool</name> <macro><name>isSameMethod</name><argument_list>(<argument>FirstMethodPtrTy FirstMethodPtr</argument>,
<argument>SecondMethodPtrTy SecondMethodPtr</argument>)</argument_list></macro> <block>{
<return>return <expr><name>false</name></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>is_same_method_impl</name><argument_list type="generic">&lt;<argument><expr><name>true</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>FirstMethodPtrTy</name></expr></argument>, <argument><expr><name>typename</name> <name>SecondMethodPtrTy</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>bool</name> <macro><name>isSameMethod</name><argument_list>(<argument>FirstMethodPtrTy FirstMethodPtr</argument>,
<argument>SecondMethodPtrTy SecondMethodPtr</argument>)</argument_list></macro> <block>{
<return>return <expr><name>FirstMethodPtr</name> <operator>==</operator> <name>SecondMethodPtr</name></expr>;</return>
}</block>
}</expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>FirstMethodPtrTy</name></expr></argument>, <argument><expr><name>typename</name> <name>SecondMethodPtrTy</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>isSameMethod</name><argument_list>(<argument>FirstMethodPtrTy FirstMethodPtr</argument>,
<argument>SecondMethodPtrTy SecondMethodPtr</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>is_same_method_impl</name><argument_list type="generic">&lt;<argument><expr><name><name>has_same_member_pointer_type</name><argument_list type="generic">&lt;
<argument><expr><name>FirstMethodPtrTy</name></expr></argument>,
<argument><expr><name>SecondMethodPtrTy</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>isSameMethod</name><argument_list>(<argument><expr><name>FirstMethodPtr</name></expr></argument>, <argument><expr><name>SecondMethodPtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

}


































































<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>RecursiveASTVisitor</name> <block>{
<expr><name>public</name><operator>:</operator></expr>





<typedef>typedef <type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type>
<name>DataRecursionQueue</name>;</typedef>


<name>Derived</name> <operator>&amp;</operator><macro><name>getDerived</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><operator>*</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return> }</block></block>



<name>bool</name> <macro><name>shouldVisitTemplateInstantiations</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>



<name>bool</name> <macro><name>shouldWalkTypesOfTypeLocs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>



<name>bool</name> <macro><name>shouldVisitImplicitCode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>


<name>bool</name> <macro><name>shouldVisitLambdaBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>


<name>bool</name> <macro><name>shouldTraversePostOrder</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>



<name>bool</name> <macro><name>TraverseAST</name><argument_list>(<argument>ASTContext &amp;AST</argument>)</argument_list></macro> <block>{


<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TraverseDecl</name><argument_list>(<argument><expr><call><name><name>AST</name><operator>.</operator><name>getTranslationUnitDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>






<name>bool</name> <call><name>TraverseStmt</name><argument_list>(<argument><expr><name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>DataRecursionQueue</name> <operator>*</operator><name>Queue</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;




<expr><name>bool</name> <macro><name>dataTraverseStmtPre</name><argument_list>(<argument>Stmt *S</argument>)</argument_list></macro> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>






<name>bool</name> <macro><name>dataTraverseStmtPost</name><argument_list>(<argument>Stmt *S</argument>)</argument_list></macro> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>






<name>bool</name> <macro><name>TraverseType</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro></expr>;






<expr><name>bool</name> <macro><name>TraverseTypeLoc</name><argument_list>(<argument>TypeLoc TL</argument>)</argument_list></macro></expr>;






<expr><name>bool</name> <call><name>TraverseAttr</name><argument_list>(<argument><expr><name>Attr</name> <operator>*</operator><name>At</name></expr></argument>)</argument_list></call></expr>;






<expr><name>bool</name> <call><name>TraverseDecl</name><argument_list>(<argument><expr><name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;




<expr><name>bool</name> <call><name>TraverseNestedNameSpecifier</name><argument_list>(<argument><expr><name>NestedNameSpecifier</name> <operator>*</operator><name>NNS</name></expr></argument>)</argument_list></call></expr>;





<expr><name>bool</name> <macro><name>TraverseNestedNameSpecifierLoc</name><argument_list>(<argument>NestedNameSpecifierLoc NNS</argument>)</argument_list></macro></expr>;




<expr><name>bool</name> <macro><name>TraverseDeclarationNameInfo</name><argument_list>(<argument>DeclarationNameInfo NameInfo</argument>)</argument_list></macro></expr>;





<expr><name>bool</name> <macro><name>TraverseTemplateName</name><argument_list>(<argument>TemplateName Template</argument>)</argument_list></macro></expr>;






<expr><name>bool</name> <call><name>TraverseTemplateArgument</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TemplateArgument</name> <operator>&amp;</operator><name>Arg</name></expr></argument>)</argument_list></call></expr>;





<expr><name>bool</name> <call><name>TraverseTemplateArgumentLoc</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TemplateArgumentLoc</name> <operator>&amp;</operator><name>ArgLoc</name></expr></argument>)</argument_list></call></expr>;







<expr><name>bool</name> <macro><name>TraverseTemplateArguments</name><argument_list>(<argument>const TemplateArgument *Args</argument>,
<argument>unsigned NumArgs</argument>)</argument_list></macro></expr>;





<expr><name>bool</name> <call><name>TraverseCXXBaseSpecifier</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXBaseSpecifier</name> <operator>&amp;</operator><name>Base</name></expr></argument>)</argument_list></call></expr>;







<expr><name>bool</name> <call><name>TraverseConstructorInitializer</name><argument_list>(<argument><expr><name>CXXCtorInitializer</name> <operator>*</operator><name>Init</name></expr></argument>)</argument_list></call></expr>;





<expr><name>bool</name> <call><name>TraverseLambdaCapture</name><argument_list>(<argument><expr><name>LambdaExpr</name> <operator>*</operator><name>LE</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LambdaCapture</name> <operator>*</operator><name>C</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>Init</name></expr></argument>)</argument_list></call></expr>;





<expr><name>bool</name> <call><name>TraverseSynOrSemInitListExpr</name><argument_list>(<argument><expr><name>InitListExpr</name> <operator>*</operator><name>S</name></expr></argument>,
<argument><expr><name>DataRecursionQueue</name> <operator>*</operator><name>Queue</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;




<expr><name>bool</name> <call><name>TraverseConceptReference</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ConceptReference</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list></call></expr>;




<expr><name>bool</name> <macro><name>VisitAttr</name><argument_list>(<argument>Attr *A</argument>)</argument_list></macro> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATTR_VISITOR_DECLS_ONLY</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/AttrVisitor.inc"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ATTR_VISITOR_DECLS_ONLY</name></cpp:undef>



<name>Stmt</name><operator>::</operator><name>child_range</name> <macro><name>getStmtChildren</name><argument_list>(<argument>Stmt *S</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>S</name><operator>-&gt;</operator><name>children</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>private</name><operator>:</operator>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRAVERSE_STMT_BASE</name><parameter_list>(<parameter><type><name>NAME</name></type></parameter>, <parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>VAR</name></type></parameter>, <parameter><type><name>QUEUE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(::clang::detail::has_same_member_pointer_type&lt; decltype(&amp;RecursiveASTVisitor::Traverse##NAME), decltype(&amp;Derived::Traverse##NAME)&gt;::value ? static_cast&lt;std::conditional_t&lt; ::clang::detail::has_same_member_pointer_type&lt; decltype(&amp;RecursiveASTVisitor::Traverse##NAME), decltype(&amp;Derived::Traverse##NAME)&gt;::value, Derived &amp;, RecursiveASTVisitor &amp;&gt;&gt;(*this) .Traverse##NAME(static_cast&lt;CLASS *&gt;(VAR), QUEUE) : getDerived().Traverse##NAME(static_cast&lt;CLASS *&gt;(VAR)))</cpp:value></cpp:define>














<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRY_TO_TRAVERSE_OR_ENQUEUE_STMT</name><parameter_list>(<parameter><type><name>S</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (!TRAVERSE_STMT_BASE(Stmt, Stmt, S, Queue)) return false; } while (false)</cpp:value></cpp:define>





<name>public</name><operator>:</operator>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_STMT</name><parameter_list>(<parameter><type><name>STMT</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STMT</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>PARENT</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bool Traverse##CLASS(CLASS *S, DataRecursionQueue *Queue = nullptr);</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtNodes.inc"</cpp:file></cpp:include>



<name>bool</name> <macro><name>WalkUpFromStmt</name><argument_list>(<argument>Stmt *S</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>VisitStmt</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>VisitStmt</name><argument_list>(<argument>Stmt *S</argument>)</argument_list></macro> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STMT</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>PARENT</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bool WalkUpFrom##CLASS(CLASS *S) { TRY_TO(WalkUpFrom##PARENT(S)); TRY_TO(Visit##CLASS(S)); return true; } bool Visit##CLASS(CLASS *S) { return true; }</cpp:value></cpp:define>






<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtNodes.inc"</cpp:file></cpp:include>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_TYPE</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>BASE</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPE</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>BASE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bool Traverse##CLASS##Type(CLASS##Type *T);</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeNodes.inc"</cpp:file></cpp:include>



<name>bool</name> <macro><name>WalkUpFromType</name><argument_list>(<argument>Type *T</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>VisitType</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>VisitType</name><argument_list>(<argument>Type *T</argument>)</argument_list></macro> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPE</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>BASE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bool WalkUpFrom##CLASS##Type(CLASS##Type *T) { TRY_TO(WalkUpFrom##BASE(T)); TRY_TO(Visit##CLASS##Type(T)); return true; } bool Visit##CLASS##Type(CLASS##Type *T) { return true; }</cpp:value></cpp:define>






<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeNodes.inc"</cpp:file></cpp:include>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_TYPELOC</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>BASE</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPELOC</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>BASE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bool Traverse##CLASS##TypeLoc(CLASS##TypeLoc TL);</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeLocNodes.def"</cpp:file></cpp:include>



<name>bool</name> <macro><name>WalkUpFromTypeLoc</name><argument_list>(<argument>TypeLoc TL</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>VisitTypeLoc</name><argument_list>(<argument><expr><name>TL</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>VisitTypeLoc</name><argument_list>(<argument>TypeLoc TL</argument>)</argument_list></macro> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>



<name>bool</name> <macro><name>WalkUpFromQualifiedTypeLoc</name><argument_list>(<argument>QualifiedTypeLoc TL</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>VisitUnqualTypeLoc</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getUnqualifiedLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>bool</name> <macro><name>VisitQualifiedTypeLoc</name><argument_list>(<argument>QualifiedTypeLoc TL</argument>)</argument_list></macro> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<name>bool</name> <macro><name>WalkUpFromUnqualTypeLoc</name><argument_list>(<argument>UnqualTypeLoc TL</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>VisitUnqualTypeLoc</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getUnqualifiedLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>bool</name> <macro><name>VisitUnqualTypeLoc</name><argument_list>(<argument>UnqualTypeLoc TL</argument>)</argument_list></macro> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPE</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>BASE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bool WalkUpFrom##CLASS##TypeLoc(CLASS##TypeLoc TL) { TRY_TO(WalkUpFrom##BASE##Loc(TL)); TRY_TO(Visit##CLASS##TypeLoc(TL)); return true; } bool Visit##CLASS##TypeLoc(CLASS##TypeLoc TL) { return true; }</cpp:value></cpp:define>






<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeNodes.inc"</cpp:file></cpp:include>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_DECL</name><parameter_list>(<parameter><type><name>DECL</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECL</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>BASE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bool Traverse##CLASS##Decl(CLASS##Decl *D);</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclNodes.inc"</cpp:file></cpp:include>



<name>bool</name> <macro><name>WalkUpFromDecl</name><argument_list>(<argument>Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>VisitDecl</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>VisitDecl</name><argument_list>(<argument>Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECL</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>BASE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bool WalkUpFrom##CLASS##Decl(CLASS##Decl *D) { TRY_TO(WalkUpFrom##BASE(D)); TRY_TO(Visit##CLASS##Decl(D)); return true; } bool Visit##CLASS##Decl(CLASS##Decl *D) { return true; }</cpp:value></cpp:define>






<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclNodes.inc"</cpp:file></cpp:include>

<name>bool</name> <call><name>canIgnoreChildDeclWhileTraversingDeclContext</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>Child</name></expr></argument>)</argument_list></call></expr>;

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_TRAVERSE_TMPL_INST</name><parameter_list>(<parameter><type><name>TMPLDECLKIND</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bool TraverseTemplateInstantiations(TMPLDECLKIND##TemplateDecl *D);</cpp:value></cpp:define>

<macro><name>DEF_TRAVERSE_TMPL_INST</name><argument_list>(<argument>Class</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_TMPL_INST</name><argument_list>(<argument>Var</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_TMPL_INST</name><argument_list>(<argument>Function</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DEF_TRAVERSE_TMPL_INST</name></cpp:undef>

<expr><name>bool</name> <call><name>dataTraverseNode</name><argument_list>(<argument><expr><name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>DataRecursionQueue</name> <operator>*</operator><name>Queue</name></expr></argument>)</argument_list></call></expr>;

<expr><name>private</name><operator>:</operator>

<name>bool</name> <call><name>TraverseTemplateParameterListHelper</name><argument_list>(<argument><expr><name>TemplateParameterList</name> <operator>*</operator><name>TPL</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <call><name>TraverseDeclTemplateParameterLists</name><argument_list>(<argument><expr><name>T</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;

<expr><name>bool</name> <call><name>TraverseTemplateTypeParamDeclConstraints</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TemplateTypeParmDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;

<expr><name>bool</name> <macro><name>TraverseTemplateArgumentLocsHelper</name><argument_list>(<argument>const TemplateArgumentLoc *TAL</argument>,
<argument>unsigned Count</argument>)</argument_list></macro></expr>;
<expr><name>bool</name> <macro><name>TraverseArrayTypeLocHelper</name><argument_list>(<argument>ArrayTypeLoc TL</argument>)</argument_list></macro></expr>;
<expr><name>bool</name> <call><name>TraverseRecordHelper</name><argument_list>(<argument><expr><name>RecordDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><name>bool</name> <call><name>TraverseCXXRecordHelper</name><argument_list>(<argument><expr><name>CXXRecordDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><name>bool</name> <call><name>TraverseDeclaratorHelper</name><argument_list>(<argument><expr><name>DeclaratorDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><name>bool</name> <call><name>TraverseDeclContextHelper</name><argument_list>(<argument><expr><name>DeclContext</name> <operator>*</operator><name>DC</name></expr></argument>)</argument_list></call></expr>;
<expr><name>bool</name> <call><name>TraverseFunctionHelper</name><argument_list>(<argument><expr><name>FunctionDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><name>bool</name> <call><name>TraverseVarHelper</name><argument_list>(<argument><expr><name>VarDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><name>bool</name> <call><name>TraverseOMPExecutableDirective</name><argument_list>(<argument><expr><name>OMPExecutableDirective</name> <operator>*</operator><name>S</name></expr></argument>)</argument_list></call></expr>;
<expr><name>bool</name> <call><name>TraverseOMPLoopDirective</name><argument_list>(<argument><expr><name>OMPLoopDirective</name> <operator>*</operator><name>S</name></expr></argument>)</argument_list></call></expr>;
<expr><name>bool</name> <call><name>TraverseOMPClause</name><argument_list>(<argument><expr><name>OMPClause</name> <operator>*</operator><name>C</name></expr></argument>)</argument_list></call></expr>;
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_CLANG_CLAUSE_CLASS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLAUSE_CLASS</name><parameter_list>(<parameter><type><name>Enum</name></type></parameter>, <parameter><type><name>Str</name></type></parameter>, <parameter><type><name>Class</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bool Visit##Class(Class *C);</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Frontend/OpenMP/OMP.inc"</cpp:file></cpp:include>

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>bool</name> <call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>T</name> <operator>*</operator><name>Node</name></expr></argument>)</argument_list></call></expr>;

<expr><name>bool</name> <call><name>VisitOMPClauseWithPreInit</name><argument_list>(<argument><expr><name>OMPClauseWithPreInit</name> <operator>*</operator><name>Node</name></expr></argument>)</argument_list></call></expr>;
<expr><name>bool</name> <call><name>VisitOMPClauseWithPostUpdate</name><argument_list>(<argument><expr><name>OMPClauseWithPostUpdate</name> <operator>*</operator><name>Node</name></expr></argument>)</argument_list></call></expr>;

<expr><name>bool</name> <call><name>PostVisitStmt</name><argument_list>(<argument><expr><name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>dataTraverseNode</name><argument_list>(<argument>Stmt *S</argument>,
<argument>DataRecursionQueue *Queue</argument>)</argument_list></macro> <block>{

<switch>switch <condition>(<expr><call><name><name>S</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Stmt</name><operator>::</operator><name>NoStmtClass</name></expr>:</case>
<break>break;</break>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_STMT</name><parameter_list>(<parameter><type><name>STMT</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STMT</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>PARENT</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case Stmt::CLASS##Class: return TRAVERSE_STMT_BASE(CLASS, CLASS, S, Queue);</cpp:value></cpp:define>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtNodes.inc"</cpp:file></cpp:include>
<expr_stmt/>}</block_content>

return true</block><empty_stmt>;</empty_stmt></switch>
}</block>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DISPATCH_STMT</name></cpp:undef>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>PostVisitStmt</name><argument_list>(<argument>Stmt *S</argument>)</argument_list></macro> <block>{
















<switch>switch <condition>(<expr><call><name><name>S</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Stmt</name><operator>::</operator><name>NoStmtClass</name></expr>:</case>
<break>break;</break>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_STMT</name><parameter_list>(<parameter><type><name>STMT</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STMT</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>PARENT</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case Stmt::CLASS##Class: if (::clang::detail::isSameMethod(&amp;RecursiveASTVisitor::Traverse##CLASS, &amp;Derived::Traverse##CLASS)) { TRY_TO(WalkUpFrom##CLASS(static_cast&lt;CLASS *&gt;(S))); } break;</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITLISTEXPR</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>PARENT</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case Stmt::CLASS##Class: if (::clang::detail::isSameMethod(&amp;RecursiveASTVisitor::Traverse##CLASS, &amp;Derived::Traverse##CLASS)) { auto ILE = static_cast&lt;CLASS *&gt;(S); if (auto Syn = ILE-&gt;isSemanticForm() ? ILE-&gt;getSyntacticForm() : ILE) TRY_TO(WalkUpFrom##CLASS(Syn)); if (auto Sem = ILE-&gt;isSemanticForm() ? ILE : ILE-&gt;getSemanticForm()) TRY_TO(WalkUpFrom##CLASS(Sem)); } break;</cpp:value></cpp:define>










<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtNodes.inc"</cpp:file></cpp:include>
<expr_stmt/>}</block_content>

return true</block><empty_stmt>;</empty_stmt></switch>
}</block>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DISPATCH_STMT</name></cpp:undef>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseStmt</name><argument_list>(<argument>Stmt *S</argument>,
<argument>DataRecursionQueue *Queue</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>S</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr>

<if_stmt><if>if <condition>(<expr><name>Queue</name></expr>)</condition> <block>{<block_content>
<macro><name>Queue</name></macro><expr_stmt><expr><operator>-&gt;</operator><macro><name>push_back</name><argument_list>(<argument>{S</argument>, <argument>false}</argument>)</argument_list></macro></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
<expr_stmt/>}</block_content>

SmallVector&lt;llvm::PointerIntPair&lt;Stmt *</block><operator>,</operator> <expr_stmt><expr><literal type="number">1</literal></expr><operator>,</operator> <expr><name>bool</name><operator>&gt;</operator></expr><operator>,</operator> <expr><literal type="number">8</literal><operator>&gt;</operator> <name>LocalQueue</name></expr>;</expr_stmt></if></if_stmt>
<macro><name>LocalQueue</name></macro><operator>.</operator><macro><name>push_back</name><argument_list>(<argument>{S</argument>, <argument>false}</argument>)</argument_list></macro></block></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name><name>LocalQueue</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>auto</name> <operator>&amp;</operator><name>CurrSAndVisited</name> <operator>=</operator> <call><name><name>LocalQueue</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>CurrS</name> <init>= <expr><call><name><name>CurrSAndVisited</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Visited</name> <init>= <expr><call><name><name>CurrSAndVisited</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>Visited</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>LocalQueue</name><operator>.</operator><name>pop_back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>dataTraverseStmtPost</name><argument_list>(<argument><expr><name>CurrS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>shouldTraversePostOrder</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>PostVisitStmt</name><argument_list>(<argument><expr><name>CurrS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>dataTraverseStmtPre</name><argument_list>(<argument><expr><name>CurrS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>CurrSAndVisited</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>N</name> <init>= <expr><call><name><name>LocalQueue</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>dataTraverseNode</name><argument_list>(<argument><expr><name>CurrS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>LocalQueue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><call><name>reverse</name><argument_list>(<argument><expr><call><name><name>LocalQueue</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>N</name></expr></argument>, <argument><expr><call><name><name>LocalQueue</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name><name>LocalQueue</name><operator>.</operator><name>pop_back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseType</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>T</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<switch>switch <condition>(<expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeClass</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_TYPE</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>BASE</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPE</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>BASE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case Type::CLASS: return getDerived().Traverse##CLASS##Type( static_cast&lt;CLASS##Type *&gt;(const_cast&lt;Type *&gt;(T.getTypePtr())));</cpp:value></cpp:define>



<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeNodes.inc"</cpp:file></cpp:include>
</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseTypeLoc</name><argument_list>(<argument>TypeLoc TL</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>TL</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<switch>switch <condition>(<expr><call><name><name>TL</name><operator>.</operator><name>getTypeLocClass</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_TYPELOC</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>BASE</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPELOC</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>BASE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case TypeLoc::CLASS: return getDerived().Traverse##CLASS##TypeLoc(TL.castAs&lt;CLASS##TypeLoc&gt;());</cpp:value></cpp:define>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeLocNodes.def"</cpp:file></cpp:include>
</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>
}


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VISITORCLASS</name></cpp:macro> <cpp:value>RecursiveASTVisitor</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/AttrVisitor.inc"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>VISITORCLASS</name></cpp:undef>

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseDecl</name><argument_list>(<argument>Decl *D</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>D</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>shouldVisitImplicitCode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>D</name><operator>-&gt;</operator><name>isImplicit</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>TTPD</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>TemplateTypeParmDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>TraverseTemplateTypeParamDeclConstraints</name><argument_list>(<argument><expr><name>TTPD</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_DECL</name><parameter_list>(<parameter><type><name>DECL</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECL</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>BASE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case Decl::CLASS: if (!getDerived().Traverse##CLASS##Decl(static_cast&lt;CLASS##Decl *&gt;(D))) return false; break;</cpp:value></cpp:define>




<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclNodes.inc"</cpp:file></cpp:include>
</block_content>}</block></switch>
<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseNestedNameSpecifier</name><argument_list>(
<argument>NestedNameSpecifier *NNS</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NNS</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>NNS</name><operator>-&gt;</operator><name>getPrefix</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseNestedNameSpecifier</name><argument_list>(<argument><expr><call><name><name>NNS</name><operator>-&gt;</operator><name>getPrefix</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><call><name><name>NNS</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>Identifier</name></expr>:</case>
<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>Namespace</name></expr>:</case>
<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>NamespaceAlias</name></expr>:</case>
<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>Global</name></expr>:</case>
<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>Super</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>

<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>TypeSpec</name></expr>:</case>
<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>TypeSpecWithTemplate</name></expr>:</case>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseType</name><argument_list>(<argument><expr><call><name>QualType</name><argument_list>(<argument><expr><call><name><name>NNS</name><operator>-&gt;</operator><name>getAsType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseNestedNameSpecifierLoc</name><argument_list>(
<argument>NestedNameSpecifierLoc NNS</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NNS</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<decl><type><name>NestedNameSpecifierLoc</name></type> <name>Prefix</name> <init>= <expr><call><name><name>NNS</name><operator>.</operator><name>getPrefix</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseNestedNameSpecifierLoc</name><argument_list>(<argument><expr><name>Prefix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><call><name><name>NNS</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getKind</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>Identifier</name></expr>:</case>
<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>Namespace</name></expr>:</case>
<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>NamespaceAlias</name></expr>:</case>
<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>Global</name></expr>:</case>
<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>Super</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>

<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>TypeSpec</name></expr>:</case>
<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>TypeSpecWithTemplate</name></expr>:</case>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseTypeLoc</name><argument_list>(<argument><expr><call><name><name>NNS</name><operator>.</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseDeclarationNameInfo</name><argument_list>(
<argument>DeclarationNameInfo NameInfo</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getNameKind</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DeclarationName</name><operator>::</operator><name>CXXConstructorName</name></expr>:</case>
<case>case <expr><name>DeclarationName</name><operator>::</operator><name>CXXDestructorName</name></expr>:</case>
<case>case <expr><name>DeclarationName</name><operator>::</operator><name>CXXConversionFunctionName</name></expr>:</case>
<if_stmt><if>if <condition>(<decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSInfo</name> <init>= <expr><call><name><name>NameInfo</name><operator>.</operator><name>getNamedTypeInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseTypeLoc</name><argument_list>(<argument><expr><call><name><name>TSInfo</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>DeclarationName</name><operator>::</operator><name>CXXDeductionGuideName</name></expr>:</case>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseTemplateName</name><argument_list>(
<argument><expr><call><name>TemplateName</name><argument_list>(<argument><expr><call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCXXDeductionGuideTemplate</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DeclarationName</name><operator>::</operator><name>Identifier</name></expr>:</case>
<case>case <expr><name>DeclarationName</name><operator>::</operator><name>ObjCZeroArgSelector</name></expr>:</case>
<case>case <expr><name>DeclarationName</name><operator>::</operator><name>ObjCOneArgSelector</name></expr>:</case>
<case>case <expr><name>DeclarationName</name><operator>::</operator><name>ObjCMultiArgSelector</name></expr>:</case>
<case>case <expr><name>DeclarationName</name><operator>::</operator><name>CXXOperatorName</name></expr>:</case>
<case>case <expr><name>DeclarationName</name><operator>::</operator><name>CXXLiteralOperatorName</name></expr>:</case>
<case>case <expr><name>DeclarationName</name><operator>::</operator><name>CXXUsingDirective</name></expr>:</case>
<break>break;</break>
<expr_stmt/></block_content></block></switch>}</block></expr></expr_stmt>

<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseTemplateName</name><argument_list>(<argument>TemplateName Template</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<decl><type><name>DependentTemplateName</name> <modifier>*</modifier></type><name>DTN</name> <init>= <expr><call><name><name>Template</name><operator>.</operator><name>getAsDependentTemplateName</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseNestedNameSpecifier</name><argument_list>(<argument><expr><call><name><name>DTN</name><operator>-&gt;</operator><name>getQualifier</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<decl><type><name>QualifiedTemplateName</name> <modifier>*</modifier></type><name>QTN</name> <init>= <expr><call><name><name>Template</name><operator>.</operator><name>getAsQualifiedTemplateName</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseNestedNameSpecifier</name><argument_list>(<argument><expr><call><name><name>QTN</name><operator>-&gt;</operator><name>getQualifier</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseTemplateArgument</name><argument_list>(
<argument>const TemplateArgument &amp;Arg</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><call><name><name>Arg</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Null</name></expr>:</case>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Declaration</name></expr>:</case>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Integral</name></expr>:</case>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>NullPtr</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>

<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Type</name></expr>:</case>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TraverseType</name><argument_list>(<argument><expr><call><name><name>Arg</name><operator>.</operator><name>getAsType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Template</name></expr>:</case>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>TemplateExpansion</name></expr>:</case>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TraverseTemplateName</name><argument_list>(
<argument><expr><call><name><name>Arg</name><operator>.</operator><name>getAsTemplateOrTemplatePattern</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Expression</name></expr>:</case>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>Arg</name><operator>.</operator><name>getAsExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Pack</name></expr>:</case>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TraverseTemplateArguments</name><argument_list>(<argument><expr><call><name><name>Arg</name><operator>.</operator><name>pack_begin</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Arg</name><operator>.</operator><name>pack_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></switch>}</block></expr></expr_stmt>

<return>return <expr><name>true</name></expr>;</return>
}



template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseTemplateArgumentLoc</name><argument_list>(
<argument>const TemplateArgumentLoc &amp;ArgLoc</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>TemplateArgument</name> <operator>&amp;</operator><name>Arg</name> <operator>=</operator> <call><name><name>ArgLoc</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call></expr>;

<switch>switch <condition>(<expr><call><name><name>Arg</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Null</name></expr>:</case>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Declaration</name></expr>:</case>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Integral</name></expr>:</case>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>NullPtr</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>

<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Type</name></expr>:</case> <block>{<block_content>

<if_stmt><if>if <condition>(<decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSI</name> <init>= <expr><call><name><name>ArgLoc</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TraverseTypeLoc</name><argument_list>(<argument><expr><call><name><name>TSI</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TraverseType</name><argument_list>(<argument><expr><call><name><name>Arg</name><operator>.</operator><name>getAsType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
<expr_stmt/></block_content></block></block_content></block></switch>}</block></expr></expr_stmt>

<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Template</name></expr>:</case>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>TemplateExpansion</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name><name>ArgLoc</name><operator>.</operator><name>getTemplateQualifierLoc</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TraverseNestedNameSpecifierLoc</name><argument_list>(
<argument><expr><call><name><name>ArgLoc</name><operator>.</operator><name>getTemplateQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TraverseTemplateName</name><argument_list>(
<argument><expr><call><name><name>Arg</name><operator>.</operator><name>getAsTemplateOrTemplatePattern</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Expression</name></expr>:</case>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>ArgLoc</name><operator>.</operator><name>getSourceExpression</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Pack</name></expr>:</case>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TraverseTemplateArguments</name><argument_list>(<argument><expr><call><name><name>Arg</name><operator>.</operator><name>pack_begin</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Arg</name><operator>.</operator><name>pack_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

return <expr_stmt><expr><name>true</name></expr>;</expr_stmt>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseTemplateArguments</name><argument_list>(
<argument>const TemplateArgument *Args</argument>, <argument>unsigned NumArgs</argument>)</argument_list></macro> <block>{
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>NumArgs</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseTemplateArgument</name><argument_list>(<argument><expr><name><name>Args</name><index>[<expr><name>I</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>

<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseConstructorInitializer</name><argument_list>(
<argument>CXXCtorInitializer *Init</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name> <init>= <expr><call><name><name>Init</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseTypeLoc</name><argument_list>(<argument><expr><call><name><name>TInfo</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Init</name><operator>-&gt;</operator><name>isWritten</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>shouldVisitImplicitCode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>Init</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name>
<name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseLambdaCapture</name><argument_list>(<argument>LambdaExpr *LE</argument>,
<argument>const LambdaCapture *C</argument>,
<argument>Expr *Init</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>LE</name><operator>-&gt;</operator><name>isInitCapture</name></name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseDecl</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCapturedVar</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
}




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_TRAVERSE_TYPE</name><parameter_list>(<parameter><type><name>TYPE</name></type></parameter>, <parameter><type><name>CODE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>template &lt;typename Derived&gt; bool RecursiveASTVisitor&lt;Derived&gt;::Traverse##TYPE(TYPE *T) { if (!getDerived().shouldTraversePostOrder()) TRY_TO(WalkUpFrom##TYPE(T)); { CODE; } if (getDerived().shouldTraversePostOrder()) TRY_TO(WalkUpFrom##TYPE(T)); return true; }</cpp:value></cpp:define>










DEF_TRAVERSE_TYPE<expr_stmt><expr><operator>(</operator><name>BuiltinType</name><operator>,</operator> <block>{}</block><operator>)</operator>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>ComplexType</argument>, <argument>{ TRY_TO(TraverseType(T-&gt;getElementType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>PointerType</argument>, <argument>{ TRY_TO(TraverseType(T-&gt;getPointeeType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>BlockPointerType</argument>,
<argument>{ TRY_TO(TraverseType(T-&gt;getPointeeType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>LValueReferenceType</argument>,
<argument>{ TRY_TO(TraverseType(T-&gt;getPointeeType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>RValueReferenceType</argument>,
<argument>{ TRY_TO(TraverseType(T-&gt;getPointeeType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>MemberPointerType</argument>, <argument>{
TRY_TO(TraverseType(QualType(T-&gt;getClass(), <literal type="number">0</literal>)));
TRY_TO(TraverseType(T-&gt;getPointeeType()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>AdjustedType</argument>, <argument>{ TRY_TO(TraverseType(T-&gt;getOriginalType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>DecayedType</argument>, <argument>{ TRY_TO(TraverseType(T-&gt;getOriginalType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>ConstantArrayType</argument>, <argument>{
TRY_TO(TraverseType(T-&gt;getElementType()));
if (T-&gt;getSizeExpr())
TRY_TO(TraverseStmt(const_cast&lt;Expr*&gt;(T-&gt;getSizeExpr())));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>IncompleteArrayType</argument>,
<argument>{ TRY_TO(TraverseType(T-&gt;getElementType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>VariableArrayType</argument>, <argument>{
TRY_TO(TraverseType(T-&gt;getElementType()));
TRY_TO(TraverseStmt(T-&gt;getSizeExpr()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>DependentSizedArrayType</argument>, <argument>{
TRY_TO(TraverseType(T-&gt;getElementType()));
if (T-&gt;getSizeExpr())
TRY_TO(TraverseStmt(T-&gt;getSizeExpr()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>DependentAddressSpaceType</argument>, <argument>{
TRY_TO(TraverseStmt(T-&gt;getAddrSpaceExpr()));
TRY_TO(TraverseType(T-&gt;getPointeeType()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>DependentVectorType</argument>, <argument>{
if (T-&gt;getSizeExpr())
TRY_TO(TraverseStmt(T-&gt;getSizeExpr()));
TRY_TO(TraverseType(T-&gt;getElementType()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>DependentSizedExtVectorType</argument>, <argument>{
if (T-&gt;getSizeExpr())
TRY_TO(TraverseStmt(T-&gt;getSizeExpr()));
TRY_TO(TraverseType(T-&gt;getElementType()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>VectorType</argument>, <argument>{ TRY_TO(TraverseType(T-&gt;getElementType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>ExtVectorType</argument>, <argument>{ TRY_TO(TraverseType(T-&gt;getElementType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>ConstantMatrixType</argument>,
<argument>{ TRY_TO(TraverseType(T-&gt;getElementType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>DependentSizedMatrixType</argument>, <argument>{
if (T-&gt;getRowExpr())
TRY_TO(TraverseStmt(T-&gt;getRowExpr()));
if (T-&gt;getColumnExpr())
TRY_TO(TraverseStmt(T-&gt;getColumnExpr()));
TRY_TO(TraverseType(T-&gt;getElementType()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>FunctionNoProtoType</argument>,
<argument>{ TRY_TO(TraverseType(T-&gt;getReturnType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>FunctionProtoType</argument>, <argument>{
TRY_TO(TraverseType(T-&gt;getReturnType()));

for (const auto &amp;A : T-&gt;param_types()) {
TRY_TO(TraverseType(A));
}

for (const auto &amp;E : T-&gt;exceptions()) {
TRY_TO(TraverseType(E));
}

if (Expr *NE = T-&gt;getNoexceptExpr())
TRY_TO(TraverseStmt(NE));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>UnresolvedUsingType</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>TypedefType</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>TypeOfExprType</argument>,
<argument>{ TRY_TO(TraverseStmt(T-&gt;getUnderlyingExpr())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>TypeOfType</argument>, <argument>{ TRY_TO(TraverseType(T-&gt;getUnderlyingType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>DecltypeType</argument>,
<argument>{ TRY_TO(TraverseStmt(T-&gt;getUnderlyingExpr())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>UnaryTransformType</argument>, <argument>{
TRY_TO(TraverseType(T-&gt;getBaseType()));
TRY_TO(TraverseType(T-&gt;getUnderlyingType()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>AutoType</argument>, <argument>{
TRY_TO(TraverseType(T-&gt;getDeducedType()));
if (T-&gt;isConstrained()) {
TRY_TO(TraverseDecl(T-&gt;getTypeConstraintConcept()));
TRY_TO(TraverseTemplateArguments(T-&gt;getArgs(), T-&gt;getNumArgs()));
}
}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>DeducedTemplateSpecializationType</argument>, <argument>{
TRY_TO(TraverseTemplateName(T-&gt;getTemplateName()));
TRY_TO(TraverseType(T-&gt;getDeducedType()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>RecordType</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>EnumType</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>TemplateTypeParmType</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>SubstTemplateTypeParmType</argument>, <argument>{
TRY_TO(TraverseType(T-&gt;getReplacementType()));
}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>SubstTemplateTypeParmPackType</argument>, <argument>{
TRY_TO(TraverseTemplateArgument(T-&gt;getArgumentPack()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>TemplateSpecializationType</argument>, <argument>{
TRY_TO(TraverseTemplateName(T-&gt;getTemplateName()));
TRY_TO(TraverseTemplateArguments(T-&gt;getArgs(), T-&gt;getNumArgs()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>InjectedClassNameType</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>AttributedType</argument>,
<argument>{ TRY_TO(TraverseType(T-&gt;getModifiedType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>ParenType</argument>, <argument>{ TRY_TO(TraverseType(T-&gt;getInnerType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>MacroQualifiedType</argument>,
<argument>{ TRY_TO(TraverseType(T-&gt;getUnderlyingType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>ElaboratedType</argument>, <argument>{
if (T-&gt;getQualifier()) {
TRY_TO(TraverseNestedNameSpecifier(T-&gt;getQualifier()));
}
TRY_TO(TraverseType(T-&gt;getNamedType()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>DependentNameType</argument>,
<argument>{ TRY_TO(TraverseNestedNameSpecifier(T-&gt;getQualifier())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>DependentTemplateSpecializationType</argument>, <argument>{
TRY_TO(TraverseNestedNameSpecifier(T-&gt;getQualifier()));
TRY_TO(TraverseTemplateArguments(T-&gt;getArgs(), T-&gt;getNumArgs()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>PackExpansionType</argument>, <argument>{ TRY_TO(TraverseType(T-&gt;getPattern())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>ObjCTypeParamType</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>ObjCInterfaceType</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>ObjCObjectType</argument>, <argument>{


if (T-&gt;getBaseType().getTypePtr() != T)
TRY_TO(TraverseType(T-&gt;getBaseType()));
for (auto typeArg : T-&gt;getTypeArgsAsWritten()) {
TRY_TO(TraverseType(typeArg));
}
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>ObjCObjectPointerType</argument>,
<argument>{ TRY_TO(TraverseType(T-&gt;getPointeeType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>AtomicType</argument>, <argument>{ TRY_TO(TraverseType(T-&gt;getValueType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>PipeType</argument>, <argument>{ TRY_TO(TraverseType(T-&gt;getElementType())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>ExtIntType</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_TYPE</name><argument_list>(<argument>DependentExtIntType</argument>,
<argument>{ TRY_TO(TraverseStmt(T-&gt;getNumBitsExpr())); }</argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DEF_TRAVERSE_TYPE</name></cpp:undef>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_TRAVERSE_TYPELOC</name><parameter_list>(<parameter><type><name>TYPE</name></type></parameter>, <parameter><type><name>CODE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>template &lt;typename Derived&gt; bool RecursiveASTVisitor&lt;Derived&gt;::Traverse##TYPE##Loc(TYPE##Loc TL) { if (!getDerived().shouldTraversePostOrder()) { TRY_TO(WalkUpFrom##TYPE##Loc(TL)); if (getDerived().shouldWalkTypesOfTypeLocs()) TRY_TO(WalkUpFrom##TYPE(const_cast&lt;TYPE *&gt;(TL.getTypePtr()))); } { CODE; } if (getDerived().shouldTraversePostOrder()) { TRY_TO(WalkUpFrom##TYPE##Loc(TL)); if (getDerived().shouldWalkTypesOfTypeLocs()) TRY_TO(WalkUpFrom##TYPE(const_cast&lt;TYPE *&gt;(TL.getTypePtr()))); } return true; }</cpp:value></cpp:define>
















<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name>
<name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseQualifiedTypeLoc</name><argument_list>(<argument>QualifiedTypeLoc TL</argument>)</argument_list></macro> <block>{















<return>return <expr><call><name>TraverseTypeLoc</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getUnqualifiedLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>BuiltinType</argument>, <argument>{}</argument>)</argument_list></macro>


<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>ComplexType</argument>, <argument>{
TRY_TO(TraverseType(TL.getTypePtr()-&gt;getElementType()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>PointerType</argument>,
<argument>{ TRY_TO(TraverseTypeLoc(TL.getPointeeLoc())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>BlockPointerType</argument>,
<argument>{ TRY_TO(TraverseTypeLoc(TL.getPointeeLoc())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>LValueReferenceType</argument>,
<argument>{ TRY_TO(TraverseTypeLoc(TL.getPointeeLoc())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>RValueReferenceType</argument>,
<argument>{ TRY_TO(TraverseTypeLoc(TL.getPointeeLoc())); }</argument>)</argument_list></macro>



<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>MemberPointerType</argument>, <argument>{
if (auto *TSI = TL.getClassTInfo())
TRY_TO(TraverseTypeLoc(TSI-&gt;getTypeLoc()));
else
TRY_TO(TraverseType(QualType(TL.getTypePtr()-&gt;getClass(), <literal type="number">0</literal>)));
TRY_TO(TraverseTypeLoc(TL.getPointeeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>AdjustedType</argument>,
<argument>{ TRY_TO(TraverseTypeLoc(TL.getOriginalLoc())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>DecayedType</argument>,
<argument>{ TRY_TO(TraverseTypeLoc(TL.getOriginalLoc())); }</argument>)</argument_list></macro>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseArrayTypeLocHelper</name><argument_list>(<argument>ArrayTypeLoc TL</argument>)</argument_list></macro> <block>{

<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>ConstantArrayType</argument>, <argument>{
TRY_TO(TraverseTypeLoc(TL.getElementLoc()));
TRY_TO(TraverseArrayTypeLocHelper(TL));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>IncompleteArrayType</argument>, <argument>{
TRY_TO(TraverseTypeLoc(TL.getElementLoc()));
TRY_TO(TraverseArrayTypeLocHelper(TL));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>VariableArrayType</argument>, <argument>{
TRY_TO(TraverseTypeLoc(TL.getElementLoc()));
TRY_TO(TraverseArrayTypeLocHelper(TL));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>DependentSizedArrayType</argument>, <argument>{
TRY_TO(TraverseTypeLoc(TL.getElementLoc()));
TRY_TO(TraverseArrayTypeLocHelper(TL));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>DependentAddressSpaceType</argument>, <argument>{
TRY_TO(TraverseStmt(TL.getTypePtr()-&gt;getAddrSpaceExpr()));
TRY_TO(TraverseType(TL.getTypePtr()-&gt;getPointeeType()));
}</argument>)</argument_list></macro>



<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>DependentSizedExtVectorType</argument>, <argument>{
if (TL.getTypePtr()-&gt;getSizeExpr())
TRY_TO(TraverseStmt(TL.getTypePtr()-&gt;getSizeExpr()));
TRY_TO(TraverseType(TL.getTypePtr()-&gt;getElementType()));
}</argument>)</argument_list></macro>


<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>VectorType</argument>, <argument>{
TRY_TO(TraverseType(TL.getTypePtr()-&gt;getElementType()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>DependentVectorType</argument>, <argument>{
if (TL.getTypePtr()-&gt;getSizeExpr())
TRY_TO(TraverseStmt(TL.getTypePtr()-&gt;getSizeExpr()));
TRY_TO(TraverseType(TL.getTypePtr()-&gt;getElementType()));
}</argument>)</argument_list></macro>



<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>ExtVectorType</argument>, <argument>{
TRY_TO(TraverseType(TL.getTypePtr()-&gt;getElementType()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>ConstantMatrixType</argument>, <argument>{
TRY_TO(TraverseStmt(TL.getAttrRowOperand()));
TRY_TO(TraverseStmt(TL.getAttrColumnOperand()));
TRY_TO(TraverseType(TL.getTypePtr()-&gt;getElementType()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>DependentSizedMatrixType</argument>, <argument>{
TRY_TO(TraverseStmt(TL.getAttrRowOperand()));
TRY_TO(TraverseStmt(TL.getAttrColumnOperand()));
TRY_TO(TraverseType(TL.getTypePtr()-&gt;getElementType()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>FunctionNoProtoType</argument>,
<argument>{ TRY_TO(TraverseTypeLoc(TL.getReturnLoc())); }</argument>)</argument_list></macro>


<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>FunctionProtoType</argument>, <argument>{
TRY_TO(TraverseTypeLoc(TL.getReturnLoc()));

const FunctionProtoType *T = TL.getTypePtr();

for (unsigned I = <literal type="number">0</literal>, E = TL.getNumParams(); I != E; ++I) {
if (TL.getParam(I)) {
TRY_TO(TraverseDecl(TL.getParam(I)));
} else if (I &lt; T-&gt;getNumParams()) {
TRY_TO(TraverseType(T-&gt;getParamType(I)));
}
}

for (const auto &amp;E : T-&gt;exceptions()) {
TRY_TO(TraverseType(E));
}

if (Expr *NE = T-&gt;getNoexceptExpr())
TRY_TO(TraverseStmt(NE));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>UnresolvedUsingType</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>TypedefType</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>TypeOfExprType</argument>,
<argument>{ TRY_TO(TraverseStmt(TL.getUnderlyingExpr())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>TypeOfType</argument>, <argument>{
TRY_TO(TraverseTypeLoc(TL.getUnderlyingTInfo()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>


<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>DecltypeType</argument>, <argument>{
TRY_TO(TraverseStmt(TL.getTypePtr()-&gt;getUnderlyingExpr()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>UnaryTransformType</argument>, <argument>{
TRY_TO(TraverseTypeLoc(TL.getUnderlyingTInfo()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>AutoType</argument>, <argument>{
TRY_TO(TraverseType(TL.getTypePtr()-&gt;getDeducedType()));
if (TL.isConstrained()) {
TRY_TO(TraverseNestedNameSpecifierLoc(TL.getNestedNameSpecifierLoc()));
TRY_TO(TraverseDeclarationNameInfo(TL.getConceptNameInfo()));
for (unsigned I = <literal type="number">0</literal>, E = TL.getNumArgs(); I != E; ++I)
TRY_TO(TraverseTemplateArgumentLoc(TL.getArgLoc(I)));
}
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>DeducedTemplateSpecializationType</argument>, <argument>{
TRY_TO(TraverseTemplateName(TL.getTypePtr()-&gt;getTemplateName()));
TRY_TO(TraverseType(TL.getTypePtr()-&gt;getDeducedType()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>RecordType</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>EnumType</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>TemplateTypeParmType</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>SubstTemplateTypeParmType</argument>, <argument>{
TRY_TO(TraverseType(TL.getTypePtr()-&gt;getReplacementType()));
}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>SubstTemplateTypeParmPackType</argument>, <argument>{
TRY_TO(TraverseTemplateArgument(TL.getTypePtr()-&gt;getArgumentPack()));
}</argument>)</argument_list></macro>


<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>TemplateSpecializationType</argument>, <argument>{
TRY_TO(TraverseTemplateName(TL.getTypePtr()-&gt;getTemplateName()));
for (unsigned I = <literal type="number">0</literal>, E = TL.getNumArgs(); I != E; ++I) {
TRY_TO(TraverseTemplateArgumentLoc(TL.getArgLoc(I)));
}
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>InjectedClassNameType</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>ParenType</argument>, <argument>{ TRY_TO(TraverseTypeLoc(TL.getInnerLoc())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>MacroQualifiedType</argument>,
<argument>{ TRY_TO(TraverseTypeLoc(TL.getInnerLoc())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>AttributedType</argument>,
<argument>{ TRY_TO(TraverseTypeLoc(TL.getModifiedLoc())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>ElaboratedType</argument>, <argument>{
if (TL.getQualifierLoc()) {
TRY_TO(TraverseNestedNameSpecifierLoc(TL.getQualifierLoc()));
}
TRY_TO(TraverseTypeLoc(TL.getNamedTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>DependentNameType</argument>, <argument>{
TRY_TO(TraverseNestedNameSpecifierLoc(TL.getQualifierLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>DependentTemplateSpecializationType</argument>, <argument>{
if (TL.getQualifierLoc()) {
TRY_TO(TraverseNestedNameSpecifierLoc(TL.getQualifierLoc()));
}

for (unsigned I = <literal type="number">0</literal>, E = TL.getNumArgs(); I != E; ++I) {
TRY_TO(TraverseTemplateArgumentLoc(TL.getArgLoc(I)));
}
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>PackExpansionType</argument>,
<argument>{ TRY_TO(TraverseTypeLoc(TL.getPatternLoc())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>ObjCTypeParamType</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>ObjCInterfaceType</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>ObjCObjectType</argument>, <argument>{


if (TL.getTypePtr()-&gt;getBaseType().getTypePtr() != TL.getTypePtr())
TRY_TO(TraverseTypeLoc(TL.getBaseLoc()));
for (unsigned i = <literal type="number">0</literal>, n = TL.getNumTypeArgs(); i != n; ++i)
TRY_TO(TraverseTypeLoc(TL.getTypeArgTInfo(i)-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>ObjCObjectPointerType</argument>,
<argument>{ TRY_TO(TraverseTypeLoc(TL.getPointeeLoc())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>AtomicType</argument>, <argument>{ TRY_TO(TraverseTypeLoc(TL.getValueLoc())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>PipeType</argument>, <argument>{ TRY_TO(TraverseTypeLoc(TL.getValueLoc())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>ExtIntType</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_TYPELOC</name><argument_list>(<argument>DependentExtIntType</argument>, <argument>{
TRY_TO(TraverseStmt(TL.getTypePtr()-&gt;getNumBitsExpr()));
}</argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DEF_TRAVERSE_TYPELOC</name></cpp:undef>








<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>canIgnoreChildDeclWhileTraversingDeclContext</name><argument_list>(
<argument>const Decl *Child</argument>)</argument_list></macro> <block>{


<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>BlockDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Child</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>CapturedDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Child</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>CXXRecordDecl</name><modifier>*</modifier></type> <name>Cls</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Child</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Cls</name><operator>-&gt;</operator><name>isLambda</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseDeclContextHelper</name><argument_list>(<argument>DeclContext *DC</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>DC</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>Child</name> <operator>:</operator> <call><name><name>DC</name><operator>-&gt;</operator><name>decls</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>canIgnoreChildDeclWhileTraversingDeclContext</name><argument_list>(<argument><expr><name>Child</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseDecl</name><argument_list>(<argument><expr><name>Child</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>true</name></expr>;</return>
}


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_TRAVERSE_DECL</name><parameter_list>(<parameter><type><name>DECL</name></type></parameter>, <parameter><type><name>CODE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>template &lt;typename Derived&gt; bool RecursiveASTVisitor&lt;Derived&gt;::Traverse##DECL(DECL *D) { bool ShouldVisitChildren = true; bool ReturnValue = true; if (!getDerived().shouldTraversePostOrder()) TRY_TO(WalkUpFrom##DECL(D)); { CODE; } if (ReturnValue &amp;&amp; ShouldVisitChildren) TRY_TO(TraverseDeclContextHelper(dyn_cast&lt;DeclContext&gt;(D))); if (ReturnValue) { for (auto *I : D-&gt;attrs()) TRY_TO(getDerived().TraverseAttr(I)); } if (ReturnValue &amp;&amp; getDerived().shouldTraversePostOrder()) TRY_TO(WalkUpFrom##DECL(D)); return ReturnValue; }</cpp:value></cpp:define>



















DEF_TRAVERSE_DECL<expr_stmt><expr><operator>(</operator><name>AccessSpecDecl</name><operator>,</operator> <block>{}</block><operator>)</operator>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>BlockDecl</argument>, <argument>{
if (TypeSourceInfo *TInfo = D-&gt;getSignatureAsWritten())
TRY_TO(TraverseTypeLoc(TInfo-&gt;getTypeLoc()));
TRY_TO(TraverseStmt(D-&gt;getBody()));
for (const auto &amp;I : D-&gt;captures()) {
if (I.hasCopyExpr()) {
TRY_TO(TraverseStmt(I.getCopyExpr()));
}
}
ShouldVisitChildren = false;
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>CapturedDecl</argument>, <argument>{
TRY_TO(TraverseStmt(D-&gt;getBody()));
ShouldVisitChildren = false;
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>EmptyDecl</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>LifetimeExtendedTemporaryDecl</argument>, <argument>{
TRY_TO(TraverseStmt(D-&gt;getTemporaryExpr()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>FileScopeAsmDecl</argument>,
<argument>{ TRY_TO(TraverseStmt(D-&gt;getAsmString())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ImportDecl</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>FriendDecl</argument>, <argument>{

if (D-&gt;getFriendType())
TRY_TO(TraverseTypeLoc(D-&gt;getFriendType()-&gt;getTypeLoc()));
else
TRY_TO(TraverseDecl(D-&gt;getFriendDecl()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>FriendTemplateDecl</argument>, <argument>{
if (D-&gt;getFriendType())
TRY_TO(TraverseTypeLoc(D-&gt;getFriendType()-&gt;getTypeLoc()));
else
TRY_TO(TraverseDecl(D-&gt;getFriendDecl()));
for (unsigned I = <literal type="number">0</literal>, E = D-&gt;getNumTemplateParameters(); I &lt; E; ++I) {
TemplateParameterList *TPL = D-&gt;getTemplateParameterList(I);
for (TemplateParameterList::iterator ITPL = TPL-&gt;begin(), ETPL = TPL-&gt;end();
ITPL != ETPL; ++ITPL) {
TRY_TO(TraverseDecl(*ITPL));
}
}
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ClassScopeFunctionSpecializationDecl</argument>, <argument>{
TRY_TO(TraverseDecl(D-&gt;getSpecialization()));

if (D-&gt;hasExplicitTemplateArgs()) {
TRY_TO(TraverseTemplateArgumentLocsHelper(
D-&gt;getTemplateArgsAsWritten()-&gt;getTemplateArgs(),
D-&gt;getTemplateArgsAsWritten()-&gt;NumTemplateArgs));
}
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>LinkageSpecDecl</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ExportDecl</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ObjCPropertyImplDecl</argument>, <argument>{
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>StaticAssertDecl</argument>, <argument>{
TRY_TO(TraverseStmt(D-&gt;getAssertExpr()));
TRY_TO(TraverseStmt(D-&gt;getMessage()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>TranslationUnitDecl</argument>, <argument>{






auto Scope = D-&gt;getASTContext().getTraversalScope();
bool HasLimitedScope =
Scope.size() != <literal type="number">1</literal> || !isa&lt;TranslationUnitDecl&gt;(Scope.front());
if (HasLimitedScope) {
ShouldVisitChildren = false;
for (auto *Child : Scope) {
if (!canIgnoreChildDeclWhileTraversingDeclContext(Child))
TRY_TO(TraverseDecl(Child));
}
}
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>PragmaCommentDecl</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>PragmaDetectMismatchDecl</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ExternCContextDecl</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>NamespaceAliasDecl</argument>, <argument>{
TRY_TO(TraverseNestedNameSpecifierLoc(D-&gt;getQualifierLoc()));



ShouldVisitChildren = false;
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>LabelDecl</argument>, <argument>{
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(
<argument>NamespaceDecl</argument>,
<argument>{


}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ObjCCompatibleAliasDecl</argument>, <argument>{
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ObjCCategoryDecl</argument>, <argument>{
if (ObjCTypeParamList *typeParamList = D-&gt;getTypeParamList()) {
for (auto typeParam : *typeParamList) {
TRY_TO(TraverseObjCTypeParamDecl(typeParam));
}
}
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ObjCCategoryImplDecl</argument>, <argument>{
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ObjCImplementationDecl</argument>, <argument>{
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ObjCInterfaceDecl</argument>, <argument>{
if (ObjCTypeParamList *typeParamList = D-&gt;getTypeParamListAsWritten()) {
for (auto typeParam : *typeParamList) {
TRY_TO(TraverseObjCTypeParamDecl(typeParam));
}
}

if (TypeSourceInfo *superTInfo = D-&gt;getSuperClassTInfo()) {
TRY_TO(TraverseTypeLoc(superTInfo-&gt;getTypeLoc()));
}
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ObjCProtocolDecl</argument>, <argument>{
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ObjCMethodDecl</argument>, <argument>{
if (D-&gt;getReturnTypeSourceInfo()) {
TRY_TO(TraverseTypeLoc(D-&gt;getReturnTypeSourceInfo()-&gt;getTypeLoc()));
}
for (ParmVarDecl *Parameter : D-&gt;parameters()) {
TRY_TO(TraverseDecl(Parameter));
}
if (D-&gt;isThisDeclarationADefinition()) {
TRY_TO(TraverseStmt(D-&gt;getBody()));
}
ShouldVisitChildren = false;
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ObjCTypeParamDecl</argument>, <argument>{
if (D-&gt;hasExplicitBound()) {
TRY_TO(TraverseTypeLoc(D-&gt;getTypeSourceInfo()-&gt;getTypeLoc()));



}
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ObjCPropertyDecl</argument>, <argument>{
if (D-&gt;getTypeSourceInfo())
TRY_TO(TraverseTypeLoc(D-&gt;getTypeSourceInfo()-&gt;getTypeLoc()));
else
TRY_TO(TraverseType(D-&gt;getType()));
ShouldVisitChildren = false;
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>UsingDecl</argument>, <argument>{
TRY_TO(TraverseNestedNameSpecifierLoc(D-&gt;getQualifierLoc()));
TRY_TO(TraverseDeclarationNameInfo(D-&gt;getNameInfo()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>UsingEnumDecl</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>UsingPackDecl</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>UsingDirectiveDecl</argument>, <argument>{
TRY_TO(TraverseNestedNameSpecifierLoc(D-&gt;getQualifierLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>UsingShadowDecl</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ConstructorUsingShadowDecl</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>OMPThreadPrivateDecl</argument>, <argument>{
for (auto *I : D-&gt;varlists()) {
TRY_TO(TraverseStmt(I));
}
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>OMPRequiresDecl</argument>, <argument>{
for (auto *C : D-&gt;clauselists()) {
TRY_TO(TraverseOMPClause(C));
}
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>OMPDeclareReductionDecl</argument>, <argument>{
TRY_TO(TraverseStmt(D-&gt;getCombiner()));
if (auto *Initializer = D-&gt;getInitializer())
TRY_TO(TraverseStmt(Initializer));
TRY_TO(TraverseType(D-&gt;getType()));
return true;
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>OMPDeclareMapperDecl</argument>, <argument>{
for (auto *C : D-&gt;clauselists())
TRY_TO(TraverseOMPClause(C));
TRY_TO(TraverseType(D-&gt;getType()));
return true;
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>OMPCapturedExprDecl</argument>, <argument>{ TRY_TO(TraverseVarHelper(D)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>OMPAllocateDecl</argument>, <argument>{
for (auto *I : D-&gt;varlists())
TRY_TO(TraverseStmt(I));
for (auto *C : D-&gt;clauselists())
TRY_TO(TraverseOMPClause(C));
}</argument>)</argument_list></macro>


<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseTemplateParameterListHelper</name><argument_list>(
<argument>TemplateParameterList *TPL</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>TPL</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name> <range>: <expr><operator>*</operator><name>TPL</name></expr></range></decl></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseDecl</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
<if_stmt><if>if <condition>(<decl><type><name>Expr</name> <modifier>*</modifier></type><name>RequiresClause</name> <init>= <expr><call><name><name>TPL</name><operator>-&gt;</operator><name>getRequiresClause</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>RequiresClause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
}
return <expr_stmt><expr><name>true</name></expr>;</expr_stmt>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseDeclTemplateParameterLists</name><argument_list>(<argument>T *D</argument>)</argument_list></macro> <block>{
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>D</name><operator>-&gt;</operator><name>getNumTemplateParameterLists</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>TPL</name> <init>= <expr><call><name><name>D</name><operator>-&gt;</operator><name>getTemplateParameterList</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>TraverseTemplateParameterListHelper</name><argument_list>(<argument><expr><name>TPL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseTemplateInstantiations</name><argument_list>(
<argument>ClassTemplateDecl *D</argument>)</argument_list></macro> <block>{
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>SD</name> <operator>:</operator> <call><name><name>D</name><operator>-&gt;</operator><name>specializations</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>RD</name> <operator>:</operator> <call><name><name>SD</name><operator>-&gt;</operator><name>redecls</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RD</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>isInjectedClassName</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<switch>switch <condition>(
<expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateSpecializationDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RD</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getSpecializationKind</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>TSK_Undeclared</name></expr>:</case>
<case>case <expr><name>TSK_ImplicitInstantiation</name></expr>:</case>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseDecl</name><argument_list>(<argument><expr><name>RD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>




<case>case <expr><name>TSK_ExplicitInstantiationDeclaration</name></expr>:</case>
<case>case <expr><name>TSK_ExplicitInstantiationDefinition</name></expr>:</case>
<case>case <expr><name>TSK_ExplicitSpecialization</name></expr>:</case>
<break>break;</break>
<expr_stmt/></block_content></block></switch></block_content></block></for></block_content></block></for>}</block></expr></expr_stmt>
}
}

<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseTemplateInstantiations</name><argument_list>(
<argument>VarTemplateDecl *D</argument>)</argument_list></macro> <block>{
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>SD</name> <operator>:</operator> <call><name><name>D</name><operator>-&gt;</operator><name>specializations</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>RD</name> <operator>:</operator> <call><name><name>SD</name><operator>-&gt;</operator><name>redecls</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<switch>switch <condition>(
<expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplateSpecializationDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RD</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getSpecializationKind</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>TSK_Undeclared</name></expr>:</case>
<case>case <expr><name>TSK_ImplicitInstantiation</name></expr>:</case>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseDecl</name><argument_list>(<argument><expr><name>RD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>TSK_ExplicitInstantiationDeclaration</name></expr>:</case>
<case>case <expr><name>TSK_ExplicitInstantiationDefinition</name></expr>:</case>
<case>case <expr><name>TSK_ExplicitSpecialization</name></expr>:</case>
<break>break;</break>
<expr_stmt/></block_content></block></switch></block_content></block></for></block_content></block></for>}</block></expr></expr_stmt>
}
}

<return>return <expr><name>true</name></expr>;</return>
}



template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseTemplateInstantiations</name><argument_list>(
<argument>FunctionTemplateDecl *D</argument>)</argument_list></macro> <block>{
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>FD</name> <operator>:</operator> <call><name><name>D</name><operator>-&gt;</operator><name>specializations</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>RD</name> <operator>:</operator> <call><name><name>FD</name><operator>-&gt;</operator><name>redecls</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><call><name><name>RD</name><operator>-&gt;</operator><name>getTemplateSpecializationKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>TSK_Undeclared</name></expr>:</case>
<case>case <expr><name>TSK_ImplicitInstantiation</name></expr>:</case>

<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseDecl</name><argument_list>(<argument><expr><name>RD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>



<case>case <expr><name>TSK_ExplicitInstantiationDeclaration</name></expr>:</case>
<case>case <expr><name>TSK_ExplicitInstantiationDefinition</name></expr>:</case>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseDecl</name><argument_list>(<argument><expr><name>RD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>TSK_ExplicitSpecialization</name></expr>:</case>
<break>break;</break>
<expr_stmt/></block_content></block></switch></block_content></block></for></block_content></block></for>}</block></expr></expr_stmt>
}
}

<return>return <expr><name>true</name></expr>;</return>
}



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_TRAVERSE_TMPL_DECL</name><parameter_list>(<parameter><type><name>TMPLDECLKIND</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DEF_TRAVERSE_DECL(TMPLDECLKIND##TemplateDecl, { TRY_TO(TraverseTemplateParameterListHelper(D-&gt;getTemplateParameters())); TRY_TO(TraverseDecl(D-&gt;getTemplatedDecl())); if (getDerived().shouldVisitTemplateInstantiations() &amp;&amp; D == D-&gt;getCanonicalDecl()) TRY_TO(TraverseTemplateInstantiations(D)); })</cpp:value></cpp:define>



















DEF_TRAVERSE_TMPL_DECL<expr_stmt><expr><operator>(</operator><name>Class</name><operator>)</operator>
<macro><name>DEF_TRAVERSE_TMPL_DECL</name><argument_list>(<argument>Var</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_TMPL_DECL</name><argument_list>(<argument>Function</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>TemplateTemplateParmDecl</argument>, <argument>{


TRY_TO(TraverseDecl(D-&gt;getTemplatedDecl()));
if (D-&gt;hasDefaultArgument() &amp;&amp; !D-&gt;defaultArgumentWasInherited())
TRY_TO(TraverseTemplateArgumentLoc(D-&gt;getDefaultArgument()));
TRY_TO(TraverseTemplateParameterListHelper(D-&gt;getTemplateParameters()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>BuiltinTemplateDecl</argument>, <argument>{
TRY_TO(TraverseTemplateParameterListHelper(D-&gt;getTemplateParameters()));
}</argument>)</argument_list></macro>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseTemplateTypeParamDeclConstraints</name><argument_list>(
<argument>const TemplateTypeParmDecl *D</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>TC</name> <init>= <expr><call><name><name>D</name><operator>-&gt;</operator><name>getTypeConstraint</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><name>Expr</name> <modifier>*</modifier></type><name>IDC</name> <init>= <expr><call><name><name>TC</name><operator>-&gt;</operator><name>getImmediatelyDeclaredConstraint</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>IDC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt>}</block></expr></expr_stmt> <if_stmt><else>else <block>{<block_content>




<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseConceptReference</name><argument_list>(<argument><expr><operator>*</operator><name>TC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
}
return <expr_stmt><expr><name>true</name></expr>;</expr_stmt>
}

DEF_TRAVERSE_DECL<expr_stmt><expr><operator>(</operator><name>TemplateTypeParmDecl</name><operator>,</operator> <block>{

<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>getTypeForDecl</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseType</name><argument_list>(<argument><expr><call><name>QualType</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getTypeForDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseTemplateTypeParamDeclConstraints</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></block>;
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>hasDefaultArgument</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>D</name><operator>-&gt;</operator><name>defaultArgumentWasInherited</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseTypeLoc</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getDefaultArgumentInfo</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTypeLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></expr></expr_stmt>
})

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>TypedefDecl</argument>, <argument>{
TRY_TO(TraverseTypeLoc(D-&gt;getTypeSourceInfo()-&gt;getTypeLoc()));



}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>TypeAliasDecl</argument>, <argument>{
TRY_TO(TraverseTypeLoc(D-&gt;getTypeSourceInfo()-&gt;getTypeLoc()));



}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>TypeAliasTemplateDecl</argument>, <argument>{
TRY_TO(TraverseDecl(D-&gt;getTemplatedDecl()));
TRY_TO(TraverseTemplateParameterListHelper(D-&gt;getTemplateParameters()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ConceptDecl</argument>, <argument>{
TRY_TO(TraverseTemplateParameterListHelper(D-&gt;getTemplateParameters()));
TRY_TO(TraverseStmt(D-&gt;getConstraintExpr()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>UnresolvedUsingTypenameDecl</argument>, <argument>{


TRY_TO(TraverseNestedNameSpecifierLoc(D-&gt;getQualifierLoc()));



}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>UnresolvedUsingIfExistsDecl</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>EnumDecl</argument>, <argument>{
TRY_TO(TraverseDeclTemplateParameterLists(D));

if (D-&gt;getTypeForDecl())
TRY_TO(TraverseType(QualType(D-&gt;getTypeForDecl(), <literal type="number">0</literal>)));

TRY_TO(TraverseNestedNameSpecifierLoc(D-&gt;getQualifierLoc()));


}</argument>)</argument_list></macro>


<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseRecordHelper</name><argument_list>(<argument>RecordDecl *D</argument>)</argument_list></macro> <block>{



<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseDeclTemplateParameterLists</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseNestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseCXXBaseSpecifier</name><argument_list>(
<argument>const CXXBaseSpecifier &amp;Base</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseTypeLoc</name><argument_list>(<argument><expr><call><name><name>Base</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTypeLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseCXXRecordHelper</name><argument_list>(<argument>CXXRecordDecl *D</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TraverseRecordHelper</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>isCompleteDefinition</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>I</name> <range>: <expr><call><name><name>D</name><operator>-&gt;</operator><name>bases</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseCXXBaseSpecifier</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
}

DEF_TRAVERSE_DECL<expr_stmt><expr><operator>(</operator><name>RecordDecl</name><operator>,</operator> <block>{ <expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseRecordHelper</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>; }</block><operator>)</operator>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>CXXRecordDecl</argument>, <argument>{ TRY_TO(TraverseCXXRecordHelper(D)); }</argument>)</argument_list></macro>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_TRAVERSE_TMPL_SPEC_DECL</name><parameter_list>(<parameter><type><name>TMPLDECLKIND</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DEF_TRAVERSE_DECL(TMPLDECLKIND##TemplateSpecializationDecl, { if (TypeSourceInfo *TSI = D-&gt;getTypeAsWritten()) TRY_TO(TraverseTypeLoc(TSI-&gt;getTypeLoc())); TRY_TO(TraverseNestedNameSpecifierLoc(D-&gt;getQualifierLoc())); if (!getDerived().shouldVisitTemplateInstantiations() &amp;&amp; D-&gt;getTemplateSpecializationKind() != TSK_ExplicitSpecialization) return true; })</cpp:value></cpp:define>






















<macro><name>DEF_TRAVERSE_TMPL_SPEC_DECL</name><argument_list>(<argument>Class</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_TMPL_SPEC_DECL</name><argument_list>(<argument>Var</argument>)</argument_list></macro>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseTemplateArgumentLocsHelper</name><argument_list>(
<argument>const TemplateArgumentLoc *TAL</argument>, <argument>unsigned Count</argument>)</argument_list></macro> <block>{
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>&lt;</operator> <name>Count</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseTemplateArgumentLoc</name><argument_list>(<argument><expr><name><name>TAL</name><index>[<expr><name>I</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
}

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_TRAVERSE_TMPL_PART_SPEC_DECL</name><parameter_list>(<parameter><type><name>TMPLDECLKIND</name></type></parameter>, <parameter><type><name>DECLKIND</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DEF_TRAVERSE_DECL(TMPLDECLKIND##TemplatePartialSpecializationDecl, { if (TemplateParameterList *TPL = D-&gt;getTemplateParameters()) { for (TemplateParameterList::iterator I = TPL-&gt;begin(), E = TPL-&gt;end(); I != E; ++I) { TRY_TO(TraverseDecl(*I)); } } TRY_TO(TraverseTemplateArgumentLocsHelper( D-&gt;getTemplateArgsAsWritten()-&gt;getTemplateArgs(), D-&gt;getTemplateArgsAsWritten()-&gt;NumTemplateArgs)); TRY_TO(Traverse##DECLKIND##Helper(D)); })</cpp:value></cpp:define>





















DEF_TRAVERSE_TMPL_PART_SPEC_DECL<expr_stmt><expr><operator>(</operator><name>Class</name><operator>,</operator> <name>CXXRecord</name><operator>)</operator>
<macro><name>DEF_TRAVERSE_TMPL_PART_SPEC_DECL</name><argument_list>(<argument>Var</argument>, <argument>Var</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>EnumConstantDecl</argument>, <argument>{ TRY_TO(TraverseStmt(D-&gt;getInitExpr())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>UnresolvedUsingValueDecl</argument>, <argument>{


TRY_TO(TraverseNestedNameSpecifierLoc(D-&gt;getQualifierLoc()));
TRY_TO(TraverseDeclarationNameInfo(D-&gt;getNameInfo()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>IndirectFieldDecl</argument>, <argument>{}</argument>)</argument_list></macro>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseDeclaratorHelper</name><argument_list>(<argument>DeclaratorDecl *D</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseDeclTemplateParameterLists</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseNestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseTypeLoc</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTypeLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseType</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
}

DEF_TRAVERSE_DECL<expr_stmt><expr><operator>(</operator><name>DecompositionDecl</name><operator>,</operator> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseVarHelper</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>Binding</name> <operator>:</operator> <call><name><name>D</name><operator>-&gt;</operator><name>bindings</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseDecl</name><argument_list>(<argument><expr><name>Binding</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
})

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>BindingDecl</argument>, <argument>{
if (getDerived().shouldVisitImplicitCode())
TRY_TO(TraverseStmt(D-&gt;getBinding()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>MSPropertyDecl</argument>, <argument>{ TRY_TO(TraverseDeclaratorHelper(D)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>MSGuidDecl</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>TemplateParamObjectDecl</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>FieldDecl</argument>, <argument>{
TRY_TO(TraverseDeclaratorHelper(D));
if (D-&gt;isBitField())
TRY_TO(TraverseStmt(D-&gt;getBitWidth()));
else if (D-&gt;hasInClassInitializer())
TRY_TO(TraverseStmt(D-&gt;getInClassInitializer()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ObjCAtDefsFieldDecl</argument>, <argument>{
TRY_TO(TraverseDeclaratorHelper(D));
if (D-&gt;isBitField())
TRY_TO(TraverseStmt(D-&gt;getBitWidth()));

}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ObjCIvarDecl</argument>, <argument>{
TRY_TO(TraverseDeclaratorHelper(D));
if (D-&gt;isBitField())
TRY_TO(TraverseStmt(D-&gt;getBitWidth()));

}</argument>)</argument_list></macro>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseFunctionHelper</name><argument_list>(<argument>FunctionDecl *D</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseDeclTemplateParameterLists</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseNestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseDeclarationNameInfo</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getNameInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;






<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>FunctionTemplateSpecializationInfo</name> <modifier>*</modifier></type><name>FTSI</name> <init>=
<expr><call><name><name>D</name><operator>-&gt;</operator><name>getTemplateSpecializationInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>FTSI</name><operator>-&gt;</operator><name>getTemplateSpecializationKind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>TSK_Undeclared</name> <operator>&amp;&amp;</operator>
<call><name><name>FTSI</name><operator>-&gt;</operator><name>getTemplateSpecializationKind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>TSK_ImplicitInstantiation</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>ASTTemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TALI</name> <init>=
<expr><name><name>FTSI</name><operator>-&gt;</operator><name>TemplateArgumentsAsWritten</name></name></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseTemplateArgumentLocsHelper</name><argument_list>(<argument><expr><call><name><name>TALI</name><operator>-&gt;</operator><name>getTemplateArgs</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name><name>TALI</name><operator>-&gt;</operator><name>NumTemplateArgs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
}
}





<if_stmt><if>if <condition>(<decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSI</name> <init>= <expr><call><name><name>D</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseTypeLoc</name><argument_list>(<argument><expr><call><name><name>TSI</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>shouldVisitImplicitCode</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>




<for>for <control>(<init><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>Parameter</name> <range>: <expr><call><name><name>D</name><operator>-&gt;</operator><name>parameters</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseDecl</name><argument_list>(<argument><expr><name>Parameter</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<decl><type><name>Expr</name> <modifier>*</modifier></type><name>TrailingRequiresClause</name> <init>= <expr><call><name><name>D</name><operator>-&gt;</operator><name>getTrailingRequiresClause</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>TrailingRequiresClause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Ctor</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructorDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>I</name> <operator>:</operator> <call><name><name>Ctor</name><operator>-&gt;</operator><name>inits</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>I</name><operator>-&gt;</operator><name>isWritten</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>shouldVisitImplicitCode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseConstructorInitializer</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>VisitBody</name> <init>=
<expr><call><name><name>D</name><operator>-&gt;</operator><name>isThisDeclarationADefinition</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>


<operator>(</operator><operator>!</operator><call><name><name>D</name><operator>-&gt;</operator><name>isDefaulted</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>shouldVisitImplicitCode</name><argument_list>()</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>MD</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXMethodDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name> <init>= <expr><call><name><name>MD</name><operator>-&gt;</operator><name>getParent</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>RD</name><operator>-&gt;</operator><name>isLambda</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>declaresSameEntity</name><argument_list>(<argument><expr><call><name><name>RD</name><operator>-&gt;</operator><name>getLambdaCallOperator</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>MD</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>VisitBody</name> <operator>=</operator> <name>VisitBody</name> <operator>&amp;&amp;</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>shouldVisitLambdaBody</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>VisitBody</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
}

DEF_TRAVERSE_DECL<expr_stmt><expr><operator>(</operator><name>FunctionDecl</name><operator>,</operator> <block>{


<expr><name>ShouldVisitChildren</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>ReturnValue</name> <operator>=</operator> <call><name>TraverseFunctionHelper</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
}</block><operator>)</operator>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>CXXDeductionGuideDecl</argument>, <argument>{


ShouldVisitChildren = false;
ReturnValue = TraverseFunctionHelper(D);
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>CXXMethodDecl</argument>, <argument>{


ShouldVisitChildren = false;
ReturnValue = TraverseFunctionHelper(D);
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>CXXConstructorDecl</argument>, <argument>{


ShouldVisitChildren = false;
ReturnValue = TraverseFunctionHelper(D);
}</argument>)</argument_list></macro>



<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>CXXConversionDecl</argument>, <argument>{


ShouldVisitChildren = false;
ReturnValue = TraverseFunctionHelper(D);
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>CXXDestructorDecl</argument>, <argument>{


ShouldVisitChildren = false;
ReturnValue = TraverseFunctionHelper(D);
}</argument>)</argument_list></macro>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseVarHelper</name><argument_list>(<argument>VarDecl *D</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseDeclaratorHelper</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><call><name><name>D</name><operator>-&gt;</operator><name>isCXXForRangeDecl</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>shouldVisitImplicitCode</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
}

DEF_TRAVERSE_DECL<expr_stmt><expr><operator>(</operator><name>VarDecl</name><operator>,</operator> <block>{ <expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseVarHelper</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>; }</block><operator>)</operator>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ImplicitParamDecl</argument>, <argument>{ TRY_TO(TraverseVarHelper(D)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>NonTypeTemplateParmDecl</argument>, <argument>{

TRY_TO(TraverseDeclaratorHelper(D));
if (D-&gt;hasDefaultArgument() &amp;&amp; !D-&gt;defaultArgumentWasInherited())
TRY_TO(TraverseStmt(D-&gt;getDefaultArgument()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>ParmVarDecl</argument>, <argument>{
TRY_TO(TraverseVarHelper(D));

if (D-&gt;hasDefaultArg() &amp;&amp; D-&gt;hasUninstantiatedDefaultArg() &amp;&amp;
!D-&gt;hasUnparsedDefaultArg())
TRY_TO(TraverseStmt(D-&gt;getUninstantiatedDefaultArg()));

if (D-&gt;hasDefaultArg() &amp;&amp; !D-&gt;hasUninstantiatedDefaultArg() &amp;&amp;
!D-&gt;hasUnparsedDefaultArg())
TRY_TO(TraverseStmt(D-&gt;getDefaultArg()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_DECL</name><argument_list>(<argument>RequiresExprBodyDecl</argument>, <argument>{}</argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DEF_TRAVERSE_DECL</name></cpp:undef>











<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEF_TRAVERSE_STMT</name><parameter_list>(<parameter><type><name>STMT</name></type></parameter>, <parameter><type><name>CODE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>template &lt;typename Derived&gt; bool RecursiveASTVisitor&lt;Derived&gt;::Traverse##STMT( STMT *S, DataRecursionQueue *Queue) { bool ShouldVisitChildren = true; bool ReturnValue = true; if (!getDerived().shouldTraversePostOrder()) TRY_TO(WalkUpFrom##STMT(S)); { CODE; } if (ShouldVisitChildren) { for (Stmt * SubStmt : getDerived().getStmtChildren(S)) { TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(SubStmt); } } if (!Queue &amp;&amp; ReturnValue &amp;&amp; getDerived().shouldTraversePostOrder()) { TRY_TO(WalkUpFrom##STMT(S)); } return ReturnValue; }</cpp:value></cpp:define>























<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>GCCAsmStmt</argument>, <argument>{
TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(S-&gt;getAsmString());
for (unsigned I = <literal type="number">0</literal>, E = S-&gt;getNumInputs(); I &lt; E; ++I) {
TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(S-&gt;getInputConstraintLiteral(I));
}
for (unsigned I = <literal type="number">0</literal>, E = S-&gt;getNumOutputs(); I &lt; E; ++I) {
TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(S-&gt;getOutputConstraintLiteral(I));
}
for (unsigned I = <literal type="number">0</literal>, E = S-&gt;getNumClobbers(); I &lt; E; ++I) {
TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(S-&gt;getClobberStringLiteral(I));
}

}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(
<argument>MSAsmStmt</argument>,
<argument>{

}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXCatchStmt</argument>, <argument>{
TRY_TO(TraverseDecl(S-&gt;getExceptionDecl()));

}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>DeclStmt</argument>, <argument>{
for (auto *I : S-&gt;decls()) {
TRY_TO(TraverseDecl(I));
}





ShouldVisitChildren = false;
}</argument>)</argument_list></macro>



<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>BreakStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXTryStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CaseStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CompoundStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ContinueStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>DefaultStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>DoStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ForStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>GotoStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>IfStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>IndirectGotoStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>LabelStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>AttributedStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>NullStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCAtCatchStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCAtFinallyStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCAtSynchronizedStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCAtThrowStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCAtTryStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCForCollectionStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCAutoreleasePoolStmt</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXForRangeStmt</argument>, <argument>{
if (!getDerived().shouldVisitImplicitCode()) {
if (S-&gt;getInit())
TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(S-&gt;getInit());
TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(S-&gt;getLoopVarStmt());
TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(S-&gt;getRangeInit());
TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(S-&gt;getBody());

ShouldVisitChildren = false;
}
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>MSDependentExistsStmt</argument>, <argument>{
TRY_TO(TraverseNestedNameSpecifierLoc(S-&gt;getQualifierLoc()));
TRY_TO(TraverseDeclarationNameInfo(S-&gt;getNameInfo()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ReturnStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>SwitchStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>WhileStmt</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ConstantExpr</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXDependentScopeMemberExpr</argument>, <argument>{
TRY_TO(TraverseNestedNameSpecifierLoc(S-&gt;getQualifierLoc()));
TRY_TO(TraverseDeclarationNameInfo(S-&gt;getMemberNameInfo()));
if (S-&gt;hasExplicitTemplateArgs()) {
TRY_TO(TraverseTemplateArgumentLocsHelper(S-&gt;getTemplateArgs(),
S-&gt;getNumTemplateArgs()));
}
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>DeclRefExpr</argument>, <argument>{
TRY_TO(TraverseNestedNameSpecifierLoc(S-&gt;getQualifierLoc()));
TRY_TO(TraverseDeclarationNameInfo(S-&gt;getNameInfo()));
TRY_TO(TraverseTemplateArgumentLocsHelper(S-&gt;getTemplateArgs(),
S-&gt;getNumTemplateArgs()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>DependentScopeDeclRefExpr</argument>, <argument>{
TRY_TO(TraverseNestedNameSpecifierLoc(S-&gt;getQualifierLoc()));
TRY_TO(TraverseDeclarationNameInfo(S-&gt;getNameInfo()));
if (S-&gt;hasExplicitTemplateArgs()) {
TRY_TO(TraverseTemplateArgumentLocsHelper(S-&gt;getTemplateArgs(),
S-&gt;getNumTemplateArgs()));
}
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>MemberExpr</argument>, <argument>{
TRY_TO(TraverseNestedNameSpecifierLoc(S-&gt;getQualifierLoc()));
TRY_TO(TraverseDeclarationNameInfo(S-&gt;getMemberNameInfo()));
TRY_TO(TraverseTemplateArgumentLocsHelper(S-&gt;getTemplateArgs(),
S-&gt;getNumTemplateArgs()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(
<argument>ImplicitCastExpr</argument>,
<argument>{

}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CStyleCastExpr</argument>, <argument>{
TRY_TO(TraverseTypeLoc(S-&gt;getTypeInfoAsWritten()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXFunctionalCastExpr</argument>, <argument>{
TRY_TO(TraverseTypeLoc(S-&gt;getTypeInfoAsWritten()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXAddrspaceCastExpr</argument>, <argument>{
TRY_TO(TraverseTypeLoc(S-&gt;getTypeInfoAsWritten()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXConstCastExpr</argument>, <argument>{
TRY_TO(TraverseTypeLoc(S-&gt;getTypeInfoAsWritten()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXDynamicCastExpr</argument>, <argument>{
TRY_TO(TraverseTypeLoc(S-&gt;getTypeInfoAsWritten()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXReinterpretCastExpr</argument>, <argument>{
TRY_TO(TraverseTypeLoc(S-&gt;getTypeInfoAsWritten()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXStaticCastExpr</argument>, <argument>{
TRY_TO(TraverseTypeLoc(S-&gt;getTypeInfoAsWritten()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>BuiltinBitCastExpr</argument>, <argument>{
TRY_TO(TraverseTypeLoc(S-&gt;getTypeInfoAsWritten()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseSynOrSemInitListExpr</name><argument_list>(
<argument>InitListExpr *S</argument>, <argument>DataRecursionQueue *Queue</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>S</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>shouldTraversePostOrder</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>WalkUpFromInitListExpr</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<for>for <control>(<init><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>SubStmt</name> <range>: <expr><call><name><name>S</name><operator>-&gt;</operator><name>children</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO_TRAVERSE_OR_ENQUEUE_STMT</name><argument_list>(<argument><expr><name>SubStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for></block_content></block></if></if_stmt>}</block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Queue</name> <operator>&amp;&amp;</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>shouldTraversePostOrder</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>WalkUpFromInitListExpr</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}
return <expr_stmt><expr><name>true</name></expr>;</expr_stmt>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseConceptReference</name><argument_list>(
<argument>const ConceptReference &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseNestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>C</name><operator>.</operator><name>getNestedNameSpecifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseDeclarationNameInfo</name><argument_list>(<argument><expr><call><name><name>C</name><operator>.</operator><name>getConceptNameInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>C</name><operator>.</operator><name>hasExplicitTemplateArgs</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseTemplateArgumentLocsHelper</name><argument_list>(
<argument><expr><call><name><name>C</name><operator>.</operator><name>getTemplateArgsAsWritten</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTemplateArgs</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>.</operator><name>getTemplateArgsAsWritten</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NumTemplateArgs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
}









template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseInitListExpr</name><argument_list>(
<argument>InitListExpr *S</argument>, <argument>DataRecursionQueue *Queue</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>-&gt;</operator><name>isSemanticForm</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>S</name><operator>-&gt;</operator><name>isSyntacticForm</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseSynOrSemInitListExpr</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>Queue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block>
<call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseSynOrSemInitListExpr</name><argument_list>(
<argument><expr><ternary><condition><expr><call><name><name>S</name><operator>-&gt;</operator><name>isSemanticForm</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>S</name><operator>-&gt;</operator><name>getSyntacticForm</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>S</name></expr></else></ternary></expr></argument>, <argument><expr><name>Queue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>shouldVisitImplicitCode</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseSynOrSemInitListExpr</name><argument_list>(
<argument><expr><ternary><condition><expr><call><name><name>S</name><operator>-&gt;</operator><name>isSemanticForm</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>S</name></expr> </then><else>: <expr><call><name><name>S</name><operator>-&gt;</operator><name>getSemanticForm</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><name>Queue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
}




DEF_TRAVERSE_STMT<expr_stmt><expr><operator>(</operator><name>GenericSelectionExpr</name><operator>,</operator> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getControllingExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><specifier>const</specifier> <name>GenericSelectionExpr</name><operator>::</operator><name>Association</name> <name>Assoc</name> <operator>:</operator> <call><name><name>S</name><operator>-&gt;</operator><name>associations</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSI</name> <init>= <expr><call><name><name>Assoc</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseTypeLoc</name><argument_list>(<argument><expr><call><name><name>TSI</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>TRY_TO_TRAVERSE_OR_ENQUEUE_STMT</name><argument_list>(<argument><expr><call><name><name>Assoc</name><operator>.</operator><name>getAssociationExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block>
<name>ShouldVisitChildren</name> <operator>=</operator> <name>false</name>;</expr></expr_stmt>
})



<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>PseudoObjectExpr</argument>, <argument>{
TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(S-&gt;getSyntacticForm());
for (PseudoObjectExpr::semantics_iterator i = S-&gt;semantics_begin(),
e = S-&gt;semantics_end();
i != e; ++i) {
Expr *sub = *i;
if (OpaqueValueExpr *OVE = dyn_cast&lt;OpaqueValueExpr&gt;(sub))
sub = OVE-&gt;getSourceExpr();
TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(sub);
}
ShouldVisitChildren = false;
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXScalarValueInitExpr</argument>, <argument>{


TRY_TO(TraverseTypeLoc(S-&gt;getTypeSourceInfo()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXNewExpr</argument>, <argument>{

TRY_TO(TraverseTypeLoc(S-&gt;getAllocatedTypeSourceInfo()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OffsetOfExpr</argument>, <argument>{




TRY_TO(TraverseTypeLoc(S-&gt;getTypeSourceInfo()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>UnaryExprOrTypeTraitExpr</argument>, <argument>{


if (S-&gt;isArgumentType())
TRY_TO(TraverseTypeLoc(S-&gt;getArgumentTypeInfo()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXTypeidExpr</argument>, <argument>{


if (S-&gt;isTypeOperand())
TRY_TO(TraverseTypeLoc(S-&gt;getTypeOperandSourceInfo()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>MSPropertyRefExpr</argument>, <argument>{
TRY_TO(TraverseNestedNameSpecifierLoc(S-&gt;getQualifierLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>MSPropertySubscriptExpr</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXUuidofExpr</argument>, <argument>{


if (S-&gt;isTypeOperand())
TRY_TO(TraverseTypeLoc(S-&gt;getTypeOperandSourceInfo()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>TypeTraitExpr</argument>, <argument>{
for (unsigned I = <literal type="number">0</literal>, N = S-&gt;getNumArgs(); I != N; ++I)
TRY_TO(TraverseTypeLoc(S-&gt;getArg(I)-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ArrayTypeTraitExpr</argument>, <argument>{
TRY_TO(TraverseTypeLoc(S-&gt;getQueriedTypeSourceInfo()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ExpressionTraitExpr</argument>,
<argument>{ TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(S-&gt;getQueriedExpression()); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>VAArgExpr</argument>, <argument>{

TRY_TO(TraverseTypeLoc(S-&gt;getWrittenTypeInfo()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXTemporaryObjectExpr</argument>, <argument>{

TRY_TO(TraverseTypeLoc(S-&gt;getTypeSourceInfo()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>


<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>LambdaExpr</argument>, <argument>{

for (unsigned I = <literal type="number">0</literal>, N = S-&gt;capture_size(); I != N; ++I) {
const LambdaCapture *C = S-&gt;capture_begin() + I;
if (C-&gt;isExplicit() || getDerived().shouldVisitImplicitCode()) {
TRY_TO(TraverseLambdaCapture(S, C, S-&gt;capture_init_begin()[I]));
}
}

if (getDerived().shouldVisitImplicitCode()) {

TRY_TO(TraverseDecl(S-&gt;getLambdaClass()));
} else {

TypeLoc TL = S-&gt;getCallOperator()-&gt;getTypeSourceInfo()-&gt;getTypeLoc();
FunctionProtoTypeLoc Proto = TL.getAsAdjusted&lt;FunctionProtoTypeLoc&gt;();

TRY_TO(TraverseTemplateParameterListHelper(S-&gt;getTemplateParameterList()));
if (S-&gt;hasExplicitParameters()) {

for (unsigned I = <literal type="number">0</literal>, N = Proto.getNumParams(); I != N; ++I)
TRY_TO(TraverseDecl(Proto.getParam(I)));
}

auto *T = Proto.getTypePtr();
for (const auto &amp;E : T-&gt;exceptions())
TRY_TO(TraverseType(E));

if (Expr *NE = T-&gt;getNoexceptExpr())
TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(NE);

if (S-&gt;hasExplicitResultType())
TRY_TO(TraverseTypeLoc(Proto.getReturnLoc()));
TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(S-&gt;getTrailingRequiresClause());

TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(S-&gt;getBody());
}
ShouldVisitChildren = false;
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXUnresolvedConstructExpr</argument>, <argument>{

TRY_TO(TraverseTypeLoc(S-&gt;getTypeSourceInfo()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>



<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXConstructExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CallExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXMemberCallExpr</argument>, <argument>{}</argument>)</argument_list></macro>



<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>AddrLabelExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ArraySubscriptExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>MatrixSubscriptExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPArraySectionExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPArrayShapingExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPIteratorExpr</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>BlockExpr</argument>, <argument>{
TRY_TO(TraverseDecl(S-&gt;getBlockDecl()));
return true;
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ChooseExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CompoundLiteralExpr</argument>, <argument>{
TRY_TO(TraverseTypeLoc(S-&gt;getTypeSourceInfo()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXBindTemporaryExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXBoolLiteralExpr</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXDefaultArgExpr</argument>, <argument>{
if (getDerived().shouldVisitImplicitCode())
TRY_TO(TraverseStmt(S-&gt;getExpr()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXDefaultInitExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXDeleteExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ExprWithCleanups</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXInheritedCtorInitExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXNullPtrLiteralExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXStdInitializerListExpr</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXPseudoDestructorExpr</argument>, <argument>{
TRY_TO(TraverseNestedNameSpecifierLoc(S-&gt;getQualifierLoc()));
if (TypeSourceInfo *ScopeInfo = S-&gt;getScopeTypeInfo())
TRY_TO(TraverseTypeLoc(ScopeInfo-&gt;getTypeLoc()));
if (TypeSourceInfo *DestroyedTypeInfo = S-&gt;getDestroyedTypeInfo())
TRY_TO(TraverseTypeLoc(DestroyedTypeInfo-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXThisExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXThrowExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>UserDefinedLiteral</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>DesignatedInitExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>DesignatedInitUpdateExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ExtVectorElementExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>GNUNullExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ImplicitValueInitExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>NoInitExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ArrayInitLoopExpr</argument>, <argument>{


if (OpaqueValueExpr *OVE = S-&gt;getCommonExpr())
TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(OVE-&gt;getSourceExpr());
}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ArrayInitIndexExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCBoolLiteralExpr</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCEncodeExpr</argument>, <argument>{
if (TypeSourceInfo *TInfo = S-&gt;getEncodedTypeSourceInfo())
TRY_TO(TraverseTypeLoc(TInfo-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCIsaExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCIvarRefExpr</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCMessageExpr</argument>, <argument>{
if (TypeSourceInfo *TInfo = S-&gt;getClassReceiverTypeInfo())
TRY_TO(TraverseTypeLoc(TInfo-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCPropertyRefExpr</argument>, <argument>{
if (S-&gt;isClassReceiver()) {
ObjCInterfaceDecl *IDecl = S-&gt;getClassReceiver();
QualType Type = IDecl-&gt;getASTContext().getObjCInterfaceType(IDecl);
ObjCInterfaceLocInfo Data;
Data.NameLoc = S-&gt;getReceiverLocation();
Data.NameEndLoc = Data.NameLoc;
TRY_TO(TraverseTypeLoc(TypeLoc(Type, &amp;Data)));
}
}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCSubscriptRefExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCProtocolExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCSelectorExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCIndirectCopyRestoreExpr</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCBridgedCastExpr</argument>, <argument>{
TRY_TO(TraverseTypeLoc(S-&gt;getTypeInfoAsWritten()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCAvailabilityCheckExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ParenExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ParenListExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>SYCLUniqueStableNameExpr</argument>, <argument>{
TRY_TO(TraverseTypeLoc(S-&gt;getTypeSourceInfo()-&gt;getTypeLoc()));
}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>PredefinedExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ShuffleVectorExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ConvertVectorExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>StmtExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>SourceLocExpr</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>UnresolvedLookupExpr</argument>, <argument>{
TRY_TO(TraverseNestedNameSpecifierLoc(S-&gt;getQualifierLoc()));
if (S-&gt;hasExplicitTemplateArgs()) {
TRY_TO(TraverseTemplateArgumentLocsHelper(S-&gt;getTemplateArgs(),
S-&gt;getNumTemplateArgs()));
}
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>UnresolvedMemberExpr</argument>, <argument>{
TRY_TO(TraverseNestedNameSpecifierLoc(S-&gt;getQualifierLoc()));
if (S-&gt;hasExplicitTemplateArgs()) {
TRY_TO(TraverseTemplateArgumentLocsHelper(S-&gt;getTemplateArgs(),
S-&gt;getNumTemplateArgs()));
}
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>SEHTryStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>SEHExceptStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>SEHFinallyStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>SEHLeaveStmt</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CapturedStmt</argument>, <argument>{ TRY_TO(TraverseDecl(S-&gt;getCapturedDecl())); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXOperatorCallExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXRewrittenBinaryOperator</argument>, <argument>{
if (!getDerived().shouldVisitImplicitCode()) {
CXXRewrittenBinaryOperator::DecomposedForm Decomposed =
S-&gt;getDecomposedForm();
TRY_TO(TraverseStmt(const_cast&lt;Expr*&gt;(Decomposed.LHS)));
TRY_TO(TraverseStmt(const_cast&lt;Expr*&gt;(Decomposed.RHS)));
ShouldVisitChildren = false;
}
}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OpaqueValueExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>TypoExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>RecoveryExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CUDAKernelCallExpr</argument>, <argument>{}</argument>)</argument_list></macro>



<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>BinaryConditionalOperator</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ConditionalOperator</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>UnaryOperator</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>BinaryOperator</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CompoundAssignOperator</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXNoexceptExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>PackExpansionExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>SizeOfPackExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>SubstNonTypeTemplateParmPackExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>SubstNonTypeTemplateParmExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>FunctionParmPackExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CXXFoldExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>AtomicExpr</argument>, <argument>{}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>MaterializeTemporaryExpr</argument>, <argument>{
if (S-&gt;getLifetimeExtendedTemporaryDecl()) {
TRY_TO(TraverseLifetimeExtendedTemporaryDecl(
S-&gt;getLifetimeExtendedTemporaryDecl()));
ShouldVisitChildren = false;
}
}</argument>)</argument_list></macro>



<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CoroutineBodyStmt</argument>, <argument>{
if (!getDerived().shouldVisitImplicitCode()) {
TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(S-&gt;getBody());
ShouldVisitChildren = false;
}
}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CoreturnStmt</argument>, <argument>{
if (!getDerived().shouldVisitImplicitCode()) {
TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(S-&gt;getOperand());
ShouldVisitChildren = false;
}
}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CoawaitExpr</argument>, <argument>{
if (!getDerived().shouldVisitImplicitCode()) {
TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(S-&gt;getOperand());
ShouldVisitChildren = false;
}
}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>DependentCoawaitExpr</argument>, <argument>{
if (!getDerived().shouldVisitImplicitCode()) {
TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(S-&gt;getOperand());
ShouldVisitChildren = false;
}
}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CoyieldExpr</argument>, <argument>{
if (!getDerived().shouldVisitImplicitCode()) {
TRY_TO_TRAVERSE_OR_ENQUEUE_STMT(S-&gt;getOperand());
ShouldVisitChildren = false;
}
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ConceptSpecializationExpr</argument>, <argument>{
TRY_TO(TraverseConceptReference(*S));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>RequiresExpr</argument>, <argument>{
TRY_TO(TraverseDecl(S-&gt;getBody()));
for (ParmVarDecl *Parm : S-&gt;getLocalParameters())
TRY_TO(TraverseDecl(Parm));
for (concepts::Requirement *Req : S-&gt;getRequirements())
if (auto *TypeReq = dyn_cast&lt;concepts::TypeRequirement&gt;(Req)) {
if (!TypeReq-&gt;isSubstitutionFailure())
TRY_TO(TraverseTypeLoc(TypeReq-&gt;getType()-&gt;getTypeLoc()));
} else if (auto *ExprReq = dyn_cast&lt;concepts::ExprRequirement&gt;(Req)) {
if (!ExprReq-&gt;isExprSubstitutionFailure())
TRY_TO(TraverseStmt(ExprReq-&gt;getExpr()));
auto &amp;RetReq = ExprReq-&gt;getReturnTypeRequirement();
if (RetReq.isTypeConstraint())
TRY_TO(TraverseTemplateParameterListHelper(
RetReq.getTypeConstraintTemplateParameterList()));
} else {
auto *NestedReq = cast&lt;concepts::NestedRequirement&gt;(Req);
if (!NestedReq-&gt;isSubstitutionFailure())
TRY_TO(TraverseStmt(NestedReq-&gt;getConstraintExpr()));
}
}</argument>)</argument_list></macro>


<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>IntegerLiteral</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>FixedPointLiteral</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>CharacterLiteral</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>FloatingLiteral</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ImaginaryLiteral</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>StringLiteral</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCStringLiteral</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCBoxedExpr</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCArrayLiteral</argument>, <argument>{}</argument>)</argument_list></macro>
<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>ObjCDictionaryLiteral</argument>, <argument>{}</argument>)</argument_list></macro>


<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>AsTypeExpr</argument>, <argument>{}</argument>)</argument_list></macro>


<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseOMPExecutableDirective</name><argument_list>(
<argument>OMPExecutableDirective *S</argument>)</argument_list></macro> <block>{
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>C</name> <operator>:</operator> <call><name><name>S</name><operator>-&gt;</operator><name>clauses</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseOMPClause</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
}

DEF_TRAVERSE_STMT<expr_stmt><expr><operator>(</operator><name>OMPCanonicalLoop</name><operator>,</operator> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>shouldVisitImplicitCode</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getLoopStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ShouldVisitChildren</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
})

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name>
<name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseOMPLoopDirective</name><argument_list>(<argument>OMPLoopDirective *S</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>TraverseOMPExecutableDirective</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPParallelDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPSimdDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTileDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPUnrollDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPForDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPForSimdDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPSectionsDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPSectionDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPSingleDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPMasterDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPCriticalDirective</argument>, <argument>{
TRY_TO(TraverseDeclarationNameInfo(S-&gt;getDirectiveName()));
TRY_TO(TraverseOMPExecutableDirective(S));
}</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPParallelForDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPParallelForSimdDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPParallelMasterDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPParallelSectionsDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTaskDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTaskyieldDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPBarrierDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTaskwaitDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTaskgroupDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPCancellationPointDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPCancelDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPFlushDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPDepobjDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPScanDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPOrderedDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPAtomicDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTargetDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTargetDataDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTargetEnterDataDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTargetExitDataDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTargetParallelDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTargetParallelForDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTeamsDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTargetUpdateDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTaskLoopDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTaskLoopSimdDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPMasterTaskLoopDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPMasterTaskLoopSimdDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPParallelMasterTaskLoopDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPParallelMasterTaskLoopSimdDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPDistributeDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPDistributeParallelForDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPDistributeParallelForSimdDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPDistributeSimdDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTargetParallelForSimdDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTargetSimdDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTeamsDistributeDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTeamsDistributeSimdDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTeamsDistributeParallelForSimdDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTeamsDistributeParallelForDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTargetTeamsDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTargetTeamsDistributeDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTargetTeamsDistributeParallelForDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTargetTeamsDistributeParallelForSimdDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPTargetTeamsDistributeSimdDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPInteropDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPDispatchDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>

<macro><name>DEF_TRAVERSE_STMT</name><argument_list>(<argument>OMPMaskedDirective</argument>,
<argument>{ TRY_TO(TraverseOMPExecutableDirective(S)); }</argument>)</argument_list></macro>


<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TraverseOMPClause</name><argument_list>(<argument>OMPClause *C</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>C</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<switch>switch <condition>(<expr><call><name><name>C</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_CLANG_CLAUSE_CLASS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLAUSE_CLASS</name><parameter_list>(<parameter><type><name>Enum</name></type></parameter>, <parameter><type><name>Str</name></type></parameter>, <parameter><type><name>Class</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case llvm::omp::Clause::Enum: TRY_TO(Visit##Class(static_cast&lt;Class *&gt;(C))); break;</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLAUSE_NO_CLASS</name><parameter_list>(<parameter><type><name>Enum</name></type></parameter>, <parameter><type><name>Str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case llvm::omp::Clause::Enum: break;</cpp:value></cpp:define>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Frontend/OpenMP/OMP.inc"</cpp:file></cpp:include>
</block_content>}</block></switch>
<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPClauseWithPreInit</name><argument_list>(
<argument>OMPClauseWithPreInit *Node</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>-&gt;</operator><name>getPreInitStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPClauseWithPostUpdate</name><argument_list>(
<argument>OMPClauseWithPostUpdate *Node</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPreInit</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>-&gt;</operator><name>getPostUpdateExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPAllocatorClause</name><argument_list>(
<argument>OMPAllocatorClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getAllocator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPAllocateClause</name><argument_list>(<argument>OMPAllocateClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getAllocator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPIfClause</name><argument_list>(<argument>OMPIfClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPreInit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCondition</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPFinalClause</name><argument_list>(<argument>OMPFinalClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPreInit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCondition</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name>
<name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPNumThreadsClause</name><argument_list>(<argument>OMPNumThreadsClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPreInit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getNumThreads</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPSafelenClause</name><argument_list>(<argument>OMPSafelenClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getSafelen</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPSimdlenClause</name><argument_list>(<argument>OMPSimdlenClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getSimdlen</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPSizesClause</name><argument_list>(<argument>OMPSizesClause *C</argument>)</argument_list></macro> <block>{
<for>for <control>(<init><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name> <range>: <expr><call><name><name>C</name><operator>-&gt;</operator><name>getSizesRefs</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block></expr></expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPFullClause</name><argument_list>(<argument>OMPFullClause *C</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPPartialClause</name><argument_list>(<argument>OMPPartialClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getFactor</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name>
<name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPCollapseClause</name><argument_list>(<argument>OMPCollapseClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getNumForLoops</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPDefaultClause</name><argument_list>(<argument>OMPDefaultClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPProcBindClause</name><argument_list>(<argument>OMPProcBindClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPUnifiedAddressClause</name><argument_list>(
<argument>OMPUnifiedAddressClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPUnifiedSharedMemoryClause</name><argument_list>(
<argument>OMPUnifiedSharedMemoryClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPReverseOffloadClause</name><argument_list>(
<argument>OMPReverseOffloadClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPDynamicAllocatorsClause</name><argument_list>(
<argument>OMPDynamicAllocatorsClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPAtomicDefaultMemOrderClause</name><argument_list>(
<argument>OMPAtomicDefaultMemOrderClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name>
<name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPScheduleClause</name><argument_list>(<argument>OMPScheduleClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPreInit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getChunkSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPOrderedClause</name><argument_list>(<argument>OMPOrderedClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getNumForLoops</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPNowaitClause</name><argument_list>(<argument>OMPNowaitClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPUntiedClause</name><argument_list>(<argument>OMPUntiedClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name>
<name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPMergeableClause</name><argument_list>(<argument>OMPMergeableClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPReadClause</name><argument_list>(<argument>OMPReadClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPWriteClause</name><argument_list>(<argument>OMPWriteClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPUpdateClause</name><argument_list>(<argument>OMPUpdateClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPCaptureClause</name><argument_list>(<argument>OMPCaptureClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPSeqCstClause</name><argument_list>(<argument>OMPSeqCstClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPAcqRelClause</name><argument_list>(<argument>OMPAcqRelClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPAcquireClause</name><argument_list>(<argument>OMPAcquireClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPReleaseClause</name><argument_list>(<argument>OMPReleaseClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPRelaxedClause</name><argument_list>(<argument>OMPRelaxedClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPThreadsClause</name><argument_list>(<argument>OMPThreadsClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPSIMDClause</name><argument_list>(<argument>OMPSIMDClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPNogroupClause</name><argument_list>(<argument>OMPNogroupClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPInitClause</name><argument_list>(<argument>OMPInitClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPUseClause</name><argument_list>(<argument>OMPUseClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getInteropVar</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPDestroyClause</name><argument_list>(<argument>OMPDestroyClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getInteropVar</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPNovariantsClause</name><argument_list>(
<argument>OMPNovariantsClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPreInit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCondition</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPNocontextClause</name><argument_list>(
<argument>OMPNocontextClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPreInit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCondition</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPClauseList</name><argument_list>(<argument>T *Node</argument>)</argument_list></macro> <block>{
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>Node</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPInclusiveClause</name><argument_list>(
<argument>OMPInclusiveClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPExclusiveClause</name><argument_list>(
<argument>OMPExclusiveClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPPrivateClause</name><argument_list>(<argument>OMPPrivateClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>private_copies</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPFirstprivateClause</name><argument_list>(
<argument>OMPFirstprivateClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPreInit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>private_copies</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>inits</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPLastprivateClause</name><argument_list>(
<argument>OMPLastprivateClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPostUpdate</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>private_copies</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>source_exprs</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>destination_exprs</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>assignment_ops</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPSharedClause</name><argument_list>(<argument>OMPSharedClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPLinearClause</name><argument_list>(<argument>OMPLinearClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getStep</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCalcStep</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPostUpdate</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>privates</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>inits</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>updates</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>finals</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPAlignedClause</name><argument_list>(<argument>OMPAlignedClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getAlignment</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPCopyinClause</name><argument_list>(<argument>OMPCopyinClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>source_exprs</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>destination_exprs</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>assignment_ops</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPCopyprivateClause</name><argument_list>(
<argument>OMPCopyprivateClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>source_exprs</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>destination_exprs</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>assignment_ops</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name>
<name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPReductionClause</name><argument_list>(<argument>OMPReductionClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseNestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseDeclarationNameInfo</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getNameInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPostUpdate</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>privates</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>lhs_exprs</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>rhs_exprs</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>reduction_ops</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><call><name><name>C</name><operator>-&gt;</operator><name>getModifier</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPC_REDUCTION_inscan</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>copy_ops</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>copy_array_temps</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>copy_array_elems</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPTaskReductionClause</name><argument_list>(
<argument>OMPTaskReductionClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseNestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseDeclarationNameInfo</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getNameInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPostUpdate</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>privates</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>lhs_exprs</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>rhs_exprs</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>reduction_ops</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPInReductionClause</name><argument_list>(
<argument>OMPInReductionClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseNestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseDeclarationNameInfo</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getNameInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPostUpdate</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>privates</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>lhs_exprs</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>rhs_exprs</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>reduction_ops</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>taskgroup_descriptors</name></name><argument_list>()</argument_list></call></expr></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPFlushClause</name><argument_list>(<argument>OMPFlushClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPDepobjClause</name><argument_list>(<argument>OMPDepobjClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getDepobj</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPDependClause</name><argument_list>(<argument>OMPDependClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPDeviceClause</name><argument_list>(<argument>OMPDeviceClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPreInit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getDevice</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPMapClause</name><argument_list>(<argument>OMPMapClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPNumTeamsClause</name><argument_list>(
<argument>OMPNumTeamsClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPreInit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getNumTeams</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPThreadLimitClause</name><argument_list>(
<argument>OMPThreadLimitClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPreInit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getThreadLimit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPPriorityClause</name><argument_list>(
<argument>OMPPriorityClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPreInit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getPriority</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPGrainsizeClause</name><argument_list>(
<argument>OMPGrainsizeClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPreInit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getGrainsize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPNumTasksClause</name><argument_list>(
<argument>OMPNumTasksClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPreInit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getNumTasks</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPHintClause</name><argument_list>(<argument>OMPHintClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getHint</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPDistScheduleClause</name><argument_list>(
<argument>OMPDistScheduleClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPreInit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getChunkSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name>
<name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPDefaultmapClause</name><argument_list>(<argument>OMPDefaultmapClause *C</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPToClause</name><argument_list>(<argument>OMPToClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPFromClause</name><argument_list>(<argument>OMPFromClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPUseDevicePtrClause</name><argument_list>(
<argument>OMPUseDevicePtrClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPUseDeviceAddrClause</name><argument_list>(
<argument>OMPUseDeviceAddrClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPIsDevicePtrClause</name><argument_list>(
<argument>OMPIsDevicePtrClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPNontemporalClause</name><argument_list>(
<argument>OMPNontemporalClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseList</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>private_refs</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPOrderClause</name><argument_list>(<argument>OMPOrderClause *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPDetachClause</name><argument_list>(<argument>OMPDetachClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEventHandler</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPUsesAllocatorsClause</name><argument_list>(
<argument>OMPUsesAllocatorsClause *C</argument>)</argument_list></macro> <block>{
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>E</name> <init>= <expr><call><name><name>C</name><operator>-&gt;</operator><name>getNumberOfAllocators</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>&lt;</operator> <name>E</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><specifier>const</specifier> <name>OMPUsesAllocatorsClause</name><operator>::</operator><name>Data</name> <name>Data</name> <operator>=</operator> <call><name><name>C</name><operator>-&gt;</operator><name>getAllocatorData</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name><name>Data</name><operator>.</operator><name>Allocator</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name><name>Data</name><operator>.</operator><name>AllocatorTraits</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPAffinityClause</name><argument_list>(
<argument>OMPAffinityClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getModifier</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name> <range>: <expr><call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block></expr></expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>RecursiveASTVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>VisitOMPFilterClause</name><argument_list>(<argument>OMPFilterClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>VisitOMPClauseWithPreInit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>TRY_TO</name><argument_list>(<argument><expr><call><name>TraverseStmt</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getThreadID</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>


















<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DEF_TRAVERSE_STMT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TRAVERSE_STMT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TRAVERSE_STMT_BASE</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TRY_TO</name></cpp:undef>

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
