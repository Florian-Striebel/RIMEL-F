<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Frontend/CompilerInstance.h">







<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_FRONTEND_COMPILERINSTANCE_H_</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_FRONTEND_COMPILERINSTANCE_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTConsumer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Diagnostic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Frontend/CompilerInvocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Frontend/PCHContainerOperations.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Frontend/Utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/HeaderSearchOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/ModuleLoader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/IntrusiveRefCntPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/BuryPointer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/FileSystem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;list&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>raw_fd_ostream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Timer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TimerGroup</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CodeCompleteConsumer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DiagnosticsEngine</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DiagnosticConsumer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ExternalASTSource</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FileEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FileManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FrontendAction</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>InMemoryModuleCache</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Module</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Preprocessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Sema</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SourceManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TargetInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>DisableValidationForModuleKind</name></decl>;</decl_stmt>



















<decl_stmt><decl><type><name>class</name></type> <name>CompilerInstance</name> <range>: <expr><name>public</name> <name>ModuleLoader</name> <block>{

<expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CompilerInvocation</name></expr></argument>&gt;</argument_list></name> <name>Invocation</name></expr>;


<expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>DiagnosticsEngine</name></expr></argument>&gt;</argument_list></name> <name>Diagnostics</name></expr>;


<expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>TargetInfo</name></expr></argument>&gt;</argument_list></name> <name>Target</name></expr>;


<expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>TargetInfo</name></expr></argument>&gt;</argument_list></name> <name>AuxTarget</name></expr>;


<expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>FileManager</name></expr></argument>&gt;</argument_list></name> <name>FileMgr</name></expr>;


<expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>SourceManager</name></expr></argument>&gt;</argument_list></name> <name>SourceMgr</name></expr>;


<expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>InMemoryModuleCache</name></expr></argument>&gt;</argument_list></name> <name>ModuleCache</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Preprocessor</name></expr></argument>&gt;</argument_list></name> <name>PP</name></expr>;


<expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>ASTContext</name></expr></argument>&gt;</argument_list></name> <name>Context</name></expr>;


<expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>ExternalSemaSource</name></expr></argument>&gt;</argument_list></name> <name>ExternalSemaSrc</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTConsumer</name></expr></argument>&gt;</argument_list></name> <name>Consumer</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CodeCompleteConsumer</name></expr></argument>&gt;</argument_list></name> <name>CompletionConsumer</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Sema</name></expr></argument>&gt;</argument_list></name> <name>TheSema</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>TimerGroup</name></expr></argument>&gt;</argument_list></name> <name>FrontendTimerGroup</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Timer</name></expr></argument>&gt;</argument_list></name> <name>FrontendTimer</name></expr>;


<expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>ASTReader</name></expr></argument>&gt;</argument_list></name> <name>TheASTReader</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ModuleDependencyCollector</name></expr></argument>&gt;</argument_list></name> <name>ModuleDepCollector</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PCHContainerOperations</name></expr></argument>&gt;</argument_list></name> <name>ThePCHContainerOperations</name></expr>;

<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>DependencyCollector</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>DependencyCollectors</name></expr>;



<expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>less</name><argument_list type="generic">&lt;&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>BuiltModules</name></expr>;


<expr><name>bool</name> <name>DeleteBuiltModules</name> <operator>=</operator> <name>true</name></expr>;



<expr><name>SourceLocation</name> <name>LastModuleImportLoc</name></expr>;



<expr><name>ModuleLoadResult</name> <name>LastModuleImportResult</name></expr>;



<expr><name>bool</name> <name>BuildGlobalModuleIndex</name> <operator>=</operator> <name>false</name></expr>;


<expr><name>bool</name> <name>HaveFullGlobalModuleIndex</name> <operator>=</operator> <name>false</name></expr>;


<expr><name>bool</name> <name>DisableGeneratingGlobalModuleIndex</name> <operator>=</operator> <name>false</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>raw_ostream</name></expr></argument>&gt;</argument_list></name> <name>OwnedVerboseOutputStream</name></expr>;


<expr><name>raw_ostream</name> <operator>*</operator><name>VerboseOutputStream</name> <operator>=</operator> <operator>&amp;</operator><name>llvm</name><operator>::</operator><call><name>errs</name><argument_list>()</argument_list></call></expr>;






struct <expr><name>OutputFile</name> <block>{
<expr><name>std</name><operator>::</operator><name>string</name> <name>Filename</name></expr>;
<expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>sys</name><operator>::</operator><name>fs</name><operator>::</operator><name>TempFile</name></expr></argument>&gt;</argument_list></name> <name>File</name></expr>;

<macro><name>OutputFile</name><argument_list>(<argument>std::string filename</argument>, <argument>Optional&lt;llvm::sys::fs::TempFile&gt; file</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Filename</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>, <macro><name>File</name><argument_list>(<argument>std::move(file)</argument>)</argument_list></macro> <expr><block>{}</block></expr>
}</block></expr>;


<expr><name>std</name><operator>::</operator><name><name>list</name><argument_list type="generic">&lt;<argument><expr><name>OutputFile</name></expr></argument>&gt;</argument_list></name> <name>OutputFiles</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>raw_pwrite_stream</name></expr></argument>&gt;</argument_list></name> <name>OutputStream</name></expr>;

<expr><call><name>CompilerInstance</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CompilerInstance</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><name>void</name> <name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>CompilerInstance</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr>;
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>CompilerInstance</name><argument_list>(
<argument><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PCHContainerOperations</name></expr></argument>&gt;</argument_list></name> <name>PCHContainerOps</name> <operator>=</operator>
<name>std</name><operator>::</operator><call><name><name>make_shared</name><argument_list type="generic">&lt;<argument><expr><name>PCHContainerOperations</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>InMemoryModuleCache</name> <operator>*</operator><name>SharedModuleCache</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>~</operator><macro><name>CompilerInstance</name><argument_list>()</argument_list></macro> <name>override</name></expr>;































<expr><name>bool</name> <call><name>ExecuteAction</name><argument_list>(<argument><expr><name>FrontendAction</name> <operator>&amp;</operator><name>Act</name></expr></argument>)</argument_list></call></expr>;





<expr><name>bool</name> <macro><name>hasInvocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Invocation</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block>

<name>CompilerInvocation</name> <operator>&amp;</operator><macro><name>getInvocation</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Invocation</name> <operator>&amp;&amp;</operator> <literal type="string">"Compiler instance has no invocation!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>Invocation</name></expr>;</return>
}</block>


<name>void</name> <call><name>setInvocation</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CompilerInvocation</name></expr></argument>&gt;</argument_list></name> <name>Value</name></expr></argument>)</argument_list></call></expr>;


<expr><name>bool</name> <macro><name>shouldBuildGlobalModuleIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>void</name> <macro><name>setBuildGlobalModuleIndex</name><argument_list>(<argument>bool Build</argument>)</argument_list></macro> <block>{
<expr><name>BuildGlobalModuleIndex</name> <operator>=</operator> <name>Build</name></expr>;
}</block>





<name>AnalyzerOptionsRef</name> <macro><name>getAnalyzerOpts</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getAnalyzerOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>CodeGenOptions</name> <operator>&amp;</operator><macro><name>getCodeGenOpts</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getCodeGenOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>CodeGenOptions</name> <operator>&amp;</operator><macro><name>getCodeGenOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getCodeGenOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>DependencyOutputOptions</name> <operator>&amp;</operator><macro><name>getDependencyOutputOpts</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getDependencyOutputOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>DependencyOutputOptions</name> <operator>&amp;</operator><macro><name>getDependencyOutputOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getDependencyOutputOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>DiagnosticOptions</name> <operator>&amp;</operator><macro><name>getDiagnosticOpts</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getDiagnosticOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>DiagnosticOptions</name> <operator>&amp;</operator><macro><name>getDiagnosticOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getDiagnosticOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>FileSystemOptions</name> <operator>&amp;</operator><macro><name>getFileSystemOpts</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getFileSystemOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>FileSystemOptions</name> <operator>&amp;</operator><macro><name>getFileSystemOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getFileSystemOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>FrontendOptions</name> <operator>&amp;</operator><macro><name>getFrontendOpts</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getFrontendOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>FrontendOptions</name> <operator>&amp;</operator><macro><name>getFrontendOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getFrontendOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>HeaderSearchOptions</name> <operator>&amp;</operator><macro><name>getHeaderSearchOpts</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getHeaderSearchOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>HeaderSearchOptions</name> <operator>&amp;</operator><macro><name>getHeaderSearchOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getHeaderSearchOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>HeaderSearchOptions</name></expr></argument>&gt;</argument_list></name> <macro><name>getHeaderSearchOptsPtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getHeaderSearchOptsPtr</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>LangOptions</name> <operator>&amp;</operator><macro><name>getLangOpts</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><operator>*</operator><call><name><name>Invocation</name><operator>-&gt;</operator><name>getLangOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><macro><name>getLangOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>*</operator><call><name><name>Invocation</name><operator>-&gt;</operator><name>getLangOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>PreprocessorOptions</name> <operator>&amp;</operator><macro><name>getPreprocessorOpts</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getPreprocessorOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>PreprocessorOptions</name> <operator>&amp;</operator><macro><name>getPreprocessorOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getPreprocessorOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>PreprocessorOutputOptions</name> <operator>&amp;</operator><macro><name>getPreprocessorOutputOpts</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getPreprocessorOutputOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>PreprocessorOutputOptions</name> <operator>&amp;</operator><macro><name>getPreprocessorOutputOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getPreprocessorOutputOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>TargetOptions</name> <operator>&amp;</operator><macro><name>getTargetOpts</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getTargetOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>TargetOptions</name> <operator>&amp;</operator><macro><name>getTargetOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Invocation</name><operator>-&gt;</operator><name>getTargetOpts</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>





<name>bool</name> <macro><name>hasDiagnostics</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Diagnostics</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block>


<name>DiagnosticsEngine</name> <operator>&amp;</operator><macro><name>getDiagnostics</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Diagnostics</name> <operator>&amp;&amp;</operator> <literal type="string">"Compiler instance has no diagnostics!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>Diagnostics</name></expr>;</return>
}</block>


<name>void</name> <call><name>setDiagnostics</name><argument_list>(<argument><expr><name>DiagnosticsEngine</name> <operator>*</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;

<expr><name>DiagnosticConsumer</name> <operator>&amp;</operator><macro><name>getDiagnosticClient</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Diagnostics</name> <operator>&amp;&amp;</operator> <call><name><name>Diagnostics</name><operator>-&gt;</operator><name>getClient</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Compiler instance has no diagnostic client!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><call><name><name>Diagnostics</name><operator>-&gt;</operator><name>getClient</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>






<name>void</name> <call><name>setVerboseOutputStream</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;


<expr><name>void</name> <call><name>setVerboseOutputStream</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>raw_ostream</name></expr></argument>&gt;</argument_list></name> <name>Value</name></expr></argument>)</argument_list></call></expr>;


<expr><name>raw_ostream</name> <operator>&amp;</operator><macro><name>getVerboseOutputStream</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><operator>*</operator><name>VerboseOutputStream</name></expr>;</return>
}</block>





<name>bool</name> <macro><name>hasTarget</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Target</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block>

<name>TargetInfo</name> <operator>&amp;</operator><macro><name>getTarget</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Target</name> <operator>&amp;&amp;</operator> <literal type="string">"Compiler instance has no target!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>Target</name></expr>;</return>
}</block>


<name>void</name> <call><name>setTarget</name><argument_list>(<argument><expr><name>TargetInfo</name> <operator>*</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;





<expr><name>TargetInfo</name> <operator>*</operator><macro><name>getAuxTarget</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>AuxTarget</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>void</name> <call><name>setAuxTarget</name><argument_list>(<argument><expr><name>TargetInfo</name> <operator>*</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;


<expr><name>bool</name> <call><name>createTarget</name><argument_list>()</argument_list></call></expr>;





<expr><name>llvm</name><operator>::</operator><name>vfs</name><operator>::</operator><name>FileSystem</name> <operator>&amp;</operator><macro><name>getVirtualFileSystem</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;





<expr><name>bool</name> <macro><name>hasFileManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FileMgr</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block>


<name>FileManager</name> <operator>&amp;</operator><macro><name>getFileManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>FileMgr</name> <operator>&amp;&amp;</operator> <literal type="string">"Compiler instance has no file manager!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>FileMgr</name></expr>;</return>
}</block>

<name>void</name> <macro><name>resetAndLeakFileManager</name><argument_list>()</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><call><name>BuryPointer</name><argument_list>(<argument><expr><call><name><name>FileMgr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>FileMgr</name><operator>.</operator><name>resetWithoutRelease</name></name><argument_list>()</argument_list></call></expr>;
}</block>


<name>void</name> <call><name>setFileManager</name><argument_list>(<argument><expr><name>FileManager</name> <operator>*</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;





<expr><name>bool</name> <macro><name>hasSourceManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SourceMgr</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block>


<name>SourceManager</name> <operator>&amp;</operator><macro><name>getSourceManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>SourceMgr</name> <operator>&amp;&amp;</operator> <literal type="string">"Compiler instance has no source manager!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>SourceMgr</name></expr>;</return>
}</block>

<name>void</name> <macro><name>resetAndLeakSourceManager</name><argument_list>()</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><call><name>BuryPointer</name><argument_list>(<argument><expr><call><name><name>SourceMgr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>SourceMgr</name><operator>.</operator><name>resetWithoutRelease</name></name><argument_list>()</argument_list></call></expr>;
}</block>


<name>void</name> <call><name>setSourceManager</name><argument_list>(<argument><expr><name>SourceManager</name> <operator>*</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;





<expr><name>bool</name> <macro><name>hasPreprocessor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PP</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block>


<name>Preprocessor</name> <operator>&amp;</operator><macro><name>getPreprocessor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>PP</name> <operator>&amp;&amp;</operator> <literal type="string">"Compiler instance has no preprocessor!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>PP</name></expr>;</return>
}</block>

<name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Preprocessor</name></expr></argument>&gt;</argument_list></name> <macro><name>getPreprocessorPtr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>PP</name></expr>;</return> }</block>

<name>void</name> <macro><name>resetAndLeakPreprocessor</name><argument_list>()</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><macro><name>BuryPointer</name><argument_list>(<argument>new std::shared_ptr&lt;Preprocessor&gt;(PP)</argument>)</argument_list></macro></expr>;
}</block>


<name>void</name> <call><name>setPreprocessor</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Preprocessor</name></expr></argument>&gt;</argument_list></name> <name>Value</name></expr></argument>)</argument_list></call></expr>;





<expr><name>bool</name> <macro><name>hasASTContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Context</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block>

<name>ASTContext</name> <operator>&amp;</operator><macro><name>getASTContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Context</name> <operator>&amp;&amp;</operator> <literal type="string">"Compiler instance has no AST context!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>Context</name></expr>;</return>
}</block>

<name>void</name> <macro><name>resetAndLeakASTContext</name><argument_list>()</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><call><name>BuryPointer</name><argument_list>(<argument><expr><call><name><name>Context</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Context</name><operator>.</operator><name>resetWithoutRelease</name></name><argument_list>()</argument_list></call></expr>;
}</block>


<name>void</name> <call><name>setASTContext</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>*</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <call><name>setSema</name><argument_list>(<argument><expr><name>Sema</name> <operator>*</operator><name>S</name></expr></argument>)</argument_list></call></expr>;





<expr><name>bool</name> <macro><name>hasASTConsumer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>bool</name><operator>)</operator><name>Consumer</name></expr>;</return> }</block>

<name>ASTConsumer</name> <operator>&amp;</operator><macro><name>getASTConsumer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Consumer</name> <operator>&amp;&amp;</operator> <literal type="string">"Compiler instance has no AST consumer!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>Consumer</name></expr>;</return>
}</block>



<name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTConsumer</name></expr></argument>&gt;</argument_list></name> <macro><name>takeASTConsumer</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Consumer</name></expr></argument>)</argument_list></call></expr>;</return> }</block>



<name>void</name> <call><name>setASTConsumer</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTConsumer</name></expr></argument>&gt;</argument_list></name> <name>Value</name></expr></argument>)</argument_list></call></expr>;




<expr><name>bool</name> <macro><name>hasSema</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>bool</name><operator>)</operator><name>TheSema</name></expr>;</return> }</block>

<name>Sema</name> <operator>&amp;</operator><macro><name>getSema</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>TheSema</name> <operator>&amp;&amp;</operator> <literal type="string">"Compiler instance has no Sema object!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>TheSema</name></expr>;</return>
}</block>

<name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Sema</name></expr></argument>&gt;</argument_list></name> <call><name>takeSema</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <call><name>resetAndLeakSema</name><argument_list>()</argument_list></call></expr>;





<expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>ASTReader</name></expr></argument>&gt;</argument_list></name> <macro><name>getASTReader</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <call><name>setASTReader</name><argument_list>(<argument><expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>ASTReader</name></expr></argument>&gt;</argument_list></name> <name>Reader</name></expr></argument>)</argument_list></call></expr>;

<expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ModuleDependencyCollector</name></expr></argument>&gt;</argument_list></name> <macro><name>getModuleDepCollector</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <call><name>setModuleDepCollector</name><argument_list>(
<argument><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ModuleDependencyCollector</name></expr></argument>&gt;</argument_list></name> <name>Collector</name></expr></argument>)</argument_list></call></expr>;

<expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PCHContainerOperations</name></expr></argument>&gt;</argument_list></name> <macro><name>getPCHContainerOperations</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ThePCHContainerOperations</name></expr>;</return>
}</block>



<specifier>const</specifier> <name>PCHContainerWriter</name> <operator>&amp;</operator><macro><name>getPCHContainerWriter</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Invocation</name> <operator>&amp;&amp;</operator> <literal type="string">"cannot determine module format without invocation"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>StringRef</name> <name>Format</name> <operator>=</operator> <call><name>getHeaderSearchOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>ModuleFormat</name></expr>;
<expr><name>auto</name> <operator>*</operator><name>Writer</name> <operator>=</operator> <call><name><name>ThePCHContainerOperations</name><operator>-&gt;</operator><name>getWriterOrNull</name></name><argument_list>(<argument><expr><name>Format</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Writer</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>Diagnostics</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Diagnostics</name><operator>-&gt;</operator><name>Report</name></name><argument_list>(<argument><expr><name>diag</name><operator>::</operator><name>err_module_format_unhandled</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>Format</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><call><name>report_fatal_error</name><argument_list>(<argument><expr><literal type="string">"unknown module format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
return *Writer</block><empty_stmt>;</empty_stmt></if></if_stmt>
}</block>



<specifier>const</specifier> <name>PCHContainerReader</name> <operator>&amp;</operator><macro><name>getPCHContainerReader</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Invocation</name> <operator>&amp;&amp;</operator> <literal type="string">"cannot determine module format without invocation"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>StringRef</name> <name>Format</name> <operator>=</operator> <call><name>getHeaderSearchOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>ModuleFormat</name></expr>;
<expr><name>auto</name> <operator>*</operator><name>Reader</name> <operator>=</operator> <call><name><name>ThePCHContainerOperations</name><operator>-&gt;</operator><name>getReaderOrNull</name></name><argument_list>(<argument><expr><name>Format</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Reader</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>Diagnostics</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Diagnostics</name><operator>-&gt;</operator><name>Report</name></name><argument_list>(<argument><expr><name>diag</name><operator>::</operator><name>err_module_format_unhandled</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>Format</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><call><name>report_fatal_error</name><argument_list>(<argument><expr><literal type="string">"unknown module format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
return *Reader</block><empty_stmt>;</empty_stmt></if></if_stmt>
}</block>





<name>bool</name> <macro><name>hasCodeCompletionConsumer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>bool</name><operator>)</operator><name>CompletionConsumer</name></expr>;</return> }</block>

<name>CodeCompleteConsumer</name> <operator>&amp;</operator><macro><name>getCodeCompletionConsumer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>CompletionConsumer</name> <operator>&amp;&amp;</operator>
<literal type="string">"Compiler instance has no code completion consumer!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>CompletionConsumer</name></expr>;</return>
}</block>



<name>void</name> <call><name>setCodeCompletionConsumer</name><argument_list>(<argument><expr><name>CodeCompleteConsumer</name> <operator>*</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;





<expr><name>bool</name> <macro><name>hasFrontendTimer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>bool</name><operator>)</operator><name>FrontendTimer</name></expr>;</return> }</block>

<name>llvm</name><operator>::</operator><name>Timer</name> <operator>&amp;</operator><macro><name>getFrontendTimer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>FrontendTimer</name> <operator>&amp;&amp;</operator> <literal type="string">"Compiler instance has no frontend timer!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>FrontendTimer</name></expr>;</return>
}</block>









<name>void</name> <macro><name>clearOutputFiles</name><argument_list>(<argument>bool EraseFiles</argument>)</argument_list></macro></expr>;

















<expr><name>void</name> <macro><name>createDiagnostics</name><argument_list>(<argument>DiagnosticConsumer *Client = nullptr</argument>,
<argument>bool ShouldOwnClient = true</argument>)</argument_list></macro></expr>;



















<expr><specifier>static</specifier> <name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>DiagnosticsEngine</name></expr></argument>&gt;</argument_list></name>
<macro><name>createDiagnostics</name><argument_list>(<argument>DiagnosticOptions *Opts</argument>,
<argument>DiagnosticConsumer *Client = nullptr</argument>,
<argument>bool ShouldOwnClient = true</argument>,
<argument>const CodeGenOptions *CodeGenOpts = nullptr</argument>)</argument_list></macro></expr>;




<expr><name>FileManager</name> <operator>*</operator>
<call><name>createFileManager</name><argument_list>(<argument><expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>vfs</name><operator>::</operator><name>FileSystem</name></expr></argument>&gt;</argument_list></name> <name>VFS</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;


<expr><name>void</name> <call><name>createSourceManager</name><argument_list>(<argument><expr><name>FileManager</name> <operator>&amp;</operator><name>FileMgr</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <macro><name>createPreprocessor</name><argument_list>(<argument>TranslationUnitKind TUKind</argument>)</argument_list></macro></expr>;

<expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getSpecificModuleCachePath</name><argument_list>(<argument>StringRef ModuleHash</argument>)</argument_list></macro></expr>;
<expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getSpecificModuleCachePath</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>getSpecificModuleCachePath</name><argument_list>(<argument><expr><call><name>getInvocation</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getModuleHash</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>void</name> <call><name>createASTContext</name><argument_list>()</argument_list></call></expr>;



<expr><name>void</name> <macro><name>createPCHExternalASTSource</name><argument_list>(
<argument>StringRef Path</argument>, <argument>DisableValidationForModuleKind DisableValidation</argument>,
<argument>bool AllowPCHWithCompilerErrors</argument>, <argument>void *DeserializationListener</argument>,
<argument>bool OwnDeserializationListener</argument>)</argument_list></macro></expr>;




<expr><specifier>static</specifier> <name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>ASTReader</name></expr></argument>&gt;</argument_list></name> <macro><name>createPCHExternalASTSource</name><argument_list>(
<argument>StringRef Path</argument>, <argument>StringRef Sysroot</argument>,
<argument>DisableValidationForModuleKind DisableValidation</argument>,
<argument>bool AllowPCHWithCompilerErrors</argument>, <argument>Preprocessor &amp;PP</argument>,
<argument>InMemoryModuleCache &amp;ModuleCache</argument>, <argument>ASTContext &amp;Context</argument>,
<argument>const PCHContainerReader &amp;PCHContainerRdr</argument>,
<argument>ArrayRef&lt;std::shared_ptr&lt;ModuleFileExtension&gt;&gt; Extensions</argument>,
<argument>ArrayRef&lt;std::shared_ptr&lt;DependencyCollector&gt;&gt; DependencyCollectors</argument>,
<argument>void *DeserializationListener</argument>, <argument>bool OwnDeserializationListener</argument>,
<argument>bool Preamble</argument>, <argument>bool UseGlobalModuleIndex</argument>)</argument_list></macro></expr>;




<expr><name>void</name> <call><name>createCodeCompletionConsumer</name><argument_list>()</argument_list></call></expr>;



<expr><specifier>static</specifier> <name>CodeCompleteConsumer</name> <operator>*</operator><macro><name>createCodeCompletionConsumer</name><argument_list>(
<argument>Preprocessor &amp;PP</argument>, <argument>StringRef Filename</argument>, <argument>unsigned Line</argument>, <argument>unsigned Column</argument>,
<argument>const CodeCompleteOptions &amp;Opts</argument>, <argument>raw_ostream &amp;OS</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <macro><name>createSema</name><argument_list>(<argument>TranslationUnitKind TUKind</argument>,
<argument>CodeCompleteConsumer *CompletionConsumer</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <call><name>createFrontendTimer</name><argument_list>()</argument_list></call></expr>;










<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>raw_pwrite_stream</name></expr></argument>&gt;</argument_list></name> <macro><name>createDefaultOutputFile</name><argument_list>(
<argument>bool Binary = true</argument>, <argument>StringRef BaseInput = <literal type="string">""</literal></argument>, <argument>StringRef Extension = <literal type="string">""</literal></argument>,
<argument>bool RemoveFileOnSignal = true</argument>, <argument>bool CreateMissingDirectories = false</argument>,
<argument>bool ForceUseTemporary = false</argument>)</argument_list></macro></expr>;





<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>raw_pwrite_stream</name></expr></argument>&gt;</argument_list></name>
<macro><name>createOutputFile</name><argument_list>(<argument>StringRef OutputPath</argument>, <argument>bool Binary</argument>, <argument>bool RemoveFileOnSignal</argument>,
<argument>bool UseTemporary</argument>, <argument>bool CreateMissingDirectories = false</argument>)</argument_list></macro></expr>;

<expr><name>private</name><operator>:</operator>

















<name><name>Expected</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>raw_pwrite_stream</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<macro><name>createOutputFileImpl</name><argument_list>(<argument>StringRef OutputPath</argument>, <argument>bool Binary</argument>,
<argument>bool RemoveFileOnSignal</argument>, <argument>bool UseTemporary</argument>,
<argument>bool CreateMissingDirectories</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>raw_pwrite_stream</name></expr></argument>&gt;</argument_list></name> <call><name>createNullOutputFile</name><argument_list>()</argument_list></call></expr>;









<expr><name>bool</name> <call><name>InitializeSourceManager</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FrontendInputFile</name> <operator>&amp;</operator><name>Input</name></expr></argument>)</argument_list></call></expr>;





<expr><specifier>static</specifier> <name>bool</name> <call><name>InitializeSourceManager</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FrontendInputFile</name> <operator>&amp;</operator><name>Input</name></expr></argument>,
<argument><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diags</name></expr></argument>,
<argument><expr><name>FileManager</name> <operator>&amp;</operator><name>FileMgr</name></expr></argument>,
<argument><expr><name>SourceManager</name> <operator>&amp;</operator><name>SourceMgr</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <macro><name>setOutputStream</name><argument_list>(<argument>std::unique_ptr&lt;llvm::raw_pwrite_stream&gt; OutStream</argument>)</argument_list></macro> <block>{
<expr><name>OutputStream</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>OutStream</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>raw_pwrite_stream</name></expr></argument>&gt;</argument_list></name> <macro><name>takeOutputStream</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>OutputStream</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <call><name>createASTReader</name><argument_list>()</argument_list></call></expr>;

<expr><name>bool</name> <macro><name>loadModuleFile</name><argument_list>(<argument>StringRef FileName</argument>)</argument_list></macro></expr>;

<expr><name>private</name><operator>:</operator>











<name>ModuleLoadResult</name> <macro><name>findOrCompileModuleAndReadAST</name><argument_list>(<argument>StringRef ModuleName</argument>,
<argument>SourceLocation ImportLoc</argument>,
<argument>SourceLocation ModuleNameLoc</argument>,
<argument>bool IsInclusionDirective</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<name>ModuleLoadResult</name> <macro><name>loadModule</name><argument_list>(<argument>SourceLocation ImportLoc</argument>, <argument>ModuleIdPath Path</argument>,
<argument>Module::NameVisibilityKind Visibility</argument>,
<argument>bool IsInclusionDirective</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>void</name> <macro><name>createModuleFromSource</name><argument_list>(<argument>SourceLocation ImportLoc</argument>, <argument>StringRef ModuleName</argument>,
<argument>StringRef Source</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>void</name> <macro><name>makeModuleVisible</name><argument_list>(<argument>Module *Mod</argument>, <argument>Module::NameVisibilityKind Visibility</argument>,
<argument>SourceLocation ImportLoc</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>bool</name> <macro><name>hadModuleLoaderFatalFailure</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ModuleLoader</name><operator>::</operator><name>HadFatalFailure</name></expr>;</return>
}</block>

<name>GlobalModuleIndex</name> <operator>*</operator><macro><name>loadGlobalModuleIndex</name><argument_list>(<argument>SourceLocation TriggerLoc</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>bool</name> <macro><name>lookupMissingImports</name><argument_list>(<argument>StringRef Name</argument>, <argument>SourceLocation TriggerLoc</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>void</name> <macro><name>addDependencyCollector</name><argument_list>(<argument>std::shared_ptr&lt;DependencyCollector&gt; Listener</argument>)</argument_list></macro> <block>{
<expr><call><name><name>DependencyCollectors</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Listener</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <call><name>setExternalSemaSource</name><argument_list>(<argument><expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>ExternalSemaSource</name></expr></argument>&gt;</argument_list></name> <name>ESS</name></expr></argument>)</argument_list></call></expr>;

<expr><name>InMemoryModuleCache</name> <operator>&amp;</operator><macro><name>getModuleCache</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>ModuleCache</name></expr>;</return> }</block>
}</expr>;

}</block></expr></range></decl></decl_stmt></block_content></block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
