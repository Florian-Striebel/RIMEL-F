<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Parse/Parser.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_PARSE_PARSER_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_PARSE_PARSER_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Availability.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/BitmaskEnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenMPKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OperatorPrecedence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Specifiers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/CodeCompletionHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/Preprocessor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/DeclSpec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/Sema.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Frontend/OpenMP/OMPContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/PrettyStackTrace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/SaveAndRestore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stack&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>PragmaHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Scope</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BalancedDelimiterTracker</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CorrectionCandidateCallback</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DeclGroupRef</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DiagnosticBuilder</name></decl>;</decl_stmt>
<struct_decl>struct <name>LoopHint</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>Parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ParsingDeclRAIIObject</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ParsingDeclSpec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ParsingDeclarator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ParsingFieldDeclarator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ColonProtectionRAIIObject</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>InMessageExpressionRAIIObject</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>PoisonSEHIdentifiersRAIIObject</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>OMPClause</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCTypeParamList</name></decl>;</decl_stmt>
<struct_decl>struct <name>OMPTraitProperty</name>;</struct_decl>
<struct_decl>struct <name>OMPTraitSelector</name>;</struct_decl>
<struct_decl>struct <name>OMPTraitSet</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>OMPTraitInfo</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>class</name></type> <name>Parser</name> <range>: <expr><name>public</name> <name>CodeCompletionHandler</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ColonProtectionRAIIObject</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ParsingOpenMPDirectiveRAII</name></expr>;
<expr><name>friend</name> <name>class</name> <name>InMessageExpressionRAIIObject</name></expr>;
<expr><name>friend</name> <name>class</name> <name>PoisonSEHIdentifiersRAIIObject</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ObjCDeclContextSwitch</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ParenBraceBracketBalancer</name></expr>;
<expr><name>friend</name> <name>class</name> <name>BalancedDelimiterTracker</name></expr>;

<expr><name>Preprocessor</name> <operator>&amp;</operator><name>PP</name></expr>;



<expr><name>Token</name> <name>Tok</name></expr>;





<expr><name>SourceLocation</name> <name>PrevTokLocation</name></expr>;



<expr><name>PreferredTypeBuilder</name> <name>PreferredType</name></expr>;

<expr><name>unsigned</name> <name>short</name> <name>ParenCount</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><name>BracketCount</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><name>BraceCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>unsigned</name> <name>short</name> <name>MisplacedModuleBeginCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name>Sema</name> <operator>&amp;</operator><name>Actions</name></expr>;

<expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diags</name></expr>;


enum <expr><block>{ <expr><name>ScopeCacheSize</name> <operator>=</operator> <literal type="number">16</literal></expr> }</block></expr>;
<expr><name>unsigned</name> <name>NumCachedScopes</name></expr>;
<expr><name>Scope</name> <operator>*</operator><name><name>ScopeCache</name><index>[<expr><name>ScopeCacheSize</name></expr>]</index></name></expr>;




<expr><name>IdentifierInfo</name> <operator>*</operator><name>Ident__exception_code</name></expr>,
<expr><operator>*</operator><name>Ident___exception_code</name></expr>,
<expr><operator>*</operator><name>Ident_GetExceptionCode</name></expr>;

<expr><name>IdentifierInfo</name> <operator>*</operator><name>Ident__exception_info</name></expr>,
<expr><operator>*</operator><name>Ident___exception_info</name></expr>,
<expr><operator>*</operator><name>Ident_GetExceptionInfo</name></expr>;

<expr><name>IdentifierInfo</name> <operator>*</operator><name>Ident__abnormal_termination</name></expr>,
<expr><operator>*</operator><name>Ident___abnormal_termination</name></expr>,
<expr><operator>*</operator><name>Ident_AbnormalTermination</name></expr>;


<expr><name>IdentifierInfo</name> <operator>*</operator><name>Ident__except</name></expr>;
<expr><name>mutable</name> <name>IdentifierInfo</name> <operator>*</operator><name>Ident_sealed</name></expr>;
<expr><name>mutable</name> <name>IdentifierInfo</name> <operator>*</operator><name>Ident_abstract</name></expr>;



<expr><name>IdentifierInfo</name> <operator>*</operator><name>Ident_super</name></expr>;



<expr><name>IdentifierInfo</name> <operator>*</operator><name>Ident_vector</name></expr>;
<expr><name>IdentifierInfo</name> <operator>*</operator><name>Ident_bool</name></expr>;
<expr><name>IdentifierInfo</name> <operator>*</operator><name>Ident_Bool</name></expr>;


<expr><name>IdentifierInfo</name> <operator>*</operator><name>Ident_pixel</name></expr>;


<expr><name>IdentifierInfo</name> <operator>*</operator><name>Ident_instancetype</name></expr>;


<expr><name>IdentifierInfo</name> <operator>*</operator><name>Ident_introduced</name></expr>;


<expr><name>IdentifierInfo</name> <operator>*</operator><name>Ident_deprecated</name></expr>;


<expr><name>IdentifierInfo</name> <operator>*</operator><name>Ident_obsoleted</name></expr>;


<expr><name>IdentifierInfo</name> <operator>*</operator><name>Ident_unavailable</name></expr>;


<expr><name>IdentifierInfo</name> <operator>*</operator><name>Ident_message</name></expr>;


<expr><name>IdentifierInfo</name> <operator>*</operator><name>Ident_strict</name></expr>;


<expr><name>IdentifierInfo</name> <operator>*</operator><name>Ident_replacement</name></expr>;


<expr><name>IdentifierInfo</name> <operator>*</operator><name>Ident_language</name></expr>, <expr><operator>*</operator><name>Ident_defined_in</name></expr>,
<expr><operator>*</operator><name>Ident_generated_declaration</name></expr>;


<expr><name>mutable</name> <name>IdentifierInfo</name> <operator>*</operator><name>Ident_final</name></expr>;
<expr><name>mutable</name> <name>IdentifierInfo</name> <operator>*</operator><name>Ident_GNU_final</name></expr>;
<expr><name>mutable</name> <name>IdentifierInfo</name> <operator>*</operator><name>Ident_override</name></expr>;


<expr><name>mutable</name> <name>IdentifierInfo</name> <operator>*</operator><name>Ident_import</name></expr>;
<expr><name>mutable</name> <name>IdentifierInfo</name> <operator>*</operator><name>Ident_module</name></expr>;



<expr><name>llvm</name><operator>::</operator><name><name>SmallDenseMap</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name></expr></argument>&gt;</argument_list></name> <name>RevertibleTypeTraits</name></expr>;

<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>AlignHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>GCCVisibilityHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>OptionsHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>PackHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>MSStructHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>UnusedHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>WeakHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>RedefineExtnameHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>FPContractHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>OpenCLExtensionHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>OpenMPHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>PCSectionHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>MSCommentHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>MSDetectMismatchHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>FloatControlHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>MSPointersToMembers</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>MSVtorDisp</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>MSInitSeg</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>MSDataSeg</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>MSBSSSeg</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>MSConstSeg</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>MSCodeSeg</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>MSSection</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>MSRuntimeChecks</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>MSIntrinsic</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>MSOptimize</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>CUDAForceHostDeviceHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>OptimizeHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>LoopHintHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>UnrollHintHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>NoUnrollHintHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>UnrollAndJamHintHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>NoUnrollAndJamHintHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>FPHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>STDCFenvAccessHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>STDCFenvRoundHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>STDCCXLIMITHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>STDCUnknownHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>AttributePragmaHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>MaxTokensHerePragmaHandler</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name> <name>MaxTokensTotalPragmaHandler</name></expr>;

<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CommentHandler</name></expr></argument>&gt;</argument_list></name> <name>CommentSemaHandler</name></expr>;





<expr><name>bool</name> <name>GreaterThanIsOperator</name></expr>;





<expr><name>bool</name> <name>ColonIsSacred</name></expr>;


<expr><name>bool</name> <name>OpenMPDirectiveParsing</name> <operator>=</operator> <name>false</name></expr>;






<expr><name>bool</name> <name>InMessageExpression</name></expr>;




<expr><name>bool</name> <name>CalledSignatureHelp</name> <operator>=</operator> <name>false</name></expr>;


<expr><name>unsigned</name> <name>TemplateParameterDepth</name></expr>;


<expr><name>OpenMPClauseKind</name> <name>OMPClauseKind</name> <operator>=</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_unknown</name></expr>;


<expr><name>class</name> <name>TemplateParameterDepthRAII</name> <block>{
<expr><name>unsigned</name> <operator>&amp;</operator><name>Depth</name></expr>;
<expr><name>unsigned</name> <name>AddedLevels</name></expr>;
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>TemplateParameterDepthRAII</name><argument_list>(<argument><expr><name>unsigned</name> <operator>&amp;</operator><name>Depth</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Depth</name><argument_list>(<argument><expr><name>Depth</name></expr></argument>)</argument_list></call></expr>, <macro><name>AddedLevels</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro> <expr><block>{}</block>

<operator>~</operator><macro><name>TemplateParameterDepthRAII</name><argument_list>()</argument_list></macro> <block>{
<expr><name>Depth</name> <operator>-=</operator> <name>AddedLevels</name></expr>;
}</block>

<name>void</name> <name>operator</name><operator>++</operator><operator>(</operator><operator>)</operator> <block>{
<expr><operator>++</operator><name>Depth</name></expr>;
<expr><operator>++</operator><name>AddedLevels</name></expr>;
}</block>
<name>void</name> <macro><name>addDepth</name><argument_list>(<argument>unsigned D</argument>)</argument_list></macro> <block>{
<expr><name>Depth</name> <operator>+=</operator> <name>D</name></expr>;
<expr><name>AddedLevels</name> <operator>+=</operator> <name>D</name></expr>;
}</block>
<name>void</name> <macro><name>setAddedDepth</name><argument_list>(<argument>unsigned D</argument>)</argument_list></macro> <block>{
<expr><name>Depth</name> <operator>=</operator> <name>Depth</name> <operator>-</operator> <name>AddedLevels</name> <operator>+</operator> <name>D</name></expr>;
<expr><name>AddedLevels</name> <operator>=</operator> <name>D</name></expr>;
}</block>

<name>unsigned</name> <macro><name>getDepth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Depth</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>getOriginalDepth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Depth</name> <operator>-</operator> <name>AddedLevels</name></expr>;</return> }</block>
}</expr>;


<expr><name>AttributeFactory</name> <name>AttrFactory</name></expr>;



<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>TemplateIdAnnotation</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>TemplateIds</name></expr>;

<expr><name>void</name> <macro><name>MaybeDestroyTemplateIds</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>TemplateIds</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>eof</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>PP</name><operator>.</operator><name>mightHavePendingAnnotationTokens</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>DestroyTemplateIds</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>
<name>void</name> <call><name>DestroyTemplateIds</name><argument_list>()</argument_list></call></expr>;



struct <expr><name>DestroyTemplateIdAnnotationsRAIIObj</name> <block>{
<expr><name>Parser</name> <operator>&amp;</operator><name>Self</name></expr>;

<expr><call><name>DestroyTemplateIdAnnotationsRAIIObj</name><argument_list>(<argument><expr><name>Parser</name> <operator>&amp;</operator><name>Self</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>Self</name><argument_list>(<argument>Self</argument>)</argument_list></macro> <block>{}</block>
<operator>~</operator><macro><name>DestroyTemplateIdAnnotationsRAIIObj</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name><name>Self</name><operator>.</operator><name>MaybeDestroyTemplateIds</name></name><argument_list>()</argument_list></call></expr>; }</block></expr>
}</block></expr>;


<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>TentativelyDeclaredIdentifiers</name></expr>;











struct <expr><name>AngleBracketTracker</name> <block>{


enum <expr><name>Priority</name> <operator>:</operator> <name>unsigned</name> <name>short</name> <block>{

<expr><name>PotentialTypo</name> <operator>=</operator> <literal type="number">0x0</literal></expr>,

<expr><name>DependentName</name> <operator>=</operator> <literal type="number">0x2</literal></expr>,


<expr><name>SpaceBeforeLess</name> <operator>=</operator> <literal type="number">0x0</literal></expr>,

<expr><name>NoSpaceBeforeLess</name> <operator>=</operator> <literal type="number">0x1</literal></expr>,

<macro><name>LLVM_MARK_AS_BITMASK_ENUM</name><argument_list>( <argument>DependentName</argument>)</argument_list></macro>
}</block></expr>;

struct <expr><name>Loc</name> <block>{
<expr><name>Expr</name> <operator>*</operator><name>TemplateName</name></expr>;
<expr><name>SourceLocation</name> <name>LessLoc</name></expr>;
<expr><name>AngleBracketTracker</name><operator>::</operator><name>Priority</name> <name>Priority</name></expr>;
<expr><name>unsigned</name> <name>short</name> <name>ParenCount</name></expr>, <expr><name>BracketCount</name></expr>, <expr><name>BraceCount</name></expr>;

<expr><name>bool</name> <macro><name>isActive</name><argument_list>(<argument>Parser &amp;P</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>P</name><operator>.</operator><name>ParenCount</name></name> <operator>==</operator> <name>ParenCount</name> <operator>&amp;&amp;</operator> <name><name>P</name><operator>.</operator><name>BracketCount</name></name> <operator>==</operator> <name>BracketCount</name> <operator>&amp;&amp;</operator>
<name><name>P</name><operator>.</operator><name>BraceCount</name></name> <operator>==</operator> <name>BraceCount</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isActiveOrNested</name><argument_list>(<argument>Parser &amp;P</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isActive</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>P</name><operator>.</operator><name>ParenCount</name></name> <operator>&gt;</operator> <name>ParenCount</name> <operator>||</operator>
<name><name>P</name><operator>.</operator><name>BracketCount</name></name> <operator>&gt;</operator> <name>BracketCount</name> <operator>||</operator> <name><name>P</name><operator>.</operator><name>BraceCount</name></name> <operator>&gt;</operator> <name>BraceCount</name></expr>;</return>
}</block>
}</expr>;

<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Loc</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>Locs</name></expr>;






<expr><name>void</name> <macro><name>add</name><argument_list>(<argument>Parser &amp;P</argument>, <argument>Expr *TemplateName</argument>, <argument>SourceLocation LessLoc</argument>,
<argument>Priority Prio</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Locs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Locs</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isActive</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Locs</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>Priority</name> <operator>&lt;=</operator> <name>Prio</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Locs</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>TemplateName</name> <operator>=</operator> <name>TemplateName</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Locs</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>LessLoc</name> <operator>=</operator> <name>LessLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Locs</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>Priority</name> <operator>=</operator> <name>Prio</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
} else <block>{<block_content>
<macro><name>Locs</name></macro><expr_stmt><expr><operator>.</operator><macro><name>push_back</name><argument_list>(<argument>{TemplateName</argument>, <argument>LessLoc</argument>, <argument>Prio</argument>,
<argument>P.ParenCount</argument>, <argument>P.BracketCount</argument>, <argument>P.BraceCount}</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}




void clear(Parser &amp;P</block></block></if></if_stmt>)</block_content> <block>{<block_content>
<while>while <condition>(<expr><operator>!</operator><call><name><name>Locs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Locs</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isActiveOrNested</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Locs</name><operator>.</operator><name>pop_back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<expr_stmt/>}</block_content>



Loc *getCurrent(Parser &amp;P</block></block></if></if_stmt>) <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Locs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Locs</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isActive</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>&amp;</operator><call><name><name>Locs</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></block></expr>
<return>return <expr><name>nullptr</name></expr>;</return>
}</block>
}</expr>;

<expr><name>AngleBracketTracker</name> <name>AngleBrackets</name></expr>;

<expr><name>IdentifierInfo</name> <operator>*</operator><call><name>getSEHExceptKeyword</name><argument_list>()</argument_list></call></expr>;






<expr><name>bool</name> <name>ParsingInObjCContainer</name></expr>;





<expr><name>bool</name> <name>SkipFunctionBodies</name></expr>;




<expr><name>SourceLocation</name> <name>ExprStatementTokLoc</name></expr>;


enum <expr><name>class</name> <name>ParsedStmtContext</name> <block>{


<expr><name>AllowDeclarationsInC</name> <operator>=</operator> <literal type="number">0x1</literal></expr>,

<expr><name>AllowStandaloneOpenMPDirectives</name> <operator>=</operator> <literal type="number">0x2</literal></expr>,

<expr><name>InStmtExpr</name> <operator>=</operator> <literal type="number">0x4</literal></expr>,


<expr><name>SubStmt</name> <operator>=</operator> <literal type="number">0</literal></expr>,

<expr><name>Compound</name> <operator>=</operator> <name>AllowDeclarationsInC</name> <operator>|</operator> <name>AllowStandaloneOpenMPDirectives</name></expr>,

<macro><name>LLVM_MARK_AS_BITMASK_ENUM</name><argument_list>(<argument>InStmtExpr</argument>)</argument_list></macro>
}</block></expr>;




<expr><name>StmtResult</name> <macro><name>handleExprStmt</name><argument_list>(<argument>ExprResult E</argument>, <argument>ParsedStmtContext StmtCtx</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>Parser</name><argument_list>(<argument>Preprocessor &amp;PP</argument>, <argument>Sema &amp;Actions</argument>, <argument>bool SkipFunctionBodies</argument>)</argument_list></macro></expr>;
<expr><operator>~</operator><macro><name>Parser</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><macro><name>getLangOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>PP</name><operator>.</operator><name>getLangOpts</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>TargetInfo</name> <operator>&amp;</operator><macro><name>getTargetInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>PP</name><operator>.</operator><name>getTargetInfo</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>Preprocessor</name> <operator>&amp;</operator><macro><name>getPreprocessor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PP</name></expr>;</return> }</block>
<name>Sema</name> <operator>&amp;</operator><macro><name>getActions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Actions</name></expr>;</return> }</block>
<name>AttributeFactory</name> <operator>&amp;</operator><macro><name>getAttrFactory</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>AttrFactory</name></expr>;</return> }</block>

<specifier>const</specifier> <name>Token</name> <operator>&amp;</operator><macro><name>getCurToken</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Tok</name></expr>;</return> }</block>
<name>Scope</name> <operator>*</operator><macro><name>getCurScope</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Actions</name><operator>.</operator><name>getCurScope</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>incrementMSManglingNumber</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Actions</name><operator>.</operator><name>incrementMSManglingNumber</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>Decl</name> <operator>*</operator><macro><name>getObjCDeclContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Actions</name><operator>.</operator><name>getObjCDeclContext</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr>



<typedef>typedef <type><name><name>OpaquePtr</name><argument_list type="generic">&lt;<argument><expr><name>DeclGroupRef</name></expr></argument>&gt;</argument_list></name></type> <name>DeclGroupPtrTy</name>;</typedef></block></expr>
<typedef>typedef <type><name><name>OpaquePtr</name><argument_list type="generic">&lt;<argument><expr><name>TemplateName</name></expr></argument>&gt;</argument_list></name></type> <name>TemplateTy</name>;</typedef></block></expr>

<typedef>typedef <type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>TemplateParameterList</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>TemplateParameterLists</name>;</typedef></block></expr></range></decl></decl_stmt>

<typedef>typedef <expr_stmt><expr><name>Sema</name><operator>::</operator><name>FullExprArg</name> <name>FullExprArg</name></expr>;</expr_stmt></typedef>





<function_decl><type><name>void</name></type> <name>Initialize</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>ParseFirstTopLevelDecl</name><parameter_list>(<parameter><decl><type><name>DeclGroupPtrTy</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>ParseTopLevelDecl</name><parameter_list>(<parameter><decl><type><name>DeclGroupPtrTy</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsFirstDecl</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>bool</name></type> <name>ParseTopLevelDecl</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DeclGroupPtrTy</name></type> <name>Result</name></decl>;</decl_stmt>
<return>return <expr><call><name>ParseTopLevelDecl</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>SourceLocation</name></type> <name>ConsumeToken</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isTokenSpecial</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Should consume special tokens with Consume*Token"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>PrevTokLocation</name> <operator>=</operator> <call><name><name>Tok</name><operator>.</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>PP</name><operator>.</operator><name>Lex</name></name><argument_list>(<argument><expr><name>Tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>PrevTokLocation</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>bool</name></type> <name>TryConsumeToken</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Expected</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>isNot</name></name><argument_list>(<argument><expr><name>Expected</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isTokenSpecial</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Should consume special tokens with Consume*Token"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>PrevTokLocation</name> <operator>=</operator> <call><name><name>Tok</name><operator>.</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>PP</name><operator>.</operator><name>Lex</name></name><argument_list>(<argument><expr><name>Tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>TryConsumeToken</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Expected</name></expr></argument>, <argument><expr><name>SourceLocation</name> <operator>&amp;</operator><name>Loc</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TryConsumeToken</name><argument_list>(<argument><expr><name>Expected</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>Loc</name> <operator>=</operator> <name>PrevTokLocation</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<function><type><name>SourceLocation</name></type> <name>ConsumeAnyToken</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>ConsumeCodeCompletionTok</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>isTokenParen</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ConsumeParen</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isTokenBracket</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ConsumeBracket</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isTokenBrace</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ConsumeBrace</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isTokenStringLiteral</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ConsumeStringToken</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>code_completion</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><name>ConsumeCodeCompletionTok</name></expr> ?</condition><then> <expr><call><name>ConsumeCodeCompletionToken</name><argument_list>()</argument_list></call></expr>
</then><else>: <expr><call><name>handleUnexpectedCodeCompletionToken</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>isAnnotation</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ConsumeAnnotationToken</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>ConsumeToken</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>SourceLocation</name></type> <name>getEndOfPreviousToken</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>PP</name><operator>.</operator><name>getLocForEndOfToken</name></name><argument_list>(<argument><expr><name>PrevTokLocation</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>getNullabilityKeyword</name><parameter_list>(<parameter><decl><type><name>NullabilityKind</name></type> <name>nullability</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>Actions</name><operator>.</operator><name>getNullabilityKeyword</name></name><argument_list>(<argument><expr><name>nullability</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<label><name>private</name>:</label>





<expr_stmt><expr><name>bool</name> <macro><name>isTokenParen</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Tok</name><operator>.</operator><name>isOneOf</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>l_paren</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>r_paren</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isTokenBracket</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Tok</name><operator>.</operator><name>isOneOf</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>l_square</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>r_square</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isTokenBrace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Tok</name><operator>.</operator><name>isOneOf</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>l_brace</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>r_brace</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isTokenStringLiteral</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>tok</name><operator>::</operator><call><name>isStringLiteral</name><argument_list>(<argument><expr><call><name><name>Tok</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isTokenSpecial</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isTokenStringLiteral</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isTokenParen</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isTokenBracket</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name>isTokenBrace</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>code_completion</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>Tok</name><operator>.</operator><name>isAnnotation</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<function_decl><type><name>bool</name></type> <name>isTokenEqualOrEqualTypo</name><parameter_list>()</parameter_list>;</function_decl>



<function><type><name>void</name></type> <name>UnconsumeToken</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Consumed</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>Token</name></type> <name>Next</name> <init>= <expr><name>Tok</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>PP</name><operator>.</operator><name>EnterToken</name></name><argument_list>(<argument><expr><name>Consumed</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>PP</name><operator>.</operator><name>Lex</name></name><argument_list>(<argument><expr><name>Tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>PP</name><operator>.</operator><name>EnterToken</name></name><argument_list>(<argument><expr><name>Next</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>SourceLocation</name></type> <name>ConsumeAnnotationToken</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Tok</name><operator>.</operator><name>isAnnotation</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"wrong consume method"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name> <init>= <expr><call><name><name>Tok</name><operator>.</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>PrevTokLocation</name> <operator>=</operator> <call><name><name>Tok</name><operator>.</operator><name>getAnnotationEndLoc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>PP</name><operator>.</operator><name>Lex</name></name><argument_list>(<argument><expr><name>Tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Loc</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>SourceLocation</name></type> <name>ConsumeParen</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isTokenParen</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"wrong consume method"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>tok</name><operator>::</operator><name>l_paren</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>ParenCount</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ParenCount</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>AngleBrackets</name><operator>.</operator><name>clear</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>ParenCount</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>PrevTokLocation</name> <operator>=</operator> <call><name><name>Tok</name><operator>.</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>PP</name><operator>.</operator><name>Lex</name></name><argument_list>(<argument><expr><name>Tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>PrevTokLocation</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>SourceLocation</name></type> <name>ConsumeBracket</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isTokenBracket</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"wrong consume method"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>tok</name><operator>::</operator><name>l_square</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>BracketCount</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>BracketCount</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>AngleBrackets</name><operator>.</operator><name>clear</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>BracketCount</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>PrevTokLocation</name> <operator>=</operator> <call><name><name>Tok</name><operator>.</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>PP</name><operator>.</operator><name>Lex</name></name><argument_list>(<argument><expr><name>Tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>PrevTokLocation</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>SourceLocation</name></type> <name>ConsumeBrace</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isTokenBrace</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"wrong consume method"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>tok</name><operator>::</operator><name>l_brace</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>BraceCount</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>BraceCount</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>AngleBrackets</name><operator>.</operator><name>clear</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>BraceCount</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>PrevTokLocation</name> <operator>=</operator> <call><name><name>Tok</name><operator>.</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>PP</name><operator>.</operator><name>Lex</name></name><argument_list>(<argument><expr><name>Tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>PrevTokLocation</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>SourceLocation</name></type> <name>ConsumeStringToken</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isTokenStringLiteral</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Should only consume string literals with this method"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>PrevTokLocation</name> <operator>=</operator> <call><name><name>Tok</name><operator>.</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>PP</name><operator>.</operator><name>Lex</name></name><argument_list>(<argument><expr><name>Tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>PrevTokLocation</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>SourceLocation</name></type> <name>ConsumeCodeCompletionToken</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>code_completion</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>PrevTokLocation</name> <operator>=</operator> <call><name><name>Tok</name><operator>.</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>PP</name><operator>.</operator><name>Lex</name></name><argument_list>(<argument><expr><name>Tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>PrevTokLocation</name></expr>;</return>
</block_content>}</block></function>






<function_decl><type><name>SourceLocation</name></type> <name>handleUnexpectedCodeCompletionToken</name><parameter_list>()</parameter_list>;</function_decl>



<function><type><name>void</name></type> <name>cutOffParsing</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>PP</name><operator>.</operator><name>isCodeCompletionEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>PP</name><operator>.</operator><name>setCodeCompletionReached</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>Tok</name><operator>.</operator><name>setKind</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>eof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name>bool</name></type> <name>isEofOrEom</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Kind</name> <operator>=</operator> <call><name><name>Tok</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Kind</name> <operator>==</operator> <name>tok</name><operator>::</operator><name>eof</name> <operator>||</operator> <name>Kind</name> <operator>==</operator> <name>tok</name><operator>::</operator><name>annot_module_begin</name> <operator>||</operator>
<name>Kind</name> <operator>==</operator> <name>tok</name><operator>::</operator><name>annot_module_end</name> <operator>||</operator> <name>Kind</name> <operator>==</operator> <name>tok</name><operator>::</operator><name>annot_module_include</name></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name>bool</name></type> <name>isFoldOperator</name><argument_list>(<argument><expr><name>prec</name><operator>::</operator><name>Level</name> <name>Level</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>isFoldOperator</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Kind</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>initializePragmaHandlers</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>resetPragmaHandlers</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>HandlePragmaUnused</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>HandlePragmaVisibility</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>HandlePragmaPack</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>HandlePragmaMSStruct</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>HandlePragmaMSPointersToMembers</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>HandlePragmaMSVtorDisp</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>HandlePragmaMSPragma</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>HandlePragmaMSSection</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>PragmaName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PragmaLocation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>HandlePragmaMSSegment</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>PragmaName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PragmaLocation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>HandlePragmaMSInitSeg</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>PragmaName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PragmaLocation</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>HandlePragmaAlign</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>HandlePragmaDump</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>HandlePragmaWeak</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>HandlePragmaWeakAlias</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>HandlePragmaRedefineExtname</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>HandlePragmaFPContract</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>HandlePragmaFEnvAccess</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>HandlePragmaFEnvRound</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>HandlePragmaFloatControl</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>HandlePragmaFP</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>HandlePragmaOpenCLExtension</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>StmtResult</name></type> <name>HandlePragmaCaptured</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>HandlePragmaLoopHint</name><parameter_list>(<parameter><decl><type><name>LoopHint</name> <modifier>&amp;</modifier></type><name>Hint</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>bool</name></type> <name>ParsePragmaAttributeSubjectMatchRuleSet</name><argument_list>(
<argument><expr><name>attr</name><operator>::</operator><name>ParsedSubjectMatchRuleSet</name> <operator>&amp;</operator><name>SubjectMatchRules</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <operator>&amp;</operator><name>AnyLoc</name></expr></argument>, <argument><expr><name>SourceLocation</name> <operator>&amp;</operator><name>LastMatchRuleEndLoc</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>HandlePragmaAttribute</name><parameter_list>()</parameter_list>;</function_decl>








<function><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>GetLookAheadToken</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>N</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>N</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>eof</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Tok</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>PP</name><operator>.</operator><name>LookAhead</name></name><argument_list>(<argument><expr><name>N</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<label><name>public</name>:</label>


<function><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>NextToken</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>PP</name><operator>.</operator><name>LookAhead</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>TypeResult</name></type> <name>getTypeAnnotation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Tok</name><operator>.</operator><name>getAnnotationValue</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>TypeError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>ParsedType</name><operator>::</operator><call><name>getFromOpaquePtr</name><argument_list>(<argument><expr><call><name><name>Tok</name><operator>.</operator><name>getAnnotationValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<label><name>private</name>:</label>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setTypeAnnotation</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>, <parameter><decl><type><name>TypeResult</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name><name>T</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>T</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"produced a valid-but-null type annotation?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Tok</name><operator>.</operator><name>setAnnotationValue</name></name><argument_list>(<argument><expr><ternary><condition><expr><call><name><name>T</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>nullptr</name></expr> </then><else>: <expr><call><name><name>T</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAsOpaquePtr</name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>getNonTypeAnnotation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Tok</name><operator>.</operator><name>getAnnotationValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>setNonTypeAnnotation</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ND</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>Tok</name><operator>.</operator><name>setAnnotationValue</name></name><argument_list>(<argument><expr><name>ND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>getIdentifierAnnotation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Tok</name><operator>.</operator><name>getAnnotationValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>setIdentifierAnnotation</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ND</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>Tok</name><operator>.</operator><name>setAnnotationValue</name></name><argument_list>(<argument><expr><name>ND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>ExprResult</name></type> <name>getExprAnnotation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>ExprResult</name><operator>::</operator><call><name>getFromOpaquePointer</name><argument_list>(<argument><expr><call><name><name>Tok</name><operator>.</operator><name>getAnnotationValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>setExprAnnotation</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name></type> <name>ER</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>Tok</name><operator>.</operator><name>setAnnotationValue</name></name><argument_list>(<argument><expr><call><name><name>ER</name><operator>.</operator><name>getAsOpaquePointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<label><name>public</name>:</label>


<function_decl><type><name>bool</name></type> <name>TryAnnotateTypeOrScopeToken</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>TryAnnotateTypeOrScopeTokenAfterScopeSpec</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsNewScope</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>TryAnnotateCXXScopeToken</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>EnteringContext</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>bool</name></type> <name>MightBeCXXScopeToken</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>identifier</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>coloncolon</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>annot_template_id</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>NextToken</name><argument_list>()</argument_list></call><operator>.</operator><call><name>is</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>coloncolon</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>kw_decltype</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>kw___super</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>TryAnnotateOptionalCXXScopeToken</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>EnteringContext</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MightBeCXXScopeToken</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>TryAnnotateCXXScopeToken</name><argument_list>(<argument><expr><name>EnteringContext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<label><name>private</name>:</label>
<enum>enum <name>AnnotatedNameKind</name> <block>{

<decl><name>ANK_Error</name></decl>,

<decl><name>ANK_TentativeDecl</name></decl>,

<decl><name>ANK_TemplateName</name></decl>,

<decl><name>ANK_Unresolved</name></decl>,

<decl><name>ANK_Success</name></decl>
}</block>;</enum>
<function_decl><type><name>AnnotatedNameKind</name></type> <name>TryAnnotateName</name><parameter_list>(<parameter><decl><type><name>CorrectionCandidateCallback</name> <modifier>*</modifier></type><name>CCC</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AnnotateScopeToken</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsNewAnnotation</name></decl></parameter>)</parameter_list>;</function_decl>




<function><type><name>bool</name></type> <name>TryAltiVecToken</name><parameter_list>(<parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>isInvalid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>AltiVec</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>ZVector</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>getIdentifierInfo</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>Ident_vector</name> <operator>&amp;&amp;</operator>
<call><name><name>Tok</name><operator>.</operator><name>getIdentifierInfo</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>Ident_bool</name> <operator>&amp;&amp;</operator>
<call><name><name>Tok</name><operator>.</operator><name>getIdentifierInfo</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>Ident_Bool</name> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>AltiVec</name> <operator>||</operator> <call><name><name>Tok</name><operator>.</operator><name>getIdentifierInfo</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>Ident_pixel</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>TryAltiVecTokenOutOfLine</name><argument_list>(<argument><expr><name>DS</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>PrevSpec</name></expr></argument>, <argument><expr><name>DiagID</name></expr></argument>, <argument><expr><name>isInvalid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><name>bool</name></type> <name>TryAltiVecVectorToken</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>AltiVec</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>ZVector</name><operator>)</operator> <operator>||</operator>
<call><name><name>Tok</name><operator>.</operator><name>getIdentifierInfo</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>Ident_vector</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>TryAltiVecVectorTokenOutOfLine</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>bool</name></type> <name>TryAltiVecVectorTokenOutOfLine</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>TryAltiVecTokenOutOfLine</name><parameter_list>(<parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>isInvalid</name></decl></parameter>)</parameter_list>;</function_decl>




<function><type><name>bool</name></type> <name>isObjCInstancetype</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>ObjC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>isAnnotation</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Ident_instancetype</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Ident_instancetype</name> <operator>=</operator> <call><name><name>PP</name><operator>.</operator><name>getIdentifierInfo</name></name><argument_list>(<argument><expr><literal type="string">"instancetype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>Tok</name><operator>.</operator><name>getIdentifierInfo</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Ident_instancetype</name></expr>;</return>
</block_content>}</block></function>






<function_decl><type><name>bool</name></type> <name>TryKeywordIdentFallback</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>DisableKeyword</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>TemplateIdAnnotation</name> <modifier>*</modifier></type><name>takeTemplateIdAnnotation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>tok</name></decl></parameter>)</parameter_list>;</function_decl>












<decl_stmt><decl><type><name>class</name></type> <name>TentativeParsingAction</name> <block>{<block_content>
<decl_stmt><decl><type><name>Parser</name> <modifier>&amp;</modifier></type><name>P</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PreferredTypeBuilder</name></type> <name>PrevPreferredType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Token</name></type> <name>PrevTok</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>PrevTentativelyDeclaredIdentifierCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>PrevParenCount</name></decl>, <decl><type ref="prev"/><name>PrevBracketCount</name></decl>, <decl><type ref="prev"/><name>PrevBraceCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isActive</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>TentativeParsingAction</name><argument_list>(<argument><expr><name>Parser</name> <operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>P</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>PrevPreferredType</name><argument_list>(<argument>P.PreferredType</argument>)</argument_list></macro> <expr><block>{
<expr><name>PrevTok</name> <operator>=</operator> <name><name>P</name><operator>.</operator><name>Tok</name></name></expr>;
<expr><name>PrevTentativelyDeclaredIdentifierCount</name> <operator>=</operator>
<call><name><name>P</name><operator>.</operator><name>TentativelyDeclaredIdentifiers</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>PrevParenCount</name> <operator>=</operator> <name><name>P</name><operator>.</operator><name>ParenCount</name></name></expr>;
<expr><name>PrevBracketCount</name> <operator>=</operator> <name><name>P</name><operator>.</operator><name>BracketCount</name></name></expr>;
<expr><name>PrevBraceCount</name> <operator>=</operator> <name><name>P</name><operator>.</operator><name>BraceCount</name></name></expr>;
<expr><call><name><name>P</name><operator>.</operator><name>PP</name><operator>.</operator><name>EnableBacktrackAtThisPos</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>isActive</name> <operator>=</operator> <name>true</name></expr>;
}</block>
<name>void</name> <macro><name>Commit</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>isActive</name> <operator>&amp;&amp;</operator> <literal type="string">"Parsing action was finished!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>P</name><operator>.</operator><name>TentativelyDeclaredIdentifiers</name><operator>.</operator><name>resize</name></name><argument_list>(
<argument><expr><name>PrevTentativelyDeclaredIdentifierCount</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>P</name><operator>.</operator><name>PP</name><operator>.</operator><name>CommitBacktrackedTokens</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>isActive</name> <operator>=</operator> <name>false</name></expr>;
}</block>
<name>void</name> <macro><name>Revert</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>isActive</name> <operator>&amp;&amp;</operator> <literal type="string">"Parsing action was finished!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>P</name><operator>.</operator><name>PP</name><operator>.</operator><name>Backtrack</name></name><argument_list>()</argument_list></call></expr>;
<expr><name><name>P</name><operator>.</operator><name>PreferredType</name></name> <operator>=</operator> <name>PrevPreferredType</name></expr>;
<expr><name><name>P</name><operator>.</operator><name>Tok</name></name> <operator>=</operator> <name>PrevTok</name></expr>;
<expr><call><name><name>P</name><operator>.</operator><name>TentativelyDeclaredIdentifiers</name><operator>.</operator><name>resize</name></name><argument_list>(
<argument><expr><name>PrevTentativelyDeclaredIdentifierCount</name></expr></argument>)</argument_list></call></expr>;
<expr><name><name>P</name><operator>.</operator><name>ParenCount</name></name> <operator>=</operator> <name>PrevParenCount</name></expr>;
<expr><name><name>P</name><operator>.</operator><name>BracketCount</name></name> <operator>=</operator> <name>PrevBracketCount</name></expr>;
<expr><name><name>P</name><operator>.</operator><name>BraceCount</name></name> <operator>=</operator> <name>PrevBraceCount</name></expr>;
<expr><name>isActive</name> <operator>=</operator> <name>false</name></expr>;
}</block>
<operator>~</operator><macro><name>TentativeParsingAction</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>isActive</name> <operator>&amp;&amp;</operator> <literal type="string">"Forgot to call Commit or Revert!"</literal></expr></argument>)</argument_list></call></expr>;
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>RevertingTentativeParsingAction</name>
<range>: <expr><name>private</name> <name>Parser</name><operator>::</operator><name>TentativeParsingAction</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>RevertingTentativeParsingAction</name><argument_list>(<argument><expr><name>Parser</name> <operator>&amp;</operator><name>P</name></expr></argument>)</argument_list></call>
<operator>:</operator> <name>Parser</name><operator>::</operator><macro><name>TentativeParsingAction</name><argument_list>(<argument>P</argument>)</argument_list></macro> <block>{}</block>
<operator>~</operator><macro><name>RevertingTentativeParsingAction</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>Revert</name><argument_list>()</argument_list></call></expr>; }</block></expr>
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>UnannotatedTentativeParsingAction</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>ObjCDeclContextSwitch</name> <block>{<block_content>
<decl_stmt><decl><type><name>Parser</name> <modifier>&amp;</modifier></type><name>P</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>DC</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SaveAndRestore</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></type> <name>WithinObjCContainer</name></decl>;</decl_stmt>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>ObjCDeclContextSwitch</name><argument_list>(<argument><expr><name>Parser</name> <operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>P</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>DC</name><argument_list>(<argument><expr><call><name><name>p</name><operator>.</operator><name>getObjCDeclContext</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>WithinObjCContainer</name><argument_list>(<argument>P.ParsingInObjCContainer</argument>, <argument>DC != nullptr</argument>)</argument_list></macro> <expr><block>{
<if_stmt><if>if <condition>(<expr><name>DC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>P</name><operator>.</operator><name>Actions</name><operator>.</operator><name>ActOnObjCTemporaryExitContainerContext</name></name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>
<expr_stmt><expr><operator>~</operator><macro><name>ObjCDeclContextSwitch</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>DC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>P</name><operator>.</operator><name>Actions</name><operator>.</operator><name>ActOnObjCReenterContainerContext</name></name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>









<decl_stmt><decl><type><name>bool</name></type> <name>ExpectAndConsume</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>ExpectedTok</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>Diag</name> <operator>=</operator> <name>diag</name><operator>::</operator><name>err_expected</name></expr></argument>,
<argument><expr><name>StringRef</name> <name>DiagMsg</name> <operator>=</operator> <literal type="string">""</literal></expr></argument>)</argument_list></decl>;</decl_stmt>






<function_decl><type><name>bool</name></type> <name>ExpectAndConsumeSemi</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>


<enum>enum <name>ExtraSemiKind</name> <block>{
<decl><name>OutsideFunction</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>InsideStruct</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>InstanceVariableList</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
<decl><name>AfterMemberFunctionDefinition</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>void</name></type> <name>ConsumeExtraSemi</name><argument_list>(<argument><expr><name>ExtraSemiKind</name> <name>Kind</name></expr></argument>, <argument><expr><name>DeclSpec</name><operator>::</operator><name>TST</name> <name>T</name> <operator>=</operator> <name>TST_unspecified</name></expr></argument>)</argument_list></decl>;</decl_stmt>







<function_decl><type><name>bool</name></type> <name>expectIdentifier</name><parameter_list>()</parameter_list>;</function_decl>


<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>CompoundToken</name> <block>{<block_content>

<expr_stmt><expr><name>StmtExprBegin</name></expr><operator>,</operator>

<expr><name>StmtExprEnd</name></expr><operator>,</operator>

<expr><name>AttrBegin</name></expr><operator>,</operator>

<expr><name>AttrEnd</name></expr><operator>,</operator>

<expr><name>MemberPtr</name></expr><operator>,</operator></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>checkCompoundToken</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>FirstTokLoc</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>FirstTokKind</name></expr></argument>, <argument><expr><name>CompoundToken</name> <name>Op</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<label><name>public</name>:</label>









<decl_stmt><decl><type><name>class</name></type> <name>ParseScope</name> <block>{<block_content>
<decl_stmt><decl><type><name>Parser</name> <modifier>*</modifier></type><name>Self</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ParseScope</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ParseScope</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>ParseScope</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>



<macro><name>ParseScope</name><argument_list>(<argument>Parser *Self</argument>, <argument>unsigned ScopeFlags</argument>, <argument>bool EnteredScope = true</argument>,
<argument>bool BeforeCompoundStmt = false</argument>)</argument_list></macro>
: <macro><name>Self</name><argument_list>(<argument>Self</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>EnteredScope</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>BeforeCompoundStmt</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Self</name><operator>-&gt;</operator><name>EnterScope</name></name><argument_list>(<argument><expr><name>ScopeFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>BeforeCompoundStmt</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Self</name><operator>-&gt;</operator><name>incrementMSManglingNumber</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>Self</name></name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>



<function><type><name>void</name></type> <name>Exit</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>Self</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Self</name><operator>-&gt;</operator><name>ExitScope</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Self</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<expr_stmt><expr><operator>~</operator><macro><name>ParseScope</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>Exit</name><argument_list>()</argument_list></call></expr>;
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>MultiParseScope</name> <block>{<block_content>
<decl_stmt><decl><type><name>Parser</name> <modifier>&amp;</modifier></type><name>Self</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumScopes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MultiParseScope</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MultiParseScope</name><operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>MultiParseScope</name><argument_list>(<argument><expr><name>Parser</name> <operator>&amp;</operator><name>Self</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>Self</name><argument_list>(<argument>Self</argument>)</argument_list></macro> <block>{}</block>
<name>void</name> <macro><name>Enter</name><argument_list>(<argument>unsigned ScopeFlags</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Self</name><operator>.</operator><name>EnterScope</name></name><argument_list>(<argument><expr><name>ScopeFlags</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>++</operator><name>NumScopes</name></expr>;
}</block>
<name>void</name> <macro><name>Exit</name><argument_list>()</argument_list></macro> <block>{
<while>while <condition>(<expr><name>NumScopes</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Self</name><operator>.</operator><name>ExitScope</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>NumScopes</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}
~MultiParseScope(</block></while>) <block>{
<expr><call><name>Exit</name><argument_list>()</argument_list></call></expr>;
}</block></block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<function_decl><type><name>void</name></type> <name>EnterScope</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>ScopeFlags</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ExitScope</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>unsigned</name></type> <name>ReenterTemplateScopes</name><parameter_list>(<parameter><decl><type><name>MultiParseScope</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>class</name></type> <name>ParseScopeFlags</name> <block>{<block_content>
<decl_stmt><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>OldFlags</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ParseScopeFlags</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ParseScopeFlags</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>ParseScopeFlags</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>ParseScopeFlags</name><argument_list>(<argument>Parser *Self</argument>, <argument>unsigned ScopeFlags</argument>, <argument>bool ManageFlags = true</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><operator>~</operator><call><name>ParseScopeFlags</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<label><name>public</name>:</label>
<function_decl><type><name>DiagnosticBuilder</name></type> <name>Diag</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DiagnosticBuilder</name></type> <name>Diag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>DiagnosticBuilder</name></type> <name>Diag</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>Diag</name><argument_list>(<argument><expr><name>Tok</name></expr></argument>, <argument><expr><name>DiagID</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<label><name>private</name>:</label>
<function_decl><type><name>void</name></type> <name>SuggestParentheses</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>DK</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>ParenRange</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckNestedObjCContexts</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>


<enum>enum <name>SkipUntilFlags</name> <block>{
<decl><name>StopAtSemi</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal></expr></init></decl>,

<decl><name>StopBeforeMatch</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>,
<decl><name>StopAtCodeCompletion</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr></init></decl>
}</block>;</enum>

<expr_stmt><expr><name>friend</name> <name>constexpr</name> <name>SkipUntilFlags</name> <name>operator</name><operator>|</operator><operator>(</operator><name>SkipUntilFlags</name> <name>L</name><operator>,</operator>
<name>SkipUntilFlags</name> <name>R</name><operator>)</operator> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>SkipUntilFlags</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call> <operator>|</operator>
<call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>










<decl_stmt><decl><type><name>bool</name></type> <name>SkipUntil</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>T</name></expr></argument>,
<argument><expr><name>SkipUntilFlags</name> <name>Flags</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>SkipUntilFlags</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>SkipUntil</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>SkipUntil</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>T1</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>T2</name></expr></argument>,
<argument><expr><name>SkipUntilFlags</name> <name>Flags</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>SkipUntilFlags</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name><name>TokArray</name><index>[]</index></name> <operator>=</operator> <block>{<expr><name>T1</name></expr>, <expr><name>T2</name></expr>}</block></expr>;</expr_stmt>
<return>return <expr><call><name>SkipUntil</name><argument_list>(<argument><expr><name>TokArray</name></expr></argument>, <argument><expr><name>Flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>SkipUntil</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>T1</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>T2</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>T3</name></expr></argument>,
<argument><expr><name>SkipUntilFlags</name> <name>Flags</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>SkipUntilFlags</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name><name>TokArray</name><index>[]</index></name> <operator>=</operator> <block>{<expr><name>T1</name></expr>, <expr><name>T2</name></expr>, <expr><name>T3</name></expr>}</block></expr>;</expr_stmt>
<return>return <expr><call><name>SkipUntil</name><argument_list>(<argument><expr><name>TokArray</name></expr></argument>, <argument><expr><name>Flags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<function_decl><type><name>bool</name></type> <name>SkipUntil</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name></expr></argument>&gt;</argument_list></name></type> <name>Toks</name></decl></parameter>,
<parameter><decl><type><name>SkipUntilFlags</name></type> <name>Flags</name> <init>= <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>SkipUntilFlags</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>SkipMalformedDecl</name><parameter_list>()</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>SourceLocation</name></type> <name>MisleadingIndentationElseLoc</name></decl>;</decl_stmt>

<label><name>private</name>:</label>



<struct_decl>struct <name>ParsingClass</name>;</struct_decl>









<decl_stmt><decl><type><name>class</name></type> <name>LateParsedDeclaration</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>LateParsedDeclaration</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>virtual</name> <name>void</name></type> <name>ParseLexedMethodDeclarations</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>virtual</name> <name>void</name></type> <name>ParseLexedMemberInitializers</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>virtual</name> <name>void</name></type> <name>ParseLexedMethodDefs</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>virtual</name> <name>void</name></type> <name>ParseLexedAttributes</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>virtual</name> <name>void</name></type> <name>ParseLexedPragmas</name><parameter_list>()</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>LateParsedClass</name> <range>: <expr><name>public</name> <name>LateParsedDeclaration</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>LateParsedClass</name><argument_list>(<argument><expr><name>Parser</name> <operator>*</operator><name>P</name></expr></argument>, <argument><expr><name>ParsingClass</name> <operator>*</operator><name>C</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>~</operator><macro><name>LateParsedClass</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>void</name> <macro><name>ParseLexedMethodDeclarations</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>ParseLexedMemberInitializers</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>ParseLexedMethodDefs</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>ParseLexedAttributes</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>ParseLexedPragmas</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>Parser</name> <operator>*</operator><name>Self</name></expr>;
<expr><name>ParsingClass</name> <operator>*</operator><name>Class</name></expr>;
}</block></expr></range></decl>;</decl_stmt>







<decl_stmt><decl><type><name><name>struct</name> <name>LateParsedAttribute</name></name></type> <range>: <expr><name>public</name> <name>LateParsedDeclaration</name> <block>{
<expr><name>Parser</name> <operator>*</operator><name>Self</name></expr>;
<expr><name>CachedTokens</name> <name>Toks</name></expr>;
<expr><name>IdentifierInfo</name> <operator>&amp;</operator><name>AttrName</name></expr>;
<expr><name>IdentifierInfo</name> <operator>*</operator><name>MacroII</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>SourceLocation</name> <name>AttrNameLoc</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>Decls</name></expr>;

<expr><name>explicit</name> <macro><name>LateParsedAttribute</name><argument_list>(<argument>Parser *P</argument>, <argument>IdentifierInfo &amp;Name</argument>,
<argument>SourceLocation Loc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Self</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>AttrName</name><argument_list>(<argument><expr><name>Name</name></expr></argument>)</argument_list></call></expr>, <macro><name>AttrNameLoc</name><argument_list>(<argument>Loc</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>ParseLexedAttributes</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>void</name> <macro><name>addDecl</name><argument_list>(<argument>Decl *D</argument>)</argument_list></macro> <block>{ <expr><call><name><name>Decls</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>; }</block></expr>
}</block></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>class</name></type> <name>LateParsedPragma</name> <range>: <expr><name>public</name> <name>LateParsedDeclaration</name> <block>{
<expr><name>Parser</name> <operator>*</operator><name>Self</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>AccessSpecifier</name> <name>AS</name> <operator>=</operator> <name>AS_none</name></expr>;
<expr><name>CachedTokens</name> <name>Toks</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <macro><name>LateParsedPragma</name><argument_list>(<argument>Parser *P</argument>, <argument>AccessSpecifier AS</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Self</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>, <macro><name>AS</name><argument_list>(<argument>AS</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>takeToks</name><argument_list>(<argument>CachedTokens &amp;Cached</argument>)</argument_list></macro> <block>{ <expr><call><name><name>Toks</name><operator>.</operator><name>swap</name></name><argument_list>(<argument><expr><name>Cached</name></expr></argument>)</argument_list></call></expr>; }</block>
<specifier>const</specifier> <name>CachedTokens</name> <operator>&amp;</operator><macro><name>toks</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Toks</name></expr>;</return> }</block>
<name>AccessSpecifier</name> <macro><name>getAccessSpecifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AS</name></expr>;</return> }</block>

<name>void</name> <macro><name>ParseLexedPragmas</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>LateParsedAttrList</name><range>: <expr><name>public</name> <name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>LateParsedAttribute</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>LateParsedAttrList</name><argument_list>(<argument>bool PSoon = false</argument>)</argument_list></macro> <operator>:</operator> <macro><name>ParseSoon</name><argument_list>(<argument>PSoon</argument>)</argument_list></macro> <block>{ }</block>

<name>bool</name> <macro><name>parseSoon</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>ParseSoon</name></expr>;</return> }</block>

<name>private</name><operator>:</operator>
<name>bool</name> <name>ParseSoon</name></expr>;
}</block></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name><name>struct</name> <name>LexedMethod</name></name></type> <range>: <expr><name>public</name> <name>LateParsedDeclaration</name> <block>{
<expr><name>Parser</name> <operator>*</operator><name>Self</name></expr>;
<expr><name>Decl</name> <operator>*</operator><name>D</name></expr>;
<expr><name>CachedTokens</name> <name>Toks</name></expr>;

<expr><name>explicit</name> <call><name>LexedMethod</name><argument_list>(<argument><expr><name>Parser</name> <operator>*</operator><name>P</name></expr></argument>, <argument><expr><name>Decl</name> <operator>*</operator><name>MD</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>Self</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>, <macro><name>D</name><argument_list>(<argument>MD</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>ParseLexedMethodDefs</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
}</block></expr></range></decl>;</decl_stmt>





<struct>struct <name>LateParsedDefaultArgument</name> <block>{
<decl_stmt><decl><type><name>explicit</name></type> <name>LateParsedDefaultArgument</name><argument_list>(<argument><expr><name>Decl</name> <operator>*</operator><name>P</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CachedTokens</name></expr></argument>&gt;</argument_list></name> <name>Toks</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list>
<range>: <expr><call><name>Param</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr></range></decl>, <decl><type ref="prev"/><name>Toks</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Toks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list> <block>{<block_content> </block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Param</name></decl>;</decl_stmt>





<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CachedTokens</name></expr></argument>&gt;</argument_list></name> <name>Toks</name></expr>;</expr_stmt>
}</block>;</struct>





<decl_stmt><decl><type><name><name>struct</name> <name>LateParsedMethodDeclaration</name></name></type> <range>: <expr><name>public</name> <name>LateParsedDeclaration</name> <block>{
<expr><name>explicit</name> <call><name>LateParsedMethodDeclaration</name><argument_list>(<argument><expr><name>Parser</name> <operator>*</operator><name>P</name></expr></argument>, <argument><expr><name>Decl</name> <operator>*</operator><name>M</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Self</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Method</name><argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr>, <macro><name>ExceptionSpecTokens</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>ParseLexedMethodDeclarations</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>Parser</name> <operator>*</operator><name>Self</name></expr>;


<expr><name>Decl</name> <operator>*</operator><name>Method</name></expr>;






<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>LateParsedDefaultArgument</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>DefaultArgs</name></expr>;



<expr><name>CachedTokens</name> <operator>*</operator><name>ExceptionSpecTokens</name></expr>;
}</block></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name><name>struct</name> <name>LateParsedMemberInitializer</name></name></type> <range>: <expr><name>public</name> <name>LateParsedDeclaration</name> <block>{
<expr><call><name>LateParsedMemberInitializer</name><argument_list>(<argument><expr><name>Parser</name> <operator>*</operator><name>P</name></expr></argument>, <argument><expr><name>Decl</name> <operator>*</operator><name>FD</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Self</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>, <macro><name>Field</name><argument_list>(<argument>FD</argument>)</argument_list></macro> <expr><block>{ }</block>

<name>void</name> <macro><name>ParseLexedMemberInitializers</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>Parser</name> <operator>*</operator><name>Self</name></expr>;


<expr><name>Decl</name> <operator>*</operator><name>Field</name></expr>;



<expr><name>CachedTokens</name> <name>Toks</name></expr>;
}</block></expr></range></decl>;</decl_stmt>







<typedef>typedef <type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>LateParsedDeclaration</name><modifier>*</modifier></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>LateParsedDeclarationsContainer</name>;</typedef>




<struct>struct <name>ParsingClass</name> <block>{
<macro><name>ParsingClass</name><argument_list>(<argument>Decl *TagOrTemplate</argument>, <argument>bool TopLevelClass</argument>, <argument>bool IsInterface</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>TopLevelClass</name><argument_list>(<argument><expr><name>TopLevelClass</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IsInterface</name><argument_list>(<argument><expr><name>IsInterface</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>TagOrTemplate</name><argument_list>(<argument>TagOrTemplate</argument>)</argument_list></macro> <expr><block>{}</block>



<name>bool</name> <name>TopLevelClass</name> <operator>:</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>IsInterface</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>TagOrTemplate</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>LateParsedDeclarationsContainer</name></type> <name>LateParsedDeclarations</name></decl>;</decl_stmt>
}</block>;</struct>




<expr_stmt><expr><name>std</name><operator>::</operator><name><name>stack</name><argument_list type="generic">&lt;<argument><expr><name>ParsingClass</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ClassStack</name></expr>;</expr_stmt>

<function><type><name>ParsingClass</name> <modifier>&amp;</modifier></type><name>getCurrentClass</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>ClassStack</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"No lexed method stacks!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><call><name><name>ClassStack</name><operator>.</operator><name>top</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name>class</name></type> <name>ParsingClassDefinition</name> <block>{<block_content>
<decl_stmt><decl><type><name>Parser</name> <modifier>&amp;</modifier></type><name>P</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Popped</name></decl>;</decl_stmt>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ParsingClassState</name> <name>State</name></expr>;</expr_stmt>

<label><name>public</name>:</label>
<macro><name>ParsingClassDefinition</name><argument_list>(<argument>Parser &amp;P</argument>, <argument>Decl *TagOrTemplate</argument>, <argument>bool TopLevelClass</argument>,
<argument>bool IsInterface</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>P</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Popped</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>State</name><argument_list>(<argument>P.PushParsingClass(TagOrTemplate, TopLevelClass, IsInterface)</argument>)</argument_list></macro> <expr><block>{
}</block>


<name>void</name> <macro><name>Pop</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>Popped</name> <operator>&amp;&amp;</operator> <literal type="string">"Nested class has already been popped"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>Popped</name> <operator>=</operator> <name>true</name></expr>;
<expr><call><name><name>P</name><operator>.</operator><name>PopParsingClass</name></name><argument_list>(<argument><expr><name>State</name></expr></argument>)</argument_list></call></expr>;
}</block>

<operator>~</operator><macro><name>ParsingClassDefinition</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Popped</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>P</name><operator>.</operator><name>PopParsingClass</name></name><argument_list>(<argument><expr><name>State</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<struct>struct <name>ParsedTemplateInfo</name> <block>{
<expr_stmt><expr><call><name>ParsedTemplateInfo</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>NonTemplate</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>TemplateParams</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>TemplateLoc</name><argument_list>()</argument_list></macro> <expr><block>{ }</block>

<macro><name>ParsedTemplateInfo</name><argument_list>(<argument>TemplateParameterLists *TemplateParams</argument>,
<argument>bool isSpecialization</argument>,
<argument>bool lastParameterListWasEmpty = false</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>isSpecialization</name><operator>?</operator> <name>ExplicitSpecialization</name> <operator>:</operator> <name>Template</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>TemplateParams</name><argument_list>(<argument><expr><name>TemplateParams</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>LastParameterListWasEmpty</name><argument_list>(<argument>lastParameterListWasEmpty</argument>)</argument_list></macro> <expr><block>{ }</block>

<name>explicit</name> <macro><name>ParsedTemplateInfo</name><argument_list>(<argument>SourceLocation ExternLoc</argument>,
<argument>SourceLocation TemplateLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>ExplicitInstantiation</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>TemplateParams</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>ExternLoc</name><argument_list>(<argument><expr><name>ExternLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>TemplateLoc</name><argument_list>(<argument><expr><name>TemplateLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>LastParameterListWasEmpty</name><argument_list>(<argument>false</argument>)</argument_list></macro><expr><block>{ }</block>


enum <block>{

<expr><name>NonTemplate</name> <operator>=</operator> <literal type="number">0</literal></expr>,

<expr><name>Template</name></expr>,

<expr><name>ExplicitSpecialization</name></expr>,

<expr><name>ExplicitInstantiation</name></expr>
}</block> <name>Kind</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>TemplateParameterLists</name> <modifier>*</modifier></type><name>TemplateParams</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ExternLoc</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>SourceLocation</name></type> <name>TemplateLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>LastParameterListWasEmpty</name></decl>;</decl_stmt>

<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;</expr_stmt>
}</block>;</struct>


<struct_decl>struct <name>ReenterTemplateScopeRAII</name>;</struct_decl>
<struct_decl>struct <name>ReenterClassScopeRAII</name>;</struct_decl>

<function_decl><type><name>void</name></type> <name>LexTemplateFunctionForLateParsing</name><parameter_list>(<parameter><decl><type><name>CachedTokens</name> <modifier>&amp;</modifier></type><name>Toks</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseLateTemplatedFuncDef</name><parameter_list>(<parameter><decl><type><name>LateParsedTemplate</name> <modifier>&amp;</modifier></type><name>LPT</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>LateTemplateParserCallback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><name>LateParsedTemplate</name> <modifier>&amp;</modifier></type><name>LPT</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ParsingClassState</name>
<macro><name>PushParsingClass</name><argument_list>(<argument>Decl *TagOrTemplate</argument>, <argument>bool TopLevelClass</argument>, <argument>bool IsInterface</argument>)</argument_list></macro></expr>;</expr_stmt>
<function_decl><type><name>void</name></type> <name>DeallocateParsedClasses</name><parameter_list>(<parameter><decl><type><name>ParsingClass</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>PopParsingClass</name><argument_list>(<argument><expr><name>Sema</name><operator>::</operator><name>ParsingClassState</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<enum>enum <name>CachedInitKind</name> <block>{
<decl><name>CIK_DefaultArgument</name></decl>,
<decl><name>CIK_DefaultInitializer</name></decl>
}</block>;</enum>

<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ParseCXXInlineMethodDef</name><parameter_list>(<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>AccessAttrs</name></decl></parameter>,
<parameter><decl><type><name>ParsingDeclarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedTemplateInfo</name> <modifier>&amp;</modifier></type><name>TemplateInfo</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>VirtSpecifiers</name> <modifier>&amp;</modifier></type><name>VS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PureSpecLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseCXXNonStaticMemberInitializer</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>VarD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseLexedAttributes</name><parameter_list>(<parameter><decl><type><name>ParsingClass</name> <modifier>&amp;</modifier></type><name>Class</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseLexedAttributeList</name><parameter_list>(<parameter><decl><type><name>LateParsedAttrList</name> <modifier>&amp;</modifier></type><name>LAs</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>EnterScope</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>OnDefinition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseLexedAttribute</name><parameter_list>(<parameter><decl><type><name>LateParsedAttribute</name> <modifier>&amp;</modifier></type><name>LA</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>EnterScope</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>OnDefinition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseLexedMethodDeclarations</name><parameter_list>(<parameter><decl><type><name>ParsingClass</name> <modifier>&amp;</modifier></type><name>Class</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseLexedMethodDeclaration</name><parameter_list>(<parameter><decl><type><name>LateParsedMethodDeclaration</name> <modifier>&amp;</modifier></type><name>LM</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseLexedMethodDefs</name><parameter_list>(<parameter><decl><type><name>ParsingClass</name> <modifier>&amp;</modifier></type><name>Class</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseLexedMethodDef</name><parameter_list>(<parameter><decl><type><name>LexedMethod</name> <modifier>&amp;</modifier></type><name>LM</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseLexedMemberInitializers</name><parameter_list>(<parameter><decl><type><name>ParsingClass</name> <modifier>&amp;</modifier></type><name>Class</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseLexedMemberInitializer</name><parameter_list>(<parameter><decl><type><name>LateParsedMemberInitializer</name> <modifier>&amp;</modifier></type><name>MI</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseLexedObjCMethodDefs</name><parameter_list>(<parameter><decl><type><name>LexedMethod</name> <modifier>&amp;</modifier></type><name>LM</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>parseMethod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseLexedPragmas</name><parameter_list>(<parameter><decl><type><name>ParsingClass</name> <modifier>&amp;</modifier></type><name>Class</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseLexedPragma</name><parameter_list>(<parameter><decl><type><name>LateParsedPragma</name> <modifier>&amp;</modifier></type><name>LP</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>ConsumeAndStoreFunctionPrologue</name><parameter_list>(<parameter><decl><type><name>CachedTokens</name> <modifier>&amp;</modifier></type><name>Toks</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>ConsumeAndStoreInitializer</name><parameter_list>(<parameter><decl><type><name>CachedTokens</name> <modifier>&amp;</modifier></type><name>Toks</name></decl></parameter>, <parameter><decl><type><name>CachedInitKind</name></type> <name>CIK</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>ConsumeAndStoreConditional</name><parameter_list>(<parameter><decl><type><name>CachedTokens</name> <modifier>&amp;</modifier></type><name>Toks</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>bool</name></type> <name>ConsumeAndStoreUntil</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>T1</name></expr></argument>,
<argument><expr><name>CachedTokens</name> <operator>&amp;</operator><name>Toks</name></expr></argument>,
<argument><expr><name>bool</name> <name>StopAtSemi</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>bool</name> <name>ConsumeFinalToken</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>ConsumeAndStoreUntil</name><argument_list>(<argument><expr><name>T1</name></expr></argument>, <argument><expr><name>T1</name></expr></argument>, <argument><expr><name>Toks</name></expr></argument>, <argument><expr><name>StopAtSemi</name></expr></argument>, <argument><expr><name>ConsumeFinalToken</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ConsumeAndStoreUntil</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>T1</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>T2</name></expr></argument>,
<argument><expr><name>CachedTokens</name> <operator>&amp;</operator><name>Toks</name></expr></argument>,
<argument><expr><name>bool</name> <name>StopAtSemi</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>bool</name> <name>ConsumeFinalToken</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ParseExternalDeclaration</name><parameter_list>(<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>,
<parameter><decl><type><name>ParsingDeclSpec</name> <modifier>*</modifier></type><name>DS</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isDeclarationAfterDeclarator</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isStartOfFunctionDefinition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParsingDeclarator</name> <modifier>&amp;</modifier></type><name>Declarator</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ParseDeclarationOrFunctionDefinition</name><parameter_list>(
<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>,
<parameter><decl><type><name>ParsingDeclSpec</name> <modifier>*</modifier></type><name>DS</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name> <init>= <expr><name>AS_none</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ParseDeclOrFunctionDefInternal</name><parameter_list>(<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>,
<parameter><decl><type><name>ParsingDeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>SkipFunctionBody</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseFunctionDefinition</name><parameter_list>(<parameter><decl><type><name>ParsingDeclarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedTemplateInfo</name> <modifier>&amp;</modifier></type><name>TemplateInfo</name> <init>= <expr><call><name>ParsedTemplateInfo</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>LateParsedAttrList</name> <modifier>*</modifier></type><name>LateParsedAttrs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseKNRParamDeclarations</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ParseSimpleAsm</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>ForAsmLabel</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseAsmStringLiteral</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>ForAsmLabel</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>void</name></type> <name>MaybeSkipAttributes</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>ObjCKeywordKind</name> <name>Kind</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ParseObjCAtDirectives</name><parameter_list>(<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ParseObjCAtClassDeclaration</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>atLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseObjCAtInterfaceDeclaration</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>prefixAttrs</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCTypeParamListScope</name></decl>;</decl_stmt>
<function_decl><type><name>ObjCTypeParamList</name> <modifier>*</modifier></type><name>parseObjCTypeParamList</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>ObjCTypeParamList</name> <modifier>*</modifier></type><name>parseObjCTypeParamListOrProtocolRefs</name><parameter_list>(
<parameter><decl><type><name>ObjCTypeParamListScope</name> <modifier>&amp;</modifier></type><name>Scope</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>lAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierLocPair</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>protocolIdents</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>rAngleLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>mayBeProtocolList</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>HelperActionsForIvarDeclarations</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>interfaceDecl</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>atLoc</name></decl></parameter>,
<parameter><decl><type><name>BalancedDelimiterTracker</name> <modifier>&amp;</modifier></type><name>T</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>AllIvarDecls</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>RBraceMissing</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>ParseObjCClassInstanceVariables</name><argument_list>(<argument><expr><name>Decl</name> <operator>*</operator><name>interfaceDecl</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>ObjCKeywordKind</name> <name>visibility</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>atLoc</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>bool</name></type> <name>ParseObjCProtocolReferences</name><parameter_list>(<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>P</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>PLocs</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>WarnOnDeclarations</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ForObjCContainer</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>LAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>EndProtoLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>consumeLastToken</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>parseObjCTypeArgsOrProtocolQualifiers</name><parameter_list>(
<parameter><decl><type><name>ParsedType</name></type> <name>baseType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>typeArgsLAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>ParsedType</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>typeArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>typeArgsRAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>protocolLAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>protocols</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>protocolLocs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>protocolRAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>consumeLastToken</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>warnOnIncompleteProtocols</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>parseObjCTypeArgsAndProtocolQualifiers</name><parameter_list>(
<parameter><decl><type><name>ParsedType</name></type> <name>baseType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>typeArgsLAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>ParsedType</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>typeArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>typeArgsRAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>protocolLAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>protocols</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>protocolLocs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>protocolRAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>consumeLastToken</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>TypeResult</name></type> <name>parseObjCProtocolQualifierType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>rAngleLoc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>TypeResult</name></type> <name>parseObjCTypeArgsAndProtocolQualifiers</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>loc</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>type</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>consumeLastToken</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>endLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>ParseObjCInterfaceDeclList</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>ObjCKeywordKind</name> <name>contextKey</name></expr></argument>,
<argument><expr><name>Decl</name> <operator>*</operator><name>CDecl</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ParseObjCAtProtocolDeclaration</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>atLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>prefixAttrs</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>ObjCImplParsingDataRAII</name> <block>{
<decl_stmt><decl><type><name>Parser</name> <modifier>&amp;</modifier></type><name>P</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Dcl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>HasCFunction</name></decl>;</decl_stmt>
<typedef>typedef <type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>LexedMethod</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>LateParsedObjCMethodContainer</name>;</typedef>
<decl_stmt><decl><type><name>LateParsedObjCMethodContainer</name></type> <name>LateParsedObjCMethods</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ObjCImplParsingDataRAII</name><argument_list>(<argument><expr><name>Parser</name> <operator>&amp;</operator><name>parser</name></expr></argument>, <argument><expr><name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>P</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Dcl</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>HasCFunction</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>P</name><operator>.</operator><name>CurParsedObjCImpl</name></name> <operator>=</operator> <name>this</name></expr>;
<expr><name>Finished</name> <operator>=</operator> <name>false</name></expr>;
}</block>
<operator>~</operator><call><name>ObjCImplParsingDataRAII</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>finish</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>AtEnd</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>bool</name> <macro><name>isFinished</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Finished</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>bool</name></type> <name>Finished</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name>ObjCImplParsingDataRAII</name> <modifier>*</modifier></type><name>CurParsedObjCImpl</name></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>StashAwayMethodOrFunctionBodyTokens</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>MDecl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ParseObjCAtImplementationDeclaration</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ParseObjCAtEndDeclaration</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>atEnd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseObjCAtAliasDeclaration</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>atLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseObjCPropertySynthesize</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>atLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseObjCPropertyDynamic</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>atLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ParseObjCSelectorPiece</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>MethodLocation</name></decl></parameter>)</parameter_list>;</function_decl>

<enum>enum <name>ObjCTypeQual</name> <block>{
<decl><name>objc_in</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><name>objc_out</name></decl>, <decl><name>objc_inout</name></decl>, <decl><name>objc_oneway</name></decl>, <decl><name>objc_bycopy</name></decl>, <decl><name>objc_byref</name></decl>,
<decl><name>objc_nonnull</name></decl>, <decl><name>objc_nullable</name></decl>, <decl><name>objc_null_unspecified</name></decl>,
<decl><name>objc_NumQuals</name></decl>
}</block>;</enum>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name><name>ObjCTypeQuals</name><index>[<expr><name>objc_NumQuals</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isTokIdentifier_in</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function_decl><type><name>ParsedType</name></type> <name>ParseObjCTypeName</name><parameter_list>(<parameter><decl><type><name>ObjCDeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>, <parameter><decl><type><name>DeclaratorContext</name></type> <name>Ctx</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>*</modifier></type><name>ParamAttrs</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseObjCMethodPrototype</name><argument_list>(
<argument><expr><name>tok</name><operator>::</operator><name>ObjCKeywordKind</name> <name>MethodImplKind</name> <operator>=</operator> <name>tok</name><operator>::</operator><name>objc_not_keyword</name></expr></argument>,
<argument><expr><name>bool</name> <name>MethodDefinition</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseObjCMethodDecl</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>mLoc</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>mType</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>ObjCKeywordKind</name> <name>MethodImplKind</name> <operator>=</operator> <name>tok</name><operator>::</operator><name>objc_not_keyword</name></expr></argument>,
<argument><expr><name>bool</name> <name>MethodDefinition</name><operator>=</operator><name>true</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>ParseObjCPropertyAttribute</name><parameter_list>(<parameter><decl><type><name>ObjCDeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseObjCMethodDefinition</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>public</name>:</label>




<enum>enum <name>TypeCastState</name> <block>{
<decl><name>NotTypeCast</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>MaybeTypeCast</name></decl>,
<decl><name>IsTypeCast</name></decl>
}</block>;</enum>

<function_decl><type><name>ExprResult</name></type> <name>ParseExpression</name><parameter_list>(<parameter><decl><type><name>TypeCastState</name></type> <name>isTypeCast</name> <init>= <expr><name>NotTypeCast</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseConstantExpressionInExprEvalContext</name><parameter_list>(
<parameter><decl><type><name>TypeCastState</name></type> <name>isTypeCast</name> <init>= <expr><name>NotTypeCast</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseConstantExpression</name><parameter_list>(<parameter><decl><type><name>TypeCastState</name></type> <name>isTypeCast</name> <init>= <expr><name>NotTypeCast</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseCaseExpression</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CaseLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseConstraintExpression</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type>
<name>ParseConstraintLogicalAndExpression</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IsTrailingRequiresClause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseConstraintLogicalOrExpression</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IsTrailingRequiresClause</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ParseAssignmentExpression</name><parameter_list>(<parameter><decl><type><name>TypeCastState</name></type> <name>isTypeCast</name> <init>= <expr><name>NotTypeCast</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>ParseMSAsmIdentifier</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Token</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>LineToks</name></expr></argument>,
<argument><expr><name>unsigned</name> <operator>&amp;</operator><name>NumLineToksConsumed</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsUnevaluated</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>ExprResult</name></type> <name>ParseStringLiteralExpression</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>AllowUserDefinedLiteral</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
<function_decl><type><name>ExprResult</name></type> <name>ParseExpressionWithLeadingAt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ParseExpressionWithLeadingExtension</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ExtLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>ParseRHSOfBinaryExpression</name><argument_list>(<argument><expr><name>ExprResult</name> <name>LHS</name></expr></argument>,
<argument><expr><name>prec</name><operator>::</operator><name>Level</name> <name>MinPrec</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<enum>enum <name>CastParseKind</name> <block>{
<decl><name>AnyCastExpr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>UnaryExprOnly</name></decl>,
<decl><name>PrimaryExprOnly</name></decl>
}</block>;</enum>
<function_decl><type><name>ExprResult</name></type> <name>ParseCastExpression</name><parameter_list>(<parameter><decl><type><name>CastParseKind</name></type> <name>ParseKind</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isAddressOfOperand</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>NotCastExpr</name></decl></parameter>,
<parameter><decl><type><name>TypeCastState</name></type> <name>isTypeCast</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isVectorLiteral</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>NotPrimaryExpression</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseCastExpression</name><parameter_list>(<parameter><decl><type><name>CastParseKind</name></type> <name>ParseKind</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isAddressOfOperand</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>TypeCastState</name></type> <name>isTypeCast</name> <init>= <expr><name>NotTypeCast</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isVectorLiteral</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>NotPrimaryExpression</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>isNotExpressionStart</name><parameter_list>()</parameter_list>;</function_decl>



<function><type><name>bool</name></type> <name>isPostfixExpressionSuffixStart</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>K</name> <operator>=</operator> <call><name><name>Tok</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>K</name> <operator>==</operator> <name>tok</name><operator>::</operator><name>l_square</name> <operator>||</operator> <name>K</name> <operator>==</operator> <name>tok</name><operator>::</operator><name>l_paren</name> <operator>||</operator>
<name>K</name> <operator>==</operator> <name>tok</name><operator>::</operator><name>period</name> <operator>||</operator> <name>K</name> <operator>==</operator> <name>tok</name><operator>::</operator><name>arrow</name> <operator>||</operator>
<name>K</name> <operator>==</operator> <name>tok</name><operator>::</operator><name>plusplus</name> <operator>||</operator> <name>K</name> <operator>==</operator> <name>tok</name><operator>::</operator><name>minusminus</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>bool</name></type> <name>diagnoseUnknownTemplateId</name><parameter_list>(<parameter><decl><type><name>ExprResult</name></type> <name>TemplateName</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Less</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>checkPotentialAngleBracket</name><parameter_list>(<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>PotentialTemplateName</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>bool</name></type> <name>checkPotentialAngleBracketDelimiter</name><argument_list>(<argument><expr><specifier>const</specifier> <name>AngleBracketTracker</name><operator>::</operator><name>Loc</name> <operator>&amp;</operator></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Token</name> <operator>&amp;</operator><name>OpToken</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function><type><name>bool</name></type> <name>checkPotentialAngleBracketDelimiter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>OpToken</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>Info</name> <operator>=</operator> <call><name><name>AngleBrackets</name><operator>.</operator><name>getCurrent</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>checkPotentialAngleBracketDelimiter</name><argument_list>(<argument><expr><operator>*</operator><name>Info</name></expr></argument>, <argument><expr><name>OpToken</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>ExprResult</name></type> <name>ParsePostfixExpressionSuffix</name><parameter_list>(<parameter><decl><type><name>ExprResult</name></type> <name>LHS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseUnaryExprOrTypeTraitExpression</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseBuiltinPrimaryExpression</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseSYCLUniqueStableNameExpression</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ParseExprAfterUnaryExprOrTypeTrait</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>OpTok</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>isCastExpr</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name> <modifier>&amp;</modifier></type><name>CastTy</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name> <modifier>&amp;</modifier></type><name>CastRange</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>&gt;</argument_list></name></type> <name>CommaLocsTy</name>;</typedef>


<decl_stmt><decl><type><name>bool</name></type> <name>ParseExpressionList</name><argument_list>(<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Exprs</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>CommaLocs</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>ExpressionStarts</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><call><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>bool</name></type> <name>ParseSimpleExpressionList</name><parameter_list>(<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Exprs</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>CommaLocs</name></decl></parameter>)</parameter_list>;</function_decl>



<enum>enum <name>ParenParseOption</name> <block>{
<decl><name>SimpleExpr</name></decl>,
<decl><name>FoldExpr</name></decl>,
<decl><name>CompoundStmt</name></decl>,
<decl><name>CompoundLiteral</name></decl>,
<decl><name>CastExpr</name></decl>
}</block>;</enum>
<function_decl><type><name>ExprResult</name></type> <name>ParseParenExpression</name><parameter_list>(<parameter><decl><type><name>ParenParseOption</name> <modifier>&amp;</modifier></type><name>ExprType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>stopIfCastExpr</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isTypeCast</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name> <modifier>&amp;</modifier></type><name>CastTy</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ParseCXXAmbiguousParenExpression</name><parameter_list>(
<parameter><decl><type><name>ParenParseOption</name> <modifier>&amp;</modifier></type><name>ExprType</name></decl></parameter>, <parameter><decl><type><name>ParsedType</name> <modifier>&amp;</modifier></type><name>CastTy</name></decl></parameter>,
<parameter><decl><type><name>BalancedDelimiterTracker</name> <modifier>&amp;</modifier></type><name>Tracker</name></decl></parameter>, <parameter><decl><type><name>ColonProtectionRAIIObject</name> <modifier>&amp;</modifier></type><name>ColonProt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseCompoundLiteralExpression</name><parameter_list>(<parameter><decl><type><name>ParsedType</name></type> <name>Ty</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ParseGenericSelectionExpression</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ParseObjCBoolLiteral</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ParseFoldExpression</name><parameter_list>(<parameter><decl><type><name>ExprResult</name></type> <name>LHS</name></decl></parameter>, <parameter><decl><type><name>BalancedDelimiterTracker</name> <modifier>&amp;</modifier></type><name>T</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>tryParseCXXIdExpression</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isAddressOfOperand</name></decl></parameter>,
<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Replacement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseCXXIdExpression</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isAddressOfOperand</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>areTokensAdjacent</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>A</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>B</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckForTemplateAndDigraph</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Next</name></decl></parameter>, <parameter><decl><type><name>ParsedType</name></type> <name>ObjectTypePtr</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>EnteringContext</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>II</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>ParseOptionalCXXScopeSpecifier</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>ObjectType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ObjectHasErrors</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>EnteringContext</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>MayBePseudoDestructor</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsTypename</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>LastII</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>OnlyNamespace</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>InUsingDeclaration</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>LambdaIntroducerTentativeParse</name> <block>{<block_content>

<expr_stmt><expr><name>Success</name></expr><operator>,</operator>


<expr><name>Incomplete</name></expr><operator>,</operator>


<expr><name>MessageSend</name></expr><operator>,</operator>

<expr><name>Invalid</name></expr><operator>,</operator></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<function_decl><type><name>ExprResult</name></type> <name>ParseLambdaExpression</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>TryParseLambdaExpression</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type>
<name>ParseLambdaIntroducer</name><parameter_list>(<parameter><decl><type><name>LambdaIntroducer</name> <modifier>&amp;</modifier></type><name>Intro</name></decl></parameter>,
<parameter><decl><type><name>LambdaIntroducerTentativeParse</name> <modifier>*</modifier></type><name>Tentative</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseLambdaExpressionAfterIntroducer</name><parameter_list>(<parameter><decl><type><name>LambdaIntroducer</name> <modifier>&amp;</modifier></type><name>Intro</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>ParseCXXCasts</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>ExprResult</name></type> <name>ParseBuiltinBitCast</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>ParseCXXTypeid</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>ParseCXXUuidof</name><parameter_list>()</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>ExprResult</name></type> <name>ParseCXXPseudoDestructor</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>Base</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>OpLoc</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>OpKind</name></expr></argument>,
<argument><expr><name>CXXScopeSpec</name> <operator>&amp;</operator><name>SS</name></expr></argument>,
<argument><expr><name>ParsedType</name> <name>ObjectType</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>ExprResult</name></type> <name>ParseCXXThis</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>ParseThrowExpression</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>ExceptionSpecificationType</name></type> <name>tryParseExceptionSpecification</name><parameter_list>(
<parameter><decl><type><name>bool</name></type> <name>Delayed</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name> <modifier>&amp;</modifier></type><name>SpecificationRange</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>ParsedType</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>DynamicExceptions</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>SourceRange</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>DynamicExceptionRanges</name></decl></parameter>,
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>NoexceptExpr</name></decl></parameter>,
<parameter><decl><type><name>CachedTokens</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>ExceptionSpecTokens</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ExceptionSpecificationType</name></type> <name>ParseDynamicExceptionSpecification</name><parameter_list>(
<parameter><decl><type><name>SourceRange</name> <modifier>&amp;</modifier></type><name>SpecificationRange</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>ParsedType</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Exceptions</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>SourceRange</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Ranges</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>TypeResult</name></type> <name>ParseTrailingReturnType</name><parameter_list>(<parameter><decl><type><name>SourceRange</name> <modifier>&amp;</modifier></type><name>Range</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>MayBeFollowedByDirectInit</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>ParseCXXBoolLiteral</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>ParseCXXTypeConstructExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>ParseCXXSimpleTypeSpecifier</name><parameter_list>(<parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>ParseCXXTypeSpecifierSeq</name><parameter_list>(<parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>ParseExpressionListOrTypeId</name><parameter_list>(<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Exprs</name></decl></parameter>,
<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseDirectNewDeclarator</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseCXXNewExpression</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>UseGlobal</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Start</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseCXXDeleteExpression</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>UseGlobal</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Start</name></decl></parameter>)</parameter_list>;</function_decl>



<struct_decl>struct <name>ForRangeInfo</name>;</struct_decl>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ConditionResult</name> <macro><name>ParseCXXCondition</name><argument_list>(<argument>StmtResult *InitStmt</argument>,
<argument>SourceLocation Loc</argument>,
<argument>Sema::ConditionKind CK</argument>,
<argument>ForRangeInfo *FRI = nullptr</argument>,
<argument>bool EnterForConditionScope = false</argument>)</argument_list></macro></expr>;</expr_stmt>




<function_decl><type><name>ExprResult</name></type> <name>ParseCoyieldExpression</name><parameter_list>()</parameter_list>;</function_decl>




<function_decl><type><name>ExprResult</name></type> <name>ParseRequiresExpression</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseTrailingRequiresClause</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>








<function><type><name>ExprResult</name></type> <name>ParseInitializer</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>isNot</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>l_brace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ParseAssignmentExpression</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>ParseBraceInitializer</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function_decl><type><name>bool</name></type> <name>MayBeDesignationStart</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseBraceInitializer</name><parameter_list>()</parameter_list>;</function_decl>
<struct>struct <name>DesignatorCompletionInfo</name> <block>{
<decl_stmt><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>InitExprs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>PreferredBaseType</name></decl>;</decl_stmt>
}</block>;</struct>
<function_decl><type><name>ExprResult</name></type> <name>ParseInitializerWithPotentialDesignator</name><parameter_list>(<parameter><decl><type><name>DesignatorCompletionInfo</name></type></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>ExprResult</name></type> <name>ParseBlockLiteralExpression</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>ParseObjCAtExpression</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLocation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseObjCStringLiteral</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseObjCCharacterLiteral</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseObjCNumericLiteral</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseObjCBooleanLiteral</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ArgValue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseObjCArrayLiteral</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseObjCDictionaryLiteral</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseObjCBoxedExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseObjCEncodeExpression</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseObjCSelectorExpression</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseObjCProtocolExpression</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isSimpleObjCMessageExpression</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseObjCMessageExpression</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseObjCMessageExpressionBody</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LBracloc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>SuperLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>ReceiverType</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ReceiverExpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseAssignmentExprWithObjCMessageExprStart</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>LBracloc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>SuperLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>ReceiverType</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ReceiverExpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>ParseObjCXXMessageReceiver</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>IsExpr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>TypeOrExpr</name></decl></parameter>)</parameter_list>;</function_decl>






<typedef>typedef <type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>&gt;</argument_list></name></type> <name>StmtVector</name>;</typedef>

<typedef>typedef <type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>&gt;</argument_list></name></type> <name>ExprVector</name>;</typedef>

<typedef>typedef <type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ParsedType</name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>&gt;</argument_list></name></type> <name>TypeVector</name>;</typedef>

<function_decl><type><name>StmtResult</name></type>
<name>ParseStatement</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>TrailingElseLoc</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>ParsedStmtContext</name></type> <name>StmtCtx</name> <init>= <expr><name>ParsedStmtContext</name><operator>::</operator><name>SubStmt</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseStatementOrDeclaration</name><parameter_list>(
<parameter><decl><type><name>StmtVector</name> <modifier>&amp;</modifier></type><name>Stmts</name></decl></parameter>, <parameter><decl><type><name>ParsedStmtContext</name></type> <name>StmtCtx</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>TrailingElseLoc</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseStatementOrDeclarationAfterAttributes</name><parameter_list>(
<parameter><decl><type><name>StmtVector</name> <modifier>&amp;</modifier></type><name>Stmts</name></decl></parameter>,
<parameter><decl><type><name>ParsedStmtContext</name></type> <name>StmtCtx</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>TrailingElseLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseExprStatement</name><parameter_list>(<parameter><decl><type><name>ParsedStmtContext</name></type> <name>StmtCtx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseLabeledStatement</name><parameter_list>(<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>,
<parameter><decl><type><name>ParsedStmtContext</name></type> <name>StmtCtx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseCaseStatement</name><parameter_list>(<parameter><decl><type><name>ParsedStmtContext</name></type> <name>StmtCtx</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>MissingCase</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>ExprResult</name></type> <name>Expr</name> <init>= <expr><call><name>ExprResult</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseDefaultStatement</name><parameter_list>(<parameter><decl><type><name>ParsedStmtContext</name></type> <name>StmtCtx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseCompoundStatement</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isStmtExpr</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseCompoundStatement</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isStmtExpr</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>ScopeFlags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseCompoundStatementLeadingPragmas</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>ConsumeNullStmt</name><parameter_list>(<parameter><decl><type><name>StmtVector</name> <modifier>&amp;</modifier></type><name>Stmts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseCompoundStatementBody</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isStmtExpr</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>bool</name></type> <name>ParseParenExprOrCondition</name><argument_list>(<argument><expr><name>StmtResult</name> <operator>*</operator><name>InitStmt</name></expr></argument>,
<argument><expr><name>Sema</name><operator>::</operator><name>ConditionResult</name> <operator>&amp;</operator><name>CondResult</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ConditionKind</name> <name>CK</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <operator>*</operator><name>LParenLoc</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <operator>*</operator><name>RParenLoc</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>StmtResult</name></type> <name>ParseIfStatement</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>TrailingElseLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseSwitchStatement</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>TrailingElseLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseWhileStatement</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>TrailingElseLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseDoStatement</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseForStatement</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>TrailingElseLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseGotoStatement</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseContinueStatement</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseBreakStatement</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseReturnStatement</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseAsmStatement</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>msAsm</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseMicrosoftAsmStatement</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AsmLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParsePragmaLoopHint</name><parameter_list>(<parameter><decl><type><name>StmtVector</name> <modifier>&amp;</modifier></type><name>Stmts</name></decl></parameter>,
<parameter><decl><type><name>ParsedStmtContext</name></type> <name>StmtCtx</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>TrailingElseLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>)</parameter_list>;</function_decl>



<enum>enum <name>IfExistsBehavior</name> <block>{

<decl><name>IEB_Parse</name></decl>,

<decl><name>IEB_Skip</name></decl>,


<decl><name>IEB_Dependent</name></decl>
}</block>;</enum>



<struct>struct <name>IfExistsCondition</name> <block>{

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>KeywordLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>IsIfExists</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>UnqualifiedId</name></type> <name>Name</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>IfExistsBehavior</name></type> <name>Behavior</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><name>bool</name></type> <name>ParseMicrosoftIfExistsCondition</name><parameter_list>(<parameter><decl><type><name>IfExistsCondition</name><modifier>&amp;</modifier></type> <name>Result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseMicrosoftIfExistsStatement</name><parameter_list>(<parameter><decl><type><name>StmtVector</name> <modifier>&amp;</modifier></type><name>Stmts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseMicrosoftIfExistsExternalDeclaration</name><parameter_list>()</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>ParseMicrosoftIfExistsClassDeclaration</name><argument_list>(<argument><expr><name>DeclSpec</name><operator>::</operator><name>TST</name> <name>TagType</name></expr></argument>,
<argument><expr><name>ParsedAttributes</name> <operator>&amp;</operator><name>AccessAttrs</name></expr></argument>,
<argument><expr><name>AccessSpecifier</name> <operator>&amp;</operator><name>CurAS</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>bool</name></type> <name>ParseMicrosoftIfExistsBraceInitializer</name><parameter_list>(<parameter><decl><type><name>ExprVector</name> <modifier>&amp;</modifier></type><name>InitExprs</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>InitExprsOk</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>ParseAsmOperandsOpt</name><parameter_list>(<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Names</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Constraints</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Exprs</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>StmtResult</name></type> <name>ParseCXXTryBlock</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseCXXTryBlockCommon</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>TryLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>FnTry</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseCXXCatchBlock</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>FnCatch</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>StmtResult</name></type> <name>ParseSEHTryBlock</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseSEHExceptBlock</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseSEHFinallyBlock</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseSEHLeaveStatement</name><parameter_list>()</parameter_list>;</function_decl>




<function_decl><type><name>StmtResult</name></type> <name>ParseObjCAtStatement</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>atLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedStmtContext</name></type> <name>StmtCtx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseObjCTryStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>atLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseObjCThrowStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>atLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseObjCSynchronizedStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>atLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ParseObjCAutoreleasePoolStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>atLoc</name></decl></parameter>)</parameter_list>;</function_decl>








<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>DeclSpecContext</name> <block>{<block_content>
<expr_stmt><expr><name>DSC_normal</name></expr><operator>,</operator>
<expr><name>DSC_class</name></expr><operator>,</operator>
<expr><name>DSC_type_specifier</name></expr><operator>,</operator>
<expr><name>DSC_trailing</name></expr><operator>,</operator>
<expr><name>DSC_alias_declaration</name></expr><operator>,</operator>
<expr><name>DSC_top_level</name></expr><operator>,</operator>
<expr><name>DSC_template_param</name></expr><operator>,</operator>
<expr><name>DSC_template_type_arg</name></expr><operator>,</operator>
<expr><name>DSC_objc_method_result</name></expr><operator>,</operator>
<expr><name>DSC_condition</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>isTypeSpecifier</name><parameter_list>(<parameter><decl><type><name>DeclSpecContext</name></type> <name>DSC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>DSC</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_normal</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_template_param</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_class</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_top_level</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_objc_method_result</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_condition</name></expr>:</case>
<return>return <expr><name>false</name></expr>;</return>

<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_template_type_arg</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_type_specifier</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_trailing</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_alias_declaration</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Missing DeclSpecContext case"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>AllowDefiningTypeSpec</name> <block>{<block_content>


<expr_stmt><expr><name>No</name></expr><operator>,</operator>


<expr><name>NoButErrorRecovery</name></expr><operator>,</operator>


<expr><name>YesButInvalid</name></expr><operator>,</operator>

<expr><name>Yes</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<function><type><specifier>static</specifier> <name>AllowDefiningTypeSpec</name></type>
<name>isDefiningTypeSpecifierContext</name><parameter_list>(<parameter><decl><type><name>DeclSpecContext</name></type> <name>DSC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>DSC</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_normal</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_class</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_top_level</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_alias_declaration</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_objc_method_result</name></expr>:</case>
<return>return <expr><name>AllowDefiningTypeSpec</name><operator>::</operator><name>Yes</name></expr>;</return>

<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_condition</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_template_param</name></expr>:</case>
<return>return <expr><name>AllowDefiningTypeSpec</name><operator>::</operator><name>YesButInvalid</name></expr>;</return>

<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_template_type_arg</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_type_specifier</name></expr>:</case>
<return>return <expr><name>AllowDefiningTypeSpec</name><operator>::</operator><name>NoButErrorRecovery</name></expr>;</return>

<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_trailing</name></expr>:</case>
<return>return <expr><name>AllowDefiningTypeSpec</name><operator>::</operator><name>No</name></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Missing DeclSpecContext case"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>isOpaqueEnumDeclarationContext</name><parameter_list>(<parameter><decl><type><name>DeclSpecContext</name></type> <name>DSC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>DSC</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_normal</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_class</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_top_level</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>

<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_alias_declaration</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_objc_method_result</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_condition</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_template_param</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_template_type_arg</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_type_specifier</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_trailing</name></expr>:</case>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Missing DeclSpecContext case"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>isClassTemplateDeductionContext</name><parameter_list>(<parameter><decl><type><name>DeclSpecContext</name></type> <name>DSC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>DSC</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_normal</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_template_param</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_class</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_top_level</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_condition</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_type_specifier</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>

<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_objc_method_result</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_template_type_arg</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_trailing</name></expr>:</case>
<case>case <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_alias_declaration</name></expr>:</case>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Missing DeclSpecContext case"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<struct>struct <name>ForRangeInit</name> <block>{
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>RangeExpr</name></decl>;</decl_stmt>

<function><type><name>bool</name></type> <name>ParsedForRangeDecl</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>!</operator><call><name><name>ColonLoc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
}</block>;</struct>
<decl_stmt><decl><type><name><name>struct</name> <name>ForRangeInfo</name></name></type> <range>: <expr><name>ForRangeInit</name> <block>{
<expr><name>StmtResult</name> <name>LoopVar</name></expr>;
}</block></expr></range></decl>;</decl_stmt>

<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ParseDeclaration</name><parameter_list>(<parameter><decl><type><name>DeclaratorContext</name></type> <name>Context</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>DeclEnd</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>DeclSpecStart</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DeclGroupPtrTy</name></type>
<name>ParseSimpleDeclaration</name><parameter_list>(<parameter><decl><type><name>DeclaratorContext</name></type> <name>Context</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>DeclEnd</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>RequireSemi</name></decl></parameter>,
<parameter><decl><type><name>ForRangeInit</name> <modifier>*</modifier></type><name>FRI</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>DeclSpecStart</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>MightBeDeclarator</name><parameter_list>(<parameter><decl><type><name>DeclaratorContext</name></type> <name>Context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ParseDeclGroup</name><parameter_list>(<parameter><decl><type><name>ParsingDeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>, <parameter><decl><type><name>DeclaratorContext</name></type> <name>Context</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>DeclEnd</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>ForRangeInit</name> <modifier>*</modifier></type><name>FRI</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseDeclarationAfterDeclarator</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedTemplateInfo</name> <modifier>&amp;</modifier></type><name>TemplateInfo</name> <init>= <expr><call><name>ParsedTemplateInfo</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>ParseAsmAttributesAfterDeclarator</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseDeclarationAfterDeclaratorAndAttributes</name><parameter_list>(
<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedTemplateInfo</name> <modifier>&amp;</modifier></type><name>TemplateInfo</name> <init>= <expr><call><name>ParsedTemplateInfo</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>ForRangeInit</name> <modifier>*</modifier></type><name>FRI</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseFunctionStatementBody</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>, <parameter><decl><type><name>ParseScope</name> <modifier>&amp;</modifier></type><name>BodyScope</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseFunctionTryBlock</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>, <parameter><decl><type><name>ParseScope</name> <modifier>&amp;</modifier></type><name>BodyScope</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>trySkippingFunctionBody</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>ParseImplicitInt</name><parameter_list>(<parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>*</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedTemplateInfo</name> <modifier>&amp;</modifier></type><name>TemplateInfo</name></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>, <parameter><decl><type><name>DeclSpecContext</name></type> <name>DSC</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DeclSpecContext</name></type>
<name>getDeclSpecContextFromDeclaratorContext</name><parameter_list>(<parameter><decl><type><name>DeclaratorContext</name></type> <name>Context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseDeclarationSpecifiers</name><parameter_list>(
<parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedTemplateInfo</name> <modifier>&amp;</modifier></type><name>TemplateInfo</name> <init>= <expr><call><name>ParsedTemplateInfo</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name> <init>= <expr><name>AS_none</name></expr></init></decl></parameter>,
<parameter><decl><type><name>DeclSpecContext</name></type> <name>DSC</name> <init>= <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_normal</name></expr></init></decl></parameter>,
<parameter><decl><type><name>LateParsedAttrList</name> <modifier>*</modifier></type><name>LateAttrs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>DiagnoseMissingSemiAfterTagDefinition</name><parameter_list>(
<parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>, <parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>, <parameter><decl><type><name>DeclSpecContext</name></type> <name>DSContext</name></decl></parameter>,
<parameter><decl><type><name>LateParsedAttrList</name> <modifier>*</modifier></type><name>LateAttrs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ParseSpecifierQualifierList</name><parameter_list>(
<parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>, <parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name> <init>= <expr><name>AS_none</name></expr></init></decl></parameter>,
<parameter><decl><type><name>DeclSpecContext</name></type> <name>DSC</name> <init>= <expr><name>DeclSpecContext</name><operator>::</operator><name>DSC_normal</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ParseObjCTypeQualifierList</name><parameter_list>(<parameter><decl><type><name>ObjCDeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>,
<parameter><decl><type><name>DeclaratorContext</name></type> <name>Context</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ParseEnumSpecifier</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>TagLoc</name></decl></parameter>, <parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedTemplateInfo</name> <modifier>&amp;</modifier></type><name>TemplateInfo</name></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>, <parameter><decl><type><name>DeclSpecContext</name></type> <name>DSC</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseEnumBody</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>TagDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>ParseStructUnionBody</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>StartLoc</name></expr></argument>, <argument><expr><name>DeclSpec</name><operator>::</operator><name>TST</name> <name>TagType</name></expr></argument>,
<argument><expr><name>RecordDecl</name> <operator>*</operator><name>TagDecl</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>ParseStructDeclaration</name><argument_list>(
<argument><expr><name>ParsingDeclSpec</name> <operator>&amp;</operator><name>DS</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>ParsingFieldDeclarator</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>FieldsCallback</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>bool</name></type> <name>isDeclarationSpecifier</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>DisambiguatingWithExpression</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isTypeSpecifierQualifier</name><parameter_list>()</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>bool</name></type> <name>isKnownToBeTypeSpecifier</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Token</name> <operator>&amp;</operator><name>Tok</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<function><type><name>bool</name></type> <name>isKnownToBeDeclarationSpecifier</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>CPlusPlus</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>isCXXDeclarationSpecifier</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TPResult</name><operator>::</operator><name>True</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>isDeclarationSpecifier</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><name>bool</name></type> <name>isDeclarationStatement</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>CPlusPlus</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>isCXXDeclarationStatement</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>isDeclarationSpecifier</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>bool</name></type> <name>isForInitDeclaration</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>OpenMP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Actions</name><operator>.</operator><name>startOpenMPLoop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>CPlusPlus</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>isCXXSimpleDeclaration</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>isDeclarationSpecifier</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name>bool</name></type> <name>isForRangeIdentifier</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>isStartOfObjCClassMessageMissingOpenBracket</name><parameter_list>()</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>isConstructorDeclarator</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Unqualified</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>DeductionGuide</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<enum>enum <name>TentativeCXXTypeIdContext</name> <block>{
<decl><name>TypeIdInParens</name></decl>,
<decl><name>TypeIdUnambiguous</name></decl>,
<decl><name>TypeIdAsTemplateArgument</name></decl>
}</block>;</enum>





<function><type><name>bool</name></type> <name>isTypeIdInParens</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>isAmbiguous</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>CPlusPlus</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>isCXXTypeId</name><argument_list>(<argument><expr><name>TypeIdInParens</name></expr></argument>, <argument><expr><name>isAmbiguous</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>isAmbiguous</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<return>return <expr><call><name>isTypeSpecifierQualifier</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>isTypeIdInParens</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>isAmbiguous</name></decl>;</decl_stmt>
<return>return <expr><call><name>isTypeIdInParens</name><argument_list>(<argument><expr><name>isAmbiguous</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><name>bool</name></type> <name>isTypeIdUnambiguously</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>IsAmbiguous</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>CPlusPlus</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>isCXXTypeId</name><argument_list>(<argument><expr><name>TypeIdUnambiguous</name></expr></argument>, <argument><expr><name>IsAmbiguous</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>isTypeSpecifierQualifier</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function_decl><type><name>bool</name></type> <name>isCXXDeclarationStatement</name><parameter_list>()</parameter_list>;</function_decl>






<function_decl><type><name>bool</name></type> <name>isCXXSimpleDeclaration</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>AllowForRangeDecl</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>bool</name></type> <name>isCXXFunctionDeclarator</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>IsAmbiguous</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<struct_decl>struct <name>ConditionDeclarationOrInitStatementState</name>;</struct_decl>
<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>ConditionOrInitStatement</name> <block>{<block_content>
<expr_stmt><expr><name>Expression</name></expr><operator>,</operator>
<expr><name>ConditionDecl</name></expr><operator>,</operator>
<expr><name>InitStmtDecl</name></expr><operator>,</operator>
<expr><name>ForRangeDecl</name></expr><operator>,</operator>
<expr><name>Error</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<function_decl><type><name>ConditionOrInitStatement</name></type>
<name>isCXXConditionDeclarationOrInitStatement</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>CanBeInitStmt</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>CanBeForRangeDecl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>isCXXTypeId</name><parameter_list>(<parameter><decl><type><name>TentativeCXXTypeIdContext</name></type> <name>Context</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>isAmbiguous</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>bool</name></type> <name>isCXXTypeId</name><parameter_list>(<parameter><decl><type><name>TentativeCXXTypeIdContext</name></type> <name>Context</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>isAmbiguous</name></decl>;</decl_stmt>
<return>return <expr><call><name>isCXXTypeId</name><argument_list>(<argument><expr><name>Context</name></expr></argument>, <argument><expr><name>isAmbiguous</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>TPResult</name> <block>{<block_content>
<expr_stmt><expr><name>True</name></expr><operator>,</operator> <expr><name>False</name></expr><operator>,</operator> <expr><name>Ambiguous</name></expr><operator>,</operator> <expr><name>Error</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>








<function_decl><type><name>bool</name></type> <name>isEnumBase</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>AllowSemi</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>TPResult</name></type>
<name>isCXXDeclarationSpecifier</name><parameter_list>(<parameter><decl><type><name>TPResult</name></type> <name>BracedCastResult</name> <init>= <expr><name>TPResult</name><operator>::</operator><name>False</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>InvalidAsDeclSpec</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>isCXXDeclarationSpecifierAType</name><parameter_list>()</parameter_list>;</function_decl>




<function_decl><type><name>TPResult</name></type> <name>isTemplateArgumentList</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>TokensToSkip</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>TPResult</name></type> <name>isExplicitBool</name><parameter_list>()</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>isTentativelyDeclared</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>TPResult</name></type> <name>TryParseSimpleDeclaration</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>AllowForRangeDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>TPResult</name></type> <name>TryParseTypeofSpecifier</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>TPResult</name></type> <name>TryParseProtocolQualifiers</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>TPResult</name></type> <name>TryParsePtrOperatorSeq</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>TPResult</name></type> <name>TryParseOperatorId</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>TPResult</name></type> <name>TryParseInitDeclaratorList</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>TPResult</name></type> <name>TryParseDeclarator</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>mayBeAbstract</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>mayHaveIdentifier</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>mayHaveDirectInit</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>TPResult</name></type>
<name>TryParseParameterDeclarationClause</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>InvalidAsDeclaration</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>VersusTemplateArg</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>TPResult</name></type> <name>TryParseFunctionDeclarator</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>TPResult</name></type> <name>TryParseBracketDeclarator</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>TPResult</name></type> <name>TryConsumeDeclarationSpecifier</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>TrySkipAttributes</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>public</name>:</label>
<function_decl><type><name>TypeResult</name></type>
<name>ParseTypeName</name><parameter_list>(<parameter><decl><type><name>SourceRange</name> <modifier>*</modifier></type><name>Range</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>DeclaratorContext</name></type> <name>Context</name> <init>= <expr><name>DeclaratorContext</name><operator>::</operator><name>TypeName</name></expr></init></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name> <init>= <expr><name>AS_none</name></expr></init></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier><modifier>*</modifier></type><name>OwnedType</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>*</modifier></type><name>Attrs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
<function_decl><type><name>void</name></type> <name>ParseBlockId</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CaretLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>bool</name> <macro><name>standardAttributesAllowed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><name>LO</name> <operator>=</operator> <call><name>getLangOpts</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name><name>LO</name><operator>.</operator><name>DoubleSquareBracketAttributes</name></name></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>bool</name></type> <name>CheckProhibitedCXX11Attribute</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>l_square</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>standardAttributesAllowed</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>NextToken</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNot</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>l_square</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>DiagnoseProhibitedCXX11Attribute</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>bool</name></type> <name>DiagnoseProhibitedCXX11Attribute</name><parameter_list>()</parameter_list>;</function_decl>
<function><type><name>void</name></type> <name>CheckMisplacedCXX11Attribute</name><parameter_list>(<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>CorrectLocation</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>standardAttributesAllowed</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name><name>Tok</name><operator>.</operator><name>isNot</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>l_square</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>NextToken</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNot</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>l_square</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name><name>Tok</name><operator>.</operator><name>isNot</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>kw_alignas</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>DiagnoseMisplacedCXX11Attribute</name><argument_list>(<argument><expr><name>Attrs</name></expr></argument>, <argument><expr><name>CorrectLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function_decl><type><name>void</name></type> <name>DiagnoseMisplacedCXX11Attribute</name><parameter_list>(<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>CorrectLocation</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>stripTypeAttributesOffDeclSpec</name><argument_list>(<argument><expr><name>ParsedAttributesWithRange</name> <operator>&amp;</operator><name>Attrs</name></expr></argument>,
<argument><expr><name>DeclSpec</name> <operator>&amp;</operator><name>DS</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>TagUseKind</name> <name>TUK</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function><type><name>void</name></type> <name>ProhibitAttributes</name><parameter_list>(<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>FixItLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Attrs</name><operator>.</operator><name>Range</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>DiagnoseProhibitedAttributes</name><argument_list>(<argument><expr><name><name>Attrs</name><operator>.</operator><name>Range</name></name></expr></argument>, <argument><expr><name>FixItLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Attrs</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ProhibitAttributes</name><parameter_list>(<parameter><decl><type><name>ParsedAttributesViewWithRange</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>FixItLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Attrs</name><operator>.</operator><name>Range</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>DiagnoseProhibitedAttributes</name><argument_list>(<argument><expr><name><name>Attrs</name><operator>.</operator><name>Range</name></name></expr></argument>, <argument><expr><name>FixItLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Attrs</name><operator>.</operator><name>clearListOnly</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function_decl><type><name>void</name></type> <name>DiagnoseProhibitedAttributes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SourceRange</name> <modifier>&amp;</modifier></type><name>Range</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>FixItLoc</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>ProhibitCXX11Attributes</name><parameter_list>(<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DiagnoseEmptyAttrs</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>SourceLocation</name></type> <name>SkipCXX11Attributes</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>DiagnoseAndSkipCXX11Attributes</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>DiagnoseCXX11AttributeExtension</name><parameter_list>(<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name>unsigned</name></type>
<name>ParseAttributeArgsCommon</name><argument_list>(<argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>AttrName</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>AttrNameLoc</name></expr></argument>,
<argument><expr><name>ParsedAttributes</name> <operator>&amp;</operator><name>Attrs</name></expr></argument>, <argument><expr><name>SourceLocation</name> <operator>*</operator><name>EndLoc</name></expr></argument>,
<argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>ScopeName</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>ScopeLoc</name></expr></argument>,
<argument><expr><name>ParsedAttr</name><operator>::</operator><name>Syntax</name> <name>Syntax</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<enum>enum <name>ParseAttrKindMask</name> <block>{
<decl><name>PAKM_GNU</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal></expr></init></decl>,
<decl><name>PAKM_Declspec</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>,
<decl><name>PAKM_CXX11</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr></init></decl>,
}</block>;</enum>















<function_decl><type><name>void</name></type> <name>ParseAttributes</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>WhichAttrKinds</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>End</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>LateParsedAttrList</name> <modifier>*</modifier></type><name>LateAttrs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>void</name></type> <name>ParseAttributes</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>WhichAttrKinds</name></decl></parameter>, <parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>End</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>LateParsedAttrList</name> <modifier>*</modifier></type><name>LateAttrs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ParsedAttributesWithRange</name></type> <name>AttrsWithRange</name><argument_list>(<argument><expr><name>AttrFactory</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ParseAttributes</name><argument_list>(<argument><expr><name>WhichAttrKinds</name></expr></argument>, <argument><expr><name>AttrsWithRange</name></expr></argument>, <argument><expr><name>End</name></expr></argument>, <argument><expr><name>LateAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Attrs</name><operator>.</operator><name>takeAllFrom</name></name><argument_list>(<argument><expr><name>AttrsWithRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>bool</name></type> <name>MaybeParseAttributes</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>WhichAttrKinds</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>End</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>LateParsedAttrList</name> <modifier>*</modifier></type><name>LateAttrs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>isOneOf</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>kw___attribute</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw___declspec</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><call><name>standardAttributesAllowed</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isCXX11AttributeSpecifier</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ParseAttributes</name><argument_list>(<argument><expr><name>WhichAttrKinds</name></expr></argument>, <argument><expr><name>Attrs</name></expr></argument>, <argument><expr><name>End</name></expr></argument>, <argument><expr><name>LateAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>MaybeParseAttributes</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>WhichAttrKinds</name></decl></parameter>, <parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>End</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>LateParsedAttrList</name> <modifier>*</modifier></type><name>LateAttrs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>isOneOf</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>kw___attribute</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw___declspec</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><call><name>standardAttributesAllowed</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isCXX11AttributeSpecifier</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ParseAttributes</name><argument_list>(<argument><expr><name>WhichAttrKinds</name></expr></argument>, <argument><expr><name>Attrs</name></expr></argument>, <argument><expr><name>End</name></expr></argument>, <argument><expr><name>LateAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>MaybeParseGNUAttributes</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>LateParsedAttrList</name> <modifier>*</modifier></type><name>LateAttrs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>kw___attribute</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ParsedAttributes</name></type> <name>attrs</name><argument_list>(<argument><expr><name>AttrFactory</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>endLoc</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ParseGNUAttributes</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endLoc</name></expr></argument>, <argument><expr><name>LateAttrs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>D</name><operator>.</operator><name>takeAttributes</name></name><argument_list>(<argument><expr><name>attrs</name></expr></argument>, <argument><expr><name>endLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>






<function><type><name>bool</name></type> <name>MaybeParseGNUAttributes</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>EndLoc</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>LateParsedAttrList</name> <modifier>*</modifier></type><name>LateAttrs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>kw___attribute</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ParsedAttributesWithRange</name></type> <name>AttrsWithRange</name><argument_list>(<argument><expr><name>AttrFactory</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ParseGNUAttributes</name><argument_list>(<argument><expr><name>Attrs</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>LateAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Attrs</name><operator>.</operator><name>takeAllFrom</name></name><argument_list>(<argument><expr><name>AttrsWithRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>MaybeParseGNUAttributes</name><parameter_list>(<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>EndLoc</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>LateParsedAttrList</name> <modifier>*</modifier></type><name>LateAttrs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>kw___attribute</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ParseGNUAttributes</name><argument_list>(<argument><expr><name>Attrs</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>LateAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>ParseGNUAttributes</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>EndLoc</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>LateParsedAttrList</name> <modifier>*</modifier></type><name>LateAttrs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>Declarator</name> <modifier>*</modifier></type><name>D</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ParsedAttributesWithRange</name></type> <name>AttrsWithRange</name><argument_list>(<argument><expr><name>AttrFactory</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ParseGNUAttributes</name><argument_list>(<argument><expr><name>AttrsWithRange</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>LateAttrs</name></expr></argument>, <argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Attrs</name><operator>.</operator><name>takeAllFrom</name></name><argument_list>(<argument><expr><name>AttrsWithRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>ParseGNUAttributes</name><parameter_list>(<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>EndLoc</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>LateParsedAttrList</name> <modifier>*</modifier></type><name>LateAttrs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>Declarator</name> <modifier>*</modifier></type><name>D</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>ParseGNUAttributeArgs</name><argument_list>(<argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>AttrName</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>AttrNameLoc</name></expr></argument>,
<argument><expr><name>ParsedAttributes</name> <operator>&amp;</operator><name>Attrs</name></expr></argument>, <argument><expr><name>SourceLocation</name> <operator>*</operator><name>EndLoc</name></expr></argument>,
<argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>ScopeName</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>ScopeLoc</name></expr></argument>,
<argument><expr><name>ParsedAttr</name><operator>::</operator><name>Syntax</name> <name>Syntax</name></expr></argument>, <argument><expr><name>Declarator</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>IdentifierLoc</name> <modifier>*</modifier></type><name>ParseIdentifierLoc</name><parameter_list>()</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>unsigned</name></type>
<name>ParseClangAttributeArgs</name><argument_list>(<argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>AttrName</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>AttrNameLoc</name></expr></argument>,
<argument><expr><name>ParsedAttributes</name> <operator>&amp;</operator><name>Attrs</name></expr></argument>, <argument><expr><name>SourceLocation</name> <operator>*</operator><name>EndLoc</name></expr></argument>,
<argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>ScopeName</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>ScopeLoc</name></expr></argument>,
<argument><expr><name>ParsedAttr</name><operator>::</operator><name>Syntax</name> <name>Syntax</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>ReplayOpenMPAttributeTokens</name><parameter_list>(<parameter><decl><type><name>CachedTokens</name> <modifier>&amp;</modifier></type><name>OpenMPTokens</name></decl></parameter>)</parameter_list> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>OpenMPTokens</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>PP</name><operator>.</operator><name>EnterToken</name></name><argument_list>(<argument><expr><name>Tok</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>PP</name><operator>.</operator><name>EnterTokenStream</name></name><argument_list>(<argument><expr><name>OpenMPTokens</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ConsumeAnyToken</name><argument_list>( <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>MaybeParseCXX11Attributes</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>standardAttributesAllowed</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isCXX11AttributeSpecifier</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ParsedAttributesWithRange</name></type> <name>attrs</name><argument_list>(<argument><expr><name>AttrFactory</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>endLoc</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ParseCXX11Attributes</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>D</name><operator>.</operator><name>takeAttributes</name></name><argument_list>(<argument><expr><name>attrs</name></expr></argument>, <argument><expr><name>endLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>MaybeParseCXX11Attributes</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>endLoc</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>standardAttributesAllowed</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isCXX11AttributeSpecifier</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ParsedAttributesWithRange</name></type> <name>attrsWithRange</name><argument_list>(<argument><expr><name>AttrFactory</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ParseCXX11Attributes</name><argument_list>(<argument><expr><name>attrsWithRange</name></expr></argument>, <argument><expr><name>endLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>attrs</name><operator>.</operator><name>takeAllFrom</name></name><argument_list>(<argument><expr><name>attrsWithRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>MaybeParseCXX11Attributes</name><parameter_list>(<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>endLoc</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>OuterMightBeMessageSend</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>standardAttributesAllowed</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>isCXX11AttributeSpecifier</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>OuterMightBeMessageSend</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ParseCXX11Attributes</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>, <argument><expr><name>endLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>ParseOpenMPAttributeArgs</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>AttrName</name></decl></parameter>,
<parameter><decl><type><name>CachedTokens</name> <modifier>&amp;</modifier></type><name>OpenMPTokens</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ParseCXX11AttributeSpecifierInternal</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>CachedTokens</name> <modifier>&amp;</modifier></type><name>OpenMPTokens</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>EndLoc</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>void</name></type> <name>ParseCXX11AttributeSpecifier</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>EndLoc</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CachedTokens</name></type> <name>OpenMPTokens</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ParseCXX11AttributeSpecifierInternal</name><argument_list>(<argument><expr><name>Attrs</name></expr></argument>, <argument><expr><name>OpenMPTokens</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ReplayOpenMPAttributeTokens</name><argument_list>(<argument><expr><name>OpenMPTokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function_decl><type><name>void</name></type> <name>ParseCXX11Attributes</name><parameter_list>(<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>EndLoc</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>ParseCXX11AttributeArgs</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>AttrName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AttrNameLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ScopeName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ScopeLoc</name></decl></parameter>,
<parameter><decl><type><name>CachedTokens</name> <modifier>&amp;</modifier></type><name>OpenMPTokens</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>TryParseCXX11AttributeIdentifier</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type> <name>MaybeParseMicrosoftAttributes</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>endLoc</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>MicrosoftExt</name> <operator>&amp;&amp;</operator> <call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>l_square</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ParseMicrosoftAttributes</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>, <argument><expr><name>endLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function_decl><type><name>void</name></type> <name>ParseMicrosoftUuidAttributeArgs</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseMicrosoftAttributes</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>endLoc</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>bool</name></type> <name>MaybeParseMicrosoftDeclSpecs</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>End</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>LO</name> <init>= <expr><call><name>getLangOpts</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>LO</name><operator>.</operator><name>DeclSpecKeyword</name></name> <operator>&amp;&amp;</operator> <call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>kw___declspec</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ParseMicrosoftDeclSpecs</name><argument_list>(<argument><expr><name>Attrs</name></expr></argument>, <argument><expr><name>End</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<function_decl><type><name>void</name></type> <name>ParseMicrosoftDeclSpecs</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>End</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>ParseMicrosoftDeclSpecArgs</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>AttrName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AttrNameLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseMicrosoftTypeAttributes</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DiagnoseAndSkipExtendedMicrosoftTypeAttributes</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>SourceLocation</name></type> <name>SkipExtendedMicrosoftTypeAttributes</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseMicrosoftInheritanceClassAttributes</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseBorlandTypeAttributes</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseOpenCLKernelAttributes</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseOpenCLQualifiers</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseNullabilityTypeSpecifiers</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VersionTuple</name></type> <name>ParseVersionTuple</name><parameter_list>(<parameter><decl><type><name>SourceRange</name> <modifier>&amp;</modifier></type><name>Range</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>ParseAvailabilityAttribute</name><argument_list>(<argument><expr><name>IdentifierInfo</name> <operator>&amp;</operator><name>Availability</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>AvailabilityLoc</name></expr></argument>,
<argument><expr><name>ParsedAttributes</name> <operator>&amp;</operator><name>attrs</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <operator>*</operator><name>endLoc</name></expr></argument>,
<argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>ScopeName</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>ScopeLoc</name></expr></argument>,
<argument><expr><name>ParsedAttr</name><operator>::</operator><name>Syntax</name> <name>Syntax</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>AvailabilitySpec</name></expr></argument>&gt;</argument_list></name></type> <name>ParseAvailabilitySpec</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseAvailabilityCheckExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>ParseExternalSourceSymbolAttribute</name><argument_list>(<argument><expr><name>IdentifierInfo</name> <operator>&amp;</operator><name>ExternalSourceSymbol</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name>ParsedAttributes</name> <operator>&amp;</operator><name>Attrs</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <operator>*</operator><name>EndLoc</name></expr></argument>,
<argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>ScopeName</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>ScopeLoc</name></expr></argument>,
<argument><expr><name>ParsedAttr</name><operator>::</operator><name>Syntax</name> <name>Syntax</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>ParseObjCBridgeRelatedAttribute</name><argument_list>(<argument><expr><name>IdentifierInfo</name> <operator>&amp;</operator><name>ObjCBridgeRelated</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>ObjCBridgeRelatedLoc</name></expr></argument>,
<argument><expr><name>ParsedAttributes</name> <operator>&amp;</operator><name>attrs</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <operator>*</operator><name>endLoc</name></expr></argument>,
<argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>ScopeName</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>ScopeLoc</name></expr></argument>,
<argument><expr><name>ParsedAttr</name><operator>::</operator><name>Syntax</name> <name>Syntax</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>ParseSwiftNewTypeAttribute</name><argument_list>(<argument><expr><name>IdentifierInfo</name> <operator>&amp;</operator><name>AttrName</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>AttrNameLoc</name></expr></argument>,
<argument><expr><name>ParsedAttributes</name> <operator>&amp;</operator><name>Attrs</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <operator>*</operator><name>EndLoc</name></expr></argument>,
<argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>ScopeName</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>ScopeLoc</name></expr></argument>,
<argument><expr><name>ParsedAttr</name><operator>::</operator><name>Syntax</name> <name>Syntax</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>ParseTypeTagForDatatypeAttribute</name><argument_list>(<argument><expr><name>IdentifierInfo</name> <operator>&amp;</operator><name>AttrName</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>AttrNameLoc</name></expr></argument>,
<argument><expr><name>ParsedAttributes</name> <operator>&amp;</operator><name>Attrs</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <operator>*</operator><name>EndLoc</name></expr></argument>,
<argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>ScopeName</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>ScopeLoc</name></expr></argument>,
<argument><expr><name>ParsedAttr</name><operator>::</operator><name>Syntax</name> <name>Syntax</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type>
<name>ParseAttributeWithTypeArg</name><argument_list>(<argument><expr><name>IdentifierInfo</name> <operator>&amp;</operator><name>AttrName</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>AttrNameLoc</name></expr></argument>, <argument><expr><name>ParsedAttributes</name> <operator>&amp;</operator><name>Attrs</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <operator>*</operator><name>EndLoc</name></expr></argument>, <argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>ScopeName</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>ScopeLoc</name></expr></argument>, <argument><expr><name>ParsedAttr</name><operator>::</operator><name>Syntax</name> <name>Syntax</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>ParseTypeofSpecifier</name><parameter_list>(<parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>SourceLocation</name></type> <name>ParseDecltypeSpecifier</name><parameter_list>(<parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>AnnotateExistingDecltypeSpecifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseUnderlyingTypeSpecifier</name><parameter_list>(<parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseAtomicSpecifier</name><parameter_list>(<parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ParseAlignArgument</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Start</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>EllipsisLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseAlignmentSpecifier</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>endLoc</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseExtIntegerArgument</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>VirtSpecifiers</name><operator>::</operator><name>Specifier</name> <macro><name>isCXX11VirtSpecifier</name><argument_list>(<argument>const Token &amp;Tok</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>VirtSpecifiers</name><operator>::</operator><name>Specifier</name> <macro><name>isCXX11VirtSpecifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isCXX11VirtSpecifier</name><argument_list>(<argument><expr><name>Tok</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function_decl><type><name>void</name></type> <name>ParseOptionalCXX11VirtSpecifierSeq</name><parameter_list>(<parameter><decl><type><name>VirtSpecifiers</name> <modifier>&amp;</modifier></type><name>VS</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsInterface</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>FriendLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>bool</name> <macro><name>isCXX11FinalKeyword</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<function><type><name>bool</name></type> <name>isClassCompatibleKeyword</name><parameter_list>()</parameter_list> const;</function>




<decl_stmt><decl><type><name>class</name></type> <name>DeclaratorScopeObj</name> <block>{<block_content>
<decl_stmt><decl><type><name>Parser</name> <modifier>&amp;</modifier></type><name>P</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>EnteredScope</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>CreatedScope</name></decl>;</decl_stmt>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>DeclaratorScopeObj</name><argument_list>(<argument><expr><name>Parser</name> <operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>CXXScopeSpec</name> <operator>&amp;</operator><name>ss</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>P</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>SS</name><argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>EnteredScope</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>CreatedScope</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>EnterDeclaratorScope</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>EnteredScope</name> <operator>&amp;&amp;</operator> <literal type="string">"Already entered the scope!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>SS</name><operator>.</operator><name>isSet</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"C++ scope was not set!"</literal></expr></argument>)</argument_list></call></expr>;

<expr><name>CreatedScope</name> <operator>=</operator> <name>true</name></expr>;
<expr><call><name><name>P</name><operator>.</operator><name>EnterScope</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>P</name><operator>.</operator><name>Actions</name><operator>.</operator><name>ActOnCXXEnterDeclaratorScope</name></name><argument_list>(<argument><expr><call><name><name>P</name><operator>.</operator><name>getCurScope</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>EnteredScope</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>

<expr_stmt><expr><operator>~</operator><macro><name>DeclaratorScopeObj</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>EnteredScope</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>SS</name><operator>.</operator><name>isSet</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"C++ scope was cleared ?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>P</name><operator>.</operator><name>Actions</name><operator>.</operator><name>ActOnCXXExitDeclaratorScope</name></name><argument_list>(<argument><expr><call><name><name>P</name><operator>.</operator><name>getCurScope</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
if (CreatedScope</block></if></if_stmt>)
<call><name><name>P</name><operator>.</operator><name>ExitScope</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<function_decl><type><name>void</name></type> <name>ParseDeclarator</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <expr_stmt><expr><call><call><name>void</name> <argument_list>(<argument><expr><name>Parser</name><operator>::</operator><operator>*</operator><name>DirectDeclParseFunction</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>Declarator</name><operator>&amp;</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></typedef>
<function_decl><type><name>void</name></type> <name>ParseDeclaratorInternal</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>DirectDeclParseFunction</name></type> <name>DirectDeclParser</name></decl></parameter>)</parameter_list>;</function_decl>

<enum>enum <name>AttrRequirements</name> <block>{
<decl><name>AR_NoAttributesParsed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>AR_GNUAttributesParsedAndRejected</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal></expr></init></decl>,
<decl><name>AR_GNUAttributesParsed</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>,
<decl><name>AR_CXX11AttributesParsed</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr></init></decl>,
<decl><name>AR_DeclspecAttributesParsed</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal></expr></init></decl>,
<decl><name>AR_AllAttributesParsed</name> <init>= <expr><name>AR_GNUAttributesParsed</name> <operator>|</operator>
<name>AR_CXX11AttributesParsed</name> <operator>|</operator>
<name>AR_DeclspecAttributesParsed</name></expr></init></decl>,
<decl><name>AR_VendorAttributesParsed</name> <init>= <expr><name>AR_GNUAttributesParsed</name> <operator>|</operator>
<name>AR_DeclspecAttributesParsed</name></expr></init></decl>
}</block>;</enum>

<function_decl><type><name>void</name></type> <name>ParseTypeQualifierListOpt</name><parameter_list>(
<parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>AttrReqs</name> <init>= <expr><name>AR_AllAttributesParsed</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AtomicAllowed</name> <init>= <expr><name>true</name></expr></init></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IdentifierRequired</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>CodeCompletionHandler</name> <init>= <expr><name>None</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseDirectDeclarator</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseDecompositionDeclarator</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseParenDeclarator</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseFunctionDeclarator</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>,
<parameter><decl><type><name>BalancedDelimiterTracker</name> <modifier>&amp;</modifier></type><name>Tracker</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsAmbiguous</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>RequiresArg</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>InitCXXThisScopeForDeclaratorIfRelevant</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>Declarator</name> <operator>&amp;</operator><name>D</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>DeclSpec</name> <operator>&amp;</operator><name>DS</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>Sema</name><operator>::</operator><name>CXXThisScopeRAII</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>ThisScope</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>bool</name></type> <name>ParseRefQualifier</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>RefQualifierIsLValueRef</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>RefQualifierLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isFunctionDeclaratorIdentifierList</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseFunctionDeclaratorIdentifierList</name><parameter_list>(
<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>DeclaratorChunk</name><operator>::</operator><name>ParamInfo</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>ParamInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseParameterDeclarationClause</name><parameter_list>(
<parameter><decl><type><name>DeclaratorContext</name></type> <name>DeclaratorContext</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>DeclaratorChunk</name><operator>::</operator><name>ParamInfo</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>ParamInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>EllipsisLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseBracketDeclarator</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseMisplacedBracketDeclarator</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>





<enum>enum <name>CXX11AttributeKind</name> <block>{

<decl><name>CAK_NotAttributeSpecifier</name></decl>,

<decl><name>CAK_AttributeSpecifier</name></decl>,


<decl><name>CAK_InvalidAttributeSpecifier</name></decl>
}</block>;</enum>
<function_decl><type><name>CXX11AttributeKind</name></type>
<name>isCXX11AttributeSpecifier</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Disambiguate</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>OuterMightBeMessageSend</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>DiagnoseUnexpectedNamespace</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Context</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ParseNamespace</name><parameter_list>(<parameter><decl><type><name>DeclaratorContext</name></type> <name>Context</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>DeclEnd</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>InlineLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>InnerNamespaceInfo</name> <block>{
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>NamespaceLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>InlineLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>IdentLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name>using</name></type> <name>InnerNamespaceInfoList</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>InnerNamespaceInfo</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>ParseInnerNamespace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InnerNamespaceInfoList</name> <modifier>&amp;</modifier></type><name>InnerNSs</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>InlineLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>,
<parameter><decl><type><name>BalancedDelimiterTracker</name> <modifier>&amp;</modifier></type><name>Tracker</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseLinkage</name><parameter_list>(<parameter><decl><type><name>ParsingDeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>, <parameter><decl><type><name>DeclaratorContext</name></type> <name>Context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseExportDeclaration</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ParseUsingDirectiveOrDeclaration</name><parameter_list>(
<parameter><decl><type><name>DeclaratorContext</name></type> <name>Context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParsedTemplateInfo</name> <modifier>&amp;</modifier></type><name>TemplateInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>DeclEnd</name></decl></parameter>, <parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseUsingDirective</name><parameter_list>(<parameter><decl><type><name>DeclaratorContext</name></type> <name>Context</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>UsingLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>DeclEnd</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>UsingDeclarator</name> <block>{
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>TypenameLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UnqualifiedId</name></type> <name>Name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>clear</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>TypenameLoc</name> <operator>=</operator> <name>EllipsisLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Name</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
}</block>;</struct>

<function_decl><type><name>bool</name></type> <name>ParseUsingDeclarator</name><parameter_list>(<parameter><decl><type><name>DeclaratorContext</name></type> <name>Context</name></decl></parameter>, <parameter><decl><type><name>UsingDeclarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ParseUsingDeclaration</name><parameter_list>(<parameter><decl><type><name>DeclaratorContext</name></type> <name>Context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedTemplateInfo</name> <modifier>&amp;</modifier></type><name>TemplateInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>UsingLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>DeclEnd</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name> <init>= <expr><name>AS_none</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseAliasDeclarationAfterDeclarator</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>ParsedTemplateInfo</name> <modifier>&amp;</modifier></type><name>TemplateInfo</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>UsingLoc</name></decl></parameter>,
<parameter><decl><type><name>UsingDeclarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>DeclEnd</name></decl></parameter>, <parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier><modifier>*</modifier></type><name>OwnedType</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseStaticAssertDeclaration</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>DeclEnd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseNamespaceAlias</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>NamespaceLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AliasLoc</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Alias</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>DeclEnd</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>isValidAfterTypeSpecifier</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>CouldBeBitfield</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>ParseClassSpecifier</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>TagTokKind</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>TagLoc</name></expr></argument>,
<argument><expr><name>DeclSpec</name> <operator>&amp;</operator><name>DS</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ParsedTemplateInfo</name> <operator>&amp;</operator><name>TemplateInfo</name></expr></argument>,
<argument><expr><name>AccessSpecifier</name> <name>AS</name></expr></argument>, <argument><expr><name>bool</name> <name>EnteringContext</name></expr></argument>,
<argument><expr><name>DeclSpecContext</name> <name>DSC</name></expr></argument>,
<argument><expr><name>ParsedAttributesWithRange</name> <operator>&amp;</operator><name>Attributes</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>SkipCXXMemberSpecification</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AttrFixitLoc</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>TagType</name></decl></parameter>,
<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>TagDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseCXXMemberSpecification</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AttrFixitLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>TagType</name></decl></parameter>,
<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>TagDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseCXXMemberInitializer</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsFunction</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>EqualLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type>
<name>ParseCXXMemberDeclaratorBeforeInitializer</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>DeclaratorInfo</name></decl></parameter>,
<parameter><decl><type><name>VirtSpecifiers</name> <modifier>&amp;</modifier></type><name>VS</name></decl></parameter>,
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>BitfieldSize</name></decl></parameter>,
<parameter><decl><type><name>LateParsedAttrList</name> <modifier>&amp;</modifier></type><name>LateAttrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>MaybeParseAndDiagnoseDeclSpecAfterCXX11VirtSpecifierSeq</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>VirtSpecifiers</name> <modifier>&amp;</modifier></type><name>VS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ParseCXXClassMemberDeclaration</name><parameter_list>(
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>, <parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedTemplateInfo</name> <modifier>&amp;</modifier></type><name>TemplateInfo</name> <init>= <expr><call><name>ParsedTemplateInfo</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>ParsingDeclRAIIObject</name> <modifier>*</modifier></type><name>DiagsFromTParams</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>DeclGroupPtrTy</name></type> <name>ParseCXXClassMemberDeclarationWithPragmas</name><argument_list>(
<argument><expr><name>AccessSpecifier</name> <operator>&amp;</operator><name>AS</name></expr></argument>, <argument><expr><name>ParsedAttributesWithRange</name> <operator>&amp;</operator><name>AccessAttrs</name></expr></argument>,
<argument><expr><name>DeclSpec</name><operator>::</operator><name>TST</name> <name>TagType</name></expr></argument>, <argument><expr><name>Decl</name> <operator>*</operator><name>Tag</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>ParseConstructorInitializer</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ConstructorDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>MemInitResult</name></type> <name>ParseMemInitializer</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ConstructorDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandleMemberFunctionDeclDelays</name><parameter_list>(<parameter><decl><type><name>Declarator</name><modifier>&amp;</modifier></type> <name>DeclaratorInfo</name></decl></parameter>,
<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ThisDecl</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>TypeResult</name></type> <name>ParseBaseTypeSpecifier</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>BaseLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>EndLocation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ParseBaseClause</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ClassDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>BaseResult</name></type> <name>ParseBaseSpecifier</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ClassDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>AccessSpecifier</name> <macro><name>getAccessSpecifierIfPresent</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function_decl><type><name>bool</name></type> <name>ParseUnqualifiedIdTemplateId</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>ObjectType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ObjectHadErrors</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>EnteringContext</name></decl></parameter>,
<parameter><decl><type><name>UnqualifiedId</name> <modifier>&amp;</modifier></type><name>Id</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AssumeTemplateId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>ParseUnqualifiedIdOperator</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>EnteringContext</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>ObjectType</name></decl></parameter>,
<parameter><decl><type><name>UnqualifiedId</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ParseOMPDeclareSimdClauses</name><parameter_list>(<parameter><decl><type><name>DeclGroupPtrTy</name></type> <name>Ptr</name></decl></parameter>,
<parameter><decl><type><name>CachedTokens</name> <modifier>&amp;</modifier></type><name>Toks</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>void</name></type> <name>parseOMPTraitPropertyKind</name><argument_list>(<argument><expr><name>OMPTraitProperty</name> <operator>&amp;</operator><name>TIProperty</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>TraitSet</name> <name>Set</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>TraitSelector</name> <name>Selector</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Seen</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>parseOMPTraitSelectorKind</name><argument_list>(<argument><expr><name>OMPTraitSelector</name> <operator>&amp;</operator><name>TISelector</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>TraitSet</name> <name>Set</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Seen</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>parseOMPTraitSetKind</name><argument_list>(<argument><expr><name>OMPTraitSet</name> <operator>&amp;</operator><name>TISet</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Seen</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>parseOMPContextProperty</name><argument_list>(<argument><expr><name>OMPTraitSelector</name> <operator>&amp;</operator><name>TISelector</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>TraitSet</name> <name>Set</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Seen</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>parseOMPContextSelector</name><argument_list>(<argument><expr><name>OMPTraitSelector</name> <operator>&amp;</operator><name>TISelector</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>TraitSet</name> <name>Set</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>SeenSelectors</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>parseOMPContextSelectorSet</name><argument_list>(<argument><expr><name>OMPTraitSet</name> <operator>&amp;</operator><name>TISet</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>SeenSets</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>bool</name></type> <name>parseOMPContextSelectors</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>OMPTraitInfo</name> <modifier>&amp;</modifier></type><name>TI</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>parseOMPDeclareVariantMatchClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>OMPTraitInfo</name> <modifier>&amp;</modifier></type><name>TI</name></decl></parameter>,
<parameter><decl><type><name>OMPTraitInfo</name> <modifier>*</modifier></type><name>ParentTI</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ParseOMPDeclareVariantClauses</name><parameter_list>(<parameter><decl><type><name>DeclGroupPtrTy</name></type> <name>Ptr</name></decl></parameter>, <parameter><decl><type><name>CachedTokens</name> <modifier>&amp;</modifier></type><name>Toks</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ParseOpenMPAssumesDirective</name><parameter_list>(<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>DKind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ParseOpenMPEndAssumesDirective</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>void</name></type> <name>ParseOMPDeclareTargetClauses</name><argument_list>(<argument><expr><name>Sema</name><operator>::</operator><name>DeclareTargetContextInfo</name> <operator>&amp;</operator><name>DTCI</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>ParseOMPEndDeclareTargetDirective</name><parameter_list>(<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>BeginDKind</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>EndDKind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>skipUntilPragmaOpenMPEnd</name><parameter_list>(<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>DKind</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type> <name>parseOMPEndDirective</name><parameter_list>(<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>BeginKind</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>ExpectedKind</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>FoundKind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>MatchingLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>FoundLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>SkipUntilOpenMPEnd</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>DeclGroupPtrTy</name></type> <name>ParseOpenMPDeclarativeDirectiveWithExtDecl</name><argument_list>(
<argument><expr><name>AccessSpecifier</name> <operator>&amp;</operator><name>AS</name></expr></argument>, <argument><expr><name>ParsedAttributesWithRange</name> <operator>&amp;</operator><name>Attrs</name></expr></argument>,
<argument><expr><name>bool</name> <name>Delayed</name> <operator>=</operator> <name>false</name></expr></argument>, <argument><expr><name>DeclSpec</name><operator>::</operator><name>TST</name> <name>TagType</name> <operator>=</operator> <name>DeclSpec</name><operator>::</operator><name>TST_unspecified</name></expr></argument>,
<argument><expr><name>Decl</name> <operator>*</operator><name>TagDecl</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ParseOpenMPDeclareReductionDirective</name><parameter_list>(<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ParseOpenMPReductionInitializerForDecl</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>OmpPrivParm</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ParseOpenMPDeclareMapperDirective</name><parameter_list>(<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TypeResult</name></type> <name>parseOpenMPDeclareMapperVarDecl</name><parameter_list>(<parameter><decl><type><name>SourceRange</name> <modifier>&amp;</modifier></type><name>Range</name></decl></parameter>,
<parameter><decl><type><name>DeclarationName</name> <modifier>&amp;</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name> <init>= <expr><name>AS_none</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>tryParseOpenMPArrayShapingCastPart</name><parameter_list>()</parameter_list>;</function_decl>








<decl_stmt><decl><type><name>bool</name></type> <name>ParseOpenMPSimpleVarList</name><argument_list>(
<argument><expr><name>OpenMPDirectiveKind</name> <name>Kind</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>CXXScopeSpec</name> <operator>&amp;</operator>, <name>DeclarationNameInfo</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator>
<name>Callback</name></expr></argument>,
<argument><expr><name>bool</name> <name>AllowScopeSpecifier</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>StmtResult</name></type>
<name>ParseOpenMPDeclarativeOrExecutableDirective</name><parameter_list>(<parameter><decl><type><name>ParsedStmtContext</name></type> <name>StmtCtx</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ParseOpenMPClause</name><parameter_list>(<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>DKind</name></decl></parameter>,
<parameter><decl><type><name>OpenMPClauseKind</name></type> <name>CKind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>FirstClause</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ParseOpenMPSingleExprClause</name><parameter_list>(<parameter><decl><type><name>OpenMPClauseKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ParseOnly</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ParseOpenMPSimpleClause</name><parameter_list>(<parameter><decl><type><name>OpenMPClauseKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ParseOnly</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ParseOpenMPSingleExprWithArgClause</name><parameter_list>(<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>DKind</name></decl></parameter>,
<parameter><decl><type><name>OpenMPClauseKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ParseOnly</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ParseOpenMPSizesClause</name><parameter_list>()</parameter_list>;</function_decl>







<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ParseOpenMPClause</name><parameter_list>(<parameter><decl><type><name>OpenMPClauseKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ParseOnly</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ParseOpenMPVarListClause</name><parameter_list>(<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>DKind</name></decl></parameter>,
<parameter><decl><type><name>OpenMPClauseKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ParseOnly</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>ExprResult</name></type> <name>ParseOpenMPIteratorsExpr</name><parameter_list>()</parameter_list>;</function_decl>




<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ParseOpenMPUsesAllocatorClause</name><parameter_list>(<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>DKind</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ParseOpenMPInteropClause</name><parameter_list>(<parameter><decl><type><name>OpenMPClauseKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ParseOnly</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>



<function_decl><type><name>ExprResult</name></type> <name>ParseOpenMPParensExpr</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>ClauseName</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>RLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsAddressOfOperand</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<struct>struct <name>OpenMPVarListDataTy</name> <block>{
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>DepModOrTailExpr</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>RLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>ReductionOrMapperIdScopeSpec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DeclarationNameInfo</name></type> <name>ReductionOrMapperId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ExtraModifier</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPMapModifierKind</name></expr></argument>, <argument><expr><name>NumberOfOMPMapClauseModifiers</name></expr></argument>&gt;</argument_list></name></type>
<name>MapTypeModifiers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>, <argument><expr><name>NumberOfOMPMapClauseModifiers</name></expr></argument>&gt;</argument_list></name></type>
<name>MapTypeModifiersLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPMotionModifierKind</name></expr></argument>, <argument><expr><name>NumberOfOMPMotionModifiers</name></expr></argument>&gt;</argument_list></name></type>
<name>MotionModifiers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>, <argument><expr><name>NumberOfOMPMotionModifiers</name></expr></argument>&gt;</argument_list></name></type> <name>MotionModifiersLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>IsMapTypeImplicit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ExtraModifierLoc</name></decl>;</decl_stmt>
}</block>;</struct>


<function_decl><type><name>bool</name></type> <name>ParseOpenMPVarList</name><parameter_list>(<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>DKind</name></decl></parameter>, <parameter><decl><type><name>OpenMPClauseKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Vars</name></decl></parameter>,
<parameter><decl><type><name>OpenMPVarListDataTy</name> <modifier>&amp;</modifier></type><name>Data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>ParseUnqualifiedId</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>ParsedType</name></type> <name>ObjectType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ObjectHadErrors</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>EnteringContext</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowDestructorName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>AllowConstructorName</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowDeductionGuide</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>TemplateKWLoc</name></decl></parameter>, <parameter><decl><type><name>UnqualifiedId</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>parseMapperModifier</name><parameter_list>(<parameter><decl><type><name>OpenMPVarListDataTy</name> <modifier>&amp;</modifier></type><name>Data</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>parseMapTypeModifiers</name><parameter_list>(<parameter><decl><type><name>OpenMPVarListDataTy</name> <modifier>&amp;</modifier></type><name>Data</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>




<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseDeclarationStartingWithTemplate</name><parameter_list>(<parameter><decl><type><name>DeclaratorContext</name></type> <name>Context</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>DeclEnd</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>AccessAttrs</name></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name> <init>= <expr><name>AS_none</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseTemplateDeclarationOrSpecialization</name><parameter_list>(<parameter><decl><type><name>DeclaratorContext</name></type> <name>Context</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>DeclEnd</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>AccessAttrs</name></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseSingleDeclarationAfterTemplate</name><parameter_list>(
<parameter><decl><type><name>DeclaratorContext</name></type> <name>Context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParsedTemplateInfo</name> <modifier>&amp;</modifier></type><name>TemplateInfo</name></decl></parameter>,
<parameter><decl><type><name>ParsingDeclRAIIObject</name> <modifier>&amp;</modifier></type><name>DiagsFromParams</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>DeclEnd</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>AccessAttrs</name></decl></parameter>, <parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name> <init>= <expr><name>AS_none</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>ParseTemplateParameters</name><parameter_list>(<parameter><decl><type><name>MultiParseScope</name> <modifier>&amp;</modifier></type><name>TemplateScopes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Depth</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>TemplateParams</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>LAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>RAngleLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>ParseTemplateParameterList</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Depth</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>TemplateParams</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>TPResult</name></type> <name>isStartOfTemplateTypeParameter</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ParseTemplateParameter</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Depth</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Position</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ParseTypeParameter</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Depth</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Position</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ParseTemplateTemplateParameter</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Depth</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Position</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ParseNonTypeTemplateParameter</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Depth</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Position</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isTypeConstraintAnnotation</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>TryAnnotateTypeConstraint</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DiagnoseMisplacedEllipsis</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>CorrectLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AlreadyHasEllipsis</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IdentifierHasName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DiagnoseMisplacedEllipsisInDeclarator</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ParsedTemplateArgument</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>TemplateArgList</name>;</typedef>

<function_decl><type><name>bool</name></type> <name>ParseGreaterThanInTemplateList</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>RAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ConsumeLastToken</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ObjCGenericList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>ParseTemplateIdAfterTemplateName</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>ConsumeLastToken</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>LAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>RAngleLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>AnnotateTemplateIdToken</name><parameter_list>(<parameter><decl><type><name>TemplateTy</name></type> <name>Template</name></decl></parameter>, <parameter><decl><type><name>TemplateNameKind</name></type> <name>TNK</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><name>UnqualifiedId</name> <modifier>&amp;</modifier></type><name>TemplateName</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowTypeAnnotation</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>TypeConstraint</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>AnnotateTemplateIdTokenAsType</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsClassName</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>ParseTemplateArgumentList</name><parameter_list>(<parameter><decl><type><name>TemplateArgList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ParsedTemplateArgument</name></type> <name>ParseTemplateTemplateArgument</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>ParsedTemplateArgument</name></type> <name>ParseTemplateArgument</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseExplicitInstantiation</name><parameter_list>(<parameter><decl><type><name>DeclaratorContext</name></type> <name>Context</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ExternLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>DeclEnd</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>AccessAttrs</name></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name> <init>= <expr><name>AS_none</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type>
<name>ParseConceptDefinition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParsedTemplateInfo</name> <modifier>&amp;</modifier></type><name>TemplateInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>DeclEnd</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ParseModuleDecl</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IsFirstDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParseModuleImport</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>parseMisplacedModuleImport</name><parameter_list>()</parameter_list>;</function_decl>
<function><type><name>bool</name></type> <name>tryParseMisplacedModuleImport</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Kind</name> <operator>=</operator> <call><name><name>Tok</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>Kind</name> <operator>==</operator> <name>tok</name><operator>::</operator><name>annot_module_begin</name> <operator>||</operator> <name>Kind</name> <operator>==</operator> <name>tok</name><operator>::</operator><name>annot_module_end</name> <operator>||</operator>
<name>Kind</name> <operator>==</operator> <name>tok</name><operator>::</operator><name>annot_module_include</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>parseMisplacedModuleImport</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>bool</name></type> <name>ParseModuleName</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>UseLoc</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <modifier>*</modifier></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Path</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsImport</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>ParseTypeTrait</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>ParseArrayTypeTrait</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ParseExpressionTrait</name><parameter_list>()</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>void</name></type> <name>CodeCompleteDirective</name><argument_list>(<argument><expr><name>bool</name> <name>InConditional</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<expr_stmt><expr><name>void</name> <macro><name>CodeCompleteInConditionalExclusion</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>CodeCompleteMacroName</name><argument_list>(<argument><expr><name>bool</name> <name>IsDefinition</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<expr_stmt><expr><name>void</name> <macro><name>CodeCompletePreprocessorExpression</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>CodeCompleteMacroArgument</name><argument_list>(<argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>Macro</name></expr></argument>, <argument><expr><name>MacroInfo</name> <operator>*</operator><name>MacroInfo</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>ArgumentIndex</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>CodeCompleteIncludedFile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>Dir</name></expr></argument>, <argument><expr><name>bool</name> <name>IsAngled</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<expr_stmt><expr><name>void</name> <macro><name>CodeCompleteNaturalLanguage</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>GNUAsmQualifiers</name> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>Qualifiers</name> <init>= <expr><name>AQ_unspecified</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>
<enum>enum <name>AQ</name> <block>{
<decl><name>AQ_unspecified</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>AQ_volatile</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>AQ_inline</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
<decl><name>AQ_goto</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,
}</block>;</enum>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getQualifierName</name><parameter_list>(<parameter><decl><type><name>AQ</name></type> <name>Qualifier</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>setAsmQualifier</name><parameter_list>(<parameter><decl><type><name>AQ</name></type> <name>Qualifier</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>inline</specifier> <name>bool</name> <macro><name>isVolatile</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Qualifiers</name> <operator>&amp;</operator> <name>AQ_volatile</name></expr>;</return> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>
<expr_stmt><expr><specifier>inline</specifier> <name>bool</name> <macro><name>isInline</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Qualifiers</name> <operator>&amp;</operator> <name>AQ_inline</name></expr>;</return> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>
<expr_stmt><expr><specifier>inline</specifier> <name>bool</name> <macro><name>isGoto</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Qualifiers</name> <operator>&amp;</operator> <name>AQ_goto</name></expr>;</return> }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isGCCAsmStatement</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Token</name> <operator>&amp;</operator><name>TokAfterAsm</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isGNUAsmQualifier</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Token</name> <operator>&amp;</operator><name>TokAfterAsm</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<expr_stmt><expr><name>GNUAsmQualifiers</name><operator>::</operator><name>AQ</name> <macro><name>getGNUAsmQualifier</name><argument_list>(<argument>const Token &amp;Tok</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<function_decl><type><name>bool</name></type> <name>parseGNUAsmQualifierListOpt</name><parameter_list>(<parameter><decl><type><name>GNUAsmQualifiers</name> <modifier>&amp;</modifier></type><name>AQ</name></decl></parameter>)</parameter_list>;</function_decl>
};

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
