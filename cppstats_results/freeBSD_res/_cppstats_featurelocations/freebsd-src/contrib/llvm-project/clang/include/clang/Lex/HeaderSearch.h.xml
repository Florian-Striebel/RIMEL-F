<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Lex/HeaderSearch.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_LEX_HEADERSEARCH_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_LEX_HEADERSEARCH_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/DirectoryLookup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/HeaderMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/ModuleMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SetVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Allocator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>DiagnosticsEngine</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DirectoryEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ExternalPreprocessorSource</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FileEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FileManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>HeaderSearchOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>IdentifierInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LangOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Module</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Preprocessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TargetInfo</name></decl>;</decl_stmt>



<struct>struct <name>HeaderFileInfo</name> <block>{

<decl_stmt><decl><type><name>unsigned</name></type> <name>isImport</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>isPragmaOnce</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>unsigned</name></type> <name>DirInfo</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>External</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>isModuleHeader</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>isCompilingModuleHeader</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>Resolved</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>








<decl_stmt><decl><type><name>unsigned</name></type> <name>IndexHeaderMapHeader</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>IsValid</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>NumIncludes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>






<decl_stmt><decl><type><name>unsigned</name></type> <name>ControllingMacroID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>









<decl_stmt><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>ControllingMacro</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>StringRef</name></type> <name>Framework</name></decl>;</decl_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SetVector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallString</name><argument_list type="generic">&lt;<argument><expr><literal type="number">32</literal></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallString</name><argument_list type="generic">&lt;<argument><expr><literal type="number">32</literal></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallSet</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallString</name><argument_list type="generic">&lt;<argument><expr><literal type="number">32</literal></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>Aliases</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>HeaderFileInfo</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>isImport</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>isPragmaOnce</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>DirInfo</name><argument_list>(<argument><expr><name>SrcMgr</name><operator>::</operator><name>C_User</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>External</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>isModuleHeader</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>isCompilingModuleHeader</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>Resolved</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IndexHeaderMapHeader</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>IsValid</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>



<specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator>
<call><name>getControllingMacro</name><argument_list>(<argument><expr><name>ExternalPreprocessorSource</name> <operator>*</operator><name>External</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isNonDefault</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>isImport</name> <operator>||</operator> <name>isPragmaOnce</name> <operator>||</operator> <name>NumIncludes</name> <operator>||</operator> <name>ControllingMacro</name> <operator>||</operator>
<name>ControllingMacroID</name></expr>;</return>
}</block></expr></expr_stmt>
}</block>;</struct>



<decl_stmt><decl><type><name>class</name></type> <name>ExternalHeaderFileInfoSource</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>ExternalHeaderFileInfoSource</name><argument_list>()</argument_list></call></expr>;</expr_stmt>






<function_decl><type><name>virtual</name> <name>HeaderFileInfo</name></type> <name>GetHeaderFileInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>FE</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<struct>struct <name>FrameworkCacheEntry</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>DirectoryEntry</name> <modifier>*</modifier></type><name>Directory</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>IsUserSpecifiedSystemFramework</name></decl>;</decl_stmt>
}</block>;</struct>



<decl_stmt><decl><type><name>class</name></type> <name>HeaderSearch</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>DirectoryLookup</name></decl>;</decl_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>HeaderSearchOptions</name></expr></argument>&gt;</argument_list></name> <name>HSOpts</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>DiagnosticsEngine</name> <modifier>&amp;</modifier></type><name>Diags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FileManager</name> <modifier>&amp;</modifier></type><name>FileMgr</name></decl>;</decl_stmt>







<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>DirectoryLookup</name></expr></argument>&gt;</argument_list></name> <name>SearchDirs</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>AngledDirIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>SystemDirIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>NoCurDirSearch</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>







<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>SystemHeaderPrefixes</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>ModuleHash</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>ModuleCachePath</name></expr>;</expr_stmt>



<expr_stmt><expr><name>mutable</name> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>HeaderFileInfo</name></expr></argument>&gt;</argument_list></name> <name>FileInfo</name></expr>;</expr_stmt>


<struct>struct <name>LookupFileCacheInfo</name> <block>{



<decl_stmt><decl><type><name>unsigned</name></type> <name>StartIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>HitIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>MappedName</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>LookupFileCacheInfo</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>

<function><type><name>void</name></type> <name>reset</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>StartIdx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>StartIdx</name></name> <operator>=</operator> <name>StartIdx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>MappedName</name></name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
</block_content>}</block></function>
}</block>;</struct>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>LookupFileCacheInfo</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name></expr></argument>&gt;</argument_list></name> <name>LookupFileCache</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>FrameworkCacheEntry</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name></expr></argument>&gt;</argument_list></name> <name>FrameworkMap</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name>using</name></type> <name>IncludeAliasMap</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>IncludeAliasMap</name></expr></argument>&gt;</argument_list></name> <name>IncludeAliases</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>HeaderMap</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>HeaderMaps</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>mutable</name> <name>ModuleMap</name></type> <name>ModMap</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>DirectoryEntry</name> <operator>*</operator></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>DirectoryHasModuleMap</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>LoadedModuleMaps</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringSet</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name></expr></argument>&gt;</argument_list></name> <name>FrameworkNames</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name>ExternalPreprocessorSource</name> <modifier>*</modifier></type><name>ExternalLookup</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ExternalHeaderFileInfoSource</name> <modifier>*</modifier></type><name>ExternalSource</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>HeaderSearch</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>HeaderSearchOptions</name></expr></argument>&gt;</argument_list></name> <name>HSOpts</name></expr></argument>,
<argument><expr><name>SourceManager</name> <operator>&amp;</operator><name>SourceMgr</name></expr></argument>, <argument><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diags</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><name>LangOpts</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>TargetInfo</name> <operator>*</operator><name>Target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HeaderSearch</name><argument_list>(<argument><expr><specifier>const</specifier> <name>HeaderSearch</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>HeaderSearch</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>HeaderSearch</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name>HeaderSearchOptions</name> <operator>&amp;</operator><macro><name>getHeaderSearchOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>HSOpts</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>FileManager</name> <operator>&amp;</operator><macro><name>getFileMgr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FileMgr</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><macro><name>getDiags</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Diags</name></expr>;</return> }</block></expr></expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>SetSearchPaths</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>DirectoryLookup</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>dirs</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>angledDirIdx</name></expr></argument>, <argument><expr><name>unsigned</name> <name>systemDirIdx</name></expr></argument>,
<argument><expr><name>bool</name> <name>noCurDirSearch</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>angledDirIdx</name> <operator>&lt;=</operator> <name>systemDirIdx</name> <operator>&amp;&amp;</operator> <name>systemDirIdx</name> <operator>&lt;=</operator> <call><name><name>dirs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Directory indices are unordered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SearchDirs</name> <operator>=</operator> <name>dirs</name></expr>;</expr_stmt>
<expr_stmt><expr><name>AngledDirIdx</name> <operator>=</operator> <name>angledDirIdx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>SystemDirIdx</name> <operator>=</operator> <name>systemDirIdx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>NoCurDirSearch</name> <operator>=</operator> <name>noCurDirSearch</name></expr>;</expr_stmt>

</block_content>}</block></decl></decl_stmt>


<function><type><name>void</name></type> <name>AddSearchPath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DirectoryLookup</name> <modifier>&amp;</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isAngled</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>idx</name> <init>= <expr><ternary><condition><expr><name>isAngled</name></expr> ?</condition><then> <expr><name>SystemDirIdx</name></expr> </then><else>: <expr><name>AngledDirIdx</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SearchDirs</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>SearchDirs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isAngled</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>AngledDirIdx</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>SystemDirIdx</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>SetSystemHeaderPrefixes</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>P</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>SystemHeaderPrefixes</name><operator>.</operator><name>assign</name></name><argument_list>(<argument><expr><call><name><name>P</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>P</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>HasIncludeAliasMap</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>bool</name><operator>)</operator><name>IncludeAliases</name></expr>;</return> }</block></expr></expr_stmt>





<function><type><name>void</name></type> <name>AddIncludeAlias</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Source</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Dest</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IncludeAliases</name></expr>)</condition><block type="pseudo"><block_content>
<macro><name>IncludeAliases</name></macro><expr_stmt><expr><operator>.</operator><macro><name>reset</name><argument_list>(<argument>new IncludeAliasMap</argument>)</argument_list></macro></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>IncludeAliases</name><operator>)</operator><index>[<expr><name>Source</name></expr>]</index> <operator>=</operator> <name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><name>Dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>StringRef</name></type> <name>MapHeaderToIncludeAlias</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Source</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>IncludeAliases</name> <operator>&amp;&amp;</operator> <literal type="string">"Trying to map headers when there's no map"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>IncludeAliasMap</name><operator>::</operator><name>const_iterator</name> <name>Iter</name> <operator>=</operator> <call><name><name>IncludeAliases</name><operator>-&gt;</operator><name>find</name></name><argument_list>(<argument><expr><name>Source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>Iter</name> <operator>!=</operator> <call><name><name>IncludeAliases</name><operator>-&gt;</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>Iter</name><operator>-&gt;</operator><name>second</name></name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><block>{}</block></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>setModuleHash</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Hash</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>ModuleHash</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><name>Hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>


<function><type><name>void</name></type> <name>setModuleCachePath</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>CachePath</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>ModuleCachePath</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><name>CachePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>StringRef</name> <macro><name>getModuleHash</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ModuleHash</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>StringRef</name> <macro><name>getModuleCachePath</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ModuleCachePath</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setDirectoryHasModuleMap</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DirectoryEntry</name><modifier>*</modifier></type> <name>Dir</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>DirectoryHasModuleMap</name><index>[<expr><name>Dir</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>ClearFileInfo</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>FileInfo</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SetExternalLookup</name><parameter_list>(<parameter><decl><type><name>ExternalPreprocessorSource</name> <modifier>*</modifier></type><name>EPS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>ExternalLookup</name> <operator>=</operator> <name>EPS</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>ExternalPreprocessorSource</name> <operator>*</operator><macro><name>getExternalLookup</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ExternalLookup</name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>SetExternalSource</name><parameter_list>(<parameter><decl><type><name>ExternalHeaderFileInfoSource</name> <modifier>*</modifier></type><name>ES</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>ExternalSource</name> <operator>=</operator> <name>ES</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function_decl><type><name>void</name></type> <name>setTarget</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>&amp;</modifier></type><name>Target</name></decl></parameter>)</parameter_list>;</function_decl>




































<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>FileEntryRef</name></expr></argument>&gt;</argument_list></name></type> <name>LookupFile</name><argument_list>(
<argument><expr><name>StringRef</name> <name>Filename</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>IncludeLoc</name></expr></argument>, <argument><expr><name>bool</name> <name>isAngled</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>DirectoryLookup</name> <operator>*</operator><name>FromDir</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>DirectoryLookup</name> <operator>*</operator><operator>&amp;</operator><name>CurDir</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>DirectoryEntry</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>Includers</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>SearchPath</name></expr></argument>, <argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>RelativePath</name></expr></argument>,
<argument><expr><name>Module</name> <operator>*</operator><name>RequestingModule</name></expr></argument>, <argument><expr><name>ModuleMap</name><operator>::</operator><name>KnownHeader</name> <operator>*</operator><name>SuggestedModule</name></expr></argument>,
<argument><expr><name>bool</name> <operator>*</operator><name>IsMapped</name></expr></argument>, <argument><expr><name>bool</name> <operator>*</operator><name>IsFrameworkFound</name></expr></argument>, <argument><expr><name>bool</name> <name>SkipCache</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>bool</name> <name>BuildSystemModule</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list></decl>;</decl_stmt>







<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>FileEntryRef</name></expr></argument>&gt;</argument_list></name></type> <name>LookupSubframeworkHeader</name><argument_list>(
<argument><expr><name>StringRef</name> <name>Filename</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator><name>ContextFileEnt</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>SearchPath</name></expr></argument>, <argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>RelativePath</name></expr></argument>,
<argument><expr><name>Module</name> <operator>*</operator><name>RequestingModule</name></expr></argument>, <argument><expr><name>ModuleMap</name><operator>::</operator><name>KnownHeader</name> <operator>*</operator><name>SuggestedModule</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function><type><name>FrameworkCacheEntry</name> <modifier>&amp;</modifier></type><name>LookupFrameworkCache</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>FWName</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name><name>FrameworkMap</name><index>[<expr><name>FWName</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>






<function_decl><type><name>bool</name></type> <name>ShouldEnterIncludeFile</name><parameter_list>(<parameter><decl><type><name>Preprocessor</name> <modifier>&amp;</modifier></type><name>PP</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>File</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isImport</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ModulesEnabled</name></decl></parameter>,
<parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>M</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>SrcMgr</name><operator>::</operator><name>CharacteristicKind</name> <macro><name>getFileDirFlavor</name><argument_list>(<argument>const FileEntry *File</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>(</operator><name>SrcMgr</name><operator>::</operator><name>CharacteristicKind</name><operator>)</operator><call><name>getFileInfo</name><argument_list>(<argument><expr><name>File</name></expr></argument>)</argument_list></call><operator>.</operator><name>DirInfo</name></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>void</name></type> <name>MarkFileIncludeOnce</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>File</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>HeaderFileInfo</name> <modifier>&amp;</modifier></type><name>FI</name> <init>= <expr><call><name>getFileInfo</name><argument_list>(<argument><expr><name>File</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>FI</name><operator>.</operator><name>isImport</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>FI</name><operator>.</operator><name>isPragmaOnce</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>MarkFileSystemHeader</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>File</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>getFileInfo</name><argument_list>(<argument><expr><name>File</name></expr></argument>)</argument_list></call><operator>.</operator><name>DirInfo</name> <operator>=</operator> <name>SrcMgr</name><operator>::</operator><name>C_System</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>AddFileAlias</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>File</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Alias</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>getFileInfo</name><argument_list>(<argument><expr><name>File</name></expr></argument>)</argument_list></call><operator>.</operator><call><name><name>Aliases</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>Alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<decl_stmt><decl><type><name>void</name></type> <name>MarkFileModuleHeader</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator><name>FE</name></expr></argument>,
<argument><expr><name>ModuleMap</name><operator>::</operator><name>ModuleHeaderRole</name> <name>Role</name></expr></argument>,
<argument><expr><name>bool</name> <name>isCompilingModuleHeader</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function><type><name>void</name></type> <name>IncrementIncludeCount</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>File</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><call><name>getFileInfo</name><argument_list>(<argument><expr><name>File</name></expr></argument>)</argument_list></call><operator>.</operator><name>NumIncludes</name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>SetFileControllingMacro</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>File</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>ControllingMacro</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>getFileInfo</name><argument_list>(<argument><expr><name>File</name></expr></argument>)</argument_list></call><operator>.</operator><name>ControllingMacro</name> <operator>=</operator> <name>ControllingMacro</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>bool</name></type> <name>FirstTimeLexingFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>File</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getFileInfo</name><argument_list>(<argument><expr><name>File</name></expr></argument>)</argument_list></call><operator>.</operator><name>NumIncludes</name> <operator>==</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>






<function_decl><type><name>bool</name></type> <name>isFileMultipleIncludeGuarded</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>File</name></decl></parameter>)</parameter_list>;</function_decl>



<function><type><name>bool</name></type> <name>hasFileBeenImported</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>File</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>HeaderFileInfo</name> <modifier>*</modifier></type><name>FI</name> <init>= <expr><call><name>getExistingFileInfo</name><argument_list>(<argument><expr><name>File</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>FI</name> <operator>&amp;&amp;</operator> <name><name>FI</name><operator>-&gt;</operator><name>isImport</name></name></expr>;</return>
</block_content>}</block></function>



<function_decl><type><specifier>const</specifier> <name>HeaderMap</name> <modifier>*</modifier></type><name>CreateHeaderMap</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>FE</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>void</name></type> <name>getHeaderMapFileNames</name><argument_list>(<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Names</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>








<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <call><name>getCachedModuleFileName</name><argument_list>(<argument><expr><name>Module</name> <operator>*</operator><name>Module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>











<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getPrebuiltModuleFileName</name><argument_list>(<argument>StringRef ModuleName</argument>,
<argument>bool FileMapOnly = false</argument>)</argument_list></macro></expr>;</expr_stmt>








<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <call><name>getPrebuiltImplicitModuleFileName</name><argument_list>(<argument><expr><name>Module</name> <operator>*</operator><name>Module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>











<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getCachedModuleFileName</name><argument_list>(<argument>StringRef ModuleName</argument>,
<argument>StringRef ModuleMapPath</argument>)</argument_list></macro></expr>;</expr_stmt>













<function_decl><type><name>Module</name> <modifier>*</modifier></type><name>lookupModule</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>ModuleName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>AllowSearch</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowExtraModuleMapSearch</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>lookupModuleMapFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DirectoryEntry</name> <modifier>*</modifier></type><name>Dir</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsFramework</name></decl></parameter>)</parameter_list>;</function_decl>












<function_decl><type><name>bool</name></type> <name>hasModuleMap</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DirectoryEntry</name> <modifier>*</modifier></type><name>Root</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsSystem</name></decl></parameter>)</parameter_list>;</function_decl>





<expr_stmt><expr><name>ModuleMap</name><operator>::</operator><name>KnownHeader</name> <macro><name>findModuleForHeader</name><argument_list>(<argument>const FileEntry *File</argument>,
<argument>bool AllowTextual = false</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<decl_stmt><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ModuleMap</name><operator>::</operator><name>KnownHeader</name></expr></argument>&gt;</argument_list></name></type>
<name>findAllModulesForHeader</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator><name>File</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>














<function_decl><type><name>bool</name></type> <name>loadModuleMapFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>File</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsSystem</name></decl></parameter>,
<parameter><decl><type><name>FileID</name></type> <name>ID</name> <init>= <expr><call><name>FileID</name><argument_list>()</argument_list></call></expr></init></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>Offset</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>OriginalModuleMapFile</name> <init>= <expr><call><name>StringRef</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>collectAllModules</name><parameter_list>(<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Module</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Modules</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>loadTopLevelSystemModules</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>private</name>:</label>













<function_decl><type><name>Module</name> <modifier>*</modifier></type><name>lookupModule</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>ModuleName</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>SearchName</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowExtraModuleMapSearch</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>













<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getCachedModuleFileNameImpl</name><argument_list>(<argument>StringRef ModuleName</argument>,
<argument>StringRef ModuleMapPath</argument>,
<argument>StringRef CachePath</argument>)</argument_list></macro></expr>;</expr_stmt>












<function_decl><type><name>Module</name> <modifier>*</modifier></type><name>loadFrameworkModule</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DirectoryEntry</name> <modifier>*</modifier></type><name>Dir</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsSystem</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>loadSubdirectoryModuleMaps</name><parameter_list>(<parameter><decl><type><name>DirectoryLookup</name> <modifier>&amp;</modifier></type><name>SearchDir</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name>bool</name></type> <name>findUsableModuleForHeader</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator><name>File</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>DirectoryEntry</name> <operator>*</operator><name>Root</name></expr></argument>,
<argument><expr><name>Module</name> <operator>*</operator><name>RequestingModule</name></expr></argument>,
<argument><expr><name>ModuleMap</name><operator>::</operator><name>KnownHeader</name> <operator>*</operator><name>SuggestedModule</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsSystemHeaderDir</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<decl_stmt><decl><type><name>bool</name></type> <name>findUsableModuleForFrameworkHeader</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator><name>File</name></expr></argument>, <argument><expr><name>StringRef</name> <name>FrameworkName</name></expr></argument>, <argument><expr><name>Module</name> <operator>*</operator><name>RequestingModule</name></expr></argument>,
<argument><expr><name>ModuleMap</name><operator>::</operator><name>KnownHeader</name> <operator>*</operator><name>SuggestedModule</name></expr></argument>, <argument><expr><name>bool</name> <name>IsSystemFramework</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>FileEntryRef</name></expr></argument>&gt;</argument_list></name></type>
<name>getFileAndSuggestModule</name><argument_list>(<argument><expr><name>StringRef</name> <name>FileName</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>IncludeLoc</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>DirectoryEntry</name> <operator>*</operator><name>Dir</name></expr></argument>, <argument><expr><name>bool</name> <name>IsSystemHeaderDir</name></expr></argument>,
<argument><expr><name>Module</name> <operator>*</operator><name>RequestingModule</name></expr></argument>,
<argument><expr><name>ModuleMap</name><operator>::</operator><name>KnownHeader</name> <operator>*</operator><name>SuggestedModule</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<label><name>public</name>:</label>

<function><type><name>ModuleMap</name> <modifier>&amp;</modifier></type><name>getModuleMap</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>ModMap</name></expr>;</return> </block_content>}</block></function>


<expr_stmt><expr><specifier>const</specifier> <name>ModuleMap</name> <operator>&amp;</operator><macro><name>getModuleMap</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ModMap</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>header_file_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>FileInfo</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<function_decl><type><name>HeaderFileInfo</name> <modifier>&amp;</modifier></type><name>getFileInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>FE</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><specifier>const</specifier> <name>HeaderFileInfo</name> <modifier>*</modifier></type><name>getExistingFileInfo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator><name>FE</name></expr></argument>,
<argument><expr><name>bool</name> <name>WantExternal</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>search_dir_iterator</name> <init>= <expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>DirectoryLookup</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>search_dir_iterator</name> <macro><name>search_dir_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>SearchDirs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>search_dir_iterator</name> <macro><name>search_dir_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>SearchDirs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>search_dir_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>SearchDirs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>search_dir_iterator</name> <macro><name>quoted_dir_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>SearchDirs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>search_dir_iterator</name> <macro><name>quoted_dir_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>SearchDirs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>AngledDirIdx</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>search_dir_iterator</name> <macro><name>angled_dir_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>SearchDirs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>AngledDirIdx</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>search_dir_iterator</name> <macro><name>angled_dir_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>SearchDirs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>SystemDirIdx</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>search_dir_iterator</name> <macro><name>system_dir_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>SearchDirs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>SystemDirIdx</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>search_dir_iterator</name> <macro><name>system_dir_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>SearchDirs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<function_decl><type><name>StringRef</name></type> <name>getUniqueFrameworkName</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Framework</name></decl></parameter>)</parameter_list>;</function_decl>










<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>suggestPathToFileForDiagnostics</name><argument_list>(<argument>const FileEntry *File</argument>,
<argument>llvm::StringRef MainFile</argument>,
<argument>bool *IsSystem = nullptr</argument>)</argument_list></macro></expr>;</expr_stmt>










<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>suggestPathToFileForDiagnostics</name><argument_list>(<argument>llvm::StringRef File</argument>,
<argument>llvm::StringRef WorkingDir</argument>,
<argument>llvm::StringRef MainFile</argument>,
<argument>bool *IsSystem = nullptr</argument>)</argument_list></macro></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>PrintStats</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>size_t</name> <macro><name>getTotalMemory</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<label><name>private</name>:</label>

<enum>enum <name>LoadModuleMapResult</name> <block>{

<decl><name>LMM_AlreadyLoaded</name></decl>,


<decl><name>LMM_NewlyLoaded</name></decl>,


<decl><name>LMM_NoDirectory</name></decl>,



<decl><name>LMM_InvalidModuleMap</name></decl>
}</block>;</enum>

<function_decl><type><name>LoadModuleMapResult</name></type> <name>loadModuleMapFileImpl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>File</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsSystem</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DirectoryEntry</name> <modifier>*</modifier></type><name>Dir</name></decl></parameter>,
<parameter><decl><type><name>FileID</name></type> <name>ID</name> <init>= <expr><call><name>FileID</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>Offset</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>










<function_decl><type><name>LoadModuleMapResult</name></type> <name>loadModuleMapFile</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>DirName</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsSystem</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsFramework</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>LoadModuleMapResult</name></type> <name>loadModuleMapFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DirectoryEntry</name> <modifier>*</modifier></type><name>Dir</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsSystem</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsFramework</name></decl></parameter>)</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

</block_content>}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
