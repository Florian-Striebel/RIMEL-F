<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/DeclBase.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_DECLBASE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_DECLBASE_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTDumperUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/AttrIterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclarationName.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/IdentifierTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Specifiers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerIntPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerUnion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/PrettyStackTrace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/VersionTuple.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;algorithm&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iterator&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;type_traits&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTMutationListener</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Attr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BlockDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DeclContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ExternalSourceSymbolAttr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>IdentifierInfo</name></decl>;</decl_stmt>
<enum_decl>enum <name>Linkage</name> : <type><name>unsigned</name> <name>char</name></type>;</enum_decl>
<decl_stmt><decl><type><name>class</name></type> <name>LinkageSpecDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Module</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>NamedDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCCategoryDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCCategoryImplDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCContainerDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCImplDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCImplementationDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCInterfaceDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCMethodDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCProtocolDecl</name></decl>;</decl_stmt>
<struct_decl>struct <name>PrintingPolicy</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>RecordDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SourceManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Stmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>StoredDeclsMap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateParameterList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TranslationUnitDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UsingDirectiveDecl</name></decl>;</decl_stmt>



<enum>enum <name>AvailabilityResult</name> <block>{
<decl><name>AR_Available</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>AR_NotYetIntroduced</name></decl>,
<decl><name>AR_Deprecated</name></decl>,
<decl><name>AR_Unavailable</name></decl>
}</block>;</enum>








<decl_stmt><decl><type><name>class</name></type> <name>alignas</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list> <name>Decl</name> <block>{<block_content>
<label><name>public</name>:</label>

<enum>enum <name>Kind</name> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECL</name><parameter_list>(<parameter><type><name>DERIVED</name></type></parameter>, <parameter><type><name>BASE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DERIVED,</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_DECL</name><parameter_list>(<parameter><type><name>DECL</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECL_RANGE</name><parameter_list>(<parameter><type><name>BASE</name></type></parameter>, <parameter><type><name>START</name></type></parameter>, <parameter><type><name>END</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>first##BASE = START, last##BASE = END,</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAST_DECL_RANGE</name><parameter_list>(<parameter><type><name>BASE</name></type></parameter>, <parameter><type><name>START</name></type></parameter>, <parameter><type><name>END</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>first##BASE = START, last##BASE = END</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclNodes.inc"</cpp:file></cpp:include>
}</block>;</enum>




<struct>struct <name>EmptyShell</name> <block>{}</block>;</struct>












<enum>enum <name>IdentifierNamespace</name> <block>{

<decl><name>IDNS_Label</name> <init>= <expr><literal type="number">0x0001</literal></expr></init></decl>,







<decl><name>IDNS_Tag</name> <init>= <expr><literal type="number">0x0002</literal></expr></init></decl>,




<decl><name>IDNS_Type</name> <init>= <expr><literal type="number">0x0004</literal></expr></init></decl>,





<decl><name>IDNS_Member</name> <init>= <expr><literal type="number">0x0008</literal></expr></init></decl>,



<decl><name>IDNS_Namespace</name> <init>= <expr><literal type="number">0x0010</literal></expr></init></decl>,



<decl><name>IDNS_Ordinary</name> <init>= <expr><literal type="number">0x0020</literal></expr></init></decl>,


<decl><name>IDNS_ObjCProtocol</name> <init>= <expr><literal type="number">0x0040</literal></expr></init></decl>,




<decl><name>IDNS_OrdinaryFriend</name> <init>= <expr><literal type="number">0x0080</literal></expr></init></decl>,




<decl><name>IDNS_TagFriend</name> <init>= <expr><literal type="number">0x0100</literal></expr></init></decl>,





<decl><name>IDNS_Using</name> <init>= <expr><literal type="number">0x0200</literal></expr></init></decl>,




<decl><name>IDNS_NonMemberOperator</name> <init>= <expr><literal type="number">0x0400</literal></expr></init></decl>,






<decl><name>IDNS_LocalExtern</name> <init>= <expr><literal type="number">0x0800</literal></expr></init></decl>,


<decl><name>IDNS_OMPReduction</name> <init>= <expr><literal type="number">0x1000</literal></expr></init></decl>,


<decl><name>IDNS_OMPMapper</name> <init>= <expr><literal type="number">0x2000</literal></expr></init></decl>,
}</block>;</enum>















<enum>enum <name>ObjCDeclQualifier</name> <block>{
<decl><name>OBJC_TQ_None</name> <init>= <expr><literal type="number">0x0</literal></expr></init></decl>,
<decl><name>OBJC_TQ_In</name> <init>= <expr><literal type="number">0x1</literal></expr></init></decl>,
<decl><name>OBJC_TQ_Inout</name> <init>= <expr><literal type="number">0x2</literal></expr></init></decl>,
<decl><name>OBJC_TQ_Out</name> <init>= <expr><literal type="number">0x4</literal></expr></init></decl>,
<decl><name>OBJC_TQ_Bycopy</name> <init>= <expr><literal type="number">0x8</literal></expr></init></decl>,
<decl><name>OBJC_TQ_Byref</name> <init>= <expr><literal type="number">0x10</literal></expr></init></decl>,
<decl><name>OBJC_TQ_Oneway</name> <init>= <expr><literal type="number">0x20</literal></expr></init></decl>,




<decl><name>OBJC_TQ_CSNullability</name> <init>= <expr><literal type="number">0x40</literal></expr></init></decl>
}</block>;</enum>




<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>ModuleOwnershipKind</name> <range>: <expr><name>unsigned</name> <block>{

<expr><name>Unowned</name></expr>,






<expr><name>Visible</name></expr>,



<expr><name>VisibleWhenImported</name></expr>,



<expr><name>ModulePrivate</name></expr>
}</block></expr></range></decl>;</decl_stmt>

<label><name>protected</name>:</label>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ModuleOwnershipKind</name></expr></argument>&gt;</argument_list></name> <name>NextInContextAndBits</name></expr>;</expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>DeclContext</name></decl>;</decl_stmt>

<struct>struct <name>MultipleDC</name> <block>{
<decl_stmt><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>SemanticDC</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>LexicalDC</name></decl>;</decl_stmt>
}</block>;</struct>














<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>*</operator></expr></argument>, <argument><expr><name>MultipleDC</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>DeclCtx</name></expr>;</expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isInSemaDC</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>DeclCtx</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>DeclContext</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isOutOfSemaDC</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>DeclCtx</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>MultipleDC</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>MultipleDC</name> <operator>*</operator><macro><name>getMultipleDC</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>DeclCtx</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>MultipleDC</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>DeclContext</name> <operator>*</operator><macro><name>getSemanticDC</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>DeclCtx</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>DeclContext</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>DeclKind</name> <range>: <expr><literal type="number">7</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>InvalidDecl</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>HasAttrs</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>Implicit</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>Used</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>unsigned</name></type> <name>Referenced</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>TopLevelDeclInObjCContainer</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>StatisticsEnabled</name></decl>;</decl_stmt>

<label><name>protected</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclWriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTNodeImporter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXClassMemberWrapper</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>LinkageComputer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>decl_type</name></expr></argument>&gt;</argument_list></name> <name>friend</name> <name>class</name></type> <name>Redeclarable</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>Access</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>FromASTFile</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>IdentifierNamespace</name> <range>: <expr><literal type="number">14</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>mutable</name> <name>unsigned</name></type> <name>CacheValidAndLinkage</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>










<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><name>operator</name></type> <name>new</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>size_t</name> <name>Size</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>, <argument><expr><name>unsigned</name> <name>ID</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name>size_t</name> <name>Extra</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><name>operator</name></type> <name>new</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>size_t</name> <name>Size</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><name>DeclContext</name> <operator>*</operator><name>Parent</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>size_t</name> <name>Extra</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><name>bool</name> <macro><name>AccessDeclContextSanity</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<function><type><specifier>static</specifier> <name>ModuleOwnershipKind</name></type> <name>getModuleOwnershipKindForChildOf</name><parameter_list>(<parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>DC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>D</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>auto</name></type> <name>MOK</name> <init>= <expr><call><name><name>D</name><operator>-&gt;</operator><name>getModuleOwnershipKind</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>MOK</name> <operator>!=</operator> <name>ModuleOwnershipKind</name><operator>::</operator><name>Unowned</name> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><call><name><name>D</name><operator>-&gt;</operator><name>isFromASTFile</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>D</name><operator>-&gt;</operator><name>hasLocalOwningModuleStorage</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>MOK</name></expr>;</return></block_content></block></if></if_stmt>


</block_content>}</block></if></if_stmt>
<return>return <expr><name>ModuleOwnershipKind</name><operator>::</operator><name>Unowned</name></expr>;</return>
</block_content>}</block></function>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>Decl</name><argument_list>()</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Decl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name><operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Decl</name><argument_list>(<argument><expr><name>Decl</name> <operator>&amp;&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Decl</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>Decl</name><operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Decl</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><name>Decl</name><operator>&amp;&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>

<label><name>protected</name>:</label>
<macro><name>Decl</name><argument_list>(<argument>Kind DK</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>NextInContextAndBits</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name>getModuleOwnershipKindForChildOf</name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>DeclCtx</name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Loc</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>DeclKind</name><argument_list>(<argument><expr><name>DK</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>InvalidDecl</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>HasAttrs</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>Implicit</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Used</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Referenced</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>TopLevelDeclInObjCContainer</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Access</name><argument_list>(<argument><expr><name>AS_none</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>FromASTFile</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>IdentifierNamespace</name><argument_list>(<argument><expr><call><name>getIdentifierNamespaceForKind</name><argument_list>(<argument><expr><name>DK</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>CacheValidAndLinkage</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro> <expr><block>{
<if_stmt><if>if <condition>(<expr><name>StatisticsEnabled</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>add</name><argument_list>(<argument><expr><name>DK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>

<macro><name>Decl</name><argument_list>(<argument>Kind DK</argument>, <argument>EmptyShell Empty</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>DeclKind</name><argument_list>(<argument><expr><name>DK</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>InvalidDecl</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>HasAttrs</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Implicit</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>Used</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Referenced</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>TopLevelDeclInObjCContainer</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>Access</name><argument_list>(<argument><expr><name>AS_none</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>FromASTFile</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>IdentifierNamespace</name><argument_list>(<argument><expr><call><name>getIdentifierNamespaceForKind</name><argument_list>(<argument><expr><name>DK</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>CacheValidAndLinkage</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro> <expr><block>{
<if_stmt><if>if <condition>(<expr><name>StatisticsEnabled</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>add</name><argument_list>(<argument><expr><name>DK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>Decl</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>updateOutOfDate</name><argument_list>(<argument><expr><name>IdentifierInfo</name> <operator>&amp;</operator><name>II</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>Linkage</name> <macro><name>getCachedLinkage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>Linkage</name><argument_list>(<argument><expr><name>CacheValidAndLinkage</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>setCachedLinkage</name><argument_list>(<argument><expr><name>Linkage</name> <name>L</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><name>CacheValidAndLinkage</name> <operator>=</operator> <name>L</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasCachedLinkage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>CacheValidAndLinkage</name></expr>;</return>
}</block></expr></expr_stmt>

<label><name>public</name>:</label>

<expr_stmt><expr><name>virtual</name> <name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getSourceRange</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBegin</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getSourceRange</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getEnd</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setLocation</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>L</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Loc</name> <operator>=</operator> <name>L</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Kind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DeclKind</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getDeclKindName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function><type><name>Decl</name> <modifier>*</modifier></type><name>getNextDeclInContext</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>NextInContextAndBits</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getNextDeclInContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{<return>return <expr><call><name><name>NextInContextAndBits</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>}</block></expr></expr_stmt>

<function><type><name>DeclContext</name> <modifier>*</modifier></type><name>getDeclContext</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>isInSemaDC</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getSemanticDC</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getMultipleDC</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>SemanticDC</name></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>getDeclContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getDeclContext</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>






<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>getNonClosureContext</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getNonClosureContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getNonClosureContext</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function_decl><type><name>TranslationUnitDecl</name> <modifier>*</modifier></type><name>getTranslationUnitDecl</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>TranslationUnitDecl</name> <operator>*</operator><macro><name>getTranslationUnitDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getTranslationUnitDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isInAnonymousNamespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isInStdNamespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>ASTContext</name> <operator>&amp;</operator><macro><name>getASTContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;</expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><macro><name>getLangOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;</expr_stmt>

<function><type><name>void</name></type> <name>setAccess</name><parameter_list>(<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Access</name> <operator>=</operator> <name>AS</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>AccessDeclContextSanity</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>AccessSpecifier</name> <macro><name>getAccess</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>AccessDeclContextSanity</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>AccessSpecifier</name><argument_list>(<argument><expr><name>Access</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>AccessSpecifier</name> <macro><name>getAccessUnsafe</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>AccessSpecifier</name><argument_list>(<argument><expr><name>Access</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasAttrs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasAttrs</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setAttrs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AttrVec</name><modifier>&amp;</modifier></type> <name>Attrs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>setAttrsImpl</name><argument_list>(<argument><expr><name>Attrs</name></expr></argument>, <argument><expr><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>AttrVec</name> <modifier>&amp;</modifier></type><name>getAttrs</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>AttrVec</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getAttrs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>AttrVec</name> <operator>&amp;</operator><macro><name>getAttrs</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<function_decl><type><name>void</name></type> <name>dropAttrs</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>addAttr</name><parameter_list>(<parameter><decl><type><name>Attr</name> <modifier>*</modifier></type><name>A</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>using</name></type> <name>attr_iterator</name> <init>= <expr><name>AttrVec</name><operator>::</operator><name>const_iterator</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>attr_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>attr_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>attr_range</name> <macro><name>attrs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>attr_range</name><argument_list>(<argument><expr><call><name>attr_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>attr_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>attr_iterator</name> <macro><name>attr_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasAttrs</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name>getAttrs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call> <operator>:</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>attr_iterator</name> <macro><name>attr_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasAttrs</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name>getAttrs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call> <operator>:</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>dropAttr</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HasAttrs</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>AttrVec</name> <modifier>&amp;</modifier></type><name>Vec</name> <init>= <expr><call><name>getAttrs</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><call><name>erase_if</name><argument_list>(<argument><expr><name>Vec</name></expr></argument>, <argument><expr><index>[]</index><operator>(</operator><name>Attr</name> <operator>*</operator><name>A</name><operator>)</operator> <block>{ <return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></argument></argument_list></call></expr></expr_stmt>)</block_content></block>;</function>

<if_stmt><if>if <condition>(<expr><call><name><name>Vec</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>HasAttrs</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name><name>specific_attr_iterator</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <macro><name>specific_attrs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>make_range</name><argument_list>(<argument><expr><call><name><name>specific_attr_begin</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>specific_attr_end</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>specific_attr_iterator</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>specific_attr_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>specific_attr_iterator</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>attr_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>specific_attr_iterator</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>specific_attr_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>specific_attr_iterator</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>attr_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>T</name> <operator>*</operator><macro><name>getAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasAttrs</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name><name>getSpecificAttr</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getAttrs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>:</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>bool</name> <macro><name>hasAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasAttrs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>hasSpecificAttr</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getAttrs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getMaxAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<function_decl><type><name>void</name></type> <name>setInvalidDecl</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Invalid</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>bool</name> <macro><name>isInvalidDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>bool</name><operator>)</operator> <name>InvalidDecl</name></expr>;</return> }</block></expr></expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>isImplicit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Implicit</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setImplicit</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>I</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Implicit</name> <operator>=</operator> <name>I</name></expr>;</expr_stmt> </block_content>}</block></function>







<decl_stmt><decl><type><name>bool</name></type> <name>isUsed</name><argument_list>(<argument><expr><name>bool</name> <name>CheckUsedAttr</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<function><type><name>void</name></type> <name>setIsUsed</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>Used</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> </block_content>}</block></function>





<function_decl><type><name>void</name></type> <name>markUsed</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>bool</name> <macro><name>isReferenced</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isThisDeclarationReferenced</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Referenced</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setReferenced</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>R</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Referenced</name> <operator>=</operator> <name>R</name></expr>;</expr_stmt> </block_content>}</block></function>




<expr_stmt><expr><name>bool</name> <macro><name>isTopLevelDeclInObjCContainer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TopLevelDeclInObjCContainer</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setTopLevelDeclInObjCContainer</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>V</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>TopLevelDeclInObjCContainer</name> <operator>=</operator> <name>V</name></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>ExternalSourceSymbolAttr</name> <operator>*</operator><macro><name>getExternalSourceSymbolAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isModulePrivate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getModuleOwnershipKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ModuleOwnershipKind</name><operator>::</operator><name>ModulePrivate</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasDefiningAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>Attr</name> <operator>*</operator><macro><name>getDefiningAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<label><name>protected</name>:</label>


<function><type><name>void</name></type> <name>setModulePrivate</name><parameter_list>()</parameter_list> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>getModuleOwnershipKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ModuleOwnershipKind</name><operator>::</operator><name>Unowned</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>setModuleOwnershipKind</name><argument_list>(<argument><expr><name>ModuleOwnershipKind</name><operator>::</operator><name>ModulePrivate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<label><name>public</name>:</label>



<function><type><name>void</name></type> <name>setFromASTFile</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>FromASTFile</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>setOwningModuleID</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isFromASTFile</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Only works on a deserialized declaration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>*</operator><operator>)</operator><name>this</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>=</operator> <name>ID</name></expr>;</expr_stmt>
</block_content>}</block></function>

<label><name>public</name>:</label>

















<decl_stmt><decl><type><name>AvailabilityResult</name></type>
<name>getAvailability</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>*</operator><name>Message</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>VersionTuple</name> <name>EnclosingVersion</name> <operator>=</operator> <call><name>VersionTuple</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>StringRef</name> <operator>*</operator><name>RealizedPlatform</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>







<expr_stmt><expr><name>VersionTuple</name> <macro><name>getVersionIntroduced</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>






<decl_stmt><decl><type><name>bool</name></type> <name>isDeprecated</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>*</operator><name>Message</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getAvailability</name><argument_list>(<argument><expr><name>Message</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AR_Deprecated</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>






<decl_stmt><decl><type><name>bool</name></type> <name>isUnavailable</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>*</operator><name>Message</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getAvailability</name><argument_list>(<argument><expr><name>Message</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AR_Unavailable</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>







<expr_stmt><expr><name>bool</name> <macro><name>isWeakImported</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>







<decl_stmt><decl><type><name>bool</name></type> <name>canBeWeakImported</name><argument_list>(<argument><expr><name>bool</name> <operator>&amp;</operator><name>IsDefinition</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isFromASTFile</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FromASTFile</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getGlobalID</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isFromASTFile</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>unsigned</name><operator>*</operator><operator>)</operator><name>this</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getOwningModuleID</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isFromASTFile</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>unsigned</name><operator>*</operator><operator>)</operator><name>this</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
}

private:
<expr_stmt><expr><name>Module</name> <operator>*</operator><macro><name>getOwningModuleSlow</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<label><name>protected</name>:</label>
<expr_stmt><expr><name>bool</name> <macro><name>hasLocalOwningModuleStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<label><name>public</name>:</label>


<expr_stmt><expr><name>Module</name> <operator>*</operator><macro><name>getImportedOwningModule</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isFromASTFile</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>hasOwningModule</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name>getOwningModuleSlow</name><argument_list>()</argument_list></call></expr>;</return>
}



Module <expr_stmt><expr><operator>*</operator><macro><name>getLocalOwningModule</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isFromASTFile</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>hasOwningModule</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>

<call><name>assert</name><argument_list>(<argument><expr><call><name>hasLocalOwningModuleStorage</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"owned local decl but no local module storage"</literal></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Module</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></expr>;</return>
}
void <macro><name>setLocalOwningModule</name><argument_list>(<argument>Module *M</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isFromASTFile</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>hasOwningModule</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>hasLocalOwningModuleStorage</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"should not have a cached owning module"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Module</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index> <operator>=</operator> <name>M</name></expr>;</expr_stmt>
</block_content>}</block>


<expr_stmt><expr><name>bool</name> <macro><name>hasOwningModule</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getModuleOwnershipKind</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>ModuleOwnershipKind</name><operator>::</operator><name>Unowned</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>Module</name> <operator>*</operator><macro><name>getOwningModule</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isFromASTFile</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name>getImportedOwningModule</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>getLocalOwningModule</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>






<decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>getOwningModuleForLinkage</name><argument_list>(<argument><expr><name>bool</name> <name>IgnoreLinkage</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<expr_stmt><expr><name>bool</name> <macro><name>isUnconditionallyVisible</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>getModuleOwnershipKind</name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>ModuleOwnershipKind</name><operator>::</operator><name>Visible</name></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>void</name></type> <name>setVisibleDespiteOwningModule</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isUnconditionallyVisible</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setModuleOwnershipKind</name><argument_list>(<argument><expr><name>ModuleOwnershipKind</name><operator>::</operator><name>Visible</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>ModuleOwnershipKind</name> <macro><name>getModuleOwnershipKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>NextInContextAndBits</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setModuleOwnershipKind</name><parameter_list>(<parameter><decl><type><name>ModuleOwnershipKind</name></type> <name>MOK</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><call><name>getModuleOwnershipKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ModuleOwnershipKind</name><operator>::</operator><name>Unowned</name> <operator>&amp;&amp;</operator>
<name>MOK</name> <operator>!=</operator> <name>ModuleOwnershipKind</name><operator>::</operator><name>Unowned</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isFromASTFile</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>hasLocalOwningModuleStorage</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"no storage available for owning module for this declaration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NextInContextAndBits</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>MOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>unsigned</name> <macro><name>getIdentifierNamespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>IdentifierNamespace</name></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isInIdentifierNamespace</name><argument_list>(<argument><expr><name>unsigned</name> <name>NS</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getIdentifierNamespace</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>NS</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function_decl><type><specifier>static</specifier> <name>unsigned</name></type> <name>getIdentifierNamespaceForKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>DK</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>bool</name> <macro><name>hasTagIdentifierNamespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isTagIdentifierNamespace</name><argument_list>(<argument><expr><call><name>getIdentifierNamespace</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isTagIdentifierNamespace</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>NS</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><operator>(</operator><name>NS</name> <operator>&amp;</operator> <operator>~</operator><name>IDNS_TagFriend</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>IDNS_Tag</name> <operator>|</operator> <name>IDNS_Type</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>











<function><type><name>DeclContext</name> <modifier>*</modifier></type><name>getLexicalDeclContext</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>isInSemaDC</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getSemanticDC</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getMultipleDC</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>LexicalDC</name></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>getLexicalDeclContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getLexicalDeclContext</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>isOutOfLine</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<function_decl><type><name>void</name></type> <name>setDeclContext</name><parameter_list>(<parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>setLexicalDeclContext</name><parameter_list>(<parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>bool</name> <macro><name>isTemplated</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getTemplateDepth</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>





<expr_stmt><expr><name>bool</name> <macro><name>isDefinedOutsideFunctionOrMethod</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getParentFunctionOrMethod</name><argument_list>()</argument_list></call> <operator>==</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>













<expr_stmt><expr><name>bool</name> <macro><name>isInLocalScopeForInstantiation</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>getParentFunctionOrMethod</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<function><type><name>DeclContext</name> <modifier>*</modifier></type><name>getParentFunctionOrMethod</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getParentFunctionOrMethod</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>virtual</name> <name>Decl</name> <modifier>*</modifier></type><name>getCanonicalDecl</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>this</name></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call> <operator>==</operator> <name>this</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>protected</name>:</label>




<function><type><name>virtual</name> <name>Decl</name> <modifier>*</modifier></type><name>getNextRedeclarationImpl</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>this</name></expr>;</return> </block_content>}</block></function>



<function><type><name>virtual</name> <name>Decl</name> <modifier>*</modifier></type><name>getPreviousDeclImpl</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>nullptr</name></expr>;</return> </block_content>}</block></function>



<function><type><name>virtual</name> <name>Decl</name> <modifier>*</modifier></type><name>getMostRecentDeclImpl</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>this</name></expr>;</return> </block_content>}</block></function>

<label><name>public</name>:</label>

<decl_stmt><decl><type><name>class</name></type> <name>redecl_iterator</name> <block>{<block_content>

<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Current</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Starter</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>using</name></type> <name>value_type</name> <init>= <expr><name>Decl</name> <operator>*</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>reference</name> <init>= <expr><specifier>const</specifier> <name>value_type</name> <operator>&amp;</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>pointer</name> <init>= <expr><specifier>const</specifier> <name>value_type</name> <operator>*</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>iterator_category</name> <init>= <expr><name>std</name><operator>::</operator><name>forward_iterator_tag</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>difference_type</name> <init>= <expr><name>std</name><operator>::</operator><name>ptrdiff_t</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>redecl_iterator</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>redecl_iterator</name><argument_list>(<argument><expr><name>Decl</name> <operator>*</operator><name>C</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>Current</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Starter</name><argument_list>(<argument>C</argument>)</argument_list></macro> <expr><block>{}</block>

<name>reference</name> <name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>Current</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>value_type</name> <name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>)</block_content> const <block>{<block_content> <return>return <expr><name>Current</name></expr>;</return> </block_content>}</block>

redecl_iterator&amp; operator++(</block></decl>) <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>Current</name> <operator>&amp;&amp;</operator> <literal type="string">"Advancing while iterator has reached end"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Next</name> <init>= <expr><call><name><name>Current</name><operator>-&gt;</operator><name>getNextRedeclarationImpl</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>Next</name> <operator>&amp;&amp;</operator> <literal type="string">"Should return next redeclaration or itself, never null!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Current</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>Next</name> <operator>!=</operator> <name>Starter</name><operator>)</operator></expr> ?</condition><then> <expr><name>Next</name></expr> </then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></decl_stmt>

<expr_stmt><expr><name>redecl_iterator</name> <name>operator</name><operator>++</operator><operator>(</operator><name>int</name><operator>)</operator> <block>{
<expr><name>redecl_iterator</name> <call><name>tmp</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>++</operator><operator>(</operator><operator>*</operator><name>this</name><operator>)</operator></expr>;
<return>return <expr><name>tmp</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><name>redecl_iterator</name> <name>x</name><operator>,</operator> <name>redecl_iterator</name> <name>y</name><operator>)</operator> <block>{
<return>return <expr><name><name>x</name><operator>.</operator><name>Current</name></name> <operator>==</operator> <name><name>y</name><operator>.</operator><name>Current</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><name>redecl_iterator</name> <name>x</name><operator>,</operator> <name>redecl_iterator</name> <name>y</name><operator>)</operator> <block>{
<return>return <expr><name><name>x</name><operator>.</operator><name>Current</name></name> <operator>!=</operator> <name><name>y</name><operator>.</operator><name>Current</name></name></expr>;</return>
}</block></expr></expr_stmt>
};

<decl_stmt><decl><type><name>using</name></type> <name>redecl_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>redecl_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name>redecl_range</name> <macro><name>redecls</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>redecl_range</name><argument_list>(<argument><expr><call><name>redecls_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>redecls_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>redecl_iterator</name> <macro><name>redecls_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>redecl_iterator</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>redecl_iterator</name> <macro><name>redecls_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>redecl_iterator</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<function><type><name>Decl</name> <modifier>*</modifier></type><name>getPreviousDecl</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>getPreviousDeclImpl</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>



<expr_stmt><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getPreviousDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPreviousDeclImpl</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isFirstDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getPreviousDecl</name><argument_list>()</argument_list></call> <operator>==</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>Decl</name> <modifier>*</modifier></type><name>getMostRecentDecl</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>getMostRecentDeclImpl</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>



<expr_stmt><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDeclImpl</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>virtual</name> <name>Stmt</name><operator>*</operator> <macro><name>getBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block></expr></expr_stmt>





<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>hasBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getBody</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>SourceLocation</name> <macro><name>getBodyRBrace</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>k</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EnableStatistics</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PrintStats</name><parameter_list>()</parameter_list>;</function_decl>



<expr_stmt><expr><name>bool</name> <macro><name>isTemplateParameter</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isTemplateParameterPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isParameterPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isTemplateDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isFunctionOrFunctionTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>DeclKind</name> <operator>&gt;=</operator> <name>Decl</name><operator>::</operator><name>firstFunction</name> <operator>&amp;&amp;</operator>
<name>DeclKind</name> <operator>&lt;=</operator> <name>Decl</name><operator>::</operator><name>lastFunction</name><operator>)</operator> <operator>||</operator>
<name>DeclKind</name> <operator>==</operator> <name>FunctionTemplate</name></expr>;</return>
}</block></expr></expr_stmt>







<expr_stmt><expr><name>TemplateDecl</name> <operator>*</operator><macro><name>getDescribedTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>TemplateParameterList</name> <operator>*</operator><macro><name>getDescribedTemplateParams</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>FunctionDecl</name> <operator>*</operator><macro><name>getAsFunction</name><argument_list>()</argument_list></macro> <name>LLVM_READONLY</name></expr>;</expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><macro><name>getAsFunction</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getAsFunction</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>







<function><type><name>void</name></type> <name>setLocalExternDecl</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Prev</name> <init>= <expr><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>IdentifierNamespace</name> <operator>&amp;=</operator> <operator>~</operator><name>IDNS_Ordinary</name></expr>;</expr_stmt>




<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>IdentifierNamespace</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>IDNS_OrdinaryFriend</name> <operator>|</operator> <name>IDNS_Tag</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<literal type="string">"namespace is not ordinary"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>IdentifierNamespace</name> <operator>|=</operator> <name>IDNS_LocalExtern</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>Prev</name> <operator>&amp;&amp;</operator> <call><name><name>Prev</name><operator>-&gt;</operator><name>getIdentifierNamespace</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>IDNS_Ordinary</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>IdentifierNamespace</name> <operator>|=</operator> <name>IDNS_Ordinary</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>




<function><type><name>bool</name></type> <name>isLocalExternDecl</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><name>IdentifierNamespace</name> <operator>&amp;</operator> <name>IDNS_LocalExtern</name></expr>;</return>
</block_content>}</block></function>








<function><type><name>void</name></type> <name>setObjectOfFriendDecl</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>PerformFriendInjection</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>OldNS</name> <init>= <expr><name>IdentifierNamespace</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>OldNS</name> <operator>&amp;</operator> <operator>(</operator><name>IDNS_Tag</name> <operator>|</operator> <name>IDNS_Ordinary</name> <operator>|</operator>
<name>IDNS_TagFriend</name> <operator>|</operator> <name>IDNS_OrdinaryFriend</name> <operator>|</operator>
<name>IDNS_LocalExtern</name> <operator>|</operator> <name>IDNS_NonMemberOperator</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"namespace includes neither ordinary nor tag"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>OldNS</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>IDNS_Tag</name> <operator>|</operator> <name>IDNS_Ordinary</name> <operator>|</operator> <name>IDNS_Type</name> <operator>|</operator>
<name>IDNS_TagFriend</name> <operator>|</operator> <name>IDNS_OrdinaryFriend</name> <operator>|</operator>
<name>IDNS_LocalExtern</name> <operator>|</operator> <name>IDNS_NonMemberOperator</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"namespace includes other than ordinary or tag"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Prev</name> <init>= <expr><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>IdentifierNamespace</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>IDNS_Ordinary</name> <operator>|</operator> <name>IDNS_Tag</name> <operator>|</operator> <name>IDNS_Type</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>OldNS</name> <operator>&amp;</operator> <operator>(</operator><name>IDNS_Tag</name> <operator>|</operator> <name>IDNS_TagFriend</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>IdentifierNamespace</name> <operator>|=</operator> <name>IDNS_TagFriend</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>PerformFriendInjection</name> <operator>||</operator>
<operator>(</operator><name>Prev</name> <operator>&amp;&amp;</operator> <call><name><name>Prev</name><operator>-&gt;</operator><name>getIdentifierNamespace</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>IDNS_Tag</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>IdentifierNamespace</name> <operator>|=</operator> <name>IDNS_Tag</name> <operator>|</operator> <name>IDNS_Type</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>OldNS</name> <operator>&amp;</operator> <operator>(</operator><name>IDNS_Ordinary</name> <operator>|</operator> <name>IDNS_OrdinaryFriend</name> <operator>|</operator>
<name>IDNS_LocalExtern</name> <operator>|</operator> <name>IDNS_NonMemberOperator</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>IdentifierNamespace</name> <operator>|=</operator> <name>IDNS_OrdinaryFriend</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>PerformFriendInjection</name> <operator>||</operator>
<operator>(</operator><name>Prev</name> <operator>&amp;&amp;</operator> <call><name><name>Prev</name><operator>-&gt;</operator><name>getIdentifierNamespace</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>IDNS_Ordinary</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>IdentifierNamespace</name> <operator>|=</operator> <name>IDNS_Ordinary</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<enum>enum <name>FriendObjectKind</name> <block>{
<decl><name>FOK_None</name></decl>,
<decl><name>FOK_Declared</name></decl>,
<decl><name>FOK_Undeclared</name></decl>
}</block>;</enum>





<expr_stmt><expr><name>FriendObjectKind</name> <macro><name>getFriendObjectKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>unsigned</name> <name>mask</name> <operator>=</operator>
<operator>(</operator><name>IdentifierNamespace</name> <operator>&amp;</operator> <operator>(</operator><name>IDNS_TagFriend</name> <operator>|</operator> <name>IDNS_OrdinaryFriend</name><operator>)</operator><operator>)</operator></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mask</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FOK_None</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><name>IdentifierNamespace</name> <operator>&amp;</operator> <operator>(</operator><name>IDNS_Tag</name> <operator>|</operator> <name>IDNS_Ordinary</name><operator>)</operator></expr> ?</condition><then> <expr><name>FOK_Declared</name></expr>
</then><else>: <expr><name>FOK_Undeclared</name></expr></else></ternary><operator>)</operator></expr>;</return>
}


void <macro><name>setNonMemberOperator</name><argument_list>()</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Function</name> <operator>||</operator> <call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>FunctionTemplate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>IdentifierNamespace</name> <operator>&amp;</operator> <name>IDNS_Ordinary</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"visible non-member operators should be in ordinary namespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>IdentifierNamespace</name> <operator>|=</operator> <name>IDNS_NonMemberOperator</name></expr>;</expr_stmt>
</block_content>}</block>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>true</name></expr>;</return> </block_content>}</block></function>
<function_decl><type><specifier>static</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>castToDeclContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Decl</name> <modifier>*</modifier></type><name>castFromDeclContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclContext</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>print</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>Out</name></expr></argument>, <argument><expr><name>unsigned</name> <name>Indentation</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><name>bool</name> <name>PrintInstantiation</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>print</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>Out</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>Policy</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>Indentation</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>bool</name> <name>PrintInstantiation</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>printGroup</name><parameter_list>(<parameter><decl><type><name>Decl</name><modifier>*</modifier><modifier>*</modifier></type> <name>Begin</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumDecls</name></decl></parameter>,
<parameter><decl><type><name>raw_ostream</name> <modifier>&amp;</modifier></type><name>Out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Indentation</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>void</name> <macro><name>dumpColor</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>dump</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>Out</name></expr></argument>, <argument><expr><name>bool</name> <name>Deserialize</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>ASTDumpOutputFormat</name> <name>OutputFormat</name> <operator>=</operator> <name>ADOF_Default</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>int64_t</name> <macro><name>getID</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<decl_stmt><decl><type><specifier>const</specifier> <name>FunctionType</name> <modifier>*</modifier></type><name>getFunctionType</name><argument_list>(<argument><expr><name>bool</name> <name>BlocksToo</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<label><name>private</name>:</label>
<function_decl><type><name>void</name></type> <name>setAttrsImpl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AttrVec</name><modifier>&amp;</modifier></type> <name>Attrs</name></decl></parameter>, <parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>setDeclContextsImpl</name><parameter_list>(<parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>SemaDC</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>LexicalDC</name></decl></parameter>,
<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Ctx</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>protected</name>:</label>
<expr_stmt><expr><name>ASTMutationListener</name> <operator>*</operator><macro><name>getASTMutationListener</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
};


<function><type><specifier>inline</specifier> <name>bool</name></type> <name>declaresSameEntity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>D1</name> <operator>||</operator> <operator>!</operator><name>D2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>D1</name> <operator>==</operator> <name>D2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name><name>D1</name><operator>-&gt;</operator><name>getCanonicalDecl</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>D2</name><operator>-&gt;</operator><name>getCanonicalDecl</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>



<decl_stmt><decl><type><name>class</name></type> <name>PrettyStackTraceDecl</name> <range>: <expr><name>public</name> <name>llvm</name><operator>::</operator><name>PrettyStackTraceEntry</name> <block>{
<expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>TheDecl</name></expr>;
<expr><name>SourceLocation</name> <name>Loc</name></expr>;
<expr><name>SourceManager</name> <operator>&amp;</operator><name>SM</name></expr>;
<expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>Message</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>PrettyStackTraceDecl</name><argument_list>(<argument>const Decl *theDecl</argument>, <argument>SourceLocation L</argument>,
<argument>SourceManager &amp;sm</argument>, <argument>const char *Msg</argument>)</argument_list></macro>
<operator>:</operator> <call><name>TheDecl</name><argument_list>(<argument><expr><name>theDecl</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Loc</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>SM</name><argument_list>(<argument><expr><name>sm</name></expr></argument>)</argument_list></call></expr>, <macro><name>Message</name><argument_list>(<argument>Msg</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>print</name><argument_list>(<argument>raw_ostream &amp;OS</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
}</block></expr></range></decl>;</decl_stmt>
}



namespace <macro><name>llvm</name></macro> <block>{<block_content>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>PointerLikeTypeTraits</name><argument_list type="generic">&lt;<argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <operator>*</operator><macro><name>getAsVoidPointer</name><argument_list>(<argument>::clang::NamedDecl *P</argument>)</argument_list></macro> <block>{ <return>return <expr><name>P</name></expr>;</return></block></expr> }</block>
<specifier>static</specifier> <specifier>inline</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>NamedDecl</name> <operator>*</operator><macro><name>getFromVoidPointer</name><argument_list>(<argument>void *P</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>constexpr</name> <name>int</name></type> <name>NumLowBitsAvailable</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
</block_content>}</block><empty_stmt>;</empty_stmt>
}

namespace <macro><name>clang</name></macro> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>DeclListNode</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>StoredDeclsList</name></decl>;</decl_stmt>
<label><name>public</name>:</label>
<decl_stmt><decl><type><name>using</name></type> <name>Decls</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name><operator>*</operator></expr></argument>, <argument><expr><name>DeclListNode</name><operator>*</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>iterator</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>DeclContextLookupResult</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>StoredDeclsList</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Decls</name></type> <name>Ptr</name></decl>;</decl_stmt>
<macro><name>iterator</name><argument_list>(<argument>Decls Node</argument>)</argument_list></macro> : <macro><name>Ptr</name><argument_list>(<argument>Node</argument>)</argument_list></macro> <block>{<block_content> </block_content>}</block>
<label><name>public</name>:</label>
<decl_stmt><decl><type><name>using</name></type> <name>difference_type</name> <init>= <expr><name>ptrdiff_t</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>value_type</name> <init>= <expr><name>NamedDecl</name><operator>*</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>pointer</name> <init>= <expr><name>void</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>reference</name> <init>= <expr><name>value_type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>iterator_category</name> <init>= <expr><name>std</name><operator>::</operator><name>forward_iterator_tag</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>iterator</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>

<expr_stmt><expr><name>reference</name> <name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Ptr</name> <operator>&amp;&amp;</operator> <literal type="string">"dereferencing end() iterator"</literal></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<decl><type><name>DeclListNode</name> <modifier>*</modifier></type><name>CurNode</name> <init>= <expr><name><name>Ptr</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>DeclListNode</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>CurNode</name><operator>-&gt;</operator><name>D</name></name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name><name>Ptr</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>NamedDecl</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<expr_stmt><expr><name>void</name> <name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>)</block_content> const <block>{<block_content> </block_content>}</block>
bool operator==(const iterator &amp;X</block></decl>) const <block>{<block_content> <return>return <expr><name>Ptr</name> <operator>==</operator> <name><name>X</name><operator>.</operator><name>Ptr</name></name></expr>;</return> </block_content>}</block></decl_stmt>
<expr_stmt><expr><name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>iterator</name> <operator>&amp;</operator><name>X</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>Ptr</name> <operator>!=</operator> <name><name>X</name><operator>.</operator><name>Ptr</name></name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>inline</specifier> <name>iterator</name> <operator>&amp;</operator><name>operator</name><operator>++</operator><operator>(</operator><operator>)</operator> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>Ptr</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Advancing empty iterator"</literal></expr></argument>)</argument_list></call></expr>;

<if_stmt><if>if <condition>(<decl><type><name>DeclListNode</name> <modifier>*</modifier></type><name>CurNode</name> <init>= <expr><name><name>Ptr</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>DeclListNode</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Ptr</name> <operator>=</operator> <name><name>CurNode</name><operator>-&gt;</operator><name>Rest</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>Ptr</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt></block_content></block></else></if_stmt></block></expr></expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block>
<expr_stmt><expr><name>iterator</name> <name>operator</name><operator>++</operator><operator>(</operator><name>int</name><operator>)</operator> <block>{
<expr><name>iterator</name> <name>temp</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;
<expr><operator>++</operator><operator>(</operator><operator>*</operator><name>this</name><operator>)</operator></expr>;
<return>return <expr><name>temp</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>iterator</name></type> <name>end</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>iterator</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
};
<label><name>private</name>:</label>
<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Decls</name></type> <name>Rest</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>DeclListNode</name><argument_list>(<argument><expr><name>NamedDecl</name> <operator>*</operator><name>ND</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>D</name><argument_list>(<argument>ND</argument>)</argument_list></macro> <block>{}</block></expr></expr_stmt>
};


<decl_stmt><decl><type><name>class</name></type> <name>DeclContextLookupResult</name> <block>{<block_content>
<decl_stmt><decl><type><name>using</name></type> <name>Decls</name> <init>= <expr><name>DeclListNode</name><operator>::</operator><name>Decls</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Decls</name></type> <name>Result</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>DeclContextLookupResult</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<macro><name>DeclContextLookupResult</name><argument_list>(<argument>Decls Result</argument>)</argument_list></macro> : <macro><name>Result</name><argument_list>(<argument>Result</argument>)</argument_list></macro> <block>{<block_content/>}</block>

<decl_stmt><decl><type><name>using</name></type> <name>iterator</name> <init>= <expr><name>DeclListNode</name><operator>::</operator><name>iterator</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>const_iterator</name> <init>= <expr><name>iterator</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>reference</name> <init>= <expr><name>iterator</name><operator>::</operator><name>reference</name></expr></init></decl>;</decl_stmt>

<function><type><name>iterator</name></type> <name>begin</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>iterator</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>iterator</name></type> <name>end</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>iterator</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><name>const_iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContextLookupResult</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>const_iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>iterator</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isSingleResult</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Result</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>NamedDecl</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>reference</name> <macro><name>front</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>





<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>T</name> <operator>*</operator><macro><name>find_first</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>D</name> <operator>:</operator> <operator>*</operator><name>this</name></expr></init>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<decl><type><name>T</name> <modifier>*</modifier></type><name>Decl</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Decl</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for></block></expr></expr_stmt>

<return>return <expr><name>nullptr</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
};


















<decl_stmt><decl><type><name>class</name></type> <name>DeclContext</name> <block>{<block_content>

<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclReader</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ExternalASTSource</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>DependentDiagnostic</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTWriter</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>class</name></type> <name>DeclContextBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>DeclContext</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>DeclKind</name> <range>: <expr><literal type="number">7</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>mutable</name> <name>uint64_t</name></type> <name>ExternalLexicalStorage</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>mutable</name> <name>uint64_t</name></type> <name>ExternalVisibleStorage</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>mutable</name> <name>uint64_t</name></type> <name>NeedToReconcileExternalVisibleStorage</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>mutable</name> <name>uint64_t</name></type> <name>HasLazyLocalLexicalLookups</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>mutable</name> <name>uint64_t</name></type> <name>HasLazyExternalLexicalLookups</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>mutable</name> <name>uint64_t</name></type> <name>UseQualifiedLookup</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<enum>enum <block>{ <decl><name>NumDeclContextBits</name> <init>= <expr><literal type="number">13</literal></expr></init></decl> }</block>;</enum>




<decl_stmt><decl><type><name>class</name></type> <name>TagDeclBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>TagDecl</name></decl>;</decl_stmt>

<label><name>uint64_t</name> :</label> <expr_stmt><expr><name>NumDeclContextBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>TagDeclKind</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsCompleteDefinition</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsBeingDefined</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsEmbeddedInDeclarator</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsFreeStanding</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>uint64_t</name></type> <name>MayHaveOutOfDateDef</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsCompleteDefinitionRequired</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<enum>enum <block>{ <decl><name>NumTagDeclBits</name> <init>= <expr><literal type="number">9</literal></expr></init></decl> }</block>;</enum>




<decl_stmt><decl><type><name>class</name></type> <name>EnumDeclBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>EnumDecl</name></decl>;</decl_stmt>

<label><name>uint64_t</name> :</label> <expr_stmt><expr><name>NumDeclContextBits</name></expr>;</expr_stmt>

<label><name>uint64_t</name> :</label> <expr_stmt><expr><name>NumTagDeclBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>NumPositiveBits</name> <range>: <expr><literal type="number">8</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>NumNegativeBits</name> <range>: <expr><literal type="number">8</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsScoped</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsScopedUsingClassTag</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsFixed</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>HasODRHash</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<enum>enum <block>{ <decl><name>NumEnumDeclBits</name> <init>= <expr><literal type="number">20</literal></expr></init></decl> }</block>;</enum>




<decl_stmt><decl><type><name>class</name></type> <name>RecordDeclBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>RecordDecl</name></decl>;</decl_stmt>

<label><name>uint64_t</name> :</label> <expr_stmt><expr><name>NumDeclContextBits</name></expr>;</expr_stmt>

<label><name>uint64_t</name> :</label> <expr_stmt><expr><name>NumTagDeclBits</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name>uint64_t</name></type> <name>HasFlexibleArrayMember</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>AnonymousStructOrUnion</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>HasObjectMember</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>HasVolatileMember</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>mutable</name> <name>uint64_t</name></type> <name>LoadedFieldsFromExternalStorage</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>NonTrivialToPrimitiveDefaultInitialize</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>NonTrivialToPrimitiveCopy</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>NonTrivialToPrimitiveDestroy</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>uint64_t</name></type> <name>HasNonTrivialToPrimitiveDefaultInitializeCUnion</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>HasNonTrivialToPrimitiveDestructCUnion</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>HasNonTrivialToPrimitiveCopyCUnion</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>ParamDestroyedInCallee</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>ArgPassingRestrictions</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<enum>enum <block>{ <decl><name>NumRecordDeclBits</name> <init>= <expr><literal type="number">14</literal></expr></init></decl> }</block>;</enum>




<decl_stmt><decl><type><name>class</name></type> <name>OMPDeclareReductionDeclBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>OMPDeclareReductionDecl</name></decl>;</decl_stmt>

<label><name>uint64_t</name> :</label> <expr_stmt><expr><name>NumDeclContextBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>InitializerKind</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<enum>enum <block>{ <decl><name>NumOMPDeclareReductionDeclBits</name> <init>= <expr><literal type="number">2</literal></expr></init></decl> }</block>;</enum>





<decl_stmt><decl><type><name>class</name></type> <name>FunctionDeclBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>FunctionDecl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXDeductionGuideDecl</name></decl>;</decl_stmt>

<label><name>uint64_t</name> :</label> <expr_stmt><expr><name>NumDeclContextBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>SClass</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsInline</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsInlineSpecified</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsVirtualAsWritten</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsPure</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>HasInheritedPrototype</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>HasWrittenPrototype</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsDeleted</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsTrivial</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsTrivialForCall</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsDefaulted</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsExplicitlyDefaulted</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>HasDefaultedFunctionInfo</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>HasImplicitReturnZero</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsLateTemplateParsed</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>ConstexprKind</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>InstantiationIsPending</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>UsesSEHTry</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>HasSkippedBody</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>WillHaveBody</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsMultiVersion</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsCopyDeductionCandidate</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>HasODRHash</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>UsesFPIntrin</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<enum>enum <block>{ <decl><name>NumFunctionDeclBits</name> <init>= <expr><literal type="number">27</literal></expr></init></decl> }</block>;</enum>




<decl_stmt><decl><type><name>class</name></type> <name>CXXConstructorDeclBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXConstructorDecl</name></decl>;</decl_stmt>

<label><name>uint64_t</name> :</label> <expr_stmt><expr><name>NumDeclContextBits</name></expr>;</expr_stmt>

<label><name>uint64_t</name> :</label> <expr_stmt><expr><name>NumFunctionDeclBits</name></expr>;</expr_stmt>






<decl_stmt><decl><type><name>uint64_t</name></type> <name>NumCtorInitializers</name> <range>: <expr><literal type="number">21</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsInheritingConstructor</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>HasTrailingExplicitSpecifier</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsSimpleExplicit</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<enum>enum <block>{
<decl><name>NumCXXConstructorDeclBits</name> <init>= <expr><literal type="number">64</literal> <operator>-</operator> <name>NumDeclContextBits</name> <operator>-</operator> <name>NumFunctionDeclBits</name></expr></init></decl>
}</block>;</enum>




<decl_stmt><decl><type><name>class</name></type> <name>ObjCMethodDeclBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ObjCMethodDecl</name></decl>;</decl_stmt>


<label><name>uint64_t</name> :</label> <expr_stmt><expr><name>NumDeclContextBits</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name>mutable</name> <name>uint64_t</name></type> <name>Family</name> <range>: <expr><name>ObjCMethodFamilyBitWidth</name></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsInstance</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsVariadic</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsPropertyAccessor</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsSynthesizedAccessorStub</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsDefined</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsRedeclaration</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>mutable</name> <name>uint64_t</name></type> <name>HasRedeclaration</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>DeclImplementation</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>objcDeclQualifier</name> <range>: <expr><literal type="number">7</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>RelatedResultType</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>SelLocsKind</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>








<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsOverriding</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>HasSkippedBody</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<enum>enum <block>{ <decl><name>NumObjCMethodDeclBits</name> <init>= <expr><literal type="number">24</literal></expr></init></decl> }</block>;</enum>




<decl_stmt><decl><type><name>class</name></type> <name>ObjCContainerDeclBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ObjCContainerDecl</name></decl>;</decl_stmt>

<label><name>uint32_t</name> :</label> <expr_stmt><expr><name>NumDeclContextBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>SourceLocation</name></type> <name>AtStart</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<enum>enum <block>{ <decl><name>NumObjCContainerDeclBits</name> <init>= <expr><literal type="number">64</literal> <operator>-</operator> <name>NumDeclContextBits</name></expr></init></decl> }</block>;</enum>




<decl_stmt><decl><type><name>class</name></type> <name>LinkageSpecDeclBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>LinkageSpecDecl</name></decl>;</decl_stmt>

<label><name>uint64_t</name> :</label> <expr_stmt><expr><name>NumDeclContextBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>Language</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>uint64_t</name></type> <name>HasBraces</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<enum>enum <block>{ <decl><name>NumLinkageSpecDeclBits</name> <init>= <expr><literal type="number">4</literal></expr></init></decl> }</block>;</enum>




<decl_stmt><decl><type><name>class</name></type> <name>BlockDeclBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>BlockDecl</name></decl>;</decl_stmt>

<label><name>uint64_t</name> :</label> <expr_stmt><expr><name>NumDeclContextBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsVariadic</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>CapturesCXXThis</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>BlockMissingReturnType</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>IsConversionFromLambda</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>DoesNotEscape</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>uint64_t</name></type> <name>CanAvoidCopyToHeap</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<enum>enum <block>{ <decl><name>NumBlockDeclBits</name> <init>= <expr><literal type="number">5</literal></expr></init></decl> }</block>;</enum>







<decl_stmt><decl><type><name>mutable</name> <name>StoredDeclsMap</name> <modifier>*</modifier></type><name>LookupPtr</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<label><name>protected</name>:</label>








<union>union <block>{
<decl_stmt><decl><type><name>DeclContextBitfields</name></type> <name>DeclContextBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TagDeclBitfields</name></type> <name>TagDeclBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EnumDeclBitfields</name></type> <name>EnumDeclBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RecordDeclBitfields</name></type> <name>RecordDeclBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OMPDeclareReductionDeclBitfields</name></type> <name>OMPDeclareReductionDeclBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FunctionDeclBitfields</name></type> <name>FunctionDeclBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXConstructorDeclBitfields</name></type> <name>CXXConstructorDeclBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ObjCMethodDeclBitfields</name></type> <name>ObjCMethodDeclBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ObjCContainerDeclBitfields</name></type> <name>ObjCContainerDeclBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LinkageSpecDeclBitfields</name></type> <name>LinkageSpecDeclBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BlockDeclBitfields</name></type> <name>BlockDeclBits</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DeclContextBitfields</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <literal type="number">8</literal></expr></argument>,
<argument><expr><literal type="string">"DeclContextBitfields is larger than 8 bytes!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TagDeclBitfields</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <literal type="number">8</literal></expr></argument>,
<argument><expr><literal type="string">"TagDeclBitfields is larger than 8 bytes!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EnumDeclBitfields</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <literal type="number">8</literal></expr></argument>,
<argument><expr><literal type="string">"EnumDeclBitfields is larger than 8 bytes!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RecordDeclBitfields</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <literal type="number">8</literal></expr></argument>,
<argument><expr><literal type="string">"RecordDeclBitfields is larger than 8 bytes!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OMPDeclareReductionDeclBitfields</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <literal type="number">8</literal></expr></argument>,
<argument><expr><literal type="string">"OMPDeclareReductionDeclBitfields is larger than 8 bytes!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FunctionDeclBitfields</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <literal type="number">8</literal></expr></argument>,
<argument><expr><literal type="string">"FunctionDeclBitfields is larger than 8 bytes!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CXXConstructorDeclBitfields</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <literal type="number">8</literal></expr></argument>,
<argument><expr><literal type="string">"CXXConstructorDeclBitfields is larger than 8 bytes!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjCMethodDeclBitfields</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <literal type="number">8</literal></expr></argument>,
<argument><expr><literal type="string">"ObjCMethodDeclBitfields is larger than 8 bytes!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjCContainerDeclBitfields</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <literal type="number">8</literal></expr></argument>,
<argument><expr><literal type="string">"ObjCContainerDeclBitfields is larger than 8 bytes!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LinkageSpecDeclBitfields</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <literal type="number">8</literal></expr></argument>,
<argument><expr><literal type="string">"LinkageSpecDeclBitfields is larger than 8 bytes!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BlockDeclBitfields</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <literal type="number">8</literal></expr></argument>,
<argument><expr><literal type="string">"BlockDeclBitfields is larger than 8 bytes!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>;</union>



<decl_stmt><decl><type><name>mutable</name> <name>Decl</name> <modifier>*</modifier></type><name>FirstDecl</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>





<decl_stmt><decl><type><name>mutable</name> <name>Decl</name> <modifier>*</modifier></type><name>LastDecl</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>




<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<macro><name>BuildDeclChain</name><argument_list>(<argument>ArrayRef&lt;Decl*&gt; Decls</argument>, <argument>bool FieldsAlreadyLoaded</argument>)</argument_list></macro></expr>;</expr_stmt>

<macro><name>DeclContext</name><argument_list>(<argument>Decl::Kind K</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><operator>~</operator><call><name>DeclContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>Decl</name><operator>::</operator><name>Kind</name> <macro><name>getDeclKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name><operator>::</operator><name>Kind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>DeclContextBits</name><operator>.</operator><name>DeclKind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getDeclKindName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<function><type><name>DeclContext</name> <modifier>*</modifier></type><name>getParent</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getDeclContext</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>getParent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getParent</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>










<function><type><name>DeclContext</name> <modifier>*</modifier></type><name>getLexicalParent</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getLexicalDeclContext</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>getLexicalParent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getLexicalParent</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function_decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>getLookupParent</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>getLookupParent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getLookupParent</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>ASTContext</name> <operator>&amp;</operator><macro><name>getParentASTContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getASTContext</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isClosure</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getDeclKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Decl</name><operator>::</operator><name>Block</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>BlockDecl</name> <operator>*</operator><macro><name>getInnermostBlockDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isObjCContainer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<switch>switch <condition>(<expr><call><name>getDeclKind</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Decl</name><operator>::</operator><name>ObjCCategory</name></expr>:</case>
<case>case <expr><name>Decl</name><operator>::</operator><name>ObjCCategoryImpl</name></expr>:</case>
<case>case <expr><name>Decl</name><operator>::</operator><name>ObjCImplementation</name></expr>:</case>
<case>case <expr><name>Decl</name><operator>::</operator><name>ObjCInterface</name></expr>:</case>
<case>case <expr><name>Decl</name><operator>::</operator><name>ObjCProtocol</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>
<default>default:</default>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/>}</block_content>
}

bool isFunctionOrMethod(</block></switch>) <specifier>const</specifier> <block>{
<switch>switch <condition>(<expr><call><name>getDeclKind</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Decl</name><operator>::</operator><name>Block</name></expr>:</case>
<case>case <expr><name>Decl</name><operator>::</operator><name>Captured</name></expr>:</case>
<case>case <expr><name>Decl</name><operator>::</operator><name>ObjCMethod</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>
<default>default:</default>
<return>return <expr><call><name>getDeclKind</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>Decl</name><operator>::</operator><name>firstFunction</name> <operator>&amp;&amp;</operator>
<call><name>getDeclKind</name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>Decl</name><operator>::</operator><name>lastFunction</name></expr>;</return>
<expr_stmt/>}</block_content>
}


bool isLookupContext(</block></switch>) <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name>isFunctionOrMethod</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>getDeclKind</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>Decl</name><operator>::</operator><name>LinkageSpec</name> <operator>&amp;&amp;</operator>
<call><name>getDeclKind</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>Decl</name><operator>::</operator><name>Export</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isFileContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getDeclKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Decl</name><operator>::</operator><name>TranslationUnit</name> <operator>||</operator>
<call><name>getDeclKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Decl</name><operator>::</operator><name>Namespace</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isTranslationUnit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getDeclKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Decl</name><operator>::</operator><name>TranslationUnit</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isRecord</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getDeclKind</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>Decl</name><operator>::</operator><name>firstRecord</name> <operator>&amp;&amp;</operator>
<call><name>getDeclKind</name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>Decl</name><operator>::</operator><name>lastRecord</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isNamespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getDeclKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Decl</name><operator>::</operator><name>Namespace</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isStdNamespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier></block></block></expr>;</expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isInlineNamespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isDependentContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
















<expr_stmt><expr><name>bool</name> <macro><name>isTransparentContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isExternCContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>LinkageSpecDecl</name> <operator>*</operator><macro><name>getExternCContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isExternCXXContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>Equals</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><name>DC</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>DC</name> <operator>&amp;&amp;</operator> <call><name><name>this</name><operator>-&gt;</operator><name>getPrimaryContext</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>DC</name><operator>-&gt;</operator><name>getPrimaryContext</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>Encloses</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><name>DC</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>getNonClosureAncestor</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getNonClosureAncestor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getNonClosureAncestor</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>







<function_decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>getPrimaryContext</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>getPrimaryContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPrimaryContext</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<function_decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>getRedeclContext</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>getRedeclContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getRedeclContext</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function_decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>getEnclosingNamespaceContext</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>getEnclosingNamespaceContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getEnclosingNamespaceContext</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function_decl><type><name>RecordDecl</name> <modifier>*</modifier></type><name>getOuterLexicalRecordContext</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>RecordDecl</name> <operator>*</operator><macro><name>getOuterLexicalRecordContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getOuterLexicalRecordContext</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>







<function><type><name>bool</name></type> <name>InEnclosingNamespaceSetOf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>NS</name></decl></parameter>)</parameter_list> const;</function>
























<function_decl><type><name>void</name></type> <name>collectAllContexts</name><parameter_list>(<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Contexts</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>class</name></type> <name>decl_iterator</name> <block>{<block_content>

<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Current</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>using</name></type> <name>value_type</name> <init>= <expr><name>Decl</name> <operator>*</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>reference</name> <init>= <expr><specifier>const</specifier> <name>value_type</name> <operator>&amp;</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>pointer</name> <init>= <expr><specifier>const</specifier> <name>value_type</name> <operator>*</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>iterator_category</name> <init>= <expr><name>std</name><operator>::</operator><name>forward_iterator_tag</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>difference_type</name> <init>= <expr><name>std</name><operator>::</operator><name>ptrdiff_t</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>decl_iterator</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>decl_iterator</name><argument_list>(<argument><expr><name>Decl</name> <operator>*</operator><name>C</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>Current</name><argument_list>(<argument>C</argument>)</argument_list></macro> <block>{}</block>

<name>reference</name> <name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>Current</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>value_type</name> <name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>)</block_content> const <block>{<block_content> <return>return <expr><name>Current</name></expr>;</return> </block_content>}</block>

decl_iterator&amp; operator++(</block></decl>) <block>{<block_content>
<expr_stmt><expr><name>Current</name> <operator>=</operator> <call><name><name>Current</name><operator>-&gt;</operator><name>getNextDeclInContext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></decl_stmt>

<expr_stmt><expr><name>decl_iterator</name> <name>operator</name><operator>++</operator><operator>(</operator><name>int</name><operator>)</operator> <block>{
<expr><name>decl_iterator</name> <call><name>tmp</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>++</operator><operator>(</operator><operator>*</operator><name>this</name><operator>)</operator></expr>;
<return>return <expr><name>tmp</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><name>decl_iterator</name> <name>x</name><operator>,</operator> <name>decl_iterator</name> <name>y</name><operator>)</operator> <block>{
<return>return <expr><name><name>x</name><operator>.</operator><name>Current</name></name> <operator>==</operator> <name><name>y</name><operator>.</operator><name>Current</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><name>decl_iterator</name> <name>x</name><operator>,</operator> <name>decl_iterator</name> <name>y</name><operator>)</operator> <block>{
<return>return <expr><name><name>x</name><operator>.</operator><name>Current</name></name> <operator>!=</operator> <name><name>y</name><operator>.</operator><name>Current</name></name></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>decl_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>decl_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name>decl_range</name> <macro><name>decls</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>decl_range</name><argument_list>(<argument><expr><call><name>decls_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>decls_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>decl_iterator</name> <macro><name>decls_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>decl_iterator</name> <macro><name>decls_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>decl_iterator</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>decls_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>decl_range</name> <macro><name>noload_decls</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>decl_range</name><argument_list>(<argument><expr><call><name>noload_decls_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>noload_decls_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>decl_iterator</name> <macro><name>noload_decls_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>decl_iterator</name><argument_list>(<argument><expr><name>FirstDecl</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>decl_iterator</name> <macro><name>noload_decls_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>decl_iterator</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>






<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>SpecificDecl</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>specific_decl_iterator</name> <block>{<block_content>



<expr_stmt><expr><name>DeclContext</name><operator>::</operator><name>decl_iterator</name> <name>Current</name></expr>;</expr_stmt>




<function><type><name>void</name></type> <name>SkipToNextDecl</name><parameter_list>()</parameter_list> <block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>Current</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>SpecificDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>Current</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>Current</name></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>using</name></type> <name>value_type</name> <init>= <expr><name>SpecificDecl</name> <operator>*</operator></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>reference</name> <init>= <expr><name>void</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>pointer</name> <init>= <expr><name>void</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>difference_type</name> <init>=
<expr><name>std</name><operator>::</operator><name><name>iterator_traits</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>::</operator><name>decl_iterator</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>difference_type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>iterator_category</name> <init>= <expr><name>std</name><operator>::</operator><name>forward_iterator_tag</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>specific_decl_iterator</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>









<decl_stmt><decl><type><name>explicit</name></type> <name>specific_decl_iterator</name><argument_list>(<argument><expr><name>DeclContext</name><operator>::</operator><name>decl_iterator</name> <name>C</name></expr></argument>)</argument_list> <range>: <macro><name>Current</name><argument_list>(<argument>C</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>SkipToNextDecl</name><argument_list>()</argument_list></call></expr>;
}</block>

<name>value_type</name> <name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>SpecificDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>Current</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></range></decl></decl_stmt>


<expr_stmt><expr><name>value_type</name> <name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>)</block_content> const <block>{<block_content> <return>return <expr><operator>*</operator><operator>*</operator><name>this</name></expr>;</return> </block_content>}</block>

specific_decl_iterator&amp; operator++(</block></decl>) <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>Current</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SkipToNextDecl</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></decl_stmt>

<expr_stmt><expr><name>specific_decl_iterator</name> <name>operator</name><operator>++</operator><operator>(</operator><name>int</name><operator>)</operator> <block>{
<expr><name>specific_decl_iterator</name> <call><name>tmp</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>++</operator><operator>(</operator><operator>*</operator><name>this</name><operator>)</operator></expr>;
<return>return <expr><name>tmp</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>specific_decl_iterator</name><operator>&amp;</operator> <name>x</name><operator>,</operator>
<specifier>const</specifier> <name>specific_decl_iterator</name><operator>&amp;</operator> <name>y</name><operator>)</operator> <block>{
<return>return <expr><name><name>x</name><operator>.</operator><name>Current</name></name> <operator>==</operator> <name><name>y</name><operator>.</operator><name>Current</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>specific_decl_iterator</name><operator>&amp;</operator> <name>x</name><operator>,</operator>
<specifier>const</specifier> <name>specific_decl_iterator</name><operator>&amp;</operator> <name>y</name><operator>)</operator> <block>{
<return>return <expr><name><name>x</name><operator>.</operator><name>Current</name></name> <operator>!=</operator> <name><name>y</name><operator>.</operator><name>Current</name></name></expr>;</return>
}</block></expr></expr_stmt>
};










<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>SpecificDecl</name></expr></argument>, <argument><expr><name>bool</name> <operator>(</operator><name>SpecificDecl</name><operator>::</operator><operator>*</operator><name>Acceptable</name><operator>)</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>filtered_decl_iterator</name> <block>{<block_content>



<expr_stmt><expr><name>DeclContext</name><operator>::</operator><name>decl_iterator</name> <name>Current</name></expr>;</expr_stmt>




<function><type><name>void</name></type> <name>SkipToNextDecl</name><parameter_list>()</parameter_list> <block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>Current</name> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>SpecificDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>Current</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><name>Acceptable</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>SpecificDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>Current</name></expr></argument>)</argument_list></call><operator>-&gt;*</operator><name>Acceptable</name><operator>)</operator><operator>(</operator><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>Current</name></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>using</name></type> <name>value_type</name> <init>= <expr><name>SpecificDecl</name> <operator>*</operator></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>reference</name> <init>= <expr><name>void</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>pointer</name> <init>= <expr><name>void</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>difference_type</name> <init>=
<expr><name>std</name><operator>::</operator><name><name>iterator_traits</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>::</operator><name>decl_iterator</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>difference_type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>iterator_category</name> <init>= <expr><name>std</name><operator>::</operator><name>forward_iterator_tag</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>filtered_decl_iterator</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>









<decl_stmt><decl><type><name>explicit</name></type> <name>filtered_decl_iterator</name><argument_list>(<argument><expr><name>DeclContext</name><operator>::</operator><name>decl_iterator</name> <name>C</name></expr></argument>)</argument_list> <range>: <macro><name>Current</name><argument_list>(<argument>C</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>SkipToNextDecl</name><argument_list>()</argument_list></call></expr>;
}</block>

<name>value_type</name> <name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>SpecificDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>Current</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></range></decl></decl_stmt>
<expr_stmt><expr><name>value_type</name> <name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>)</block_content> const <block>{<block_content> <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>SpecificDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>Current</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block>

filtered_decl_iterator&amp; operator++(</block></decl>) <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>Current</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SkipToNextDecl</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></decl_stmt>

<expr_stmt><expr><name>filtered_decl_iterator</name> <name>operator</name><operator>++</operator><operator>(</operator><name>int</name><operator>)</operator> <block>{
<expr><name>filtered_decl_iterator</name> <call><name>tmp</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>++</operator><operator>(</operator><operator>*</operator><name>this</name><operator>)</operator></expr>;
<return>return <expr><name>tmp</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>filtered_decl_iterator</name><operator>&amp;</operator> <name>x</name><operator>,</operator>
<specifier>const</specifier> <name>filtered_decl_iterator</name><operator>&amp;</operator> <name>y</name><operator>)</operator> <block>{
<return>return <expr><name><name>x</name><operator>.</operator><name>Current</name></name> <operator>==</operator> <name><name>y</name><operator>.</operator><name>Current</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>filtered_decl_iterator</name><operator>&amp;</operator> <name>x</name><operator>,</operator>
<specifier>const</specifier> <name>filtered_decl_iterator</name><operator>&amp;</operator> <name>y</name><operator>)</operator> <block>{
<return>return <expr><name><name>x</name><operator>.</operator><name>Current</name></name> <operator>!=</operator> <name><name>y</name><operator>.</operator><name>Current</name></name></expr>;</return>
}</block></expr></expr_stmt>
};













<function_decl><type><name>void</name></type> <name>addDecl</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>void</name></type> <name>addDeclInternal</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>void</name></type> <name>addHiddenDecl</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>removeDecl</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>bool</name></type> <name>containsDecl</name><argument_list>(<argument><expr><name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>containsDeclAndLoad</name><argument_list>(<argument><expr><name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>lookup_result</name> <init>= <expr><name>DeclContextLookupResult</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>lookup_iterator</name> <init>= <expr><name>lookup_result</name><operator>::</operator><name>iterator</name></expr></init></decl>;</decl_stmt>






<decl_stmt><decl><type><name>lookup_result</name></type> <name>lookup</name><argument_list>(<argument><expr><name>DeclarationName</name> <name>Name</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<function_decl><type><name>lookup_result</name></type> <name>noload_lookup</name><parameter_list>(<parameter><decl><type><name>DeclarationName</name></type> <name>Name</name></decl></parameter>)</parameter_list>;</function_decl>










<function_decl><type><name>void</name></type> <name>localUncachedLookup</name><parameter_list>(<parameter><decl><type><name>DeclarationName</name></type> <name>Name</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Results</name></decl></parameter>)</parameter_list>;</function_decl>















<function_decl><type><name>void</name></type> <name>makeDeclVisibleInContext</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>class</name></type> <name>all_lookups_iterator</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>lookups_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>all_lookups_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>lookups_range</name> <macro><name>lookups</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<decl_stmt><decl><type><name>lookups_range</name></type> <name>noload_lookups</name><argument_list>(<argument><expr><name>bool</name> <name>PreserveInternalState</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>all_lookups_iterator</name> <macro><name>lookups_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>all_lookups_iterator</name> <macro><name>lookups_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>all_lookups_iterator</name> <macro><name>noload_lookups_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>all_lookups_iterator</name> <macro><name>noload_lookups_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<struct_decl>struct <name>udir_iterator</name>;</struct_decl>

<decl_stmt><decl><type><name>using</name></type> <name>udir_iterator_base</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>iterator_adaptor_base</name><argument_list type="generic">&lt;<argument><expr><name>udir_iterator</name></expr></argument>, <argument><expr><name>lookup_iterator</name></expr></argument>,
<argument><expr><name>typename</name> <name>lookup_iterator</name><operator>::</operator><name>iterator_category</name></expr></argument>,
<argument><expr><name>UsingDirectiveDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>udir_iterator</name></name></type> <range>: <expr><name>udir_iterator_base</name> <block>{
<macro><name>udir_iterator</name><argument_list>(<argument>lookup_iterator I</argument>)</argument_list></macro> <operator>:</operator> <macro><name>udir_iterator_base</name><argument_list>(<argument>I</argument>)</argument_list></macro> <expr><block>{}</block>

<name>UsingDirectiveDecl</name> <operator>*</operator><name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier></expr>;
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>udir_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>udir_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>udir_range</name> <macro><name>using_directives</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>ddiag_iterator</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>ddiag_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>::</operator><name>ddiag_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>ddiag_range</name> <macro><name>ddiags</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>









<function><type><name>void</name></type> <name>setMustBuildLookupTable</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>this</name> <operator>==</operator> <call><name>getPrimaryContext</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"should only be called on primary context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>DeclContextBits</name><operator>.</operator><name>HasLazyExternalLexicalLookups</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>StoredDeclsMap</name> <operator>*</operator><macro><name>getLookupPtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LookupPtr</name></expr>;</return> }</block></expr></expr_stmt>


<function_decl><type><name>StoredDeclsMap</name> <modifier>*</modifier></type><name>buildLookup</name><parameter_list>()</parameter_list>;</function_decl>



<expr_stmt><expr><name>bool</name> <macro><name>hasExternalLexicalStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>DeclContextBits</name><operator>.</operator><name>ExternalLexicalStorage</name></name></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>setHasExternalLexicalStorage</name><argument_list>(<argument><expr><name>bool</name> <name>ES</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><name><name>DeclContextBits</name><operator>.</operator><name>ExternalLexicalStorage</name></name> <operator>=</operator> <name>ES</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasExternalVisibleStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>DeclContextBits</name><operator>.</operator><name>ExternalVisibleStorage</name></name></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>setHasExternalVisibleStorage</name><argument_list>(<argument><expr><name>bool</name> <name>ES</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><name><name>DeclContextBits</name><operator>.</operator><name>ExternalVisibleStorage</name></name> <operator>=</operator> <name>ES</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ES</name> <operator>&amp;&amp;</operator> <name>LookupPtr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>DeclContextBits</name><operator>.</operator><name>NeedToReconcileExternalVisibleStorage</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isDeclInLexicalTraversal</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>D</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>D</name><operator>-&gt;</operator><name>NextInContextAndBits</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call> <operator>||</operator> <name>D</name> <operator>==</operator> <name>FirstDecl</name> <operator>||</operator>
<name>D</name> <operator>==</operator> <name>LastDecl</name><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>setUseQualifiedLookup</name><argument_list>(<argument><expr><name>bool</name> <name>use</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>old_value</name> <init>= <expr><name><name>DeclContextBits</name><operator>.</operator><name>UseQualifiedLookup</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>DeclContextBits</name><operator>.</operator><name>UseQualifiedLookup</name></name> <operator>=</operator> <name>use</name></expr>;</expr_stmt>
<return>return <expr><name>old_value</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>shouldUseQualifiedLookup</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>DeclContextBits</name><operator>.</operator><name>UseQualifiedLookup</name></name></expr>;</return>
}</block></expr></expr_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>true</name></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name>void</name> <macro><name>dumpDeclContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>void</name> <macro><name>dumpLookups</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>dumpLookups</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>, <argument><expr><name>bool</name> <name>DumpDecls</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>bool</name> <name>Deserialize</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<label><name>private</name>:</label>




<expr_stmt><expr><name>bool</name> <macro><name>hasNeedToReconcileExternalVisibleStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>DeclContextBits</name><operator>.</operator><name>NeedToReconcileExternalVisibleStorage</name></name></expr>;</return>
}</block></expr></expr_stmt>





<decl_stmt><decl><type><name>void</name></type> <name>setNeedToReconcileExternalVisibleStorage</name><argument_list>(<argument><expr><name>bool</name> <name>Need</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><name><name>DeclContextBits</name><operator>.</operator><name>NeedToReconcileExternalVisibleStorage</name></name> <operator>=</operator> <name>Need</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasLazyLocalLexicalLookups</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>DeclContextBits</name><operator>.</operator><name>HasLazyLocalLexicalLookups</name></name></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>setHasLazyLocalLexicalLookups</name><argument_list>(<argument><expr><name>bool</name> <name>HasLLLL</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><name><name>DeclContextBits</name><operator>.</operator><name>HasLazyLocalLexicalLookups</name></name> <operator>=</operator> <name>HasLLLL</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasLazyExternalLexicalLookups</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>DeclContextBits</name><operator>.</operator><name>HasLazyExternalLexicalLookups</name></name></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>setHasLazyExternalLexicalLookups</name><argument_list>(<argument><expr><name>bool</name> <name>HasLELL</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><name><name>DeclContextBits</name><operator>.</operator><name>HasLazyExternalLexicalLookups</name></name> <operator>=</operator> <name>HasLELL</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>void</name> <macro><name>reconcileExternalVisibleStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>LoadLexicalDeclsFromExternalStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>







<function_decl><type><name>void</name></type> <name>makeDeclVisibleInContextInternal</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>StoredDeclsMap</name> <modifier>*</modifier></type><name>CreateStoredDeclsMap</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>loadLazyLocalLexicalLookups</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>buildLookupImpl</name><parameter_list>(<parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DCtx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Internal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>makeDeclVisibleInContextWithFlags</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Internal</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Rediscoverable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>makeDeclVisibleInContextImpl</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Internal</name></decl></parameter>)</parameter_list>;</function_decl>
};

<expr_stmt><expr><specifier>inline</specifier> <name>bool</name> <name>Decl</name><operator>::</operator><macro><name>isTemplateParameter</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TemplateTypeParm</name> <operator>||</operator> <call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>NonTypeTemplateParm</name> <operator>||</operator>
<call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TemplateTemplateParm</name></expr>;</return>
}</block></expr></expr_stmt>


<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>ToTy</name></expr><operator>,</operator>
<expr><name>bool</name> <name>IsKnownSubtype</name> <operator>=</operator> <operator>::</operator><name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name></expr></argument>, <argument><expr><name>ToTy</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name><operator>&gt;</operator>
struct <name>cast_convert_decl_context</name> <block>{
<expr><specifier>static</specifier> <specifier>const</specifier> <name>ToTy</name> <operator>*</operator><macro><name>doit</name><argument_list>(<argument>const DeclContext *Val</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ToTy</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Decl</name><operator>::</operator><call><name>castFromDeclContext</name><argument_list>(<argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block></expr>
}</block>

<specifier>static</specifier> <name>ToTy</name> <operator>*</operator><macro><name>doit</name><argument_list>(<argument>DeclContext *Val</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ToTy</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Decl</name><operator>::</operator><call><name>castFromDeclContext</name><argument_list>(<argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
};


<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>ToTy</name><operator>&gt;</operator>
struct <name><name>cast_convert_decl_context</name><argument_list type="generic">&lt;<argument><expr><name>ToTy</name></expr></argument>, <argument><expr><name>true</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <specifier>const</specifier> <name>ToTy</name> <operator>*</operator><macro><name>doit</name><argument_list>(<argument>const DeclContext *Val</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ToTy</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr>;</return></block></expr>
}</block>

<specifier>static</specifier> <name>ToTy</name> <operator>*</operator><macro><name>doit</name><argument_list>(<argument>DeclContext *Val</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ToTy</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
};

}

namespace <macro><name>llvm</name></macro> <block>{<block_content>


<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>To</name><operator>&gt;</operator>
struct <name><name>isa_impl</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>, <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>DeclContext</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <name>bool</name> <macro><name>doit</name><argument_list>(<argument>const ::clang::DeclContext &amp;Val</argument>)</argument_list></macro> <block>{
<return>return <expr><name>To</name><operator>::</operator><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>Val</name><operator>.</operator><name>getDeclKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block></expr>
}</block></expr></expr_stmt>
</block_content>}</block><empty_stmt>;</empty_stmt>


<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>ToTy</name><operator>&gt;</operator>
struct <name><name>cast_convert_val</name><argument_list type="generic">&lt;<argument><expr><name>ToTy</name></expr></argument>,
<argument><expr><specifier>const</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>DeclContext</name></expr></argument>,<argument><expr><specifier>const</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>DeclContext</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <specifier>const</specifier> <name>ToTy</name> <operator>&amp;</operator><macro><name>doit</name><argument_list>(<argument>const ::clang::DeclContext &amp;Val</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>*</operator><operator>::</operator><name>clang</name><operator>::</operator><name><name>cast_convert_decl_context</name><argument_list type="generic">&lt;<argument><expr><name>ToTy</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>doit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Val</name></expr></argument>)</argument_list></call></expr>;</return></block></expr>
}</block></expr></expr_stmt>
};

<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>ToTy</name><operator>&gt;</operator>
struct <name><name>cast_convert_val</name><argument_list type="generic">&lt;<argument><expr><name>ToTy</name></expr></argument>, <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>DeclContext</name></expr></argument>, <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>DeclContext</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <name>ToTy</name> <operator>&amp;</operator><macro><name>doit</name><argument_list>(<argument>::clang::DeclContext &amp;Val</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>*</operator><operator>::</operator><name>clang</name><operator>::</operator><name><name>cast_convert_decl_context</name><argument_list type="generic">&lt;<argument><expr><name>ToTy</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>doit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Val</name></expr></argument>)</argument_list></call></expr>;</return></block></expr>
}</block></expr></expr_stmt>
};

<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>ToTy</name><operator>&gt;</operator>
struct <name><name>cast_convert_val</name><argument_list type="generic">&lt;<argument><expr><name>ToTy</name></expr></argument>,
<argument><expr><specifier>const</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>DeclContext</name><operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>DeclContext</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <specifier>const</specifier> <name>ToTy</name> <operator>*</operator><macro><name>doit</name><argument_list>(<argument>const ::clang::DeclContext *Val</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>::</operator><name>clang</name><operator>::</operator><name><name>cast_convert_decl_context</name><argument_list type="generic">&lt;<argument><expr><name>ToTy</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>doit</name><argument_list>(<argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr>;</return></block></expr>
}</block></expr></expr_stmt>
};

<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>ToTy</name><operator>&gt;</operator>
struct <name><name>cast_convert_val</name><argument_list type="generic">&lt;<argument><expr><name>ToTy</name></expr></argument>, <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>DeclContext</name><operator>*</operator></expr></argument>, <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>DeclContext</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <name>ToTy</name> <operator>*</operator><macro><name>doit</name><argument_list>(<argument>::clang::DeclContext *Val</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>::</operator><name>clang</name><operator>::</operator><name><name>cast_convert_decl_context</name><argument_list type="generic">&lt;<argument><expr><name>ToTy</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>doit</name><argument_list>(<argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr>;</return></block></expr>
}</block></expr></expr_stmt>
};


<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>FromTy</name><operator>&gt;</operator>
struct <name><name>cast_convert_val</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>DeclContext</name></expr></argument>, <argument><expr><name>FromTy</name></expr></argument>, <argument><expr><name>FromTy</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>DeclContext</name> <operator>&amp;</operator><macro><name>doit</name><argument_list>(<argument>const FromTy &amp;Val</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>*</operator><name>FromTy</name><operator>::</operator><call><name>castToDeclContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Val</name></expr></argument>)</argument_list></call></expr>;</return></block></expr>
}</block></expr></expr_stmt>
};

<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>FromTy</name><operator>&gt;</operator>
struct <name><name>cast_convert_val</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>clang</name><operator>::</operator><name>DeclContext</name></expr></argument>, <argument><expr><name>FromTy</name><operator>*</operator></expr></argument>, <argument><expr><name>FromTy</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>DeclContext</name> <operator>*</operator><macro><name>doit</name><argument_list>(<argument>const FromTy *Val</argument>)</argument_list></macro> <block>{
<return>return <expr><name>FromTy</name><operator>::</operator><call><name>castToDeclContext</name><argument_list>(<argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr>;</return></block></expr>
}</block></expr></expr_stmt>
};

<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>FromTy</name><operator>&gt;</operator>
struct <name><name>cast_convert_val</name><argument_list type="generic">&lt; <argument><expr><specifier>const</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>DeclContext</name></expr></argument>, <argument><expr><name>FromTy</name></expr></argument>, <argument><expr><name>FromTy</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <specifier>const</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>DeclContext</name> <operator>&amp;</operator><macro><name>doit</name><argument_list>(<argument>const FromTy &amp;Val</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>*</operator><name>FromTy</name><operator>::</operator><call><name>castToDeclContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Val</name></expr></argument>)</argument_list></call></expr>;</return></block></expr>
}</block></expr></expr_stmt>
};

<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>FromTy</name><operator>&gt;</operator>
struct <name><name>cast_convert_val</name><argument_list type="generic">&lt; <argument><expr><specifier>const</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>DeclContext</name></expr></argument>, <argument><expr><name>FromTy</name><operator>*</operator></expr></argument>, <argument><expr><name>FromTy</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <specifier>const</specifier> <operator>::</operator><name>clang</name><operator>::</operator><name>DeclContext</name> <operator>*</operator><macro><name>doit</name><argument_list>(<argument>const FromTy *Val</argument>)</argument_list></macro> <block>{
<return>return <expr><name>FromTy</name><operator>::</operator><call><name>castToDeclContext</name><argument_list>(<argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr>;</return></block></expr>
}</block></expr></expr_stmt>
};

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
