<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/DeclObjC.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_DECLOBJC_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_DECLOBJC_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclBase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclObjCCommon.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExternalASTSource.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Redeclarable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/SelectorLocationsKind.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/IdentifierTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Specifiers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/None.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerIntPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/STLExtras.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/TrailingObjects.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iterator&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CompoundStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXCtorInitializer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCCategoryDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCCategoryImplDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCImplementationDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCInterfaceDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCIvarDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCPropertyDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCPropertyImplDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCProtocolDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Stmt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>ObjCListBase</name> <block>{<block_content>
<label><name>protected</name>:</label>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>List</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumElts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>ObjCListBase</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<expr_stmt><expr><call><name>ObjCListBase</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCListBase</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ObjCListBase</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>ObjCListBase</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumElts</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumElts</name> <operator>==</operator> <literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>

<label><name>protected</name>:</label>
<function_decl><type><name>void</name></type> <name>set</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type> <name>InList</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Elts</name></decl></parameter>, <parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Ctx</name></decl></parameter>)</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ObjCList</name> <range>: <expr><name>public</name> <name>ObjCListBase</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>void</name> <macro><name>set</name><argument_list>(<argument>T* const* InList</argument>, <argument>unsigned Elts</argument>, <argument>ASTContext &amp;Ctx</argument>)</argument_list></macro> <block>{
<expr><name>ObjCListBase</name><operator>::</operator><call><name>set</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>*</operator><specifier>const</specifier><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>InList</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Elts</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>using</name> <name>iterator</name> <operator>=</operator> <name>T</name><operator>*</operator> <specifier>const</specifier> <operator>*</operator></expr>;

<expr><name>iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>iterator</name><operator>)</operator><name>List</name></expr>;</return> }</block>
<name>iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>iterator</name><operator>)</operator><name>List</name><operator>+</operator><name>NumElts</name></expr>;</return> }</block>

<name>T</name><operator>*</operator> <name><name>operator</name><index>[]</index></name><operator>(</operator><name>unsigned</name> <name>Idx</name><operator>)</operator> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Idx</name> <operator>&lt;</operator> <name>NumElts</name> <operator>&amp;&amp;</operator> <literal type="string">"Invalid access"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>(</operator><name>T</name><operator>*</operator><operator>)</operator><name><name>List</name><index>[<expr><name>Idx</name></expr>]</index></name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>ObjCProtocolList</name> <operator>:</operator> <name>public</name> <name><name>ObjCList</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>SourceLocation</name> <operator>*</operator><name>Locations</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>using</name> <name><name>ObjCList</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>set</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>ObjCProtocolList</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>using</name> <name>loc_iterator</name> <operator>=</operator> <specifier>const</specifier> <name>SourceLocation</name> <operator>*</operator></expr>;

<expr><name>loc_iterator</name> <macro><name>loc_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Locations</name></expr>;</return> }</block>
<name>loc_iterator</name> <macro><name>loc_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Locations</name> <operator>+</operator> <call><name>size</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>set</name><argument_list>(<argument>ObjCProtocolDecl* const* InList</argument>, <argument>unsigned Elts</argument>,
<argument>const SourceLocation *Locs</argument>, <argument>ASTContext &amp;Ctx</argument>)</argument_list></macro></expr>;
}</block></expr>;





















<expr><name>class</name> <name>ObjCMethodDecl</name> <operator>:</operator> <name>public</name> <name>NamedDecl</name></expr>, <expr><name>public</name> <name>DeclContext</name> <block>{



<expr><name>public</name><operator>:</operator>
enum <name>ImplementationControl</name> <block>{ <expr><name>None</name></expr>, <expr><name>Required</name></expr>, <expr><name>Optional</name></expr> }</block></expr>;

<expr><name>private</name><operator>:</operator>

<name>QualType</name> <name>MethodDeclType</name></expr>;


<expr><name>TypeSourceInfo</name> <operator>*</operator><name>ReturnTInfo</name></expr>;



<expr><name>void</name> <operator>*</operator><name>ParamsAndSelLocs</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>unsigned</name> <name>NumParams</name> <operator>=</operator> <literal type="number">0</literal></expr>;


<expr><name>SourceLocation</name> <name>DeclEndLoc</name></expr>;


<expr><name>LazyDeclStmtPtr</name> <name>Body</name></expr>;



<expr><name>ImplicitParamDecl</name> <operator>*</operator><name>SelfDecl</name> <operator>=</operator> <name>nullptr</name></expr>;



<expr><name>ImplicitParamDecl</name> <operator>*</operator><name>CmdDecl</name> <operator>=</operator> <name>nullptr</name></expr>;

<macro><name>ObjCMethodDecl</name><argument_list>(<argument>SourceLocation beginLoc</argument>, <argument>SourceLocation endLoc</argument>,
<argument>Selector SelInfo</argument>, <argument>QualType T</argument>, <argument>TypeSourceInfo *ReturnTInfo</argument>,
<argument>DeclContext *contextDecl</argument>, <argument>bool isInstance = true</argument>,
<argument>bool isVariadic = false</argument>, <argument>bool isPropertyAccessor = false</argument>,
<argument>bool isSynthesizedAccessorStub = false</argument>,
<argument>bool isImplicitlyDeclared = false</argument>, <argument>bool isDefined = false</argument>,
<argument>ImplementationControl impControl = None</argument>,
<argument>bool HasRelatedResultType = false</argument>)</argument_list></macro>;

<expr><name>SelectorLocationsKind</name> <macro><name>getSelLocsKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>SelectorLocationsKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>SelLocsKind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setSelLocsKind</name><argument_list>(<argument>SelectorLocationsKind Kind</argument>)</argument_list></macro> <block>{
<expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>SelLocsKind</name></name> <operator>=</operator> <name>Kind</name></expr>;
}</block>

<name>bool</name> <macro><name>hasStandardSelLocs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getSelLocsKind</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SelLoc_NonStandard</name></expr>;</return>
}</block>



<name>SourceLocation</name> <operator>*</operator><macro><name>getStoredSelLocs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getParams</name><argument_list>()</argument_list></call> <operator>+</operator> <name>NumParams</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>SourceLocation</name> <operator>*</operator><macro><name>getStoredSelLocs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>SourceLocation</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getParams</name><argument_list>()</argument_list></call> <operator>+</operator> <name>NumParams</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>ParmVarDecl</name> <operator>*</operator><operator>*</operator><macro><name>getParams</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ParamsAndSelLocs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>ParmVarDecl</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><macro><name>getParams</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ParmVarDecl</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ParamsAndSelLocs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>unsigned</name> <macro><name>getNumStoredSelLocs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasStandardSelLocs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getNumSelectorLocs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <call><name>setParamsAndSelLocs</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Params</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <name>SelLocs</name></expr></argument>)</argument_list></call></expr>;




<expr><name>ObjCMethodDecl</name> <operator>*</operator><macro><name>getNextRedeclarationImpl</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;

<expr><specifier>static</specifier> <name>ObjCMethodDecl</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>SourceLocation beginLoc</argument>, <argument>SourceLocation endLoc</argument>,
<argument>Selector SelInfo</argument>, <argument>QualType T</argument>, <argument>TypeSourceInfo *ReturnTInfo</argument>,
<argument>DeclContext *contextDecl</argument>, <argument>bool isInstance = true</argument>,
<argument>bool isVariadic = false</argument>, <argument>bool isPropertyAccessor = false</argument>,
<argument>bool isSynthesizedAccessorStub = false</argument>,
<argument>bool isImplicitlyDeclared = false</argument>, <argument>bool isDefined = false</argument>,
<argument>ImplementationControl impControl = None</argument>,
<argument>bool HasRelatedResultType = false</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>ObjCMethodDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>ObjCMethodDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><specifier>const</specifier> <name>ObjCMethodDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ObjCDeclQualifier</name> <macro><name>getObjCDeclQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCDeclQualifier</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>objcDeclQualifier</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setObjCDeclQualifier</name><argument_list>(<argument>ObjCDeclQualifier QV</argument>)</argument_list></macro> <block>{
<expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>objcDeclQualifier</name></name> <operator>=</operator> <name>QV</name></expr>;
}</block>



<name>bool</name> <macro><name>hasRelatedResultType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>RelatedResultType</name></name></expr>;</return>
}</block>


<name>void</name> <macro><name>setRelatedResultType</name><argument_list>(<argument>bool RRT = true</argument>)</argument_list></macro> <block>{
<expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>RelatedResultType</name></name> <operator>=</operator> <name>RRT</name></expr>;
}</block>


<name>bool</name> <macro><name>isRedeclaration</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>IsRedeclaration</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setIsRedeclaration</name><argument_list>(<argument>bool RD</argument>)</argument_list></macro> <block>{ <expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>IsRedeclaration</name></name> <operator>=</operator> <name>RD</name></expr>; }</block>
<name>void</name> <call><name>setAsRedeclaration</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCMethodDecl</name> <operator>*</operator><name>PrevMethod</name></expr></argument>)</argument_list></call></expr>;


<expr><name>bool</name> <macro><name>hasRedeclaration</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>HasRedeclaration</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setHasRedeclaration</name><argument_list>(<argument>bool HRD</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>HasRedeclaration</name></name> <operator>=</operator> <name>HRD</name></expr>;
}</block>




<name>SourceLocation</name> <macro><name>getDeclaratorEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DeclEndLoc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;
<expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getSelectorStartLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isImplicit</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getSelectorLoc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>getSelectorLoc</name><argument_list>(<argument><expr><name>unsigned</name> <name>Index</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>Index</name> <operator>&lt;</operator> <call><name>getNumSelectorLocs</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Index out of range!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>hasStandardSelLocs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getStandardSelectorLoc</name><argument_list>(<argument><expr><name>Index</name></expr></argument>, <argument><expr><call><name>getSelector</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getSelLocsKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>SelLoc_StandardWithSpace</name></expr></argument>,
<argument><expr><call><name>parameters</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>DeclEndLoc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getStoredSelLocs</name><argument_list>()</argument_list></call><index>[<expr><name>Index</name></expr>]</index></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>getSelectorLocs</name><argument_list>(<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>SelLocs</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>getNumSelectorLocs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isImplicit</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<name>Selector</name> <name>Sel</name> <operator>=</operator> <call><name>getSelector</name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Sel</name><operator>.</operator><name>isUnarySelector</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>Sel</name><operator>.</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function_decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>getClassInterface</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getClassInterface</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getClassInterface</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<function_decl><type><name>ObjCCategoryDecl</name> <modifier>*</modifier></type><name>getCategory</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>ObjCCategoryDecl</name> <operator>*</operator><macro><name>getCategory</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getCategory</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>Selector</name> <macro><name>getSelector</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getDeclName</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getObjCSelector</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>QualType</name> <macro><name>getReturnType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MethodDeclType</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setReturnType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>MethodDeclType</name> <operator>=</operator> <name>T</name></expr>;</expr_stmt> </block_content>}</block></function>
<expr_stmt><expr><name>SourceRange</name> <macro><name>getReturnTypeSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>





<expr_stmt><expr><name>QualType</name> <macro><name>getSendResultType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getSendResultType</name><argument_list>(<argument><expr><name>QualType</name> <name>receiverType</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>TypeSourceInfo</name> <operator>*</operator><macro><name>getReturnTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ReturnTInfo</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setReturnTypeSourceInfo</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>ReturnTInfo</name> <operator>=</operator> <name>TInfo</name></expr>;</expr_stmt> </block_content>}</block></function>


<expr_stmt><expr><name>unsigned</name> <macro><name>param_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumParams</name></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>param_const_iterator</name> <init>= <expr><specifier>const</specifier> <name>ParmVarDecl</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>param_iterator</name> <init>= <expr><name>ParmVarDecl</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>param_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>param_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>param_const_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>param_const_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>param_const_iterator</name> <macro><name>param_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>param_const_iterator</name><argument_list>(<argument><expr><call><name>getParams</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>param_const_iterator</name> <macro><name>param_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>param_const_iterator</name><argument_list>(<argument><expr><call><name>getParams</name><argument_list>()</argument_list></call> <operator>+</operator> <name>NumParams</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>param_iterator</name></type> <name>param_begin</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>param_iterator</name><argument_list>(<argument><expr><call><name>getParams</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>param_iterator</name></type> <name>param_end</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>param_iterator</name><argument_list>(<argument><expr><call><name>getParams</name><argument_list>()</argument_list></call> <operator>+</operator> <name>NumParams</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>



<expr_stmt><expr><name>param_const_iterator</name> <macro><name>sel_param_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>param_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getSelector</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getNumArgs</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>parameters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name><operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getParams</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NumParams</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>getParamDecl</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>Idx</name> <operator>&lt;</operator> <name>NumParams</name> <operator>&amp;&amp;</operator> <literal type="string">"Index out of bounds!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>getParams</name><argument_list>()</argument_list></call><index>[<expr><name>Idx</name></expr>]</index></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>const</specifier> <name>ParmVarDecl</name> <modifier>*</modifier></type><name>getParamDecl</name><argument_list>(<argument><expr><name>unsigned</name> <name>Idx</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getParamDecl</name><argument_list>(<argument><expr><name>Idx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<function_decl><type><name>void</name></type> <name>setMethodParams</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Params</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>SelLocs</name> <init>= <expr><name>llvm</name><operator>::</operator><name>None</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<struct>struct <name>GetTypeFn</name> <block>{
<expr_stmt><expr><name>QualType</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>ParmVarDecl</name> <operator>*</operator><name>PD</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>PD</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name>using</name></type> <name>param_type_iterator</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>mapped_iterator</name><argument_list type="generic">&lt;<argument><expr><name>param_const_iterator</name></expr></argument>, <argument><expr><name>GetTypeFn</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>param_type_iterator</name> <macro><name>param_type_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>map_iterator</name><argument_list>(<argument><expr><call><name>param_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>GetTypeFn</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>param_type_iterator</name> <macro><name>param_type_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>map_iterator</name><argument_list>(<argument><expr><call><name>param_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>GetTypeFn</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>





<function_decl><type><name>void</name></type> <name>createImplicitParams</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>ID</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>QualType</name></type> <name>getSelfType</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><name>OID</name></expr></argument>,
<argument><expr><name>bool</name> <operator>&amp;</operator><name>selfIsPseudoStrong</name></expr></argument>, <argument><expr><name>bool</name> <operator>&amp;</operator><name>selfIsConsumed</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>ImplicitParamDecl</name> <operator>*</operator> <macro><name>getSelfDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SelfDecl</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setSelfDecl</name><parameter_list>(<parameter><decl><type><name>ImplicitParamDecl</name> <modifier>*</modifier></type><name>SD</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>SelfDecl</name> <operator>=</operator> <name>SD</name></expr>;</expr_stmt> </block_content>}</block></function>
<expr_stmt><expr><name>ImplicitParamDecl</name> <operator>*</operator> <macro><name>getCmdDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CmdDecl</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setCmdDecl</name><parameter_list>(<parameter><decl><type><name>ImplicitParamDecl</name> <modifier>*</modifier></type><name>CD</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>CmdDecl</name> <operator>=</operator> <name>CD</name></expr>;</expr_stmt> </block_content>}</block></function>


<expr_stmt><expr><name>ObjCMethodFamily</name> <macro><name>getMethodFamily</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isInstanceMethod</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>IsInstance</name></name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setInstanceMethod</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isInst</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>IsInstance</name></name> <operator>=</operator> <name>isInst</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>isVariadic</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>IsVariadic</name></name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setVariadic</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isVar</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>IsVariadic</name></name> <operator>=</operator> <name>isVar</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>isClassMethod</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>isInstanceMethod</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isPropertyAccessor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>IsPropertyAccessor</name></name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setPropertyAccessor</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isAccessor</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>IsPropertyAccessor</name></name> <operator>=</operator> <name>isAccessor</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>isSynthesizedAccessorStub</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>IsSynthesizedAccessorStub</name></name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setSynthesizedAccessorStub</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isSynthesizedAccessorStub</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>IsSynthesizedAccessorStub</name></name> <operator>=</operator> <name>isSynthesizedAccessorStub</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>isDefined</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>IsDefined</name></name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setDefined</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isDefined</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>IsDefined</name></name> <operator>=</operator> <name>isDefined</name></expr>;</expr_stmt> </block_content>}</block></function>








<expr_stmt><expr><name>bool</name> <macro><name>isOverriding</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>IsOverriding</name></name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setOverriding</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IsOver</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>IsOverriding</name></name> <operator>=</operator> <name>IsOver</name></expr>;</expr_stmt> </block_content>}</block></function>









<decl_stmt><decl><type><name>void</name></type> <name>getOverriddenMethods</name><argument_list>(
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ObjCMethodDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Overridden</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasSkippedBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>HasSkippedBody</name></name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setHasSkippedBody</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Skipped</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>HasSkippedBody</name></name> <operator>=</operator> <name>Skipped</name></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>isDirectMethod</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>






<decl_stmt><decl><type><specifier>const</specifier> <name>ObjCPropertyDecl</name> <modifier>*</modifier></type><name>findPropertyDecl</name><argument_list>(<argument><expr><name>bool</name> <name>CheckOverrides</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<function><type><name>void</name></type> <name>setDeclImplementation</name><parameter_list>(<parameter><decl><type><name>ImplementationControl</name></type> <name>ic</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>DeclImplementation</name></name> <operator>=</operator> <name>ic</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>ImplementationControl</name> <macro><name>getImplementationControl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>ImplementationControl</name><argument_list>(<argument><expr><name><name>ObjCMethodDeclBits</name><operator>.</operator><name>DeclImplementation</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isOptional</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getImplementationControl</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Optional</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isThisDeclarationADesignatedInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>







<decl_stmt><decl><type><name>bool</name></type> <name>isDesignatedInitializerForTheInterface</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>ObjCMethodDecl</name> <operator>*</operator><operator>*</operator><name>InitMethod</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><call><name><name>Body</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>Stmt</name> <operator>*</operator><macro><name>getBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;</expr_stmt>

<function><type><name>void</name></type> <name>setLazyBody</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>Offset</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Body</name> <operator>=</operator> <name>Offset</name></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>CompoundStmt</name> <modifier>*</modifier></type><name>getCompoundBody</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>CompoundStmt</name><operator>*</operator><operator>)</operator><call><name>getBody</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setBody</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Body</name> <operator>=</operator> <name>B</name></expr>;</expr_stmt> </block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>isThisDeclarationADefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>hasBody</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>definedInNSObject</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>K</name> <operator>==</operator> <name>ObjCMethod</name></expr>;</return> </block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>castToDeclContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>castFromDeclContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
};


<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>ObjCTypeParamVariance</name> <range>: <expr><name>uint8_t</name> <block>{

<expr><name>Invariant</name></expr>,



<expr><name>Covariant</name></expr>,



<expr><name>Contravariant</name></expr>,
}</block></expr></range></decl>;</decl_stmt>













<decl_stmt><decl><type><name>class</name></type> <name>ObjCTypeParamDecl</name> <range>: <expr><name>public</name> <name>TypedefNameDecl</name> <block>{

<expr><name>unsigned</name> <name>Index</name> <operator>:</operator> <literal type="number">14</literal></expr>;


<expr><name>unsigned</name> <name>Variance</name> <operator>:</operator> <literal type="number">2</literal></expr>;


<expr><name>SourceLocation</name> <name>VarianceLoc</name></expr>;



<expr><name>SourceLocation</name> <name>ColonLoc</name></expr>;

<macro><name>ObjCTypeParamDecl</name><argument_list>(<argument>ASTContext &amp;ctx</argument>, <argument>DeclContext *dc</argument>,
<argument>ObjCTypeParamVariance variance</argument>, <argument>SourceLocation varianceLoc</argument>,
<argument>unsigned index</argument>,
<argument>SourceLocation nameLoc</argument>, <argument>IdentifierInfo *name</argument>,
<argument>SourceLocation colonLoc</argument>, <argument>TypeSourceInfo *boundInfo</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>TypedefNameDecl</name><argument_list>(<argument><expr><name>ObjCTypeParam</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>dc</name></expr></argument>, <argument><expr><name>nameLoc</name></expr></argument>, <argument><expr><name>nameLoc</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><name>boundInfo</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Index</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Variance</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>variance</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>VarianceLoc</name><argument_list>(<argument><expr><name>varianceLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>ColonLoc</name><argument_list>(<argument>colonLoc</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;

<expr><specifier>static</specifier> <name>ObjCTypeParamDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;ctx</argument>, <argument>DeclContext *dc</argument>,
<argument>ObjCTypeParamVariance variance</argument>,
<argument>SourceLocation varianceLoc</argument>,
<argument>unsigned index</argument>,
<argument>SourceLocation nameLoc</argument>,
<argument>IdentifierInfo *name</argument>,
<argument>SourceLocation colonLoc</argument>,
<argument>TypeSourceInfo *boundInfo</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>ObjCTypeParamDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;ctx</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;


<expr><name>ObjCTypeParamVariance</name> <macro><name>getVariance</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCTypeParamVariance</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Variance</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>void</name> <macro><name>setVariance</name><argument_list>(<argument>ObjCTypeParamVariance variance</argument>)</argument_list></macro> <block>{
<expr><name>Variance</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>variance</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>SourceLocation</name> <macro><name>getVarianceLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>VarianceLoc</name></expr>;</return> }</block>


<name>unsigned</name> <macro><name>getIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Index</name></expr>;</return> }</block>



<name>bool</name> <macro><name>hasExplicitBound</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>ColonLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>SourceLocation</name> <macro><name>getColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColonLoc</name></expr>;</return> }</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>ObjCTypeParam</name></expr>;</return> }</block>
}</expr>;








<expr><name>class</name> <name>ObjCTypeParamList</name> <name>final</name>
<operator>:</operator> <name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ObjCTypeParamList</name></expr></argument>, <argument><expr><name>ObjCTypeParamDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{

<expr><name>SourceRange</name> <name>Brackets</name></expr>;

<expr><name>unsigned</name> <name>NumParams</name></expr>;

<macro><name>ObjCTypeParamList</name><argument_list>(<argument>SourceLocation lAngleLoc</argument>,
<argument>ArrayRef&lt;ObjCTypeParamDecl *&gt; typeParams</argument>,
<argument>SourceLocation rAngleLoc</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>TrailingObjects</name></expr>;


<expr><specifier>static</specifier> <name>ObjCTypeParamList</name> <operator>*</operator><macro><name>create</name><argument_list>(<argument>ASTContext &amp;ctx</argument>,
<argument>SourceLocation lAngleLoc</argument>,
<argument>ArrayRef&lt;ObjCTypeParamDecl *&gt; typeParams</argument>,
<argument>SourceLocation rAngleLoc</argument>)</argument_list></macro></expr>;


<expr><name>using</name> <name>iterator</name> <operator>=</operator> <name>ObjCTypeParamDecl</name> <operator>*</operator><operator>*</operator></expr>;

<expr><name>iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ObjCTypeParamDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>size</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>unsigned</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumParams</name></expr>;</return> }</block>


<name>using</name> <name>const_iterator</name> <operator>=</operator> <name>ObjCTypeParamDecl</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator></expr>;

<expr><name>const_iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ObjCTypeParamDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>const_iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>size</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ObjCTypeParamDecl</name> <operator>*</operator><macro><name>front</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>size</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="string">"empty Objective-C type parameter list"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ObjCTypeParamDecl</name> <operator>*</operator><macro><name>back</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>size</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="string">"empty Objective-C type parameter list"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><operator>(</operator><call><name>end</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getLAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Brackets</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getRAngleLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Brackets</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Brackets</name></expr>;</return> }</block>



<name>void</name> <macro><name>gatherDefaultTypeArgs</name><argument_list>(<argument>SmallVectorImpl&lt;QualType&gt; &amp;typeArgs</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr>;

enum <expr><name>class</name> <name>ObjCPropertyQueryKind</name> <operator>:</operator> <name>uint8_t</name> <block>{
<expr><name>OBJC_PR_query_unknown</name> <operator>=</operator> <literal type="number">0x00</literal></expr>,
<expr><name>OBJC_PR_query_instance</name></expr>,
<expr><name>OBJC_PR_query_class</name></expr>
}</block></expr>;







<expr><name>class</name> <name>ObjCPropertyDecl</name> <operator>:</operator> <name>public</name> <name>NamedDecl</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
enum <name>SetterKind</name> <block>{ <expr><name>Assign</name></expr>, <expr><name>Retain</name></expr>, <expr><name>Copy</name></expr>, <expr><name>Weak</name></expr> }</block></expr>;
enum <expr><name>PropertyControl</name> <block>{ <expr><name>None</name></expr>, <expr><name>Required</name></expr>, <expr><name>Optional</name></expr> }</block></expr>;

<expr><name>private</name><operator>:</operator>

<name>SourceLocation</name> <name>AtLoc</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;

<expr><name>QualType</name> <name>DeclType</name></expr>;
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>DeclTypeSourceInfo</name></expr>;
<expr><name>unsigned</name> <name>PropertyAttributes</name> <operator>:</operator> <name>NumObjCPropertyAttrsBits</name></expr>;
<expr><name>unsigned</name> <name>PropertyAttributesAsWritten</name> <operator>:</operator> <name>NumObjCPropertyAttrsBits</name></expr>;


<expr><name>unsigned</name> <name>PropertyImplementation</name> <operator>:</operator> <literal type="number">2</literal></expr>;


<expr><name>Selector</name> <name>GetterName</name></expr>;


<expr><name>Selector</name> <name>SetterName</name></expr>;


<expr><name>SourceLocation</name> <name>GetterNameLoc</name></expr>;


<expr><name>SourceLocation</name> <name>SetterNameLoc</name></expr>;


<expr><name>ObjCMethodDecl</name> <operator>*</operator><name>GetterMethodDecl</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>ObjCMethodDecl</name> <operator>*</operator><name>SetterMethodDecl</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>ObjCIvarDecl</name> <operator>*</operator><name>PropertyIvarDecl</name> <operator>=</operator> <name>nullptr</name></expr>;

<macro><name>ObjCPropertyDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>, <argument>IdentifierInfo *Id</argument>,
<argument>SourceLocation AtLocation</argument>, <argument>SourceLocation LParenLocation</argument>,
<argument>QualType T</argument>, <argument>TypeSourceInfo *TSI</argument>, <argument>PropertyControl propControl</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>NamedDecl</name><argument_list>(<argument><expr><name>ObjCProperty</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>L</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>AtLoc</name><argument_list>(<argument><expr><name>AtLocation</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLocation</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>DeclType</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>DeclTypeSourceInfo</name><argument_list>(<argument><expr><name>TSI</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>PropertyAttributes</name><argument_list>(<argument><expr><name>ObjCPropertyAttribute</name><operator>::</operator><name>kind_noattr</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>PropertyAttributesAsWritten</name><argument_list>(<argument><expr><name>ObjCPropertyAttribute</name><operator>::</operator><name>kind_noattr</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>PropertyImplementation</name><argument_list>(<argument><expr><name>propControl</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>GetterName</name><argument_list>(<argument><expr><call><name>Selector</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>SetterName</name><argument_list>(<argument>Selector()</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>ObjCPropertyDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation L</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>SourceLocation AtLocation</argument>,
<argument>SourceLocation LParenLocation</argument>,
<argument>QualType T</argument>,
<argument>TypeSourceInfo *TSI</argument>,
<argument>PropertyControl propControl = None</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>ObjCPropertyDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>SourceLocation</name> <macro><name>getAtLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AtLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setAtLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>AtLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DeclTypeSourceInfo</name></expr>;</return> }</block>

<name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DeclType</name></expr>;</return> }</block>

<name>void</name> <macro><name>setType</name><argument_list>(<argument>QualType T</argument>, <argument>TypeSourceInfo *TSI</argument>)</argument_list></macro> <block>{
<expr><name>DeclType</name> <operator>=</operator> <name>T</name></expr>;
<expr><name>DeclTypeSourceInfo</name> <operator>=</operator> <name>TSI</name></expr>;
}</block>



<name>QualType</name> <macro><name>getUsageType</name><argument_list>(<argument>QualType objectType</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>ObjCPropertyAttribute</name><operator>::</operator><name>Kind</name> <macro><name>getPropertyAttributes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ObjCPropertyAttribute</name><operator>::</operator><call><name>Kind</name><argument_list>(<argument><expr><name>PropertyAttributes</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setPropertyAttributes</name><argument_list>(<argument>ObjCPropertyAttribute::Kind PRVal</argument>)</argument_list></macro> <block>{
<expr><name>PropertyAttributes</name> <operator>|=</operator> <name>PRVal</name></expr>;
}</block>

<name>void</name> <macro><name>overwritePropertyAttributes</name><argument_list>(<argument>unsigned PRVal</argument>)</argument_list></macro> <block>{
<expr><name>PropertyAttributes</name> <operator>=</operator> <name>PRVal</name></expr>;
}</block>

<name>ObjCPropertyAttribute</name><operator>::</operator><name>Kind</name> <macro><name>getPropertyAttributesAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ObjCPropertyAttribute</name><operator>::</operator><call><name>Kind</name><argument_list>(<argument><expr><name>PropertyAttributesAsWritten</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setPropertyAttributesAsWritten</name><argument_list>(<argument>ObjCPropertyAttribute::Kind PRVal</argument>)</argument_list></macro> <block>{
<expr><name>PropertyAttributesAsWritten</name> <operator>=</operator> <name>PRVal</name></expr>;
}</block>




<name>bool</name> <macro><name>isReadOnly</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>PropertyAttributes</name> <operator>&amp;</operator> <name>ObjCPropertyAttribute</name><operator>::</operator><name>kind_readonly</name><operator>)</operator></expr>;</return>
}</block>


<name>bool</name> <macro><name>isAtomic</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>PropertyAttributes</name> <operator>&amp;</operator> <name>ObjCPropertyAttribute</name><operator>::</operator><name>kind_atomic</name><operator>)</operator></expr>;</return>
}</block>


<name>bool</name> <macro><name>isRetaining</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>PropertyAttributes</name> <operator>&amp;</operator> <operator>(</operator><name>ObjCPropertyAttribute</name><operator>::</operator><name>kind_retain</name> <operator>|</operator>
<name>ObjCPropertyAttribute</name><operator>::</operator><name>kind_strong</name> <operator>|</operator>
<name>ObjCPropertyAttribute</name><operator>::</operator><name>kind_copy</name><operator>)</operator><operator>)</operator></expr>;</return>
}</block>

<name>bool</name> <macro><name>isInstanceProperty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>isClassProperty</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>isClassProperty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PropertyAttributes</name> <operator>&amp;</operator> <name>ObjCPropertyAttribute</name><operator>::</operator><name>kind_class</name></expr>;</return>
}</block>
<name>bool</name> <macro><name>isDirectProperty</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>ObjCPropertyQueryKind</name> <macro><name>getQueryKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isClassProperty</name><argument_list>()</argument_list></call> <operator>?</operator> <name>ObjCPropertyQueryKind</name><operator>::</operator><name>OBJC_PR_query_class</name> <operator>:</operator>
<name>ObjCPropertyQueryKind</name><operator>::</operator><name>OBJC_PR_query_instance</name></expr>;</return>
}</block>

<specifier>static</specifier> <name>ObjCPropertyQueryKind</name> <macro><name>getQueryKind</name><argument_list>(<argument>bool isClassProperty</argument>)</argument_list></macro> <block>{
<return>return <expr><ternary><condition><expr><name>isClassProperty</name></expr> ?</condition><then> <expr><name>ObjCPropertyQueryKind</name><operator>::</operator><name>OBJC_PR_query_class</name></expr> </then><else>:
<expr><name>ObjCPropertyQueryKind</name><operator>::</operator><name>OBJC_PR_query_instance</name></expr></else></ternary></expr>;</return>
}</block>




<name>SetterKind</name> <macro><name>getSetterKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>PropertyAttributes</name> <operator>&amp;</operator> <name>ObjCPropertyAttribute</name><operator>::</operator><name>kind_strong</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isBlockPointerType</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>Copy</name></expr> </then><else>: <expr><name>Retain</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<expr><name>PropertyAttributes</name> <operator>&amp;</operator> <name>ObjCPropertyAttribute</name><operator>::</operator><name>kind_retain</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Retain</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<expr><name>PropertyAttributes</name> <operator>&amp;</operator> <name>ObjCPropertyAttribute</name><operator>::</operator><name>kind_copy</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Copy</name></expr>;</return></block_content></block></if></if_stmt></block></expr></range></decl></decl_stmt>
<if_stmt><if>if <condition>(<expr><name>PropertyAttributes</name> <operator>&amp;</operator> <name>ObjCPropertyAttribute</name><operator>::</operator><name>kind_weak</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Weak</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>Assign</name></expr>;</return>
}

Selector <macro><name>getGetterName</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{ <return>return <expr><name>GetterName</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getGetterNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>GetterNameLoc</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setGetterName</name><parameter_list>(<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>GetterName</name> <operator>=</operator> <name>Sel</name></expr>;</expr_stmt>
<expr_stmt><expr><name>GetterNameLoc</name> <operator>=</operator> <name>Loc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>Selector</name> <macro><name>getSetterName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SetterName</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getSetterNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SetterNameLoc</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setSetterName</name><parameter_list>(<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SetterName</name> <operator>=</operator> <name>Sel</name></expr>;</expr_stmt>
<expr_stmt><expr><name>SetterNameLoc</name> <operator>=</operator> <name>Loc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>ObjCMethodDecl</name> <operator>*</operator><macro><name>getGetterMethodDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>GetterMethodDecl</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setGetterMethodDecl</name><parameter_list>(<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>gDecl</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>GetterMethodDecl</name> <operator>=</operator> <name>gDecl</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>ObjCMethodDecl</name> <operator>*</operator><macro><name>getSetterMethodDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SetterMethodDecl</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setSetterMethodDecl</name><parameter_list>(<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>gDecl</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>SetterMethodDecl</name> <operator>=</operator> <name>gDecl</name></expr>;</expr_stmt> </block_content>}</block></function>


<function><type><name>void</name></type> <name>setPropertyImplementation</name><parameter_list>(<parameter><decl><type><name>PropertyControl</name></type> <name>pc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>PropertyImplementation</name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>PropertyControl</name> <macro><name>getPropertyImplementation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>PropertyControl</name><argument_list>(<argument><expr><name>PropertyImplementation</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isOptional</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getPropertyImplementation</name><argument_list>()</argument_list></call> <operator>==</operator> <name>PropertyControl</name><operator>::</operator><name>Optional</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setPropertyIvarDecl</name><parameter_list>(<parameter><decl><type><name>ObjCIvarDecl</name> <modifier>*</modifier></type><name>Ivar</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>PropertyIvarDecl</name> <operator>=</operator> <name>Ivar</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>ObjCIvarDecl</name> <operator>*</operator><macro><name>getPropertyIvarDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PropertyIvarDecl</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>AtLoc</name></expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>getDefaultSynthIvarName</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>ObjCPropertyDecl</name> <modifier>*</modifier></type><name>findPropertyDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>propertyID</name></decl></parameter>,
<parameter><decl><type><name>ObjCPropertyQueryKind</name></type> <name>queryKind</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>K</name> <operator>==</operator> <name>ObjCProperty</name></expr>;</return> </block_content>}</block></function>
};





<decl_stmt><decl><type><name>class</name></type> <name>ObjCContainerDecl</name> <range>: <expr><name>public</name> <name>NamedDecl</name></expr></range></decl>, <decl><type ref="prev"/><name>public</name> <name>DeclContext</name> <block>{<block_content>





<decl_stmt><decl><type><name>SourceRange</name></type> <name>AtEnd</name></decl>;</decl_stmt>

<expr_stmt><expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>

<label><name>public</name>:</label>
<macro><name>ObjCContainerDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>DeclContext *DC</argument>, <argument>IdentifierInfo *Id</argument>,
<argument>SourceLocation nameLoc</argument>, <argument>SourceLocation atStartLoc</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>prop_iterator</name> <init>= <expr><name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>ObjCPropertyDecl</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>prop_range</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>ObjCPropertyDecl</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>prop_range</name> <macro><name>properties</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>prop_range</name><argument_list>(<argument><expr><call><name>prop_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>prop_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>prop_iterator</name> <macro><name>prop_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>prop_iterator</name><argument_list>(<argument><expr><call><name>decls_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>prop_iterator</name> <macro><name>prop_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>prop_iterator</name><argument_list>(<argument><expr><call><name>decls_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>instprop_iterator</name> <init>=
<expr><name><name>filtered_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>ObjCPropertyDecl</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>ObjCPropertyDecl</name><operator>::</operator><name>isInstanceProperty</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>instprop_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>instprop_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>instprop_range</name> <macro><name>instance_properties</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>instprop_range</name><argument_list>(<argument><expr><call><name>instprop_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>instprop_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>instprop_iterator</name> <macro><name>instprop_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>instprop_iterator</name><argument_list>(<argument><expr><call><name>decls_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>instprop_iterator</name> <macro><name>instprop_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>instprop_iterator</name><argument_list>(<argument><expr><call><name>decls_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>classprop_iterator</name> <init>=
<expr><name><name>filtered_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>ObjCPropertyDecl</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>ObjCPropertyDecl</name><operator>::</operator><name>isClassProperty</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>classprop_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>classprop_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>classprop_range</name> <macro><name>class_properties</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>classprop_range</name><argument_list>(<argument><expr><call><name>classprop_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>classprop_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>classprop_iterator</name> <macro><name>classprop_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>classprop_iterator</name><argument_list>(<argument><expr><call><name>decls_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>classprop_iterator</name> <macro><name>classprop_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>classprop_iterator</name><argument_list>(<argument><expr><call><name>decls_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>method_iterator</name> <init>= <expr><name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>method_range</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>method_range</name> <macro><name>methods</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>method_range</name><argument_list>(<argument><expr><call><name>meth_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>meth_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>method_iterator</name> <macro><name>meth_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>method_iterator</name><argument_list>(<argument><expr><call><name>decls_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>method_iterator</name> <macro><name>meth_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>method_iterator</name><argument_list>(<argument><expr><call><name>decls_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>instmeth_iterator</name> <init>=
<expr><name><name>filtered_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>ObjCMethodDecl</name><operator>::</operator><name>isInstanceMethod</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>instmeth_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>instmeth_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>instmeth_range</name> <macro><name>instance_methods</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>instmeth_range</name><argument_list>(<argument><expr><call><name>instmeth_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>instmeth_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>instmeth_iterator</name> <macro><name>instmeth_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>instmeth_iterator</name><argument_list>(<argument><expr><call><name>decls_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>instmeth_iterator</name> <macro><name>instmeth_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>instmeth_iterator</name><argument_list>(<argument><expr><call><name>decls_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>classmeth_iterator</name> <init>=
<expr><name><name>filtered_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>ObjCMethodDecl</name><operator>::</operator><name>isClassMethod</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>classmeth_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>classmeth_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>classmeth_range</name> <macro><name>class_methods</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>classmeth_range</name><argument_list>(<argument><expr><call><name>classmeth_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>classmeth_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>classmeth_iterator</name> <macro><name>classmeth_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>classmeth_iterator</name><argument_list>(<argument><expr><call><name>decls_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>classmeth_iterator</name> <macro><name>classmeth_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>classmeth_iterator</name><argument_list>(<argument><expr><call><name>decls_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>getMethod</name><argument_list>(<argument><expr><name>Selector</name> <name>Sel</name></expr></argument>, <argument><expr><name>bool</name> <name>isInstance</name></expr></argument>,
<argument><expr><name>bool</name> <name>AllowHidden</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>getInstanceMethod</name><argument_list>(<argument><expr><name>Selector</name> <name>Sel</name></expr></argument>,
<argument><expr><name>bool</name> <name>AllowHidden</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getMethod</name><argument_list>(<argument><expr><name>Sel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>AllowHidden</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>getClassMethod</name><argument_list>(<argument><expr><name>Selector</name> <name>Sel</name></expr></argument>, <argument><expr><name>bool</name> <name>AllowHidden</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getMethod</name><argument_list>(<argument><expr><name>Sel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>AllowHidden</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>HasUserDeclaredSetterMethod</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCPropertyDecl</name> <operator>*</operator><name>P</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>ObjCIvarDecl</name> <modifier>*</modifier></type><name>getIvarDecl</name><argument_list>(<argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>Id</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>ObjCPropertyDecl</name> <modifier>*</modifier></type>
<name>FindPropertyDeclaration</name><argument_list>(<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>PropertyId</name></expr></argument>,
<argument><expr><name>ObjCPropertyQueryKind</name> <name>QueryKind</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>PropertyMap</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>ObjCPropertyDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>ProtocolPropertySet</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>SmallDenseSet</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ObjCProtocolDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>PropertyDeclOrder</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ObjCPropertyDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>collectPropertiesToImplement</name><argument_list>(<argument><expr><name>PropertyMap</name> <operator>&amp;</operator><name>PM</name></expr></argument>,
<argument><expr><name>PropertyDeclOrder</name> <operator>&amp;</operator><name>PO</name></expr></argument>)</argument_list> const <block>{<block_content/>}</block></decl></decl_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getAtStartLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ObjCContainerDeclBits</name><operator>.</operator><name>AtStart</name></name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setAtStartLoc</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>ObjCContainerDeclBits</name><operator>.</operator><name>AtStart</name></name> <operator>=</operator> <name>Loc</name></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>SourceRange</name> <macro><name>getAtEndRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AtEnd</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setAtEndRange</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>atEnd</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>AtEnd</name> <operator>=</operator> <name>atEnd</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getAtStartLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getAtEndRange</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getEnd</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>K</name> <operator>&gt;=</operator> <name>firstObjCContainer</name> <operator>&amp;&amp;</operator>
<name>K</name> <operator>&lt;=</operator> <name>lastObjCContainer</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>castToDeclContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCContainerDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCContainerDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ObjCContainerDecl</name> <modifier>*</modifier></type><name>castFromDeclContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCContainerDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


























<decl_stmt><decl><type><name>class</name></type> <name>ObjCInterfaceDecl</name> <range>: <expr><name>public</name> <name>ObjCContainerDecl</name></expr></range></decl>
, <decl><type ref="prev"/><name>public</name> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>ObjCInterfaceDecl</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>mutable</name> <specifier>const</specifier> <name>Type</name> <modifier>*</modifier></type><name>TypeForDecl</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<struct>struct <name>DefinitionData</name> <block>{


<decl_stmt><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>Definition</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>SuperClassTInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ObjCProtocolList</name></type> <name>ReferencedProtocols</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>ObjCList</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name></expr></argument>&gt;</argument_list></name></type> <name>AllReferencedProtocols</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>ObjCCategoryDecl</name> <modifier>*</modifier></type><name>CategoryList</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>ObjCIvarDecl</name> <modifier>*</modifier></type><name>IvarList</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>mutable</name> <name>unsigned</name></type> <name>ExternallyCompleted</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>mutable</name> <name>unsigned</name></type> <name>IvarListMissingImplementation</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>HasDesignatedInitializers</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<enum>enum <name>InheritedDesignatedInitializersState</name> <block>{


<decl><name>IDI_Unknown</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,


<decl><name>IDI_Inherited</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,


<decl><name>IDI_NotInherited</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>mutable</name> <name>unsigned</name></type> <name>InheritedDesignatedInitializers</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DefinitionData</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>ExternallyCompleted</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IvarListMissingImplementation</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>HasDesignatedInitializers</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>InheritedDesignatedInitializers</name><argument_list>(<argument>IDI_Unknown</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>


<decl_stmt><decl><type><name>ObjCTypeParamList</name> <modifier>*</modifier></type><name>TypeParamList</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>






<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>DefinitionData</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>Data</name></expr>;</expr_stmt>

<macro><name>ObjCInterfaceDecl</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation AtLoc</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>ObjCTypeParamList *typeParamList</argument>,
<argument>SourceLocation CLoc</argument>, <argument>ObjCInterfaceDecl *PrevDecl</argument>,
<argument>bool IsInternal</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>

<expr_stmt><expr><name>void</name> <macro><name>LoadExternalDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>DefinitionData</name> <operator>&amp;</operator><macro><name>data</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Data</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Declaration has no definition!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><call><name><name>Data</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function_decl><type><name>void</name></type> <name>allocateDefinitionData</name><parameter_list>()</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>using</name></type> <name>redeclarable_base</name> <init>= <expr><name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>ObjCInterfaceDecl</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<function><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>getNextRedeclarationImpl</name><parameter_list>()</parameter_list> override <block>{<block_content>
<return>return <expr><call><name>getNextRedeclaration</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>getPreviousDeclImpl</name><parameter_list>()</parameter_list> override <block>{<block_content>
<return>return <expr><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>getMostRecentDeclImpl</name><parameter_list>()</parameter_list> override <block>{<block_content>
<return>return <expr><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<label><name>public</name>:</label>
<function_decl><type><specifier>static</specifier> <name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>Create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>atLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Id</name></decl></parameter>,
<parameter><decl><type><name>ObjCTypeParamList</name> <modifier>*</modifier></type><name>typeParamList</name></decl></parameter>,
<parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>PrevDecl</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ClassLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isInternal</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>CreateDeserialized</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>)</parameter_list>;</function_decl>







<expr_stmt><expr><name>ObjCTypeParamList</name> <operator>*</operator><macro><name>getTypeParamList</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>





<function_decl><type><name>void</name></type> <name>setTypeParamList</name><parameter_list>(<parameter><decl><type><name>ObjCTypeParamList</name> <modifier>*</modifier></type><name>TPL</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>ObjCTypeParamList</name> <operator>*</operator><macro><name>getTypeParamListAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TypeParamList</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isThisDeclarationADefinition</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ObjCContainerDecl</name><operator>::</operator><call><name>getSourceRange</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getAtStartLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<function_decl><type><name>void</name></type> <name>setExternallyCompleted</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>setHasDesignatedInitializers</name><parameter_list>()</parameter_list>;</function_decl>



<expr_stmt><expr><name>bool</name> <macro><name>hasDesignatedInitializers</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>declaresOrInheritsDesignatedInitializers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasDesignatedInitializers</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>inheritsDesignatedInitializers</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>ObjCProtocolList</name> <operator>&amp;</operator><macro><name>getReferencedProtocols</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasDefinition</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Caller did not check for forward reference!"</literal></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>ExternallyCompleted</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LoadExternalDefinition</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>ReferencedProtocols</name></expr>;</return>
}

ObjCImplementationDecl <expr_stmt><expr><operator>*</operator><macro><name>getImplementation</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<function_decl><type><name>void</name></type> <name>setImplementation</name><parameter_list>(<parameter><decl><type><name>ObjCImplementationDecl</name> <modifier>*</modifier></type><name>ImplD</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>ObjCCategoryDecl</name> <modifier>*</modifier></type><name>FindCategoryDeclaration</name><argument_list>(<argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>CategoryId</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>getCategoryInstanceMethod</name><argument_list>(<argument><expr><name>Selector</name> <name>Sel</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>getCategoryClassMethod</name><argument_list>(<argument><expr><name>Selector</name> <name>Sel</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>getCategoryMethod</name><argument_list>(<argument><expr><name>Selector</name> <name>Sel</name></expr></argument>, <argument><expr><name>bool</name> <name>isInstance</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><ternary><condition><expr><name>isInstance</name></expr> ?</condition><then> <expr><call><name>getCategoryInstanceMethod</name><argument_list>(<argument><expr><name>Sel</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name>getCategoryClassMethod</name><argument_list>(<argument><expr><name>Sel</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>protocol_iterator</name> <init>= <expr><name>ObjCProtocolList</name><operator>::</operator><name>iterator</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>protocol_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>protocol_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>protocol_range</name> <macro><name>protocols</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>protocol_range</name><argument_list>(<argument><expr><call><name>protocol_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>protocol_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>protocol_iterator</name> <macro><name>protocol_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasDefinition</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>protocol_iterator</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>ExternallyCompleted</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LoadExternalDefinition</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>ReferencedProtocols</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return>
}

protocol_iterator <macro><name>protocol_end</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasDefinition</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>protocol_iterator</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>ExternallyCompleted</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LoadExternalDefinition</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>ReferencedProtocols</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return>
}

using <expr_stmt><expr><name>protocol_loc_iterator</name> <operator>=</operator> <name>ObjCProtocolList</name><operator>::</operator><name>loc_iterator</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>protocol_loc_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>protocol_loc_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>protocol_loc_range</name> <macro><name>protocol_locs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>protocol_loc_range</name><argument_list>(<argument><expr><call><name>protocol_loc_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>protocol_loc_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>protocol_loc_iterator</name> <macro><name>protocol_loc_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasDefinition</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>protocol_loc_iterator</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>ExternallyCompleted</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LoadExternalDefinition</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>ReferencedProtocols</name><operator>.</operator><name>loc_begin</name></name><argument_list>()</argument_list></call></expr>;</return>
}

protocol_loc_iterator <macro><name>protocol_loc_end</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasDefinition</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>protocol_loc_iterator</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>ExternallyCompleted</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LoadExternalDefinition</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>ReferencedProtocols</name><operator>.</operator><name>loc_end</name></name><argument_list>()</argument_list></call></expr>;</return>
}

using <expr_stmt><expr><name>all_protocol_iterator</name> <operator>=</operator> <name><name>ObjCList</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>all_protocol_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>all_protocol_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>all_protocol_range</name> <macro><name>all_referenced_protocols</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>all_protocol_range</name><argument_list>(<argument><expr><call><name>all_referenced_protocol_begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>all_referenced_protocol_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>all_protocol_iterator</name> <macro><name>all_referenced_protocol_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasDefinition</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>all_protocol_iterator</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>ExternallyCompleted</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LoadExternalDefinition</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><ternary><condition><expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>AllReferencedProtocols</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>
?</condition><then> <expr><call><name>protocol_begin</name><argument_list>()</argument_list></call></expr>
</then><else>: <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>AllReferencedProtocols</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}

all_protocol_iterator <macro><name>all_referenced_protocol_end</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasDefinition</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>all_protocol_iterator</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>ExternallyCompleted</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LoadExternalDefinition</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><ternary><condition><expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>AllReferencedProtocols</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>
?</condition><then> <expr><call><name>protocol_end</name><argument_list>()</argument_list></call></expr>
</then><else>: <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>AllReferencedProtocols</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}

using <expr_stmt><expr><name>ivar_iterator</name> <operator>=</operator> <name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>ObjCIvarDecl</name></expr></argument>&gt;</argument_list></name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>ivar_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>ObjCIvarDecl</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ivar_range</name> <macro><name>ivars</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>ivar_range</name><argument_list>(<argument><expr><call><name>ivar_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>ivar_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>ivar_iterator</name> <macro><name>ivar_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>Def</name> <init>= <expr><call><name>getDefinition</name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ivar_iterator</name><argument_list>(<argument><expr><call><name><name>Def</name><operator>-&gt;</operator><name>decls_begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>


<return>return <expr><call><name>ivar_iterator</name><argument_list>()</argument_list></call></expr>;</return>
}

ivar_iterator <macro><name>ivar_end</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>Def</name> <init>= <expr><call><name>getDefinition</name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ivar_iterator</name><argument_list>(<argument><expr><call><name><name>Def</name><operator>-&gt;</operator><name>decls_end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>


<return>return <expr><call><name>ivar_iterator</name><argument_list>()</argument_list></call></expr>;</return>
}

unsigned <macro><name>ivar_size</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<return>return <expr><name>std</name><operator>::</operator><call><name>distance</name><argument_list>(<argument><expr><call><name>ivar_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>ivar_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>ivar_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>ivar_begin</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name>ivar_end</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<function_decl><type><name>ObjCIvarDecl</name> <modifier>*</modifier></type><name>all_declared_ivar_begin</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>ObjCIvarDecl</name> <operator>*</operator><macro><name>all_declared_ivar_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{


<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCInterfaceDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>all_declared_ivar_begin</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setIvarList</name><parameter_list>(<parameter><decl><type><name>ObjCIvarDecl</name> <modifier>*</modifier></type><name>ivar</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>IvarList</name> <operator>=</operator> <name>ivar</name></expr>;</expr_stmt> </block_content>}</block></function>



<function><type><name>void</name></type> <name>setProtocolList</name><parameter_list>(<parameter><decl><type><name>ObjCProtocolDecl</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type> <name>List</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Num</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>SourceLocation</name> <modifier>*</modifier></type><name>Locs</name></decl></parameter>, <parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>ReferencedProtocols</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>Num</name></expr></argument>, <argument><expr><name>Locs</name></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function_decl><type><name>void</name></type> <name>mergeClassExtensionProtocolList</name><parameter_list>(<parameter><decl><type><name>ObjCProtocolDecl</name> <modifier>*</modifier><specifier>const</specifier><modifier>*</modifier></type> <name>List</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Num</name></decl></parameter>,
<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>StringRef</name> <macro><name>getObjCRuntimeNameAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>






<decl_stmt><decl><type><name>void</name></type> <name>getDesignatedInitializers</name><argument_list>(
<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ObjCMethodDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Methods</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>










<decl_stmt><decl><type><name>bool</name></type>
<name>isDesignatedInitializer</name><argument_list>(<argument><expr><name>Selector</name> <name>Sel</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ObjCMethodDecl</name> <operator>*</operator><operator>*</operator><name>InitMethod</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isThisDeclarationADefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getDefinition</name><argument_list>()</argument_list></call> <operator>==</operator> <name>this</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{




<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Data</name><operator>.</operator><name>getOpaqueValue</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name><name>Data</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}




ObjCInterfaceDecl <expr_stmt><expr><operator>*</operator><macro><name>getDefinition</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>hasDefinition</name><argument_list>()</argument_list></call><operator>?</operator> <call><name><name>Data</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>Definition</name> <operator>:</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasDefinition</name><argument_list>()</argument_list></call><operator>?</operator> <call><name><name>Data</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>Definition</name> <operator>:</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>



<function_decl><type><name>void</name></type> <name>startDefinition</name><parameter_list>()</parameter_list>;</function_decl>


<expr_stmt><expr><specifier>const</specifier> <name>ObjCObjectType</name> <operator>*</operator><macro><name>getSuperClassType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name> <init>= <expr><call><name>getSuperClassTInfo</name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>TInfo</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>castAs</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><name>nullptr</name></expr>;</return>
}


TypeSourceInfo <expr_stmt><expr><operator>*</operator><macro><name>getSuperClassTInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasDefinition</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>ExternallyCompleted</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LoadExternalDefinition</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>SuperClassTInfo</name></expr>;</return>
}



ObjCInterfaceDecl <expr_stmt><expr><operator>*</operator><macro><name>getSuperClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function><type><name>void</name></type> <name>setSuperClass</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>superClass</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>SuperClassTInfo</name> <operator>=</operator> <name>superClass</name></expr>;</expr_stmt>
</block_content>}</block></function>






<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>bool</name> <operator>(</operator><operator>*</operator><name>Filter</name><operator>)</operator><operator>(</operator><name>ObjCCategoryDecl</name> <modifier>*</modifier><operator>)</operator></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>filtered_category_iterator</name> <block>{<block_content>
<decl_stmt><decl><type><name>ObjCCategoryDecl</name> <modifier>*</modifier></type><name>Current</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>findAcceptableCategory</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>using</name></type> <name>value_type</name> <init>= <expr><name>ObjCCategoryDecl</name> <operator>*</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>reference</name> <init>= <expr><name>value_type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>pointer</name> <init>= <expr><name>value_type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>difference_type</name> <init>= <expr><name>std</name><operator>::</operator><name>ptrdiff_t</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>iterator_category</name> <init>= <expr><name>std</name><operator>::</operator><name>input_iterator_tag</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>filtered_category_iterator</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>filtered_category_iterator</name><argument_list>(<argument><expr><name>ObjCCategoryDecl</name> <operator>*</operator><name>Current</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>Current</name><argument_list>(<argument>Current</argument>)</argument_list></macro> <block>{
<expr><call><name>findAcceptableCategory</name><argument_list>()</argument_list></call></expr>;
}</block>

<name>reference</name> <name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>Current</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>pointer</name> <name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>)</block_content> const <block>{<block_content> <return>return <expr><name>Current</name></expr>;</return> </block_content>}</block>

filtered_category_iterator &amp;operator++(</block></decl>);</decl_stmt>

<expr_stmt><expr><name>filtered_category_iterator</name> <name>operator</name><operator>++</operator><operator>(</operator><name>int</name><operator>)</operator> <block>{
<expr><name>filtered_category_iterator</name> <name>Tmp</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;
<expr><operator>++</operator><operator>(</operator><operator>*</operator><name>this</name><operator>)</operator></expr>;
<return>return <expr><name>Tmp</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><name>filtered_category_iterator</name> <name>X</name><operator>,</operator>
<name>filtered_category_iterator</name> <name>Y</name><operator>)</operator> <block>{
<return>return <expr><name><name>X</name><operator>.</operator><name>Current</name></name> <operator>==</operator> <name><name>Y</name><operator>.</operator><name>Current</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><name>filtered_category_iterator</name> <name>X</name><operator>,</operator>
<name>filtered_category_iterator</name> <name>Y</name><operator>)</operator> <block>{
<return>return <expr><name><name>X</name><operator>.</operator><name>Current</name></name> <operator>!=</operator> <name><name>Y</name><operator>.</operator><name>Current</name></name></expr>;</return>
}</block></expr></expr_stmt>
};

<label><name>private</name>:</label>



<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isVisibleCategory</name><parameter_list>(<parameter><decl><type><name>ObjCCategoryDecl</name> <modifier>*</modifier></type><name>Cat</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>


<decl_stmt><decl><type><name>using</name></type> <name>visible_categories_iterator</name> <init>=
<expr><name><name>filtered_category_iterator</name><argument_list type="generic">&lt;<argument><expr><name>isVisibleCategory</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>visible_categories_range</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>visible_categories_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>visible_categories_range</name> <macro><name>visible_categories</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>visible_categories_range</name><argument_list>(<argument><expr><call><name>visible_categories_begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>visible_categories_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>visible_categories_iterator</name> <macro><name>visible_categories_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>visible_categories_iterator</name><argument_list>(<argument><expr><call><name>getCategoryListRaw</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>visible_categories_iterator</name> <macro><name>visible_categories_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>visible_categories_iterator</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>visible_categories_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>visible_categories_begin</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name>visible_categories_end</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>isKnownCategory</name><parameter_list>(<parameter><decl><type><name>ObjCCategoryDecl</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>true</name></expr>;</return> </block_content>}</block></function>

<label><name>public</name>:</label>


<decl_stmt><decl><type><name>using</name></type> <name>known_categories_iterator</name> <init>= <expr><name><name>filtered_category_iterator</name><argument_list type="generic">&lt;<argument><expr><name>isKnownCategory</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>known_categories_range</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>known_categories_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>known_categories_range</name> <macro><name>known_categories</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>known_categories_range</name><argument_list>(<argument><expr><call><name>known_categories_begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>known_categories_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>known_categories_iterator</name> <macro><name>known_categories_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>known_categories_iterator</name><argument_list>(<argument><expr><call><name>getCategoryListRaw</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>known_categories_iterator</name> <macro><name>known_categories_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>known_categories_iterator</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>known_categories_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>known_categories_begin</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name>known_categories_end</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>



<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isVisibleExtension</name><parameter_list>(<parameter><decl><type><name>ObjCCategoryDecl</name> <modifier>*</modifier></type><name>Cat</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>


<decl_stmt><decl><type><name>using</name></type> <name>visible_extensions_iterator</name> <init>=
<expr><name><name>filtered_category_iterator</name><argument_list type="generic">&lt;<argument><expr><name>isVisibleExtension</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>visible_extensions_range</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>visible_extensions_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>visible_extensions_range</name> <macro><name>visible_extensions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>visible_extensions_range</name><argument_list>(<argument><expr><call><name>visible_extensions_begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>visible_extensions_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>visible_extensions_iterator</name> <macro><name>visible_extensions_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>visible_extensions_iterator</name><argument_list>(<argument><expr><call><name>getCategoryListRaw</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>visible_extensions_iterator</name> <macro><name>visible_extensions_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>visible_extensions_iterator</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>visible_extensions_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>visible_extensions_begin</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name>visible_extensions_end</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>



<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isKnownExtension</name><parameter_list>(<parameter><decl><type><name>ObjCCategoryDecl</name> <modifier>*</modifier></type><name>Cat</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclWriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTReader</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>known_extensions_iterator</name> <init>=
<expr><name><name>filtered_category_iterator</name><argument_list type="generic">&lt;<argument><expr><name>isKnownExtension</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>known_extensions_range</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>known_extensions_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>known_extensions_range</name> <macro><name>known_extensions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>known_extensions_range</name><argument_list>(<argument><expr><call><name>known_extensions_begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>known_extensions_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>known_extensions_iterator</name> <macro><name>known_extensions_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>known_extensions_iterator</name><argument_list>(<argument><expr><call><name>getCategoryListRaw</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>known_extensions_iterator</name> <macro><name>known_extensions_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>known_extensions_iterator</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>known_extensions_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>known_extensions_begin</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name>known_extensions_end</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>ObjCCategoryDecl</name><operator>*</operator> <macro><name>getCategoryListRaw</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasDefinition</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>ExternallyCompleted</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LoadExternalDefinition</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>CategoryList</name></expr>;</return>
}



void <macro><name>setCategoryListRaw</name><argument_list>(<argument>ObjCCategoryDecl *category</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>CategoryList</name> <operator>=</operator> <name>category</name></expr>;</expr_stmt>
</block_content>}</block>

<decl_stmt><decl><type><name>ObjCPropertyDecl</name>
<modifier>*</modifier></type><name>FindPropertyVisibleInPrimaryClass</name><argument_list>(<argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>PropertyId</name></expr></argument>,
<argument><expr><name>ObjCPropertyQueryKind</name> <name>QueryKind</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>collectPropertiesToImplement</name><argument_list>(<argument><expr><name>PropertyMap</name> <operator>&amp;</operator><name>PM</name></expr></argument>,
<argument><expr><name>PropertyDeclOrder</name> <operator>&amp;</operator><name>PO</name></expr></argument>)</argument_list> const <name>override</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isSuperClassOf</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><name>I</name></expr></argument>)</argument_list> const <block>{<block_content>

<while>while <condition>(<expr><name>I</name> <operator>!=</operator> <name>nullptr</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>declaresSameEntity</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>I</name> <operator>=</operator> <call><name><name>I</name><operator>-&gt;</operator><name>getSuperClass</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isArcWeakrefUnavailable</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>isObjCRequiresPropertyDefs</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function_decl><type><name>ObjCIvarDecl</name> <modifier>*</modifier></type><name>lookupInstanceVariable</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>IVarName</name></decl></parameter>,
<parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>ClassDeclared</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>ObjCIvarDecl</name> <modifier>*</modifier></type><name>lookupInstanceVariable</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>IVarName</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>ClassDeclared</name></decl>;</decl_stmt>
<return>return <expr><call><name>lookupInstanceVariable</name><argument_list>(<argument><expr><name>IVarName</name></expr></argument>, <argument><expr><name>ClassDeclared</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>ObjCProtocolDecl</name> <modifier>*</modifier></type><name>lookupNestedProtocol</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>lookupMethod</name><argument_list>(<argument><expr><name>Selector</name> <name>Sel</name></expr></argument>, <argument><expr><name>bool</name> <name>isInstance</name></expr></argument>,
<argument><expr><name>bool</name> <name>shallowCategoryLookup</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>bool</name> <name>followSuper</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ObjCCategoryDecl</name> <operator>*</operator><name>C</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>lookupInstanceMethod</name><argument_list>(<argument><expr><name>Selector</name> <name>Sel</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>lookupMethod</name><argument_list>(<argument><expr><name>Sel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>lookupClassMethod</name><argument_list>(<argument><expr><name>Selector</name> <name>Sel</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>lookupMethod</name><argument_list>(<argument><expr><name>Sel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function_decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>lookupInheritedClass</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>ICName</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>lookupPrivateMethod</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Selector</name> <operator>&amp;</operator><name>Sel</name></expr></argument>,
<argument><expr><name>bool</name> <name>Instance</name><operator>=</operator><name>true</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>lookupPrivateClassMethod</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Selector</name> <modifier>&amp;</modifier></type><name>Sel</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>lookupPrivateMethod</name><argument_list>(<argument><expr><name>Sel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>lookupPropertyAccessor</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Selector</name> <name>Sel</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ObjCCategoryDecl</name> <operator>*</operator><name>Cat</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsClassProperty</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>lookupMethod</name><argument_list>(<argument><expr><name>Sel</name></expr></argument>, <argument><expr><operator>!</operator><name>IsClassProperty</name></expr></argument>,
<argument><expr><name>false</name></expr></argument>,
<argument><expr><name>true</name></expr></argument> ,
<argument><expr><name>Cat</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndOfDefinitionLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasDefinition</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>EndLoc</name></expr>;</return>
}

void <macro><name>setEndOfDefinitionLoc</name><argument_list>(<argument>SourceLocation LE</argument>)</argument_list></macro> <block>{<block_content> <expr_stmt><expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>EndLoc</name> <operator>=</operator> <name>LE</name></expr>;</expr_stmt> </block_content>}</block>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getSuperClassLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>isImplicitInterfaceDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasDefinition</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>Definition</name><operator>-&gt;</operator><name>isImplicit</name></name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>isImplicit</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<function_decl><type><name>bool</name></type> <name>ClassImplementsProtocol</name><parameter_list>(<parameter><decl><type><name>ObjCProtocolDecl</name> <modifier>*</modifier></type><name>lProto</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>lookupCategory</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>RHSIsQualifiedID</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>using</name></type> <name>redecl_range</name> <init>= <expr><name>redeclarable_base</name><operator>::</operator><name>redecl_range</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>redecl_iterator</name> <init>= <expr><name>redeclarable_base</name><operator>::</operator><name>redecl_iterator</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_begin</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_end</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getPreviousDecl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getMostRecentDecl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>isFirstDecl</name></expr>;</expr_stmt>


<function><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>getCanonicalDecl</name><parameter_list>()</parameter_list> override <block>{<block_content> <return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><macro><name>getTypeForDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TypeForDecl</name></expr>;</return> }</block></expr></expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>setTypeForDecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>TD</name></expr></argument>)</argument_list> const <block>{<block_content> <expr_stmt><expr><name>TypeForDecl</name> <operator>=</operator> <name>TD</name></expr>;</expr_stmt> </block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>K</name> <operator>==</operator> <name>ObjCInterface</name></expr>;</return> </block_content>}</block></function>

<label><name>private</name>:</label>
<expr_stmt><expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>findInterfaceWithDesignatedInitializers</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>inheritsDesignatedInitializers</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
};
















<decl_stmt><decl><type><name>class</name></type> <name>ObjCIvarDecl</name> <range>: <expr><name>public</name> <name>FieldDecl</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
enum <name>AccessControl</name> <block>{
<expr><name>None</name></expr>, <expr><name>Private</name></expr>, <expr><name>Protected</name></expr>, <expr><name>Public</name></expr>, <expr><name>Package</name></expr>
}</block></expr>;

<expr><name>private</name><operator>:</operator>
<macro><name>ObjCIvarDecl</name><argument_list>(<argument>ObjCContainerDecl *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>IdentifierInfo *Id</argument>,
<argument>QualType T</argument>, <argument>TypeSourceInfo *TInfo</argument>, <argument>AccessControl ac</argument>, <argument>Expr *BW</argument>,
<argument>bool synthesized</argument>)</argument_list></macro>
<operator>:</operator> <call><name>FieldDecl</name><argument_list>(<argument><expr><name>ObjCIvar</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>IdLoc</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>TInfo</name></expr></argument>, <argument><expr><name>BW</name></expr></argument>,
<argument><expr><name>false</name></expr></argument>, <argument><expr><name>ICIS_NoInit</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DeclAccess</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>, <macro><name>Synthesized</name><argument_list>(<argument>synthesized</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>ObjCIvarDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>ObjCContainerDecl *DC</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation IdLoc</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>QualType T</argument>,
<argument>TypeSourceInfo *TInfo</argument>,
<argument>AccessControl ac</argument>, <argument>Expr *BW = nullptr</argument>,
<argument>bool synthesized=false</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>ObjCIvarDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;





<expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getContainingInterface</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>ObjCIvarDecl</name> <operator>*</operator><macro><name>getNextIvar</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>NextIvar</name></expr>;</return> }</block>
<specifier>const</specifier> <name>ObjCIvarDecl</name> <operator>*</operator><macro><name>getNextIvar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NextIvar</name></expr>;</return> }</block>
<name>void</name> <macro><name>setNextIvar</name><argument_list>(<argument>ObjCIvarDecl *ivar</argument>)</argument_list></macro> <block>{ <expr><name>NextIvar</name> <operator>=</operator> <name>ivar</name></expr>; }</block>

<name>void</name> <macro><name>setAccessControl</name><argument_list>(<argument>AccessControl ac</argument>)</argument_list></macro> <block>{ <expr><name>DeclAccess</name> <operator>=</operator> <name>ac</name></expr>; }</block>

<name>AccessControl</name> <macro><name>getAccessControl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>AccessControl</name><argument_list>(<argument><expr><name>DeclAccess</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>AccessControl</name> <macro><name>getCanonicalAccessControl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>DeclAccess</name> <operator>==</operator> <name>None</name> <operator>?</operator> <name>Protected</name> <operator>:</operator> <call><name>AccessControl</name><argument_list>(<argument><expr><name>DeclAccess</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setSynthesize</name><argument_list>(<argument>bool synth</argument>)</argument_list></macro> <block>{ <expr><name>Synthesized</name> <operator>=</operator> <name>synth</name></expr>; }</block>
<name>bool</name> <macro><name>getSynthesize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Synthesized</name></expr>;</return> }</block>



<name>QualType</name> <macro><name>getUsageType</name><argument_list>(<argument>QualType objectType</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>ObjCIvar</name></expr>;</return> }</block>

<name>private</name><operator>:</operator>


<name>ObjCIvarDecl</name> <operator>*</operator><name>NextIvar</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>unsigned</name> <name>DeclAccess</name> <operator>:</operator> <literal type="number">3</literal></expr>;
<expr><name>unsigned</name> <name>Synthesized</name> <operator>:</operator> <literal type="number">1</literal></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>ObjCAtDefsFieldDecl</name> <range>: <expr><name>public</name> <name>FieldDecl</name> <block>{
<macro><name>ObjCAtDefsFieldDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>IdentifierInfo *Id</argument>,
<argument>QualType T</argument>, <argument>Expr *BW</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>FieldDecl</name><argument_list>(<argument>ObjCAtDefsField</argument>, <argument>DC</argument>, <argument>StartLoc</argument>, <argument>IdLoc</argument>, <argument>Id</argument>, <argument>T</argument>,
<argument>nullptr</argument>,
<argument>BW</argument>, <argument>false</argument>, <argument>ICIS_NoInit</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>ObjCAtDefsFieldDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>IdentifierInfo *Id</argument>,
<argument>QualType T</argument>, <argument>Expr *BW</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>ObjCAtDefsFieldDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>ObjCAtDefsField</name></expr>;</return> }</block>
}</expr>;






























<expr><name>class</name> <name>ObjCProtocolDecl</name> <operator>:</operator> <name>public</name> <name>ObjCContainerDecl</name></expr>,
<expr><name>public</name> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name></expr></argument>&gt;</argument_list></name> <block>{
struct <expr><name>DefinitionData</name> <block>{

<expr><name>ObjCProtocolDecl</name> <operator>*</operator><name>Definition</name></expr>;


<expr><name>ObjCProtocolList</name> <name>ReferencedProtocols</name></expr>;
}</block></expr>;






<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>DefinitionData</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>Data</name></expr>;

<macro><name>ObjCProtocolDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>IdentifierInfo *Id</argument>,
<argument>SourceLocation nameLoc</argument>, <argument>SourceLocation atStartLoc</argument>,
<argument>ObjCProtocolDecl *PrevDecl</argument>)</argument_list></macro>;

<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>DefinitionData</name> <operator>&amp;</operator><macro><name>data</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Data</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Objective-C protocol has no definition!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><call><name><name>Data</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <call><name>allocateDefinitionData</name><argument_list>()</argument_list></call></expr>;

<expr><name>using</name> <name>redeclarable_base</name> <operator>=</operator> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>ObjCProtocolDecl</name> <operator>*</operator><macro><name>getNextRedeclarationImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getNextRedeclaration</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ObjCProtocolDecl</name> <operator>*</operator><macro><name>getPreviousDeclImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ObjCProtocolDecl</name> <operator>*</operator><macro><name>getMostRecentDeclImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;

<expr><specifier>static</specifier> <name>ObjCProtocolDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>IdentifierInfo *Id</argument>,
<argument>SourceLocation nameLoc</argument>,
<argument>SourceLocation atStartLoc</argument>,
<argument>ObjCProtocolDecl *PrevDecl</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>ObjCProtocolDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><specifier>const</specifier> <name>ObjCProtocolList</name> <operator>&amp;</operator><macro><name>getReferencedProtocols</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasDefinition</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"No definition available!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>ReferencedProtocols</name></expr>;</return>
}</block>

<name>using</name> <name>protocol_iterator</name> <operator>=</operator> <name>ObjCProtocolList</name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>protocol_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>protocol_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>protocol_range</name> <macro><name>protocols</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>protocol_range</name><argument_list>(<argument><expr><call><name>protocol_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>protocol_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>protocol_iterator</name> <macro><name>protocol_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasDefinition</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>protocol_iterator</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>ReferencedProtocols</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>protocol_iterator</name> <macro><name>protocol_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasDefinition</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>protocol_iterator</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>ReferencedProtocols</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>protocol_loc_iterator</name> <init>= <expr><name>ObjCProtocolList</name><operator>::</operator><name>loc_iterator</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>protocol_loc_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>protocol_loc_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>protocol_loc_range</name> <macro><name>protocol_locs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>protocol_loc_range</name><argument_list>(<argument><expr><call><name>protocol_loc_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>protocol_loc_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>protocol_loc_iterator</name> <macro><name>protocol_loc_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasDefinition</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>protocol_loc_iterator</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>ReferencedProtocols</name><operator>.</operator><name>loc_begin</name></name><argument_list>()</argument_list></call></expr>;</return>
}

protocol_loc_iterator <macro><name>protocol_loc_end</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasDefinition</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>protocol_loc_iterator</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>ReferencedProtocols</name><operator>.</operator><name>loc_end</name></name><argument_list>()</argument_list></call></expr>;</return>
}

unsigned <macro><name>protocol_size</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasDefinition</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>ReferencedProtocols</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
}



void <macro><name>setProtocolList</name><argument_list>(<argument>ObjCProtocolDecl *const*List</argument>, <argument>unsigned Num</argument>,
<argument>const SourceLocation *Locs</argument>, <argument>ASTContext &amp;C</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasDefinition</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Protocol is not defined"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>ReferencedProtocols</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>Num</name></expr></argument>, <argument><expr><name>Locs</name></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>



<expr_stmt><expr><name>bool</name> <macro><name>isNonRuntimeProtocol</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>getImpliedProtocols</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>DenseSet</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ObjCProtocolDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>IPs</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function_decl><type><name>ObjCProtocolDecl</name> <modifier>*</modifier></type><name>lookupProtocolNamed</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>PName</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>lookupMethod</name><argument_list>(<argument><expr><name>Selector</name> <name>Sel</name></expr></argument>, <argument><expr><name>bool</name> <name>isInstance</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>lookupInstanceMethod</name><argument_list>(<argument><expr><name>Selector</name> <name>Sel</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>lookupMethod</name><argument_list>(<argument><expr><name>Sel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>lookupClassMethod</name><argument_list>(<argument><expr><name>Selector</name> <name>Sel</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>lookupMethod</name><argument_list>(<argument><expr><name>Sel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{




<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Data</name><operator>.</operator><name>getOpaqueValue</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name><name>Data</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}


ObjCProtocolDecl <expr_stmt><expr><operator>*</operator><macro><name>getDefinition</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>hasDefinition</name><argument_list>()</argument_list></call><operator>?</operator> <call><name><name>Data</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>Definition</name> <operator>:</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>ObjCProtocolDecl</name> <operator>*</operator><macro><name>getDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasDefinition</name><argument_list>()</argument_list></call><operator>?</operator> <call><name><name>Data</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>Definition</name> <operator>:</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isThisDeclarationADefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getDefinition</name><argument_list>()</argument_list></call> <operator>==</operator> <name>this</name></expr>;</return>
}</block></expr></expr_stmt>


<function_decl><type><name>void</name></type> <name>startDefinition</name><parameter_list>()</parameter_list>;</function_decl>



<expr_stmt><expr><name>StringRef</name> <macro><name>getObjCRuntimeNameAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isThisDeclarationADefinition</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ObjCContainerDecl</name><operator>::</operator><call><name>getSourceRange</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getAtStartLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

using <expr_stmt><expr><name>redecl_range</name> <operator>=</operator> <name>redeclarable_base</name><operator>::</operator><name>redecl_range</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>redecl_iterator</name> <init>= <expr><name>redeclarable_base</name><operator>::</operator><name>redecl_iterator</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_begin</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_end</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getPreviousDecl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getMostRecentDecl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>isFirstDecl</name></expr>;</expr_stmt>


<function><type><name>ObjCProtocolDecl</name> <modifier>*</modifier></type><name>getCanonicalDecl</name><parameter_list>()</parameter_list> override <block>{<block_content> <return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>ObjCProtocolDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>collectPropertiesToImplement</name><argument_list>(<argument><expr><name>PropertyMap</name> <operator>&amp;</operator><name>PM</name></expr></argument>,
<argument><expr><name>PropertyDeclOrder</name> <operator>&amp;</operator><name>PO</name></expr></argument>)</argument_list> const <name>override</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>collectInheritedProtocolProperties</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCPropertyDecl</name> <operator>*</operator><name>Property</name></expr></argument>,
<argument><expr><name>ProtocolPropertySet</name> <operator>&amp;</operator><name>PS</name></expr></argument>,
<argument><expr><name>PropertyDeclOrder</name> <operator>&amp;</operator><name>PO</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>K</name> <operator>==</operator> <name>ObjCProtocol</name></expr>;</return> </block_content>}</block></function>
};

















<decl_stmt><decl><type><name>class</name></type> <name>ObjCCategoryDecl</name> <range>: <expr><name>public</name> <name>ObjCContainerDecl</name> <block>{

<expr><name>ObjCInterfaceDecl</name> <operator>*</operator><name>ClassInterface</name></expr>;


<expr><name>ObjCTypeParamList</name> <operator>*</operator><name>TypeParamList</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>ObjCProtocolList</name> <name>ReferencedProtocols</name></expr>;



<expr><name>ObjCCategoryDecl</name> <operator>*</operator><name>NextClassCategory</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>SourceLocation</name> <name>CategoryNameLoc</name></expr>;


<expr><name>SourceLocation</name> <name>IvarLBraceLoc</name></expr>;
<expr><name>SourceLocation</name> <name>IvarRBraceLoc</name></expr>;

<macro><name>ObjCCategoryDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation AtLoc</argument>,
<argument>SourceLocation ClassNameLoc</argument>, <argument>SourceLocation CategoryNameLoc</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>ObjCInterfaceDecl *IDecl</argument>,
<argument>ObjCTypeParamList *typeParamList</argument>,
<argument>SourceLocation IvarLBraceLoc = SourceLocation()</argument>,
<argument>SourceLocation IvarRBraceLoc = SourceLocation()</argument>)</argument_list></macro>;

<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;

<expr><specifier>static</specifier> <name>ObjCCategoryDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation AtLoc</argument>,
<argument>SourceLocation ClassNameLoc</argument>,
<argument>SourceLocation CategoryNameLoc</argument>,
<argument>IdentifierInfo *Id</argument>,
<argument>ObjCInterfaceDecl *IDecl</argument>,
<argument>ObjCTypeParamList *typeParamList</argument>,
<argument>SourceLocation IvarLBraceLoc=SourceLocation()</argument>,
<argument>SourceLocation IvarRBraceLoc=SourceLocation()</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>ObjCCategoryDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getClassInterface</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>ClassInterface</name></expr>;</return> }</block>
<specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getClassInterface</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ClassInterface</name></expr>;</return> }</block>



<name>ObjCTypeParamList</name> <operator>*</operator><macro><name>getTypeParamList</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TypeParamList</name></expr>;</return> }</block>





<name>void</name> <call><name>setTypeParamList</name><argument_list>(<argument><expr><name>ObjCTypeParamList</name> <operator>*</operator><name>TPL</name></expr></argument>)</argument_list></call></expr>;


<expr><name>ObjCCategoryImplDecl</name> <operator>*</operator><macro><name>getImplementation</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <call><name>setImplementation</name><argument_list>(<argument><expr><name>ObjCCategoryImplDecl</name> <operator>*</operator><name>ImplD</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <macro><name>setProtocolList</name><argument_list>(<argument>ObjCProtocolDecl *const*List</argument>, <argument>unsigned Num</argument>,
<argument>const SourceLocation *Locs</argument>, <argument>ASTContext &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ReferencedProtocols</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>Num</name></expr></argument>, <argument><expr><name>Locs</name></expr></argument>, <argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>const</specifier> <name>ObjCProtocolList</name> <operator>&amp;</operator><macro><name>getReferencedProtocols</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ReferencedProtocols</name></expr>;</return>
}</block>

<name>using</name> <name>protocol_iterator</name> <operator>=</operator> <name>ObjCProtocolList</name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>protocol_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>protocol_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>protocol_range</name> <macro><name>protocols</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>protocol_range</name><argument_list>(<argument><expr><call><name>protocol_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>protocol_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>protocol_iterator</name> <macro><name>protocol_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>ReferencedProtocols</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>protocol_iterator</name> <macro><name>protocol_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>ReferencedProtocols</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>unsigned</name> <macro><name>protocol_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>ReferencedProtocols</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>using</name> <name>protocol_loc_iterator</name> <operator>=</operator> <name>ObjCProtocolList</name><operator>::</operator><name>loc_iterator</name></expr>;
<expr><name>using</name> <name>protocol_loc_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>protocol_loc_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>protocol_loc_range</name> <macro><name>protocol_locs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>protocol_loc_range</name><argument_list>(<argument><expr><call><name>protocol_loc_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>protocol_loc_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>protocol_loc_iterator</name> <macro><name>protocol_loc_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>ReferencedProtocols</name><operator>.</operator><name>loc_begin</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>protocol_loc_iterator</name> <macro><name>protocol_loc_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>ReferencedProtocols</name><operator>.</operator><name>loc_end</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ObjCCategoryDecl</name> <operator>*</operator><macro><name>getNextClassCategory</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NextClassCategory</name></expr>;</return> }</block>



<name>ObjCCategoryDecl</name> <operator>*</operator><macro><name>getNextClassCategoryRaw</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NextClassCategory</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>IsClassExtension</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getIdentifier</name><argument_list>()</argument_list></call> <operator>==</operator> <name>nullptr</name></expr>;</return> }</block>

<name>using</name> <name>ivar_iterator</name> <operator>=</operator> <name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>ObjCIvarDecl</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>ivar_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>ObjCIvarDecl</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>ivar_range</name> <macro><name>ivars</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>ivar_range</name><argument_list>(<argument><expr><call><name>ivar_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>ivar_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>ivar_iterator</name> <macro><name>ivar_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>ivar_iterator</name><argument_list>(<argument><expr><call><name>decls_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>ivar_iterator</name> <macro><name>ivar_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>ivar_iterator</name><argument_list>(<argument><expr><call><name>decls_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>ivar_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>std</name><operator>::</operator><call><name>distance</name><argument_list>(<argument><expr><call><name>ivar_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>ivar_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>ivar_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>ivar_begin</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name>ivar_end</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getCategoryNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CategoryNameLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setCategoryNameLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>CategoryNameLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>void</name> <macro><name>setIvarLBraceLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>IvarLBraceLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getIvarLBraceLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IvarLBraceLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setIvarRBraceLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>IvarRBraceLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getIvarRBraceLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IvarRBraceLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>ObjCCategory</name></expr>;</return> }</block>
}</expr>;

<expr><name>class</name> <name>ObjCImplDecl</name> <operator>:</operator> <name>public</name> <name>ObjCContainerDecl</name> <block>{

<expr><name>ObjCInterfaceDecl</name> <operator>*</operator><name>ClassInterface</name></expr>;

<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>ObjCImplDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>DeclContext *DC</argument>,
<argument>ObjCInterfaceDecl *classInterface</argument>,
<argument>IdentifierInfo *Id</argument>,
<argument>SourceLocation nameLoc</argument>, <argument>SourceLocation atStartLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>ObjCContainerDecl</name><argument_list>(<argument><expr><name>DK</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>, <argument><expr><name>nameLoc</name></expr></argument>, <argument><expr><name>atStartLoc</name></expr></argument>)</argument_list></call></expr>,
<macro><name>ClassInterface</name><argument_list>(<argument>classInterface</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getClassInterface</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ClassInterface</name></expr>;</return> }</block>
<name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getClassInterface</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>ClassInterface</name></expr>;</return> }</block>
<name>void</name> <call><name>setClassInterface</name><argument_list>(<argument><expr><name>ObjCInterfaceDecl</name> <operator>*</operator><name>IFace</name></expr></argument>)</argument_list></call></expr>;

<expr><name>void</name> <macro><name>addInstanceMethod</name><argument_list>(<argument>ObjCMethodDecl *method</argument>)</argument_list></macro> <block>{

<expr><call><name><name>method</name><operator>-&gt;</operator><name>setLexicalDeclContext</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>addDecl</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>addClassMethod</name><argument_list>(<argument>ObjCMethodDecl *method</argument>)</argument_list></macro> <block>{

<expr><call><name><name>method</name><operator>-&gt;</operator><name>setLexicalDeclContext</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>addDecl</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <call><name>addPropertyImplementation</name><argument_list>(<argument><expr><name>ObjCPropertyImplDecl</name> <operator>*</operator><name>property</name></expr></argument>)</argument_list></call></expr>;

<expr><name>ObjCPropertyImplDecl</name> <operator>*</operator><macro><name>FindPropertyImplDecl</name><argument_list>(<argument>IdentifierInfo *propertyId</argument>,
<argument>ObjCPropertyQueryKind queryKind</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>ObjCPropertyImplDecl</name> <operator>*</operator><macro><name>FindPropertyImplIvarDecl</name><argument_list>(<argument>IdentifierInfo *ivarId</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>using</name> <name>propimpl_iterator</name> <operator>=</operator> <name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>ObjCPropertyImplDecl</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>propimpl_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>ObjCPropertyImplDecl</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>propimpl_range</name> <macro><name>property_impls</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>propimpl_range</name><argument_list>(<argument><expr><call><name>propimpl_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>propimpl_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>propimpl_iterator</name> <macro><name>propimpl_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>propimpl_iterator</name><argument_list>(<argument><expr><call><name>decls_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>propimpl_iterator</name> <macro><name>propimpl_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>propimpl_iterator</name><argument_list>(<argument><expr><call><name>decls_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{
<return>return <expr><name>K</name> <operator>&gt;=</operator> <name>firstObjCImpl</name> <operator>&amp;&amp;</operator> <name>K</name> <operator>&lt;=</operator> <name>lastObjCImpl</name></expr>;</return>
}</block>
}</expr>;














<expr><name>class</name> <name>ObjCCategoryImplDecl</name> <operator>:</operator> <name>public</name> <name>ObjCImplDecl</name> <block>{

<expr><name>SourceLocation</name> <name>CategoryNameLoc</name></expr>;

<macro><name>ObjCCategoryImplDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>IdentifierInfo *Id</argument>,
<argument>ObjCInterfaceDecl *classInterface</argument>,
<argument>SourceLocation nameLoc</argument>, <argument>SourceLocation atStartLoc</argument>,
<argument>SourceLocation CategoryNameLoc</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>ObjCImplDecl</name><argument_list>(<argument><expr><name>ObjCCategoryImpl</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>classInterface</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>,
<argument><expr><name>nameLoc</name></expr></argument>, <argument><expr><name>atStartLoc</name></expr></argument>)</argument_list></call></expr>,
<macro><name>CategoryNameLoc</name><argument_list>(<argument>CategoryNameLoc</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;

<expr><specifier>static</specifier> <name>ObjCCategoryImplDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>IdentifierInfo *Id</argument>,
<argument>ObjCInterfaceDecl *classInterface</argument>,
<argument>SourceLocation nameLoc</argument>,
<argument>SourceLocation atStartLoc</argument>,
<argument>SourceLocation CategoryNameLoc</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>ObjCCategoryImplDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>ObjCCategoryDecl</name> <operator>*</operator><macro><name>getCategoryDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>SourceLocation</name> <macro><name>getCategoryNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CategoryNameLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>ObjCCategoryImpl</name></expr>;</return>}</block>
}</expr>;

<expr><name>raw_ostream</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name>, <specifier>const</specifier> <name>ObjCCategoryImplDecl</name> <operator>&amp;</operator><name>CID</name><operator>)</operator></expr>;


















<expr><name>class</name> <name>ObjCImplementationDecl</name> <operator>:</operator> <name>public</name> <name>ObjCImplDecl</name> <block>{

<expr><name>ObjCInterfaceDecl</name> <operator>*</operator><name>SuperClass</name></expr>;
<expr><name>SourceLocation</name> <name>SuperLoc</name></expr>;


<expr><name>SourceLocation</name> <name>IvarLBraceLoc</name></expr>;
<expr><name>SourceLocation</name> <name>IvarRBraceLoc</name></expr>;



<expr><name>LazyCXXCtorInitializersPtr</name> <name>IvarInitializers</name></expr>;
<expr><name>unsigned</name> <name>NumIvarInitializers</name> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name>bool</name> <name>HasNonZeroConstructors</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>bool</name> <name>HasDestructors</name> <operator>:</operator> <literal type="number">1</literal></expr>;

<macro><name>ObjCImplementationDecl</name><argument_list>(<argument>DeclContext *DC</argument>,
<argument>ObjCInterfaceDecl *classInterface</argument>,
<argument>ObjCInterfaceDecl *superDecl</argument>,
<argument>SourceLocation nameLoc</argument>, <argument>SourceLocation atStartLoc</argument>,
<argument>SourceLocation superLoc = SourceLocation()</argument>,
<argument>SourceLocation IvarLBraceLoc=SourceLocation()</argument>,
<argument>SourceLocation IvarRBraceLoc=SourceLocation()</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>ObjCImplDecl</name><argument_list>(<argument><expr><name>ObjCImplementation</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>classInterface</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>classInterface</name></expr> ?</condition><then> <expr><call><name><name>classInterface</name><operator>-&gt;</operator><name>getIdentifier</name></name><argument_list>()</argument_list></call></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr></argument>,
<argument><expr><name>nameLoc</name></expr></argument>, <argument><expr><name>atStartLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SuperClass</name><argument_list>(<argument><expr><name>superDecl</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>SuperLoc</name><argument_list>(<argument><expr><name>superLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>IvarLBraceLoc</name><argument_list>(<argument><expr><name>IvarLBraceLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>IvarRBraceLoc</name><argument_list>(<argument><expr><name>IvarRBraceLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>HasNonZeroConstructors</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>, <macro><name>HasDestructors</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;

<expr><specifier>static</specifier> <name>ObjCImplementationDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>ObjCInterfaceDecl *classInterface</argument>,
<argument>ObjCInterfaceDecl *superDecl</argument>,
<argument>SourceLocation nameLoc</argument>,
<argument>SourceLocation atStartLoc</argument>,
<argument>SourceLocation superLoc = SourceLocation()</argument>,
<argument>SourceLocation IvarLBraceLoc=SourceLocation()</argument>,
<argument>SourceLocation IvarRBraceLoc=SourceLocation()</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>ObjCImplementationDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;


<expr><name>using</name> <name>init_iterator</name> <operator>=</operator> <name>CXXCtorInitializer</name> <operator>*</operator><operator>*</operator></expr>;


<expr><name>using</name> <name>init_const_iterator</name> <operator>=</operator> <name>CXXCtorInitializer</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator></expr>;

<expr><name>using</name> <name>init_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>init_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>init_const_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>init_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>init_range</name> <macro><name>inits</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>init_range</name><argument_list>(<argument><expr><call><name>init_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>init_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>init_const_range</name> <macro><name>inits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>init_const_range</name><argument_list>(<argument><expr><call><name>init_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>init_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>init_iterator</name> <macro><name>init_begin</name><argument_list>()</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>auto</name> <operator>*</operator><name>ConstThis</name> <operator>=</operator> <name>this</name></expr>;
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>init_iterator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>ConstThis</name><operator>-&gt;</operator><name>init_begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>init_const_iterator</name> <macro><name>init_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>init_iterator</name> <macro><name>init_end</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>init_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <name>NumIvarInitializers</name></expr>;</return>
}</block>


<name>init_const_iterator</name> <macro><name>init_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>init_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <name>NumIvarInitializers</name></expr>;</return>
}</block>


<name>unsigned</name> <macro><name>getNumIvarInitializers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumIvarInitializers</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setNumIvarInitializers</name><argument_list>(<argument>unsigned numNumIvarInitializers</argument>)</argument_list></macro> <block>{
<expr><name>NumIvarInitializers</name> <operator>=</operator> <name>numNumIvarInitializers</name></expr>;
}</block>

<name>void</name> <macro><name>setIvarInitializers</name><argument_list>(<argument>ASTContext &amp;C</argument>,
<argument>CXXCtorInitializer ** initializers</argument>,
<argument>unsigned numInitializers</argument>)</argument_list></macro></expr>;



<expr><name>bool</name> <macro><name>hasNonZeroConstructors</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasNonZeroConstructors</name></expr>;</return> }</block>
<name>void</name> <macro><name>setHasNonZeroConstructors</name><argument_list>(<argument>bool val</argument>)</argument_list></macro> <block>{ <expr><name>HasNonZeroConstructors</name> <operator>=</operator> <name>val</name></expr>; }</block>



<name>bool</name> <macro><name>hasDestructors</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasDestructors</name></expr>;</return> }</block>
<name>void</name> <macro><name>setHasDestructors</name><argument_list>(<argument>bool val</argument>)</argument_list></macro> <block>{ <expr><name>HasDestructors</name> <operator>=</operator> <name>val</name></expr>; }</block>



<name>IdentifierInfo</name> <operator>*</operator><macro><name>getIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getClassInterface</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getIdentifier</name><argument_list>()</argument_list></call></expr>;</return>
}</block>






<name>StringRef</name> <macro><name>getName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getIdentifier</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Name is not a simple identifier"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getIdentifier</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getName</name><argument_list>()</argument_list></call></expr>;</return>
}</block>




<name>std</name><operator>::</operator><name>string</name> <macro><name>getNameAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>



<name>StringRef</name> <macro><name>getObjCRuntimeNameAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getSuperClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SuperClass</name></expr>;</return> }</block>
<name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getSuperClass</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>SuperClass</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getSuperClassLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SuperLoc</name></expr>;</return> }</block>

<name>void</name> <macro><name>setSuperClass</name><argument_list>(<argument>ObjCInterfaceDecl * superCls</argument>)</argument_list></macro> <block>{ <expr><name>SuperClass</name> <operator>=</operator> <name>superCls</name></expr>; }</block>

<name>void</name> <macro><name>setIvarLBraceLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>IvarLBraceLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getIvarLBraceLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IvarLBraceLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setIvarRBraceLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>IvarRBraceLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getIvarRBraceLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IvarRBraceLoc</name></expr>;</return> }</block>

<name>using</name> <name>ivar_iterator</name> <operator>=</operator> <name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>ObjCIvarDecl</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>ivar_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>ObjCIvarDecl</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>ivar_range</name> <macro><name>ivars</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>ivar_range</name><argument_list>(<argument><expr><call><name>ivar_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>ivar_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>ivar_iterator</name> <macro><name>ivar_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>ivar_iterator</name><argument_list>(<argument><expr><call><name>decls_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>ivar_iterator</name> <macro><name>ivar_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>ivar_iterator</name><argument_list>(<argument><expr><call><name>decls_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>ivar_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>std</name><operator>::</operator><call><name>distance</name><argument_list>(<argument><expr><call><name>ivar_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>ivar_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>ivar_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>ivar_begin</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name>ivar_end</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>ObjCImplementation</name></expr>;</return> }</block>
}</expr>;

<expr><name>raw_ostream</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name>, <specifier>const</specifier> <name>ObjCImplementationDecl</name> <operator>&amp;</operator><name>ID</name><operator>)</operator></expr>;



<expr><name>class</name> <name>ObjCCompatibleAliasDecl</name> <operator>:</operator> <name>public</name> <name>NamedDecl</name> <block>{

<expr><name>ObjCInterfaceDecl</name> <operator>*</operator><name>AliasedClass</name></expr>;

<macro><name>ObjCCompatibleAliasDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>, <argument>IdentifierInfo *Id</argument>,
<argument>ObjCInterfaceDecl* aliasedClass</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>NamedDecl</name><argument_list>(<argument><expr><name>ObjCCompatibleAlias</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>L</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>)</argument_list></call></expr>, <macro><name>AliasedClass</name><argument_list>(<argument>aliasedClass</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>ObjCCompatibleAliasDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation L</argument>, <argument>IdentifierInfo *Id</argument>,
<argument>ObjCInterfaceDecl* aliasedClass</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>ObjCCompatibleAliasDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>,
<argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getClassInterface</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AliasedClass</name></expr>;</return> }</block>
<name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getClassInterface</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>AliasedClass</name></expr>;</return> }</block>
<name>void</name> <macro><name>setClassInterface</name><argument_list>(<argument>ObjCInterfaceDecl *D</argument>)</argument_list></macro> <block>{ <expr><name>AliasedClass</name> <operator>=</operator> <name>D</name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>ObjCCompatibleAlias</name></expr>;</return> }</block>
}</expr>;





<expr><name>class</name> <name>ObjCPropertyImplDecl</name> <operator>:</operator> <name>public</name> <name>Decl</name> <block>{
<expr><name>public</name><operator>:</operator>
enum <name>Kind</name> <block>{
<expr><name>Synthesize</name></expr>,
<expr><name>Dynamic</name></expr>
}</block></expr>;

<expr><name>private</name><operator>:</operator>
<name>SourceLocation</name> <name>AtLoc</name></expr>;







<expr><name>SourceLocation</name> <name>IvarLoc</name></expr>;


<expr><name>ObjCPropertyDecl</name> <operator>*</operator><name>PropertyDecl</name></expr>;


<expr><name>ObjCIvarDecl</name> <operator>*</operator><name>PropertyIvarDecl</name></expr>;


<expr><name>ObjCMethodDecl</name> <operator>*</operator><name>GetterMethodDecl</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>ObjCMethodDecl</name> <operator>*</operator><name>SetterMethodDecl</name> <operator>=</operator> <name>nullptr</name></expr>;



<expr><name>Expr</name> <operator>*</operator><name>GetterCXXConstructor</name> <operator>=</operator> <name>nullptr</name></expr>;



<expr><name>Expr</name> <operator>*</operator><name>SetterCXXAssignment</name> <operator>=</operator> <name>nullptr</name></expr>;

<macro><name>ObjCPropertyImplDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation atLoc</argument>, <argument>SourceLocation L</argument>,
<argument>ObjCPropertyDecl *property</argument>,
<argument>Kind PK</argument>,
<argument>ObjCIvarDecl *ivarDecl</argument>,
<argument>SourceLocation ivarLoc</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Decl</name><argument_list>(<argument><expr><name>ObjCPropertyImpl</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>AtLoc</name><argument_list>(<argument><expr><name>atLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>IvarLoc</name><argument_list>(<argument><expr><name>ivarLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>PropertyDecl</name><argument_list>(<argument><expr><name>property</name></expr></argument>)</argument_list></call></expr>, <macro><name>PropertyIvarDecl</name><argument_list>(<argument>ivarDecl</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>PK</name> <operator>==</operator> <name>Dynamic</name> <operator>||</operator> <name>PropertyIvarDecl</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;

<expr><specifier>static</specifier> <name>ObjCPropertyImplDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation atLoc</argument>, <argument>SourceLocation L</argument>,
<argument>ObjCPropertyDecl *property</argument>,
<argument>Kind PK</argument>,
<argument>ObjCIvarDecl *ivarDecl</argument>,
<argument>SourceLocation ivarLoc</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>ObjCPropertyImplDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>AtLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setAtLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>AtLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>ObjCPropertyDecl</name> <operator>*</operator><macro><name>getPropertyDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PropertyDecl</name></expr>;</return>
}</block>
<name>void</name> <macro><name>setPropertyDecl</name><argument_list>(<argument>ObjCPropertyDecl *Prop</argument>)</argument_list></macro> <block>{ <expr><name>PropertyDecl</name> <operator>=</operator> <name>Prop</name></expr>; }</block>

<name>Kind</name> <macro><name>getPropertyImplementation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><name>PropertyIvarDecl</name></expr> ?</condition><then> <expr><name>Synthesize</name></expr> </then><else>: <expr><name>Dynamic</name></expr></else></ternary></expr>;</return>
}</block>

<name>ObjCIvarDecl</name> <operator>*</operator><macro><name>getPropertyIvarDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PropertyIvarDecl</name></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getPropertyIvarDeclLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IvarLoc</name></expr>;</return> }</block>

<name>void</name> <macro><name>setPropertyIvarDecl</name><argument_list>(<argument>ObjCIvarDecl *Ivar</argument>,
<argument>SourceLocation IvarLoc</argument>)</argument_list></macro> <block>{
<expr><name>PropertyIvarDecl</name> <operator>=</operator> <name>Ivar</name></expr>;
<expr><name><name>this</name><operator>-&gt;</operator><name>IvarLoc</name></name> <operator>=</operator> <name>IvarLoc</name></expr>;
}</block>








<name>bool</name> <macro><name>isIvarNameSpecified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>IvarLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>IvarLoc</name> <operator>!=</operator> <call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ObjCMethodDecl</name> <operator>*</operator><macro><name>getGetterMethodDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>GetterMethodDecl</name></expr>;</return> }</block>
<name>void</name> <macro><name>setGetterMethodDecl</name><argument_list>(<argument>ObjCMethodDecl *MD</argument>)</argument_list></macro> <block>{ <expr><name>GetterMethodDecl</name> <operator>=</operator> <name>MD</name></expr>; }</block>

<name>ObjCMethodDecl</name> <operator>*</operator><macro><name>getSetterMethodDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SetterMethodDecl</name></expr>;</return> }</block>
<name>void</name> <macro><name>setSetterMethodDecl</name><argument_list>(<argument>ObjCMethodDecl *MD</argument>)</argument_list></macro> <block>{ <expr><name>SetterMethodDecl</name> <operator>=</operator> <name>MD</name></expr>; }</block>

<name>Expr</name> <operator>*</operator><macro><name>getGetterCXXConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>GetterCXXConstructor</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setGetterCXXConstructor</name><argument_list>(<argument>Expr *getterCXXConstructor</argument>)</argument_list></macro> <block>{
<expr><name>GetterCXXConstructor</name> <operator>=</operator> <name>getterCXXConstructor</name></expr>;
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getSetterCXXAssignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>SetterCXXAssignment</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setSetterCXXAssignment</name><argument_list>(<argument>Expr *setterCXXAssignment</argument>)</argument_list></macro> <block>{
<expr><name>SetterCXXAssignment</name> <operator>=</operator> <name>setterCXXAssignment</name></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Decl::Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>ObjCPropertyImpl</name></expr>;</return> }</block>
}</expr>;

<expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>bool</name> <operator>(</operator><operator>*</operator><name>Filter</name><operator>)</operator><operator>(</operator><name>ObjCCategoryDecl</name> <operator>*</operator><operator>)</operator></expr></argument>&gt;</argument_list></name>
<name>void</name>
<name>ObjCInterfaceDecl</name><operator>::</operator><name><name>filtered_category_iterator</name><argument_list type="generic">&lt;<argument><expr><name>Filter</name></expr></argument>&gt;</argument_list></name><operator>::</operator>
<macro><name>findAcceptableCategory</name><argument_list>()</argument_list></macro> <block>{
<while>while <condition>(<expr><name>Current</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>Filter</name><argument_list>(<argument><expr><name>Current</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Current</name> <operator>=</operator> <call><name><name>Current</name><operator>-&gt;</operator><name>getNextClassCategoryRaw</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></while>
}</block>

<name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>bool</name> <operator>(</operator><operator>*</operator><name>Filter</name><operator>)</operator><operator>(</operator><name>ObjCCategoryDecl</name> <operator>*</operator><operator>)</operator></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>ObjCInterfaceDecl</name><operator>::</operator><name><name>filtered_category_iterator</name><argument_list type="generic">&lt;<argument><expr><name>Filter</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator>
<name>ObjCInterfaceDecl</name><operator>::</operator><name><name>filtered_category_iterator</name><argument_list type="generic">&lt;<argument><expr><name>Filter</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>operator</name><operator>++</operator><operator>(</operator><operator>)</operator> <block>{
<expr><name>Current</name> <operator>=</operator> <call><name><name>Current</name><operator>-&gt;</operator><name>getNextClassCategoryRaw</name></name><argument_list>()</argument_list></call></expr>;
<expr><call><name>findAcceptableCategory</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>ObjCInterfaceDecl</name><operator>::</operator><macro><name>isVisibleCategory</name><argument_list>(<argument>ObjCCategoryDecl *Cat</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Cat</name><operator>-&gt;</operator><name>isUnconditionallyVisible</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>ObjCInterfaceDecl</name><operator>::</operator><macro><name>isVisibleExtension</name><argument_list>(<argument>ObjCCategoryDecl *Cat</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Cat</name><operator>-&gt;</operator><name>IsClassExtension</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Cat</name><operator>-&gt;</operator><name>isUnconditionallyVisible</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <name>ObjCInterfaceDecl</name><operator>::</operator><macro><name>isKnownExtension</name><argument_list>(<argument>ObjCCategoryDecl *Cat</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Cat</name><operator>-&gt;</operator><name>IsClassExtension</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

}</expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></range></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
