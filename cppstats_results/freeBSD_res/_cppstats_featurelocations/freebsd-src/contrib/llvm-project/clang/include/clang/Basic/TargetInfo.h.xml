<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Basic/TargetInfo.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_BASIC_TARGETINFO_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_BASIC_TARGETINFO_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/AddressSpaces.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/CodeGenOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LangOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Specifiers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TargetCXXABI.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TargetOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/APFloat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/APInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/IntrusiveRefCntPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Triple.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Frontend/OpenMP/OMPGridValues.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/DataTypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/VersionTuple.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>
<struct_decl>struct <name>fltSemantics</name>;</struct_decl>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>DiagnosticsEngine</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LangOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CodeGenOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MacroBuilder</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>QualType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SourceLocation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SourceManager</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>Builtin</name> <block>{<block_content> <struct_decl>struct <name>Info</name>;</struct_decl> </block_content>}</block></decl></decl_stmt>




<struct>struct <name>TransferrableTargetInfo</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>PointerWidth</name></decl>, <decl><type ref="prev"/><name>PointerAlign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>BoolWidth</name></decl>, <decl><type ref="prev"/><name>BoolAlign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>IntWidth</name></decl>, <decl><type ref="prev"/><name>IntAlign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>HalfWidth</name></decl>, <decl><type ref="prev"/><name>HalfAlign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>BFloat16Width</name></decl>, <decl><type ref="prev"/><name>BFloat16Align</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>FloatWidth</name></decl>, <decl><type ref="prev"/><name>FloatAlign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>DoubleWidth</name></decl>, <decl><type ref="prev"/><name>DoubleAlign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>LongDoubleWidth</name></decl>, <decl><type ref="prev"/><name>LongDoubleAlign</name></decl>, <decl><type ref="prev"/><name>Float128Align</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>LargeArrayMinWidth</name></decl>, <decl><type ref="prev"/><name>LargeArrayAlign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>LongWidth</name></decl>, <decl><type ref="prev"/><name>LongAlign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>LongLongWidth</name></decl>, <decl><type ref="prev"/><name>LongLongAlign</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>ShortAccumWidth</name></decl>, <decl><type ref="prev"/><name>ShortAccumAlign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>AccumWidth</name></decl>, <decl><type ref="prev"/><name>AccumAlign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>LongAccumWidth</name></decl>, <decl><type ref="prev"/><name>LongAccumAlign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>ShortFractWidth</name></decl>, <decl><type ref="prev"/><name>ShortFractAlign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>FractWidth</name></decl>, <decl><type ref="prev"/><name>FractAlign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>LongFractWidth</name></decl>, <decl><type ref="prev"/><name>LongFractAlign</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>bool</name></type> <name>PaddingOnUnsignedFixedPoint</name></decl>;</decl_stmt>








<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>ShortAccumScale</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>AccumScale</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>LongAccumScale</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>SuitableAlign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>DefaultAlignForAttributeAligned</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>MinGlobalAlign</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>NewAlign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>MaxVectorAlign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>MaxTLSAlign</name></decl>;</decl_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>fltSemantics</name> <operator>*</operator><name>HalfFormat</name></expr><operator>,</operator> <expr><operator>*</operator><name>BFloat16Format</name></expr><operator>,</operator> <expr><operator>*</operator><name>FloatFormat</name></expr><operator>,</operator>
<expr><operator>*</operator><name>DoubleFormat</name></expr><operator>,</operator> <expr><operator>*</operator><name>LongDoubleFormat</name></expr><operator>,</operator> <expr><operator>*</operator><name>Float128Format</name></expr>;</expr_stmt>


<enum>enum <name>IntType</name> <block>{
<decl><name>NoInt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>SignedChar</name></decl>,
<decl><name>UnsignedChar</name></decl>,
<decl><name>SignedShort</name></decl>,
<decl><name>UnsignedShort</name></decl>,
<decl><name>SignedInt</name></decl>,
<decl><name>UnsignedInt</name></decl>,
<decl><name>SignedLong</name></decl>,
<decl><name>UnsignedLong</name></decl>,
<decl><name>SignedLongLong</name></decl>,
<decl><name>UnsignedLongLong</name></decl>
}</block>;</enum>

<enum>enum <name>RealType</name> <block>{
<decl><name>NoFloat</name> <init>= <expr><literal type="number">255</literal></expr></init></decl>,
<decl><name>Float</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>Double</name></decl>,
<decl><name>LongDouble</name></decl>,
<decl><name>Float128</name></decl>
}</block>;</enum>
<label><name>protected</name>:</label>
<decl_stmt><decl><type><name>IntType</name></type> <name>SizeType</name></decl>, <decl><type ref="prev"/><name>IntMaxType</name></decl>, <decl><type ref="prev"/><name>PtrDiffType</name></decl>, <decl><type ref="prev"/><name>IntPtrType</name></decl>, <decl><type ref="prev"/><name>WCharType</name></decl>, <decl><type ref="prev"/><name>WIntType</name></decl>,
<decl><type ref="prev"/><name>Char16Type</name></decl>, <decl><type ref="prev"/><name>Char32Type</name></decl>, <decl><type ref="prev"/><name>Int64Type</name></decl>, <decl><type ref="prev"/><name>Int16Type</name></decl>, <decl><type ref="prev"/><name>SigAtomicType</name></decl>,
<decl><type ref="prev"/><name>ProcessIDType</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>unsigned</name></type> <name>UseSignedCharForObjCBool</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>






<decl_stmt><decl><type><name>unsigned</name></type> <name>UseBitFieldTypeAlignment</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>







<decl_stmt><decl><type><name>unsigned</name></type> <name>UseZeroLengthBitfieldAlignment</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>UseLeadingZeroLengthBitfield</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>UseExplicitBitFieldAlignment</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>ZeroLengthBitfieldBoundary</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>MaxAlignedAttribute</name></decl>;</decl_stmt>
}</block>;</struct>


<enum>enum <name>OpenCLTypeKind</name> : <type><name>uint8_t</name></type> <block>{
<decl><name>OCLTK_Default</name></decl>,
<decl><name>OCLTK_ClkEvent</name></decl>,
<decl><name>OCLTK_Event</name></decl>,
<decl><name>OCLTK_Image</name></decl>,
<decl><name>OCLTK_Pipe</name></decl>,
<decl><name>OCLTK_Queue</name></decl>,
<decl><name>OCLTK_ReserveID</name></decl>,
<decl><name>OCLTK_Sampler</name></decl>,
}</block>;</enum>



<decl_stmt><decl><type><name>class</name></type> <name>TargetInfo</name> <range>: <expr><name>public</name> <name>virtual</name> <name>TransferrableTargetInfo</name></expr></range></decl>,
<decl><type ref="prev"/><name>public</name> <name><name>RefCountedBase</name><argument_list type="generic">&lt;<argument><expr><name>TargetInfo</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>TargetOptions</name></expr></argument>&gt;</argument_list></name> <name>TargetOpts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Triple</name> <name>Triple</name></expr>;</expr_stmt>
<label><name>protected</name>:</label>


<decl_stmt><decl><type><name>bool</name></type> <name>BigEndian</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>TLSSupported</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>VLASupported</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>NoAsmVariants</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>HasLegalHalfType</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>HasFloat128</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>HasFloat16</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>HasBFloat16</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>HasStrictFP</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>MaxAtomicPromoteWidth</name></decl>, <decl><type ref="prev"/><name>MaxAtomicInlineWidth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>SimdDefaultAlign</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>DataLayoutString</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>UserLabelPrefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>MCountName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>RegParmMax</name></decl>, <decl><type ref="prev"/><name>SSERegParmMax</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TargetCXXABI</name></type> <name>TheCXXABI</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>LangASMap</name> <modifier>*</modifier></type><name>AddrSpaceMap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <modifier>*</modifier></type><name>GridValues</name> <init>=
<expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>mutable</name> <name>StringRef</name></type> <name>PlatformName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mutable</name> <name>VersionTuple</name></type> <name>PlatformMinVersion</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>HasAlignMac68kSupport</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>RealTypeUsesObjCFPRet</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ComplexLongDoubleUsesFP2Ret</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>HasBuiltinMSVaList</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>IsRenderScriptTarget</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>HasAArch64SVETypes</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>HasRISCVVTypes</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>AllowAMDGPUUnsafeFPAtomics</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>ARMCDECoprocMask</name> <range>: <expr><literal type="number">8</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>MaxOpenCLWorkGroupSize</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>TargetInfo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>Triple</name> <operator>&amp;</operator><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<function_decl><type><name>void</name></type> <name>resetDataLayout</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>DL</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>UserLabelPrefix</name> <init>= <expr><literal type="string">""</literal></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>





<decl_stmt><decl><type><specifier>static</specifier> <name>TargetInfo</name> <modifier>*</modifier></type>
<name>CreateTargetInfo</name><argument_list>(<argument><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diags</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>TargetOptions</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Opts</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>TargetInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>TargetOptions</name> <operator>&amp;</operator><macro><name>getTargetOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>TargetOpts</name> <operator>&amp;&amp;</operator> <literal type="string">"Missing target options"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>TargetOpts</name></expr>;</return>
}</block></expr></expr_stmt>



<enum>enum <name>BuiltinVaListKind</name> <block>{

<decl><name>CharPtrBuiltinVaList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,


<decl><name>VoidPtrBuiltinVaList</name></decl>,



<decl><name>AArch64ABIBuiltinVaList</name></decl>,



<decl><name>PNaClABIBuiltinVaList</name></decl>,




<decl><name>PowerABIBuiltinVaList</name></decl>,



<decl><name>X86_64ABIBuiltinVaList</name></decl>,




<decl><name>AAPCSABIBuiltinVaList</name></decl>,








<decl><name>SystemZBuiltinVaList</name></decl>,






<decl><name>HexagonBuiltinVaList</name></decl>
}</block>;</enum>

<label><name>protected</name>:</label>


<decl_stmt><decl><type><name>bool</name></type> <name>UseAddrSpaceMapMangling</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><name>IntType</name> <macro><name>getSizeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SizeType</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>IntType</name> <macro><name>getSignedSizeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<switch>switch <condition>(<expr><name>SizeType</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>UnsignedShort</name></expr>:</case>
<return>return <expr><name>SignedShort</name></expr>;</return>
<case>case <expr><name>UnsignedInt</name></expr>:</case>
<return>return <expr><name>SignedInt</name></expr>;</return>
<case>case <expr><name>UnsignedLong</name></expr>:</case>
<return>return <expr><name>SignedLong</name></expr>;</return>
<case>case <expr><name>UnsignedLongLong</name></expr>:</case>
<return>return <expr><name>SignedLongLong</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Invalid SizeType"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}
IntType getIntMaxType(</block></switch>) <specifier>const</specifier> <block>{ <return>return <expr><name>IntMaxType</name></expr>;</return> }</block>
<name>IntType</name> <macro><name>getUIntMaxType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCorrespondingUnsignedType</name><argument_list>(<argument><expr><name>IntMaxType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>IntType</name> <macro><name>getPtrDiffType</name><argument_list>(<argument>unsigned AddrSpace</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>AddrSpace</name> <operator>==</operator> <literal type="number">0</literal> <operator>?</operator> <name>PtrDiffType</name> <operator>:</operator> <call><name>getPtrDiffTypeV</name><argument_list>(<argument><expr><name>AddrSpace</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>IntType</name> <macro><name>getUnsignedPtrDiffType</name><argument_list>(<argument>unsigned AddrSpace</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCorrespondingUnsignedType</name><argument_list>(<argument><expr><call><name>getPtrDiffType</name><argument_list>(<argument><expr><name>AddrSpace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>IntType</name> <macro><name>getIntPtrType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IntPtrType</name></expr>;</return> }</block>
<name>IntType</name> <macro><name>getUIntPtrType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCorrespondingUnsignedType</name><argument_list>(<argument><expr><name>IntPtrType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>IntType</name> <macro><name>getWCharType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>WCharType</name></expr>;</return> }</block>
<name>IntType</name> <macro><name>getWIntType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>WIntType</name></expr>;</return> }</block>
<name>IntType</name> <macro><name>getChar16Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Char16Type</name></expr>;</return> }</block>
<name>IntType</name> <macro><name>getChar32Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Char32Type</name></expr>;</return> }</block>
<name>IntType</name> <macro><name>getInt64Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Int64Type</name></expr>;</return> }</block>
<name>IntType</name> <macro><name>getUInt64Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCorrespondingUnsignedType</name><argument_list>(<argument><expr><name>Int64Type</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>IntType</name> <macro><name>getInt16Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Int16Type</name></expr>;</return> }</block>
<name>IntType</name> <macro><name>getUInt16Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCorrespondingUnsignedType</name><argument_list>(<argument><expr><name>Int16Type</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>IntType</name> <macro><name>getSigAtomicType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SigAtomicType</name></expr>;</return> }</block>
<name>IntType</name> <macro><name>getProcessIDType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ProcessIDType</name></expr>;</return> }</block>

<specifier>static</specifier> <name>IntType</name> <macro><name>getCorrespondingUnsignedType</name><argument_list>(<argument>IntType T</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><name>T</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SignedChar</name></expr>:</case>
<return>return <expr><name>UnsignedChar</name></expr>;</return>
<case>case <expr><name>SignedShort</name></expr>:</case>
<return>return <expr><name>UnsignedShort</name></expr>;</return>
<case>case <expr><name>SignedInt</name></expr>:</case>
<return>return <expr><name>UnsignedInt</name></expr>;</return>
<case>case <expr><name>SignedLong</name></expr>:</case>
<return>return <expr><name>UnsignedLong</name></expr>;</return>
<case>case <expr><name>SignedLongLong</name></expr>:</case>
<return>return <expr><name>UnsignedLongLong</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Unexpected signed integer type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}





bool doUnsignedFixedPointTypesHavePadding(</block></switch>) <specifier>const</specifier> <block>{
<return>return <expr><name>PaddingOnUnsignedFixedPoint</name></expr>;</return>
}</block>




<name>unsigned</name> <macro><name>getTypeWidth</name><argument_list>(<argument>IntType T</argument>)</argument_list></macro> <specifier>const</specifier></block></block></expr>;</expr_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>IntType</name></type> <name>getIntTypeByWidth</name><argument_list>(<argument><expr><name>unsigned</name> <name>BitWidth</name></expr></argument>, <argument><expr><name>bool</name> <name>IsSigned</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>IntType</name></type> <name>getLeastIntTypeByWidth</name><argument_list>(<argument><expr><name>unsigned</name> <name>BitWidth</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsSigned</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>







<decl_stmt><decl><type><name>RealType</name></type> <name>getRealTypeByWidth</name><argument_list>(<argument><expr><name>unsigned</name> <name>BitWidth</name></expr></argument>, <argument><expr><name>bool</name> <name>ExplicitIEEE</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>getTypeAlign</name><argument_list>(<argument><expr><name>IntType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isTypeSigned</name><parameter_list>(<parameter><decl><type><name>IntType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>getPointerWidth</name><argument_list>(<argument><expr><name>unsigned</name> <name>AddrSpace</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><ternary><condition><expr><name>AddrSpace</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>PointerWidth</name></expr> </then><else>: <expr><call><name>getPointerWidthV</name><argument_list>(<argument><expr><name>AddrSpace</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>getPointerAlign</name><argument_list>(<argument><expr><name>unsigned</name> <name>AddrSpace</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><ternary><condition><expr><name>AddrSpace</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>PointerAlign</name></expr> </then><else>: <expr><call><name>getPointerAlignV</name><argument_list>(<argument><expr><name>AddrSpace</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name>virtual</name> <name>uint64_t</name> <macro><name>getMaxPointerWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PointerWidth</name></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>uint64_t</name></type> <name>getNullPointerValue</name><argument_list>(<argument><expr><name>LangAS</name> <name>AddrSpace</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getBoolWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BoolWidth</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getBoolAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BoolAlign</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>getCharWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><literal type="number">8</literal></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getCharAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><literal type="number">8</literal></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getShortWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><literal type="number">16</literal></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getShortAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><literal type="number">16</literal></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getIntWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IntWidth</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getIntAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IntAlign</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getLongWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LongWidth</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getLongAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LongAlign</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getLongLongWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LongLongWidth</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getLongLongAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LongLongAlign</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getShortAccumWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ShortAccumWidth</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getShortAccumAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ShortAccumAlign</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getAccumWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AccumWidth</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getAccumAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AccumAlign</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getLongAccumWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LongAccumWidth</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getLongAccumAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LongAccumAlign</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getShortFractWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ShortFractWidth</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getShortFractAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ShortFractAlign</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getFractWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FractWidth</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getFractAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FractAlign</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getLongFractWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LongFractWidth</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getLongFractAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LongFractAlign</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getShortAccumScale</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ShortAccumScale</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getShortAccumIBits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ShortAccumWidth</name> <operator>-</operator> <name>ShortAccumScale</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getAccumScale</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AccumScale</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getAccumIBits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AccumWidth</name> <operator>-</operator> <name>AccumScale</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getLongAccumScale</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LongAccumScale</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getLongAccumIBits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>LongAccumWidth</name> <operator>-</operator> <name>LongAccumScale</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getUnsignedShortAccumScale</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PaddingOnUnsignedFixedPoint</name> <operator>?</operator> <name>ShortAccumScale</name> <operator>:</operator> <name>ShortAccumScale</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getUnsignedShortAccumIBits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PaddingOnUnsignedFixedPoint</name>
<operator>?</operator> <call><name>getShortAccumIBits</name><argument_list>()</argument_list></call>
<operator>:</operator> <name>ShortAccumWidth</name> <operator>-</operator> <call><name>getUnsignedShortAccumScale</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getUnsignedAccumScale</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PaddingOnUnsignedFixedPoint</name> <operator>?</operator> <name>AccumScale</name> <operator>:</operator> <name>AccumScale</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getUnsignedAccumIBits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PaddingOnUnsignedFixedPoint</name> <operator>?</operator> <call><name>getAccumIBits</name><argument_list>()</argument_list></call>
<operator>:</operator> <name>AccumWidth</name> <operator>-</operator> <call><name>getUnsignedAccumScale</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getUnsignedLongAccumScale</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PaddingOnUnsignedFixedPoint</name> <operator>?</operator> <name>LongAccumScale</name> <operator>:</operator> <name>LongAccumScale</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getUnsignedLongAccumIBits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PaddingOnUnsignedFixedPoint</name>
<operator>?</operator> <call><name>getLongAccumIBits</name><argument_list>()</argument_list></call>
<operator>:</operator> <name>LongAccumWidth</name> <operator>-</operator> <call><name>getUnsignedLongAccumScale</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getShortFractScale</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ShortFractWidth</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getFractScale</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FractWidth</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getLongFractScale</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LongFractWidth</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getUnsignedShortFractScale</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PaddingOnUnsignedFixedPoint</name> <operator>?</operator> <call><name>getShortFractScale</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>getShortFractScale</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getUnsignedFractScale</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PaddingOnUnsignedFixedPoint</name> <operator>?</operator> <call><name>getFractScale</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>getFractScale</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getUnsignedLongFractScale</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PaddingOnUnsignedFixedPoint</name> <operator>?</operator> <call><name>getLongFractScale</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>getLongFractScale</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>hasInt128Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>getPointerWidth</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">64</literal><operator>)</operator> <operator>||</operator> <call><name>getTargetOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>ForceEnableInt128</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>hasExtIntType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>false</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>hasLegalHalfType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasLegalHalfType</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>hasFloat128Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasFloat128</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>hasFloat16Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasFloat16</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>hasBFloat16Type</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasBFloat16</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>hasStrictFP</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasStrictFP</name></expr>;</return> }</block></expr></expr_stmt>




<expr_stmt><expr><name>unsigned</name> <macro><name>getSuitableAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SuitableAlign</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getDefaultAlignForAttributeAligned</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>DefaultAlignForAttributeAligned</name></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>unsigned</name></type> <name>getMinGlobalAlign</name> <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>MinGlobalAlign</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<expr_stmt><expr><name>unsigned</name> <macro><name>getNewAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NewAlign</name> <operator>?</operator> <name>NewAlign</name> <operator>:</operator> <name>std</name><operator>::</operator><call><name>max</name><argument_list>(<argument><expr><name>LongDoubleAlign</name></expr></argument>, <argument><expr><name>LongLongAlign</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getWCharWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTypeWidth</name><argument_list>(<argument><expr><name>WCharType</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getWCharAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTypeAlign</name><argument_list>(<argument><expr><name>WCharType</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getChar16Width</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTypeWidth</name><argument_list>(<argument><expr><name>Char16Type</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getChar16Align</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTypeAlign</name><argument_list>(<argument><expr><name>Char16Type</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getChar32Width</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTypeWidth</name><argument_list>(<argument><expr><name>Char32Type</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getChar32Align</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTypeAlign</name><argument_list>(<argument><expr><name>Char32Type</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getHalfWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HalfWidth</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getHalfAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HalfAlign</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>fltSemantics</name> <operator>&amp;</operator><macro><name>getHalfFormat</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>HalfFormat</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getFloatWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FloatWidth</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getFloatAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FloatAlign</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>fltSemantics</name> <operator>&amp;</operator><macro><name>getFloatFormat</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>FloatFormat</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getBFloat16Width</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BFloat16Width</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getBFloat16Align</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BFloat16Align</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>fltSemantics</name> <operator>&amp;</operator><macro><name>getBFloat16Format</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>BFloat16Format</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getDoubleWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DoubleWidth</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getDoubleAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DoubleAlign</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>fltSemantics</name> <operator>&amp;</operator><macro><name>getDoubleFormat</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>DoubleFormat</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getLongDoubleWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LongDoubleWidth</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getLongDoubleAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LongDoubleAlign</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>fltSemantics</name> <operator>&amp;</operator><macro><name>getLongDoubleFormat</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>*</operator><name>LongDoubleFormat</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getFloat128Width</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><literal type="number">128</literal></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getFloat128Align</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Float128Align</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>fltSemantics</name> <operator>&amp;</operator><macro><name>getFloat128Format</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>*</operator><name>Float128Format</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>virtual</name> <specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getLongDoubleMangling</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><literal type="string">"e"</literal></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>virtual</name> <specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getFloat128Mangling</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><literal type="string">"g"</literal></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>virtual</name> <specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getBFloat16Mangling</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"bfloat not implemented on this target"</literal></expr></argument>)</argument_list></call></expr>;
}</block>


<name>virtual</name> <name>unsigned</name> <macro><name>getFloatEvalMethod</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getLargeArrayMinWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LargeArrayMinWidth</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getLargeArrayAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LargeArrayAlign</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getMaxAtomicPromoteWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MaxAtomicPromoteWidth</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getMaxAtomicInlineWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MaxAtomicInlineWidth</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>virtual</name> <name>void</name></type> <name>setMaxAtomicWidth</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>


<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>hasBuiltinAtomic</name><argument_list>(<argument><expr><name>uint64_t</name> <name>AtomicSizeInBits</name></expr></argument>,
<argument><expr><name>uint64_t</name> <name>AlignmentInBits</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>AtomicSizeInBits</name> <operator>&lt;=</operator> <name>AlignmentInBits</name> <operator>&amp;&amp;</operator>
<name>AtomicSizeInBits</name> <operator>&lt;=</operator> <call><name>getMaxAtomicInlineWidth</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><name>AtomicSizeInBits</name> <operator>&lt;=</operator> <call><name>getCharWidth</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>llvm</name><operator>::</operator><call><name>isPowerOf2_64</name><argument_list>(<argument><expr><name>AtomicSizeInBits</name> <operator>/</operator> <call><name>getCharWidth</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getMaxVectorAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MaxVectorAlign</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getSimdDefaultAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SimdDefaultAlign</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>getMaxOpenCLWorkGroupSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MaxOpenCLWorkGroupSize</name></expr>;</return> }</block></expr></expr_stmt>




<expr_stmt><expr><name>virtual</name> <name>unsigned</name> <macro><name>getExnObjectAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{








<return>return <expr><call><name>getDefaultAlignForAttributeAligned</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getIntMaxTWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypeWidth</name><argument_list>(<argument><expr><name>IntMaxType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>virtual</name> <name>unsigned</name> <macro><name>getUnwindWordWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getPointerWidth</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>virtual</name> <name>unsigned</name> <macro><name>getRegisterWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{



<return>return <expr><name>PointerWidth</name></expr>;</return>
}</block></expr></expr_stmt>





<expr_stmt><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getUserLabelPrefix</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>UserLabelPrefix</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getMCountName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>MCountName</name></expr>;</return>
}</block></expr></expr_stmt>






<expr_stmt><expr><name>bool</name> <macro><name>useSignedCharForObjCBool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>UseSignedCharForObjCBool</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>noSignedCharForObjCBool</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>UseSignedCharForObjCBool</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>useBitFieldTypeAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>UseBitFieldTypeAlignment</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>useZeroLengthBitfieldAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>UseZeroLengthBitfieldAlignment</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>useLeadingZeroLengthBitfield</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>UseLeadingZeroLengthBitfield</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getZeroLengthBitfieldBoundary</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ZeroLengthBitfieldBoundary</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getMaxAlignedAttribute</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MaxAlignedAttribute</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>useExplicitBitFieldAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>UseExplicitBitFieldAlignment</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasAlignMac68kSupport</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>HasAlignMac68kSupport</name></expr>;</return>
}</block></expr></expr_stmt>




<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getTypeName</name><parameter_list>(<parameter><decl><type><name>IntType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getTypeConstantSuffix</name><argument_list>(<argument><expr><name>IntType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getTypeFormatModifier</name><parameter_list>(<parameter><decl><type><name>IntType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>bool</name></type> <name>useObjCFPRetForRealType</name><argument_list>(<argument><expr><name>RealType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>RealTypeUsesObjCFPRet</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>T</name><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>useObjCFP2RetForComplexLongDouble</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ComplexLongDoubleUsesFP2Ret</name></expr>;</return>
}</block></expr></expr_stmt>





<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>useFP16ConversionIntrinsics</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>useAddressSpaceMapMangling</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>UseAddrSpaceMapMangling</name></expr>;</return>
}</block></expr></expr_stmt>





<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>getTargetDefines</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><name>Opts</name></expr></argument>,
<argument><expr><name>MacroBuilder</name> <operator>&amp;</operator><name>Builder</name></expr></argument>)</argument_list> const <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>





<expr_stmt><expr><name>virtual</name> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Builtin</name><operator>::</operator><name>Info</name></expr></argument>&gt;</argument_list></name> <macro><name>getTargetBuiltins</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>






<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>isCLZForZeroUndef</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>virtual</name> <name>BuiltinVaListKind</name> <macro><name>getBuiltinVaListKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasBuiltinMSVaList</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasBuiltinMSVaList</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isRenderScriptTarget</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsRenderScriptTarget</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasAArch64SVETypes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasAArch64SVETypes</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasRISCVVTypes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasRISCVVTypes</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>allowAMDGPUUnsafeFPAtomics</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AllowAMDGPUUnsafeFPAtomics</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>uint32_t</name> <macro><name>getARMCDECoprocMask</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ARMCDECoprocMask</name></expr>;</return> }</block></expr></expr_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>isValidClobber</name><argument_list>(<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>isValidGCCRegisterName</name><argument_list>(<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<decl_stmt><decl><type><name>StringRef</name></type> <name>getNormalizedGCCRegisterName</name><argument_list>(<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>,
<argument><expr><name>bool</name> <name>ReturnCanonical</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>isSPRegName</name><argument_list>(<argument><expr><name>StringRef</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><name>false</name></expr>;</return> </block_content>}</block></decl></decl_stmt>







<decl_stmt><decl><type><name>virtual</name> <name>StringRef</name></type> <name>getConstraintRegister</name><argument_list>(<argument><expr><name>StringRef</name> <name>Constraint</name></expr></argument>,
<argument><expr><name>StringRef</name> <name>Expression</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><literal type="string">""</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<struct>struct <name>ConstraintInfo</name> <block>{
<enum>enum <block>{
<decl><name>CI_None</name> <init>= <expr><literal type="number">0x00</literal></expr></init></decl>,
<decl><name>CI_AllowsMemory</name> <init>= <expr><literal type="number">0x01</literal></expr></init></decl>,
<decl><name>CI_AllowsRegister</name> <init>= <expr><literal type="number">0x02</literal></expr></init></decl>,
<decl><name>CI_ReadWrite</name> <init>= <expr><literal type="number">0x04</literal></expr></init></decl>,
<decl><name>CI_HasMatchingInput</name> <init>= <expr><literal type="number">0x08</literal></expr></init></decl>,
<decl><name>CI_ImmediateConstant</name> <init>= <expr><literal type="number">0x10</literal></expr></init></decl>,
<decl><name>CI_EarlyClobber</name> <init>= <expr><literal type="number">0x20</literal></expr></init></decl>,
}</block>;</enum>
<decl_stmt><decl><type><name>unsigned</name></type> <name>Flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>TiedOperand</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>Min</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>Max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isConstrained</name></decl>;</decl_stmt>
}</block> <decl><name>ImmRange</name></decl>;</struct>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallSet</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>ImmSet</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>ConstraintStr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>Name</name></expr>;</expr_stmt>
<label><name>public</name>:</label>
<macro><name>ConstraintInfo</name><argument_list>(<argument>StringRef ConstraintStr</argument>, <argument>StringRef Name</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Flags</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>TiedOperand</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ConstraintStr</name><argument_list>(<argument><expr><call><name><name>ConstraintStr</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>Name</name><argument_list>(<argument>Name.str()</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>ImmRange</name><operator>.</operator><name>Min</name></name> <operator>=</operator> <name><name>ImmRange</name><operator>.</operator><name>Max</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name><name>ImmRange</name><operator>.</operator><name>isConstrained</name></name> <operator>=</operator> <name>false</name></expr>;
}</block>

<specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><macro><name>getConstraintStr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ConstraintStr</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><macro><name>getName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Name</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isReadWrite</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>Flags</name> <operator>&amp;</operator> <name>CI_ReadWrite</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>bool</name></type> <name>earlyClobber</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>Flags</name> <operator>&amp;</operator> <name>CI_EarlyClobber</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><name>bool</name> <macro><name>allowsRegister</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>Flags</name> <operator>&amp;</operator> <name>CI_AllowsRegister</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>allowsMemory</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>Flags</name> <operator>&amp;</operator> <name>CI_AllowsMemory</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasMatchingInput</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>Flags</name> <operator>&amp;</operator> <name>CI_HasMatchingInput</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>






<expr_stmt><expr><name>bool</name> <macro><name>hasTiedOperand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TiedOperand</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getTiedOperand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasTiedOperand</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Has no tied operand!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>TiedOperand</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>requiresImmediateConstant</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>Flags</name> <operator>&amp;</operator> <name>CI_ImmediateConstant</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
}</block></expr></expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isValidAsmImmediate</name><argument_list>(<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>APInt</name> <operator>&amp;</operator><name>Value</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>ImmSet</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>isSignedIntN</name></name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>ImmSet</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><call><name><name>Value</name><operator>.</operator><name>getZExtValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>!</operator><name><name>ImmRange</name><operator>.</operator><name>isConstrained</name></name> <operator>||</operator>
<operator>(</operator><call><name><name>Value</name><operator>.</operator><name>sge</name></name><argument_list>(<argument><expr><name><name>ImmRange</name><operator>.</operator><name>Min</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Value</name><operator>.</operator><name>sle</name></name><argument_list>(<argument><expr><name><name>ImmRange</name><operator>.</operator><name>Max</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type> <name>setIsReadWrite</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Flags</name> <operator>|=</operator> <name>CI_ReadWrite</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setEarlyClobber</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Flags</name> <operator>|=</operator> <name>CI_EarlyClobber</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setAllowsMemory</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Flags</name> <operator>|=</operator> <name>CI_AllowsMemory</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setAllowsRegister</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Flags</name> <operator>|=</operator> <name>CI_AllowsRegister</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setHasMatchingInput</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Flags</name> <operator>|=</operator> <name>CI_HasMatchingInput</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setRequiresImmediate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>Min</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>Max</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Flags</name> <operator>|=</operator> <name>CI_ImmediateConstant</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ImmRange</name><operator>.</operator><name>Min</name></name> <operator>=</operator> <name>Min</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ImmRange</name><operator>.</operator><name>Max</name></name> <operator>=</operator> <name>Max</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ImmRange</name><operator>.</operator><name>isConstrained</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>
<decl_stmt><decl><type><name>void</name></type> <name>setRequiresImmediate</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <name>Exacts</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name>Flags</name> <operator>|=</operator> <name>CI_ImmediateConstant</name></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>Exact</name> <range>: <expr><name>Exacts</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>ImmSet</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>Exact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></decl></decl_stmt>
<function><type><name>void</name></type> <name>setRequiresImmediate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>Exact</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Flags</name> <operator>|=</operator> <name>CI_ImmediateConstant</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ImmSet</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>Exact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setRequiresImmediate</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Flags</name> <operator>|=</operator> <name>CI_ImmediateConstant</name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>setTiedOperand</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>N</name></decl></parameter>, <parameter><decl><type><name>ConstraintInfo</name> <modifier>&amp;</modifier></type><name>Output</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>Output</name><operator>.</operator><name>setHasMatchingInput</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Flags</name> <operator>=</operator> <name><name>Output</name><operator>.</operator><name>Flags</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>TiedOperand</name> <operator>=</operator> <name>N</name></expr>;</expr_stmt>

</block_content>}</block></function>
}</block>;</struct>







<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>validateGlobalRegisterVariable</name><argument_list>(<argument><expr><name>StringRef</name> <name>RegName</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>RegSize</name></expr></argument>,
<argument><expr><name>bool</name> <operator>&amp;</operator><name>HasSizeMismatch</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><name>HasSizeMismatch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>validateOutputConstraint</name><argument_list>(<argument><expr><name>ConstraintInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>validateInputConstraint</name><argument_list>(<argument><expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ConstraintInfo</name></expr></argument>&gt;</argument_list></name> <name>OutputConstraints</name></expr></argument>,
<argument><expr><name>ConstraintInfo</name> <operator>&amp;</operator><name>info</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>validateOutputSize</name><argument_list>(<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>FeatureMap</name></expr></argument>,
<argument><expr><name>StringRef</name></expr></argument> ,
<argument><expr><name>unsigned</name></expr></argument> )</argument_list> const <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>validateInputSize</name><argument_list>(<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>FeatureMap</name></expr></argument>,
<argument><expr><name>StringRef</name></expr></argument> ,
<argument><expr><name>unsigned</name></expr></argument> )</argument_list> const <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type>
<name>validateConstraintModifier</name><argument_list>(<argument><expr><name>StringRef</name></expr></argument> ,
<argument><expr><name>char</name></expr></argument> ,
<argument><expr><name>unsigned</name></expr></argument> ,
<argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type>
<name>validateAsmConstraint</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>&amp;</operator><name>Name</name></expr></argument>,
<argument><expr><name>TargetInfo</name><operator>::</operator><name>ConstraintInfo</name> <operator>&amp;</operator><name>info</name></expr></argument>)</argument_list> const <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>resolveSymbolicName</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>&amp;</operator><name>Name</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ConstraintInfo</name></expr></argument>&gt;</argument_list></name> <name>OutputConstraints</name></expr></argument>,
<argument><expr><name>unsigned</name> <operator>&amp;</operator><name>Index</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<expr_stmt><expr><name>virtual</name> <name>std</name><operator>::</operator><name>string</name> <macro><name>convertConstraint</name><argument_list>(<argument>const char *&amp;Constraint</argument>)</argument_list></macro> <specifier>const</specifier> <block>{

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>Constraint</name> <operator>==</operator> <literal type="char">'p'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>*</operator><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <macro><name>handleAsmEscapedChar</name><argument_list>(<argument>char C</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><name>None</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>virtual</name> <specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getClobbers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>



<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>isNan2008</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>Triple</name> <operator>&amp;</operator><macro><name>getTriple</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Triple</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <macro><name>getTargetID</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>llvm</name><operator>::</operator><name>None</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getDataLayoutString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>DataLayoutString</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Uninitialized DataLayout!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>DataLayoutString</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<struct>struct <name>GCCRegAlias</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>Aliases</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>Register</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>AddlRegName</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>Names</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>RegNum</name></decl>;</decl_stmt>
}</block>;</struct>











<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>hasProtectedVisibility</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>shouldDLLImportComdatSymbols</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTriple</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isWindowsMSVCEnvironment</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name>getTriple</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isWindowsItaniumEnvironment</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>getTriple</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isPS4CPU</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>hasPS4DLLImportExport</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTriple</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isPS4CPU</name><argument_list>()</argument_list></call> <operator>||</operator>


<operator>(</operator><call><name>getTriple</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isWindowsItaniumEnvironment</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>getTriple</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getVendor</name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator><name>Triple</name><operator>::</operator><name>SCEI</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>






<function_decl><type><name>virtual</name> <name>void</name></type> <name>adjust</name><parameter_list>(<parameter><decl><type><name>DiagnosticsEngine</name> <modifier>&amp;</modifier></type><name>Diags</name></decl></parameter>, <parameter><decl><type><name>LangOptions</name> <modifier>&amp;</modifier></type><name>Opts</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>adjustTargetOptions</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CodeGenOptions</name> <operator>&amp;</operator><name>CGOpts</name></expr></argument>,
<argument><expr><name>TargetOptions</name> <operator>&amp;</operator><name>TargetOpts</name></expr></argument>)</argument_list> const <block>{<block_content/>}</block></decl></decl_stmt>





<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>initFeatureMap</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Features</name></expr></argument>,
<argument><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diags</name></expr></argument>, <argument><expr><name>StringRef</name> <name>CPU</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>FeatureVec</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>virtual</name> <name>StringRef</name> <macro><name>getABI</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>StringRef</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>TargetCXXABI</name> <macro><name>getCXXABI</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TheCXXABI</name></expr>;</return>
}</block></expr></expr_stmt>




<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>setCPU</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>Name</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>fillValidCPUList</name><argument_list>(<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Values</name></expr></argument>)</argument_list> const <block>{<block_content/>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>fillValidTuneCPUList</name><argument_list>(<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Values</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>fillValidCPUList</name><argument_list>(<argument><expr><name>Values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>isValidCPUName</name><argument_list>(<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>isValidTuneCPUName</name><argument_list>(<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>isValidCPUName</name><argument_list>(<argument><expr><name>Name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>supportsTargetAttributeTune</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>false</name></expr>;</return>
}</block></expr></expr_stmt>




<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>setABI</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>Name</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<function><type><name>virtual</name> <name>bool</name></type> <name>setFPMath</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>hasFeatureEnabled</name><argument_list>(<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Features</name></expr></argument>,
<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>Features</name><operator>.</operator><name>lookup</name></name><argument_list>(<argument><expr><name>Name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>setFeatureEnabled</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Features</name></expr></argument>,
<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>,
<argument><expr><name>bool</name> <name>Enabled</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><name><name>Features</name><index>[<expr><name>Name</name></expr>]</index></name> <operator>=</operator> <name>Enabled</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>isValidFeatureName</name><argument_list>(<argument><expr><name>StringRef</name> <name>Feature</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<struct>struct <name>BranchProtectionInfo</name> <block>{
<expr_stmt><expr><name>LangOptions</name><operator>::</operator><name>SignReturnAddressScopeKind</name> <name>SignReturnAddr</name> <operator>=</operator>
<name>LangOptions</name><operator>::</operator><name>SignReturnAddressScopeKind</name><operator>::</operator><name>None</name></expr>;</expr_stmt>
<expr_stmt><expr><name>LangOptions</name><operator>::</operator><name>SignReturnAddressKeyKind</name> <name>SignKey</name> <operator>=</operator>
<name>LangOptions</name><operator>::</operator><name>SignReturnAddressKeyKind</name><operator>::</operator><name>AKey</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>BranchTargetEnforcement</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
}</block>;</struct>



<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>validateBranchProtection</name><argument_list>(<argument><expr><name>StringRef</name> <name>Spec</name></expr></argument>,
<argument><expr><name>BranchProtectionInfo</name> <operator>&amp;</operator><name>BPI</name></expr></argument>,
<argument><expr><name>StringRef</name> <operator>&amp;</operator><name>Err</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><name>Err</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>












<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>handleTargetFeatures</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Features</name></expr></argument>,
<argument><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diags</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>hasFeature</name><argument_list>(<argument><expr><name>StringRef</name> <name>Feature</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>supportsMultiVersioning</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTriple</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isX86</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>supportsIFunc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTriple</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isOSBinFormatELF</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>validateCpuSupports</name><argument_list>(<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><name>false</name></expr>;</return> </block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>unsigned</name></type> <name>multiVersionSortPriority</name><argument_list>(<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>validateCpuIs</name><argument_list>(<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><name>false</name></expr>;</return> </block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>validateCPUSpecificCPUDispatch</name><argument_list>(<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>char</name></type> <name>CPUSpecificManglingCharacter</name><argument_list>(<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(
<argument><expr><literal type="string">"cpu_specific Multiversioning not implemented on this target"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>getCPUSpecificCPUDispatchFeatures</name><argument_list>(
<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Features</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(
<argument><expr><literal type="string">"cpu_specific Multiversioning not implemented on this target"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name>virtual</name> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <macro><name>getCPUCacheLineSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>None</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getRegParmMax</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>RegParmMax</name> <operator>&lt;</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator> <literal type="string">"RegParmMax value is larger than AST can handle"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>RegParmMax</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isTLSSupported</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TLSSupported</name></expr>;</return>
}</block></expr></expr_stmt>





<expr_stmt><expr><name>unsigned</name> <macro><name>getMaxTLSAlign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MaxTLSAlign</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isVLASupported</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>VLASupported</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isSEHTrySupported</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTriple</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isOSWindows</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>getTriple</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isX86</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name>getTriple</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getArch</name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator><name>Triple</name><operator>::</operator><name>aarch64</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>







<expr_stmt><expr><name>bool</name> <macro><name>hasNoAsmVariants</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NoAsmVariants</name></expr>;</return>
}</block></expr></expr_stmt>





<decl_stmt><decl><type><name>virtual</name> <name>int</name></type> <name>getEHDataRegisterNumber</name><argument_list>(<argument><expr><name>unsigned</name> <name>RegNo</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name>virtual</name> <specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getStaticInitSectionSpecifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>LangASMap</name> <operator>&amp;</operator><macro><name>getAddressSpaceMap</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>AddrSpaceMap</name></expr>;</return> }</block></expr></expr_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>LangAS</name></type> <name>getOpenCLBuiltinAddressSpace</name><argument_list>(<argument><expr><name>unsigned</name> <name>AS</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getLangASFromTargetAS</name><argument_list>(<argument><expr><name>AS</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>LangAS</name></type> <name>getCUDABuiltinAddressSpace</name><argument_list>(<argument><expr><name>unsigned</name> <name>AS</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getLangASFromTargetAS</name><argument_list>(<argument><expr><name>AS</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>LangAS</name></expr></argument>&gt;</argument_list></name> <macro><name>getConstantAddressSpace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>LangAS</name><operator>::</operator><name>Default</name></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>getGridValue</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>GVIDX</name> <name>gv</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>GridValues</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator> <literal type="string">"GridValues not initialized"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>GridValues</name><index>[<expr><name>gv</name></expr>]</index></name></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name>StringRef</name> <macro><name>getPlatformName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PlatformName</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>VersionTuple</name> <macro><name>getPlatformMinVersion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PlatformMinVersion</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isBigEndian</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BigEndian</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isLittleEndian</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><name>BigEndian</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>supportsExtendIntArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>checkArithmeticFenceSupported</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>virtual</name> <name>CallingConv</name> <macro><name>getDefaultCallingConv</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{



<return>return <expr><name>CC_C</name></expr>;</return>
}</block></expr></expr_stmt>

<enum>enum <name>CallingConvCheckResult</name> <block>{
<decl><name>CCCR_OK</name></decl>,
<decl><name>CCCR_Warning</name></decl>,
<decl><name>CCCR_Ignore</name></decl>,
<decl><name>CCCR_Error</name></decl>,
}</block>;</enum>





<decl_stmt><decl><type><name>virtual</name> <name>CallingConvCheckResult</name></type> <name>checkCallingConvention</name><argument_list>(<argument><expr><name>CallingConv</name> <name>CC</name></expr></argument>)</argument_list> const <block>{<block_content>
<switch>switch <condition>(<expr><name>CC</name></expr>)</condition> <block>{<block_content>
<default>default:</default>
<return>return <expr><name>CCCR_Warning</name></expr>;</return>
<case>case <expr><name>CC_C</name></expr>:</case>
<return>return <expr><name>CCCR_OK</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></decl></decl_stmt>

<enum>enum <name>CallingConvKind</name> <block>{
<decl><name>CCK_Default</name></decl>,
<decl><name>CCK_ClangABI4OrPS4</name></decl>,
<decl><name>CCK_MicrosoftWin64</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><name>virtual</name> <name>CallingConvKind</name></type> <name>getCallingConvKind</name><argument_list>(<argument><expr><name>bool</name> <name>ClangABICompat4</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>hasSjLjLowering</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>false</name></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type>
<name>checkCFProtectionBranchSupported</name><argument_list>(<argument><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diags</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type>
<name>checkCFProtectionReturnSupported</name><argument_list>(<argument><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diags</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>allowsLargerPreferedTypeAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>defaultsToAIXPowerAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>virtual</name> <name>void</name></type> <name>setSupportedOpenCLOpts</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>

<function><type><name>virtual</name> <name>void</name></type> <name>supportAllOpenCLOpts</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>V</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPENCLEXTNAME</name><parameter_list>(<parameter><type><name>Ext</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>setFeatureEnabled(getTargetOpts().OpenCLFeaturesMap, #Ext, V);</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenCLExtensions.def"</cpp:file></cpp:include>
</block_content>}</block></function>


<function><type><name>virtual</name> <name>void</name></type> <name>setCommandLineOpenCLOpts</name><parameter_list>()</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>Ext</name> <range>: <expr><call><name>getTargetOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>OpenCLExtensionsAsWritten</name></expr></range></decl></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>IsPrefixed</name> <init>= <expr><operator>(</operator><name><name>Ext</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name><name>Ext</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>Name</name> <operator>=</operator> <ternary><condition><expr><name>IsPrefixed</name></expr> ?</condition><then> <expr><call><name><name>Ext</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>Ext</name></expr></else></ternary></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>V</name> <init>= <expr><ternary><condition><expr><name>IsPrefixed</name></expr> ?</condition><then> <expr><name><name>Ext</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>Name</name> <operator>==</operator> <literal type="string">"all"</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>supportAllOpenCLOpts</name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>getTargetOpts</name><argument_list>()</argument_list></call><operator>.</operator><name><name>OpenCLFeaturesMap</name><index>[<expr><name>Name</name></expr>]</index></name> <operator>=</operator> <name>V</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><macro><name>getSupportedOpenCLOpts</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>getTargetOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>OpenCLFeaturesMap</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><macro><name>getSupportedOpenCLOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTargetOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>OpenCLFeaturesMap</name></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>LangAS</name></type> <name>getOpenCLTypeAddrSpace</name><argument_list>(<argument><expr><name>OpenCLTypeKind</name> <name>TK</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>virtual</name> <name>unsigned</name> <macro><name>getVtblPtrAddressSpace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><literal type="number">0</literal></expr>;</return>
}</block></expr></expr_stmt>







<decl_stmt><decl><type><name>virtual</name> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>getDWARFAddressSpace</name><argument_list>(<argument><expr><name>unsigned</name> <name>AddressSpace</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>None</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>VersionTuple</name> <operator>&amp;</operator><macro><name>getSDKVersion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTargetOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>SDKVersion</name></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>validateTarget</name><argument_list>(<argument><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diags</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>validateOpenCLTarget</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><name>Opts</name></expr></argument>,
<argument><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diags</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function><type><name>virtual</name> <name>void</name></type> <name>setAuxTarget</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>*</modifier></type><name>Aux</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>


<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>allowDebugInfoForExternalRef</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>protected</name>:</label>

<function_decl><type><name>void</name></type> <name>copyAuxTarget</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>*</modifier></type><name>Aux</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>virtual</name> <name>uint64_t</name></type> <name>getPointerWidthV</name><argument_list>(<argument><expr><name>unsigned</name> <name>AddrSpace</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>PointerWidth</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>virtual</name> <name>uint64_t</name></type> <name>getPointerAlignV</name><argument_list>(<argument><expr><name>unsigned</name> <name>AddrSpace</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>PointerAlign</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>virtual</name> <name><name>enum</name> <name>IntType</name></name></type> <name>getPtrDiffTypeV</name><argument_list>(<argument><expr><name>unsigned</name> <name>AddrSpace</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>PtrDiffType</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<expr_stmt><expr><name>virtual</name> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getGCCRegNames</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>virtual</name> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>GCCRegAlias</name></expr></argument>&gt;</argument_list></name> <macro><name>getGCCRegAliases</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>virtual</name> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>AddlRegName</name></expr></argument>&gt;</argument_list></name> <macro><name>getGCCAddlRegNames</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>None</name></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>


<expr_stmt><expr><name>void</name> <macro><name>CheckFixedPointBits</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
