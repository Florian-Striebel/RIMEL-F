<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Sema/ScopeInfo.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_SEMA_SCOPEINFO_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_SEMA_SCOPEINFO_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/CapturedStmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/PartialDiagnostic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/CleanupInfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/DeclSpec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMapInfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/MapVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerIntPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallPtrSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringSwitch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/TinyPtrVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/ErrorHandling.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;algorithm&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>BlockDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CapturedDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXMethodDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXRecordDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ImplicitParamDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>NamedDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCIvarRefExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCMessageExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCPropertyDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCPropertyRefExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ParmVarDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>RecordDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ReturnStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Scope</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Stmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SwitchStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateParameterList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateTypeParmDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VarDecl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>sema</name> <block>{<block_content>



<decl_stmt><decl><type><name>class</name></type> <name>CompoundScopeInfo</name> <block>{<block_content>
<label><name>public</name>:</label>


<decl_stmt><decl><type><name>bool</name></type> <name>HasEmptyLoopBodies</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>IsStmtExpr</name></decl>;</decl_stmt>

<macro><name>CompoundScopeInfo</name><argument_list>(<argument>bool IsStmtExpr</argument>)</argument_list></macro> : <macro><name>IsStmtExpr</name><argument_list>(<argument>IsStmtExpr</argument>)</argument_list></macro> <block>{<block_content/>}</block>

<function><type><name>void</name></type> <name>setHasEmptyLoopBodies</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>HasEmptyLoopBodies</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>PossiblyUnreachableDiag</name> <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><name>PartialDiagnostic</name></type> <name>PD</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>TinyPtrVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Stmt</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Stmts</name></expr>;</expr_stmt>

<macro><name>PossiblyUnreachableDiag</name><argument_list>(<argument>const PartialDiagnostic &amp;PD</argument>, <argument>SourceLocation Loc</argument>,
<argument>ArrayRef&lt;const Stmt *&gt; Stmts</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>PD</name><argument_list>(<argument><expr><name>PD</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Loc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Stmts</name><argument_list>(<argument>Stmts</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>FunctionScopeInfo</name> <block>{<block_content>
<label><name>protected</name>:</label>
<enum>enum <name>ScopeKind</name> <block>{
<decl><name>SK_Function</name></decl>,
<decl><name>SK_Block</name></decl>,
<decl><name>SK_Lambda</name></decl>,
<decl><name>SK_CapturedRegion</name></decl>
}</block>;</enum>

<label><name>public</name>:</label>

<decl_stmt><decl><type><name>ScopeKind</name></type> <name>Kind</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>HasBranchProtectedScope</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>HasBranchIntoScope</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>HasIndirectGoto</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>HasMustTail</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>HasDroppedStmt</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>HasOMPDeclareReductionCombiner</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>HasFallthroughStmt</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>UsesFPIntrin</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>HasPotentialAvailabilityViolations</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>ObjCShouldCallSuper</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>ObjCIsDesignatedInit</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>ObjCWarnForNoDesignatedInitChain</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>ObjCIsSecondaryInit</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>ObjCWarnForNoInitDelegation</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>NeedsCoroutineSuspends</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>FirstCoroutineStmtKind</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>SourceLocation</name></type> <name>FirstCoroutineStmtLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>FirstReturnLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>FirstCXXTryLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>FirstSEHTryLoc</name></decl>;</decl_stmt>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>DiagnosticErrorTrap</name></type> <name>ErrorTrap</name></decl>;</decl_stmt>

<label><name>public</name>:</label>


<decl_stmt><decl><type><name>using</name></type> <name>SwitchInfo</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>SwitchStmt</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>SwitchInfo</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>SwitchStack</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ReturnStmt</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>Returns</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>CoroutinePromise</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallMapVector</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>CoroutineParameterMoves</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CoroutineSuspends</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>CompoundScopeInfo</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>CompoundScopes</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>BlockDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <name>Blocks</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>TinyPtrVector</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ByrefBlockVars</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>PossiblyUnreachableDiag</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>PossiblyUnreachableDiags</name></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ParmVarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>ModifiedNonNullParams</name></expr>;</expr_stmt>

<label><name>public</name>:</label>






















<decl_stmt><decl><type><name>class</name></type> <name>WeakObjectProfileTy</name> <block>{<block_content>






<decl_stmt><decl><type><name>using</name></type> <name>BaseInfoTy</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BaseInfoTy</name></type> <name>Base</name></decl>;</decl_stmt>





<decl_stmt><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>Property</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>BaseInfoTy</name></type> <name>getBaseInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>BaseE</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><specifier>inline</specifier> <call><name>WeakObjectProfileTy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>WeakObjectProfileTy</name></type> <name>getSentinel</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>WeakObjectProfileTy</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCPropertyRefExpr</name> <operator>*</operator><name>RE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>WeakObjectProfileTy</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>Base</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ObjCPropertyDecl</name> <operator>*</operator><name>Property</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>WeakObjectProfileTy</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclRefExpr</name> <operator>*</operator><name>RE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>WeakObjectProfileTy</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCIvarRefExpr</name> <operator>*</operator><name>RE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Base</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><macro><name>getProperty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Property</name></expr>;</return> }</block></expr></expr_stmt>












<expr_stmt><expr><name>bool</name> <macro><name>isExactProfile</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Base</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>WeakObjectProfileTy</name> <operator>&amp;</operator><name>Other</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>Base</name> <operator>==</operator> <name><name>Other</name><operator>.</operator><name>Base</name></name> <operator>&amp;&amp;</operator> <name>Property</name> <operator>==</operator> <name><name>Other</name><operator>.</operator><name>Property</name></name></expr>;</return>
}</block></expr></expr_stmt>





<decl_stmt><decl><type><name>class</name></type> <name>DenseMapInfo</name> <block>{<block_content>
<label><name>public</name>:</label>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>WeakObjectProfileTy</name></type> <name>getEmptyKey</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>WeakObjectProfileTy</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>WeakObjectProfileTy</name></type> <name>getTombstoneKey</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><name>WeakObjectProfileTy</name><operator>::</operator><call><name>getSentinel</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>getHashValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>WeakObjectProfileTy</name> <modifier>&amp;</modifier></type><name>Val</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>using</name></type> <name>Pair</name> <init>= <expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>BaseInfoTy</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<return>return <expr><name>llvm</name><operator>::</operator><name><name>DenseMapInfo</name><argument_list type="generic">&lt;<argument><expr><name>Pair</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>getHashValue</name><argument_list>(<argument><expr><call><name>Pair</name><argument_list>(<argument><expr><name><name>Val</name><operator>.</operator><name>Base</name></name></expr></argument>,
<argument><expr><name><name>Val</name><operator>.</operator><name>Property</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isEqual</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>WeakObjectProfileTy</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>WeakObjectProfileTy</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>LHS</name> <operator>==</operator> <name>RHS</name></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>







<decl_stmt><decl><type><name>class</name></type> <name>WeakUseTy</name> <block>{<block_content>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>Rep</name></expr>;</expr_stmt>

<label><name>public</name>:</label>
<macro><name>WeakUseTy</name><argument_list>(<argument>const Expr *Use</argument>, <argument>bool IsRead</argument>)</argument_list></macro> : <macro><name>Rep</name><argument_list>(<argument>Use</argument>, <argument>IsRead</argument>)</argument_list></macro> <block>{<block_content/>}</block>

<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getUseExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Rep</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isUnsafe</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Rep</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>markSafe</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>Rep</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>WeakUseTy</name> <operator>&amp;</operator><name>Other</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>Rep</name> <operator>==</operator> <name><name>Other</name><operator>.</operator><name>Rep</name></name></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<decl_stmt><decl><type><name>using</name></type> <name>WeakUseVector</name> <init>= <expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>WeakUseTy</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>using</name></type> <name>WeakObjectUseMap</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>SmallDenseMap</name><argument_list type="generic">&lt;<argument><expr><name>WeakObjectProfileTy</name></expr></argument>, <argument><expr><name>WeakUseVector</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>,
<argument><expr><name>WeakObjectProfileTy</name><operator>::</operator><name>DenseMapInfo</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<label><name>private</name>:</label>



<decl_stmt><decl><type><name>WeakObjectUseMap</name></type> <name>WeakObjectUses</name></decl>;</decl_stmt>

<label><name>protected</name>:</label>
<expr_stmt><expr><call><name>FunctionScopeInfo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionScopeInfo</name><operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>FunctionScopeInfo</name><argument_list>(<argument><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diag</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>SK_Function</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>HasBranchProtectedScope</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>HasBranchIntoScope</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>HasIndirectGoto</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>HasMustTail</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>HasDroppedStmt</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>HasOMPDeclareReductionCombiner</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>HasFallthroughStmt</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>UsesFPIntrin</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>HasPotentialAvailabilityViolations</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ObjCShouldCallSuper</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>ObjCIsDesignatedInit</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ObjCWarnForNoDesignatedInitChain</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>ObjCIsSecondaryInit</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ObjCWarnForNoInitDelegation</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>NeedsCoroutineSuspends</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>ErrorTrap</name><argument_list>(<argument>Diag</argument>)</argument_list></macro> <expr><block>{}</block>

<name>virtual</name> <operator>~</operator><call><name>FunctionScopeInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>








<expr_stmt><expr><name>bool</name> <macro><name>hasUnrecoverableErrorOccurred</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>ErrorTrap</name><operator>.</operator><name>hasUnrecoverableErrorOccurred</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<function_decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ExprT</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>void</name></type> <name>recordUseOfWeak</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExprT</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsRead</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>recordUseOfWeak</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCMessageExpr</name> <modifier>*</modifier></type><name>Msg</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCPropertyDecl</name> <modifier>*</modifier></type><name>Prop</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type> <name>markSafeWeakUse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><specifier>const</specifier> <name>WeakObjectUseMap</name> <operator>&amp;</operator><macro><name>getWeakObjectUses</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>WeakObjectUses</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setHasBranchIntoScope</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>HasBranchIntoScope</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setHasBranchProtectedScope</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>HasBranchProtectedScope</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setHasIndirectGoto</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>HasIndirectGoto</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setHasMustTail</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>HasMustTail</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>void</name></type> <name>setHasDroppedStmt</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>HasDroppedStmt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setHasOMPDeclareReductionCombiner</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>HasOMPDeclareReductionCombiner</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setHasFallthroughStmt</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>HasFallthroughStmt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setUsesFPIntrin</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>UsesFPIntrin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setHasCXXTry</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>TryLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>setHasBranchProtectedScope</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>FirstCXXTryLoc</name> <operator>=</operator> <name>TryLoc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setHasSEHTry</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>TryLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>setHasBranchProtectedScope</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>FirstSEHTryLoc</name> <operator>=</operator> <name>TryLoc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>NeedsScopeChecking</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><name>HasDroppedStmt</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>HasIndirectGoto</name> <operator>||</operator> <name>HasMustTail</name> <operator>||</operator>
<operator>(</operator><name>HasBranchProtectedScope</name> <operator>&amp;&amp;</operator> <name>HasBranchIntoScope</name><operator>)</operator><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>addBlock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BlockDecl</name> <modifier>*</modifier></type><name>BD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>Blocks</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>BD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>addByrefBlockVar</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>ByrefBlockVars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>VD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>isCoroutine</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name><name>FirstCoroutineStmtLoc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setFirstCoroutineStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Keyword</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>FirstCoroutineStmtLoc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"first coroutine statement location already set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>FirstCoroutineStmtLoc</name> <operator>=</operator> <name>Loc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>FirstCoroutineStmtKind</name> <operator>=</operator> <name>llvm</name><operator>::</operator><call><name><name>StringSwitch</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Keyword</name></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>Case</name><argument_list>(<argument><expr><literal type="string">"co_return"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>Case</name><argument_list>(<argument><expr><literal type="string">"co_await"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>Case</name><argument_list>(<argument><expr><literal type="string">"co_yield"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>StringRef</name> <macro><name>getFirstCoroutineStmtKeyword</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>FirstCoroutineStmtLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call>
<operator>&amp;&amp;</operator> <literal type="string">"no coroutine statement available"</literal></expr></argument>)</argument_list></call></expr>;
<switch>switch <condition>(<expr><name>FirstCoroutineStmtKind</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"co_return"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"co_await"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"co_yield"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"FirstCoroutineStmtKind has an invalid value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content></block><empty_stmt>;</empty_stmt></switch>
}</block>

<name>void</name> <macro><name>setNeedsCoroutineSuspends</name><argument_list>(<argument>bool value = true</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>!</operator><name>value</name> <operator>||</operator> <name><name>CoroutineSuspends</name><operator>.</operator><name>first</name></name> <operator>==</operator> <name>nullptr</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"we already have valid suspend points"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>NeedsCoroutineSuspends</name> <operator>=</operator> <name>value</name></expr>;
}</block>

<name>bool</name> <macro><name>hasInvalidCoroutineSuspends</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><name>NeedsCoroutineSuspends</name> <operator>&amp;&amp;</operator> <name><name>CoroutineSuspends</name><operator>.</operator><name>first</name></name> <operator>==</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setCoroutineSuspends</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Initial</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Final</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>Initial</name> <operator>&amp;&amp;</operator> <name>Final</name> <operator>&amp;&amp;</operator> <literal type="string">"suspend points cannot be null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>CoroutineSuspends</name><operator>.</operator><name>first</name></name> <operator>==</operator> <name>nullptr</name> <operator>&amp;&amp;</operator> <literal type="string">"suspend points already set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>NeedsCoroutineSuspends</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>CoroutineSuspends</name><operator>.</operator><name>first</name></name> <operator>=</operator> <name>Initial</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>CoroutineSuspends</name><operator>.</operator><name>second</name></name> <operator>=</operator> <name>Final</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function_decl><type><name>void</name></type> <name>Clear</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>bool</name> <macro><name>isPlainFunction</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>SK_Function</name></expr>;</return> }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>Capture</name> <block>{<block_content>













<enum>enum <name>CaptureKind</name> <block>{
<decl><name>Cap_ByCopy</name></decl>, <decl><name>Cap_ByRef</name></decl>, <decl><name>Cap_Block</name></decl>, <decl><name>Cap_VLA</name></decl>
}</block>;</enum>

<union>union <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>VariableArrayType</name> <modifier>*</modifier></type><name>CapturedVLA</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>CapturedVar</name></decl>;</decl_stmt>
}</block>;</union>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>CaptureType</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>Kind</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>Nested</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>CapturesThis</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>ODRUsed</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NonODRUsed</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>Invalid</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>Capture</name><argument_list>(<argument>VarDecl *Var</argument>, <argument>bool Block</argument>, <argument>bool ByRef</argument>, <argument>bool IsNested</argument>,
<argument>SourceLocation Loc</argument>, <argument>SourceLocation EllipsisLoc</argument>, <argument>QualType CaptureType</argument>,
<argument>bool Invalid</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>CapturedVar</name><argument_list>(<argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Loc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>EllipsisLoc</name><argument_list>(<argument><expr><name>EllipsisLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>CaptureType</name><argument_list>(<argument><expr><name>CaptureType</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>Kind</name><argument_list>(<argument><expr><ternary><condition><expr><name>Block</name></expr> ?</condition><then> <expr><name>Cap_Block</name></expr> </then><else>: <expr><ternary><condition><expr><name>ByRef</name></expr> ?</condition><then> <expr><name>Cap_ByRef</name></expr> </then><else>: <expr><name>Cap_ByCopy</name></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>Nested</name><argument_list>(<argument><expr><name>IsNested</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>CapturesThis</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ODRUsed</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>NonODRUsed</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Invalid</name><argument_list>(<argument>Invalid</argument>)</argument_list></macro> <expr><block>{}</block>

enum <name>IsThisCapture</name> <block>{ <expr><name>ThisCapture</name></expr> }</block></expr>;</expr_stmt>
<macro><name>Capture</name><argument_list>(<argument>IsThisCapture</argument>, <argument>bool IsNested</argument>, <argument>SourceLocation Loc</argument>,
<argument>QualType CaptureType</argument>, <argument>const bool ByCopy</argument>, <argument>bool Invalid</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Loc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>CaptureType</name><argument_list>(<argument><expr><name>CaptureType</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>Kind</name><argument_list>(<argument><expr><ternary><condition><expr><name>ByCopy</name></expr> ?</condition><then> <expr><name>Cap_ByCopy</name></expr> </then><else>: <expr><name>Cap_ByRef</name></expr></else></ternary></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Nested</name><argument_list>(<argument><expr><name>IsNested</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>CapturesThis</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ODRUsed</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>NonODRUsed</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>Invalid</name><argument_list>(<argument>Invalid</argument>)</argument_list></macro> <expr><block>{}</block>

enum <name>IsVLACapture</name> <block>{ <expr><name>VLACapture</name></expr> }</block></expr>;</expr_stmt>
<macro><name>Capture</name><argument_list>(<argument>IsVLACapture</argument>, <argument>const VariableArrayType *VLA</argument>, <argument>bool IsNested</argument>,
<argument>SourceLocation Loc</argument>, <argument>QualType CaptureType</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>CapturedVLA</name><argument_list>(<argument><expr><name>VLA</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Loc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>CaptureType</name><argument_list>(<argument><expr><name>CaptureType</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Kind</name><argument_list>(<argument><expr><name>Cap_VLA</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>Nested</name><argument_list>(<argument><expr><name>IsNested</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>CapturesThis</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ODRUsed</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>NonODRUsed</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Invalid</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>isThisCapture</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CapturesThis</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isVariableCapture</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name>isThisCapture</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isVLATypeCapture</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isCopyCapture</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>Cap_ByCopy</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isReferenceCapture</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>Cap_ByRef</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isBlockCapture</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>Cap_Block</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isVLATypeCapture</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>Cap_VLA</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isNested</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Nested</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isInvalid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Invalid</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isInitCapture</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isODRUsed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ODRUsed</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isNonODRUsed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NonODRUsed</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>markUsed</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IsODRUse</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>IsODRUse</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ODRUsed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>NonODRUsed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>VarDecl</name> <operator>*</operator><macro><name>getVariable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isVariableCapture</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>CapturedVar</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>VariableArrayType</name> <operator>*</operator><macro><name>getCapturedVLAType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isVLATypeCapture</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>CapturedVLA</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEllipsisLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>EllipsisLoc</name></expr>;</return> }</block></expr></expr_stmt>




<expr_stmt><expr><name>QualType</name> <macro><name>getCaptureType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CaptureType</name></expr>;</return> }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CapturingScopeInfo</name> <range>: <expr><name>public</name> <name>FunctionScopeInfo</name> <block>{
<expr><name>protected</name><operator>:</operator>
<call><name>CapturingScopeInfo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CapturingScopeInfo</name><operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>public</name><operator>:</operator>
enum <name>ImplicitCaptureStyle</name> <block>{
<expr><name>ImpCap_None</name></expr>, <expr><name>ImpCap_LambdaByval</name></expr>, <expr><name>ImpCap_LambdaByref</name></expr>, <expr><name>ImpCap_Block</name></expr>,
<expr><name>ImpCap_CapturedRegion</name></expr>
}</block></expr>;

<expr><name>ImplicitCaptureStyle</name> <name>ImpCaptureStyle</name></expr>;

<macro><name>CapturingScopeInfo</name><argument_list>(<argument>DiagnosticsEngine &amp;Diag</argument>, <argument>ImplicitCaptureStyle Style</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>FunctionScopeInfo</name><argument_list>(<argument><expr><name>Diag</name></expr></argument>)</argument_list></call></expr>, <macro><name>ImpCaptureStyle</name><argument_list>(<argument>Style</argument>)</argument_list></macro> <expr><block>{}</block>


<name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name><operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>CaptureMap</name></expr>;



<expr><name>unsigned</name> <name>CXXThisCaptureIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;


<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Capture</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>Captures</name></expr>;



<expr><name>bool</name> <name>HasImplicitReturnType</name> <operator>=</operator> <name>false</name></expr>;



<expr><name>QualType</name> <name>ReturnType</name></expr>;

<expr><name>void</name> <macro><name>addCapture</name><argument_list>(<argument>VarDecl *Var</argument>, <argument>bool isBlock</argument>, <argument>bool isByref</argument>, <argument>bool isNested</argument>,
<argument>SourceLocation Loc</argument>, <argument>SourceLocation EllipsisLoc</argument>,
<argument>QualType CaptureType</argument>, <argument>bool Invalid</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Captures</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>Capture</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>isBlock</name></expr></argument>, <argument><expr><name>isByref</name></expr></argument>, <argument><expr><name>isNested</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>,
<argument><expr><name>EllipsisLoc</name></expr></argument>, <argument><expr><name>CaptureType</name></expr></argument>, <argument><expr><name>Invalid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name><name>CaptureMap</name><index>[<expr><name>Var</name></expr>]</index></name> <operator>=</operator> <call><name><name>Captures</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>addVLATypeCapture</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>const VariableArrayType *VLAType</argument>,
<argument>QualType CaptureType</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Captures</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>Capture</name><argument_list>(<argument><expr><name>Capture</name><operator>::</operator><name>VLACapture</name></expr></argument>, <argument><expr><name>VLAType</name></expr></argument>,
<argument><expr><name>false</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>CaptureType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>addThisCapture</name><argument_list>(<argument>bool isNested</argument>, <argument>SourceLocation Loc</argument>, <argument>QualType CaptureType</argument>,
<argument>bool ByCopy</argument>)</argument_list></macro></expr>;


<expr><name>bool</name> <macro><name>isCXXThisCaptured</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CXXThisCaptureIndex</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return> }</block>


<name>Capture</name> <operator>&amp;</operator><macro><name>getCXXThisCapture</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isCXXThisCaptured</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"this has not been captured"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>Captures</name><index>[<expr><name>CXXThisCaptureIndex</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
}</block>


<name>bool</name> <macro><name>isCaptured</name><argument_list>(<argument>VarDecl *Var</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>CaptureMap</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>isVLATypeCaptured</name><argument_list>(<argument>const VariableArrayType *VAT</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>Capture</name> <operator>&amp;</operator><macro><name>getCapture</name><argument_list>(<argument>VarDecl *Var</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isCaptured</name><argument_list>(<argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Variable has not been captured"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>Captures</name><index>[<expr><name><name>CaptureMap</name><index>[<expr><name>Var</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
}</block>

<specifier>const</specifier> <name>Capture</name> <operator>&amp;</operator><macro><name>getCapture</name><argument_list>(<argument>VarDecl *Var</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name><operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name> <name>Known</name>
<operator>=</operator> <call><name><name>CaptureMap</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Known</name> <operator>!=</operator> <call><name><name>CaptureMap</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Variable has not been captured"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>Captures</name><index>[<expr><name><name>Known</name><operator>-&gt;</operator><name>second</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const FunctionScopeInfo *FSI</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>FSI</name><operator>-&gt;</operator><name>Kind</name></name> <operator>==</operator> <name>SK_Block</name> <operator>||</operator> <name><name>FSI</name><operator>-&gt;</operator><name>Kind</name></name> <operator>==</operator> <name>SK_Lambda</name>
<operator>||</operator> <name><name>FSI</name><operator>-&gt;</operator><name>Kind</name></name> <operator>==</operator> <name>SK_CapturedRegion</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>BlockScopeInfo</name> <name>final</name> <operator>:</operator> <name>public</name> <name>CapturingScopeInfo</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>BlockDecl</name> <operator>*</operator><name>TheDecl</name></expr>;



<expr><name>Scope</name> <operator>*</operator><name>TheScope</name></expr>;



<expr><name>QualType</name> <name>FunctionType</name></expr>;

<expr><call><name>BlockScopeInfo</name><argument_list>(<argument><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diag</name></expr></argument>, <argument><expr><name>Scope</name> <operator>*</operator><name>BlockScope</name></expr></argument>, <argument><expr><name>BlockDecl</name> <operator>*</operator><name>Block</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>CapturingScopeInfo</name><argument_list>(<argument><expr><name>Diag</name></expr></argument>, <argument><expr><name>ImpCap_Block</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>TheDecl</name><argument_list>(<argument><expr><name>Block</name></expr></argument>)</argument_list></call></expr>,
<macro><name>TheScope</name><argument_list>(<argument>BlockScope</argument>)</argument_list></macro> <expr><block>{
<expr><name>Kind</name> <operator>=</operator> <name>SK_Block</name></expr>;
}</block>

<operator>~</operator><macro><name>BlockScopeInfo</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const FunctionScopeInfo *FSI</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>FSI</name><operator>-&gt;</operator><name>Kind</name></name> <operator>==</operator> <name>SK_Block</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>CapturedRegionScopeInfo</name> <name>final</name> <operator>:</operator> <name>public</name> <name>CapturingScopeInfo</name> <block>{
<expr><name>public</name><operator>:</operator>

<name>CapturedDecl</name> <operator>*</operator><name>TheCapturedDecl</name></expr>;


<expr><name>RecordDecl</name> <operator>*</operator><name>TheRecordDecl</name></expr>;


<expr><name>Scope</name> <operator>*</operator><name>TheScope</name></expr>;


<expr><name>ImplicitParamDecl</name> <operator>*</operator><name>ContextParam</name></expr>;


<expr><name>unsigned</name> <name>short</name> <name>CapRegionKind</name></expr>;

<expr><name>unsigned</name> <name>short</name> <name>OpenMPLevel</name></expr>;
<expr><name>unsigned</name> <name>short</name> <name>OpenMPCaptureLevel</name></expr>;

<macro><name>CapturedRegionScopeInfo</name><argument_list>(<argument>DiagnosticsEngine &amp;Diag</argument>, <argument>Scope *S</argument>, <argument>CapturedDecl *CD</argument>,
<argument>RecordDecl *RD</argument>, <argument>ImplicitParamDecl *Context</argument>,
<argument>CapturedRegionKind K</argument>, <argument>unsigned OpenMPLevel</argument>,
<argument>unsigned OpenMPCaptureLevel</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>CapturingScopeInfo</name><argument_list>(<argument><expr><name>Diag</name></expr></argument>, <argument><expr><name>ImpCap_CapturedRegion</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TheCapturedDecl</name><argument_list>(<argument><expr><name>CD</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>TheRecordDecl</name><argument_list>(<argument><expr><name>RD</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>TheScope</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ContextParam</name><argument_list>(<argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>CapRegionKind</name><argument_list>(<argument><expr><name>K</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>OpenMPLevel</name><argument_list>(<argument><expr><name>OpenMPLevel</name></expr></argument>)</argument_list></call></expr>,
<macro><name>OpenMPCaptureLevel</name><argument_list>(<argument>OpenMPCaptureLevel</argument>)</argument_list></macro> <expr><block>{
<expr><name>Kind</name> <operator>=</operator> <name>SK_CapturedRegion</name></expr>;
}</block>

<operator>~</operator><macro><name>CapturedRegionScopeInfo</name><argument_list>()</argument_list></macro> <name>override</name></expr>;


<expr><name>StringRef</name> <macro><name>getRegionName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<switch>switch <condition>(<expr><name>CapRegionKind</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CR_Default</name></expr>:</case>
<return>return <expr><literal type="string">"default captured statement"</literal></expr>;</return>
<case>case <expr><name>CR_ObjCAtFinally</name></expr>:</case>
<return>return <expr><literal type="string">"Objective-C @finally statement"</literal></expr>;</return>
<case>case <expr><name>CR_OpenMP</name></expr>:</case>
<return>return <expr><literal type="string">"OpenMP region"</literal></expr>;</return>
<expr_stmt/>}</block_content>
llvm_unreachable("Invalid captured region kind!"</block></switch>)</block></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const FunctionScopeInfo *FSI</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>FSI</name><operator>-&gt;</operator><name>Kind</name></name> <operator>==</operator> <name>SK_CapturedRegion</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>LambdaScopeInfo</name> <name>final</name> <operator>:</operator>
<name>public</name> <name>CapturingScopeInfo</name></expr>, <expr><name>public</name> <name>InventedTemplateParameterInfo</name> <block>{
<expr><name>public</name><operator>:</operator>

<name>CXXRecordDecl</name> <operator>*</operator><name>Lambda</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>CXXMethodDecl</name> <operator>*</operator><name>CallOperator</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>SourceRange</name> <name>IntroducerRange</name></expr>;



<expr><name>SourceLocation</name> <name>CaptureDefaultLoc</name></expr>;



<expr><name>unsigned</name> <name>NumExplicitCaptures</name> <operator>=</operator> <literal type="number">0</literal></expr>;


<expr><name>bool</name> <name>Mutable</name> <operator>=</operator> <name>false</name></expr>;


<expr><name>bool</name> <name>ExplicitParams</name> <operator>=</operator> <name>false</name></expr>;


<expr><name>CleanupInfo</name> <name>Cleanup</name></expr>;


<expr><name>bool</name> <name>ContainsUnexpandedParameterPack</name> <operator>=</operator> <name>false</name></expr>;


<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>LocalPacks</name></expr>;


<expr><name>SourceRange</name> <name>ExplicitTemplateParamsRange</name></expr>;




<expr><name>ExprResult</name> <name>RequiresClause</name></expr>;




<expr><name>TemplateParameterList</name> <operator>*</operator><name>GLTemplateParameterList</name> <operator>=</operator> <name>nullptr</name></expr>;














<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>PotentiallyCapturingExprs</name></expr>;





<expr><name>llvm</name><operator>::</operator><name><name>SmallSet</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>NonODRUsedCapturingExprs</name></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>SourceRange</name></expr></argument>&gt;</argument_list></name> <name>ExplicitCaptureRanges</name></expr>;




struct <expr><name>ShadowedOuterDecl</name> <block>{
<expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr>;
<expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>ShadowedDecl</name></expr>;
}</block></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ShadowedOuterDecl</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>ShadowingDecls</name></expr>;

<expr><name>SourceLocation</name> <name>PotentialThisCaptureLocation</name></expr>;

<expr><call><name>LambdaScopeInfo</name><argument_list>(<argument><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diag</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CapturingScopeInfo</name><argument_list>(<argument>Diag</argument>, <argument>ImpCap_None</argument>)</argument_list></macro> <block>{
<expr><name>Kind</name> <operator>=</operator> <name>SK_Lambda</name></expr>;
}</block>


<name>void</name> <macro><name>finishedExplicitCaptures</name><argument_list>()</argument_list></macro> <block>{
<expr><name>NumExplicitCaptures</name> <operator>=</operator> <call><name><name>Captures</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const FunctionScopeInfo *FSI</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>FSI</name><operator>-&gt;</operator><name>Kind</name></name> <operator>==</operator> <name>SK_Lambda</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>isGenericLambda</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name><name>TemplateParams</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>||</operator> <name>GLTemplateParameterList</name></expr>;</return>
}</block>


















<name>void</name> <macro><name>addPotentialCapture</name><argument_list>(<argument>Expr *VarExpr</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>DeclRefExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VarExpr</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>MemberExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VarExpr</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>FunctionParmPackExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VarExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>PotentiallyCapturingExprs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>VarExpr</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>addPotentialThisCapture</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><name>PotentialThisCaptureLocation</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>bool</name> <macro><name>hasPotentialThisCapture</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>PotentialThisCaptureLocation</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>








































<name>void</name> <macro><name>markVariableExprAsNonODRUsed</name><argument_list>(<argument>Expr *CapturingVarExpr</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>DeclRefExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CapturingVarExpr</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>MemberExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CapturingVarExpr</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>FunctionParmPackExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CapturingVarExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>NonODRUsedCapturingExprs</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>CapturingVarExpr</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>bool</name> <macro><name>isVariableExprMarkedAsNonODRUsed</name><argument_list>(<argument>Expr *CapturingVarExpr</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>DeclRefExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CapturingVarExpr</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>MemberExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CapturingVarExpr</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>FunctionParmPackExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CapturingVarExpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>NonODRUsedCapturingExprs</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>CapturingVarExpr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>removePotentialCapture</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{
<expr><call><name><name>PotentiallyCapturingExprs</name><operator>.</operator><name>erase</name></name><argument_list>(
<argument><expr><name>std</name><operator>::</operator><call><name>remove</name><argument_list>(<argument><expr><call><name><name>PotentiallyCapturingExprs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>PotentiallyCapturingExprs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>PotentiallyCapturingExprs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>
<name>void</name> <macro><name>clearPotentialCaptures</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name><name>PotentiallyCapturingExprs</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>PotentialThisCaptureLocation</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;
}</block>
<name>unsigned</name> <macro><name>getNumPotentialVariableCaptures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>PotentiallyCapturingExprs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasPotentialCaptures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNumPotentialVariableCaptures</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>PotentialThisCaptureLocation</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>visitPotentialCaptures</name><argument_list>(
<argument>llvm::function_ref&lt;void(VarDecl *, Expr *)&gt; Callback</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr>;

<expr><name>FunctionScopeInfo</name><operator>::</operator><name>WeakObjectProfileTy</name><operator>::</operator><call><name>WeakObjectProfileTy</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>Base</name><argument_list>(<argument>nullptr</argument>, <argument>false</argument>)</argument_list></macro> <block>{}</block>

<name>FunctionScopeInfo</name><operator>::</operator><name>WeakObjectProfileTy</name>
<name>FunctionScopeInfo</name><operator>::</operator><name>WeakObjectProfileTy</name><operator>::</operator><macro><name>getSentinel</name><argument_list>()</argument_list></macro> <block>{
<expr><name>FunctionScopeInfo</name><operator>::</operator><name>WeakObjectProfileTy</name> <name>Result</name></expr>;
<expr><call><name><name>Result</name><operator>.</operator><name>Base</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Result</name></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ExprT</name></expr></argument>&gt;</argument_list></name>
<name>void</name> <name>FunctionScopeInfo</name><operator>::</operator><macro><name>recordUseOfWeak</name><argument_list>(<argument>const ExprT *E</argument>, <argument>bool IsRead</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;
<expr><name>WeakUseVector</name> <operator>&amp;</operator><name>Uses</name> <operator>=</operator> <name><name>WeakObjectUses</name><index>[<expr><call><name>WeakObjectProfileTy</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;
<expr><call><name><name>Uses</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>WeakUseTy</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>IsRead</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>inline</specifier> <name>void</name> <name>CapturingScopeInfo</name><operator>::</operator><macro><name>addThisCapture</name><argument_list>(<argument>bool isNested</argument>,
<argument>SourceLocation Loc</argument>,
<argument>QualType CaptureType</argument>,
<argument>bool ByCopy</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Captures</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>Capture</name><argument_list>(<argument><expr><name>Capture</name><operator>::</operator><name>ThisCapture</name></expr></argument>, <argument><expr><name>isNested</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>CaptureType</name></expr></argument>,
<argument><expr><name>ByCopy</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>CXXThisCaptureIndex</name> <operator>=</operator> <call><name><name>Captures</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;
}</block>

}

}</expr></block></expr></block></expr></range></decl></decl_stmt></block_content></block></decl></decl_stmt></block_content></block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
