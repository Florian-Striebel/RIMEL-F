<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/Decl.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_DECL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_DECL_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/APValue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTContextAllocate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclAccessPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclBase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclarationName.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExternalASTSource.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/NestedNameSpecifier.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Redeclarable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/AddressSpaces.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Diagnostic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/IdentifierTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Linkage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OperatorKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/PartialDiagnostic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/PragmaKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Specifiers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Visibility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/APSInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerIntPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerUnion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/TrailingObjects.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<struct_decl>struct <name>ASTTemplateArgumentListInfo</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>Attr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CompoundStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DependentFunctionTemplateSpecializationInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>EnumDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionTemplateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionTemplateSpecializationInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionTypeLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LabelStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MemberSpecializationInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Module</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>NamespaceDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ParmVarDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>RecordDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Stmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>StringLiteral</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TagDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateArgumentList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateArgumentListInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateParameterList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TypeAliasTemplateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TypeLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UnresolvedSetImpl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VarTemplateDecl</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>TranslationUnitDecl</name> <range>: <expr><name>public</name> <name>Decl</name></expr></range></decl>,
<decl><type ref="prev"/><name>public</name> <name>DeclContext</name></decl>,
<decl><type ref="prev"/><name>public</name> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>TranslationUnitDecl</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<decl_stmt><decl><type><name>using</name></type> <name>redeclarable_base</name> <init>= <expr><name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>TranslationUnitDecl</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<function><type><name>TranslationUnitDecl</name> <modifier>*</modifier></type><name>getNextRedeclarationImpl</name><parameter_list>()</parameter_list> override <block>{<block_content>
<return>return <expr><call><name>getNextRedeclaration</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>TranslationUnitDecl</name> <modifier>*</modifier></type><name>getPreviousDeclImpl</name><parameter_list>()</parameter_list> override <block>{<block_content>
<return>return <expr><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>TranslationUnitDecl</name> <modifier>*</modifier></type><name>getMostRecentDeclImpl</name><parameter_list>()</parameter_list> override <block>{<block_content>
<return>return <expr><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Ctx</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>NamespaceDecl</name> <modifier>*</modifier></type><name>AnonymousNamespace</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<function_decl><type><name>explicit</name></type> <name>TranslationUnitDecl</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>virtual</name> <name>void</name></type> <name>anchor</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>using</name></type> <name>redecl_range</name> <init>= <expr><name>redeclarable_base</name><operator>::</operator><name>redecl_range</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>redecl_iterator</name> <init>= <expr><name>redeclarable_base</name><operator>::</operator><name>redecl_iterator</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getMostRecentDecl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getPreviousDecl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>isFirstDecl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_begin</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_end</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ASTContext</name> <operator>&amp;</operator><macro><name>getASTContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Ctx</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>NamespaceDecl</name> <operator>*</operator><macro><name>getAnonymousNamespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AnonymousNamespace</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setAnonymousNamespace</name><parameter_list>(<parameter><decl><type><name>NamespaceDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>AnonymousNamespace</name> <operator>=</operator> <name>D</name></expr>;</expr_stmt> </block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>TranslationUnitDecl</name> <modifier>*</modifier></type><name>Create</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>K</name> <operator>==</operator> <name>TranslationUnit</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>castToDeclContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TranslationUnitDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>TranslationUnitDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>TranslationUnitDecl</name> <modifier>*</modifier></type><name>castFromDeclContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TranslationUnitDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name> <name>PragmaCommentDecl</name></type> <name>final</name>
<range>: <expr><name>public</name> <name>Decl</name></expr></range></decl>,
<decl><type ref="prev"/><name>private</name> <name>llvm</name>::<name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>PragmaCommentDecl</name></expr></argument>, <argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclWriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name></type> <name>TrailingObjects</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PragmaMSCommentKind</name></type> <name>CommentKind</name></decl>;</decl_stmt>

<macro><name>PragmaCommentDecl</name><argument_list>(<argument>TranslationUnitDecl *TU</argument>, <argument>SourceLocation CommentLoc</argument>,
<argument>PragmaMSCommentKind CommentKind</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Decl</name><argument_list>(<argument><expr><name>PragmaComment</name></expr></argument>, <argument><expr><name>TU</name></expr></argument>, <argument><expr><name>CommentLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>CommentKind</name><argument_list>(<argument>CommentKind</argument>)</argument_list></macro> <expr><block>{}</block>

<name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>public</name>:</label>
<function_decl><type><specifier>static</specifier> <name>PragmaCommentDecl</name> <modifier>*</modifier></type><name>Create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>, <parameter><decl><type><name>TranslationUnitDecl</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>CommentLoc</name></decl></parameter>,
<parameter><decl><type><name>PragmaMSCommentKind</name></type> <name>CommentKind</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PragmaCommentDecl</name> <modifier>*</modifier></type><name>CreateDeserialized</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>ArgSize</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>PragmaMSCommentKind</name> <macro><name>getCommentKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CommentKind</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>StringRef</name> <macro><name>getArg</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>K</name> <operator>==</operator> <name>PragmaComment</name></expr>;</return> </block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name> <name>PragmaDetectMismatchDecl</name></type> <name>final</name>
<range>: <expr><name>public</name> <name>Decl</name></expr></range></decl>,
<decl><type ref="prev"/><name>private</name> <name>llvm</name>::<name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>PragmaDetectMismatchDecl</name></expr></argument>, <argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclWriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name></type> <name>TrailingObjects</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>ValueStart</name></decl>;</decl_stmt>

<macro><name>PragmaDetectMismatchDecl</name><argument_list>(<argument>TranslationUnitDecl *TU</argument>, <argument>SourceLocation Loc</argument>,
<argument>size_t ValueStart</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Decl</name><argument_list>(<argument><expr><name>PragmaDetectMismatch</name></expr></argument>, <argument><expr><name>TU</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>ValueStart</name><argument_list>(<argument>ValueStart</argument>)</argument_list></macro> <expr><block>{}</block>

<name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>public</name>:</label>
<function_decl><type><specifier>static</specifier> <name>PragmaDetectMismatchDecl</name> <modifier>*</modifier></type><name>Create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>,
<parameter><decl><type><name>TranslationUnitDecl</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Name</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PragmaDetectMismatchDecl</name> <modifier>*</modifier></type>
<name>CreateDeserialized</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NameValueSize</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>StringRef</name> <macro><name>getName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>StringRef</name> <macro><name>getValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator> <name>ValueStart</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>K</name> <operator>==</operator> <name>PragmaDetectMismatch</name></expr>;</return> </block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


















<decl_stmt><decl><type><name>class</name></type> <name>ExternCContextDecl</name> <range>: <expr><name>public</name> <name>Decl</name></expr></range></decl>, <decl><type ref="prev"/><name>public</name> <name>DeclContext</name> <block>{<block_content>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>ExternCContextDecl</name><argument_list>(<argument><expr><name>TranslationUnitDecl</name> <operator>*</operator><name>TU</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Decl</name><argument_list>(<argument><expr><name>ExternCContext</name></expr></argument>, <argument><expr><name>TU</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>DeclContext</name><argument_list>(<argument>ExternCContext</argument>)</argument_list></macro> <expr><block>{}</block>

<name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>public</name>:</label>
<function_decl><type><specifier>static</specifier> <name>ExternCContextDecl</name> <modifier>*</modifier></type><name>Create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>,
<parameter><decl><type><name>TranslationUnitDecl</name> <modifier>*</modifier></type><name>TU</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>K</name> <operator>==</operator> <name>ExternCContext</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>castToDeclContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExternCContextDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExternCContextDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>ExternCContextDecl</name> <modifier>*</modifier></type><name>castFromDeclContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExternCContextDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>






<decl_stmt><decl><type><name>class</name></type> <name>NamedDecl</name> <range>: <expr><name>public</name> <name>Decl</name> <block>{



<expr><name>DeclarationName</name> <name>Name</name></expr>;

<expr><name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;

<expr><name>private</name><operator>:</operator>
<name>NamedDecl</name> <operator>*</operator><macro><name>getUnderlyingDeclImpl</name><argument_list>()</argument_list></macro> <name>LLVM_READONLY</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>NamedDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>, <argument>DeclarationName N</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Decl</name><argument_list>(<argument><expr><name>DK</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>, <macro><name>Name</name><argument_list>(<argument>N</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>





<name>IdentifierInfo</name> <operator>*</operator><macro><name>getIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Name</name><operator>.</operator><name>getAsIdentifierInfo</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>





<name>StringRef</name> <macro><name>getName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Name</name><operator>.</operator><name>isIdentifier</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Name is not a simple identifier"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><ternary><condition><expr><call><name>getIdentifier</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getIdentifier</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getName</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</return>
}</block>












<name>std</name><operator>::</operator><name>string</name> <macro><name>getNameAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Name</name><operator>.</operator><name>getAsString</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>virtual</name> <name>void</name> <macro><name>printName</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
















<expr><name>DeclarationName</name> <macro><name>getDeclName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Name</name></expr>;</return> }</block>


<name>void</name> <macro><name>setDeclName</name><argument_list>(<argument>DeclarationName N</argument>)</argument_list></macro> <block>{ <expr><name>Name</name> <operator>=</operator> <name>N</name></expr>; }</block>









<name>void</name> <macro><name>printQualifiedName</name><argument_list>(<argument>raw_ostream &amp;OS</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <macro><name>printQualifiedName</name><argument_list>(<argument>raw_ostream &amp;OS</argument>, <argument>const PrintingPolicy &amp;Policy</argument>)</argument_list></macro> <specifier>const</specifier></expr>;





<expr><name>void</name> <macro><name>printNestedNameSpecifier</name><argument_list>(<argument>raw_ostream &amp;OS</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <macro><name>printNestedNameSpecifier</name><argument_list>(<argument>raw_ostream &amp;OS</argument>,
<argument>const PrintingPolicy &amp;Policy</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getQualifiedNameAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;







<expr><name>virtual</name> <name>void</name> <macro><name>getNameForDiagnostic</name><argument_list>(<argument>raw_ostream &amp;OS</argument>,
<argument>const PrintingPolicy &amp;Policy</argument>,
<argument>bool Qualified</argument>)</argument_list></macro> <specifier>const</specifier></expr>;











<expr><name>bool</name> <macro><name>declarationReplaces</name><argument_list>(<argument>NamedDecl *OldD</argument>, <argument>bool IsKnownNewer = true</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>hasLinkage</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>using</name> <name>Decl</name><operator>::</operator><name>isModulePrivate</name></expr>;
<expr><name>using</name> <name>Decl</name><operator>::</operator><name>setModulePrivate</name></expr>;


<expr><name>bool</name> <macro><name>isCXXClassMember</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><name>DC</name> <operator>=</operator> <call><name>getDeclContext</name><argument_list>()</argument_list></call></expr>;




<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>EnumDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>DC</name> <operator>=</operator> <call><name><name>DC</name><operator>-&gt;</operator><name>getRedeclContext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name><name>DC</name><operator>-&gt;</operator><name>isRecord</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isCXXInstanceMember</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<decl_stmt><decl><type><name>ReservedIdentifierStatus</name></type> <name>isReserved</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><name>LangOpts</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<expr_stmt><expr><name>Linkage</name> <macro><name>getLinkageInternal</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>Linkage</name> <macro><name>getFormalLinkage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>clang</name><operator>::</operator><call><name>getFormalLinkage</name><argument_list>(<argument><expr><call><name>getLinkageInternal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasExternalFormalLinkage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isExternalFormalLinkage</name><argument_list>(<argument><expr><call><name>getLinkageInternal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isExternallyVisible</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>clang</name><operator>::</operator><call><name>isExternallyVisible</name><argument_list>(<argument><expr><call><name>getLinkageInternal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isExternallyDeclarable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isExternallyVisible</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>getOwningModuleForLinkage</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>Visibility</name> <macro><name>getVisibility</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLinkageAndVisibility</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getVisibility</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>LinkageInfo</name> <macro><name>getLinkageAndVisibility</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<enum>enum <name>ExplicitVisibilityKind</name> <block>{



<decl><name>VisibilityForType</name></decl>,




<decl><name>VisibilityForValue</name></decl>
}</block>;</enum>



<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>Visibility</name></expr></argument>&gt;</argument_list></name></type>
<name>getExplicitVisibility</name><argument_list>(<argument><expr><name>ExplicitVisibilityKind</name> <name>kind</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isLinkageValid</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>







<expr_stmt><expr><name>bool</name> <macro><name>hasLinkageBeenComputed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasCachedLinkage</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>NamedDecl</name> <modifier>*</modifier></type><name>getUnderlyingDecl</name><parameter_list>()</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name><name>this</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>UsingShadow</name> <operator>&amp;&amp;</operator>
<call><name><name>this</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>ConstructorUsingShadow</name> <operator>&amp;&amp;</operator>
<call><name><name>this</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>ObjCCompatibleAlias</name> <operator>&amp;&amp;</operator>
<call><name><name>this</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>NamespaceAlias</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>this</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getUnderlyingDeclImpl</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><macro><name>getUnderlyingDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getUnderlyingDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>NamedDecl</name> <modifier>*</modifier></type><name>getMostRecentDecl</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>ObjCStringFormatFamily</name> <macro><name>getObjCFStringFormattingFamily</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>K</name> <operator>&gt;=</operator> <name>firstNamed</name> <operator>&amp;&amp;</operator> <name>K</name> <operator>&lt;=</operator> <name>lastNamed</name></expr>;</return> </block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>raw_ostream</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name><operator>,</operator> <specifier>const</specifier> <name>NamedDecl</name> <operator>&amp;</operator><name>ND</name><operator>)</operator> <block>{
<expr><call><name><name>ND</name><operator>.</operator><name>printName</name></name><argument_list>(<argument><expr><name>OS</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>OS</name></expr>;</return>
}</block></expr></expr_stmt>






<decl_stmt><decl><type><name>class</name></type> <name>LabelDecl</name> <range>: <expr><name>public</name> <name>NamedDecl</name> <block>{
<expr><name>LabelStmt</name> <operator>*</operator><name>TheStmt</name></expr>;
<expr><name>StringRef</name> <name>MSAsmName</name></expr>;
<expr><name>bool</name> <name>MSAsmNameResolved</name> <operator>=</operator> <name>false</name></expr>;




<expr><name>SourceLocation</name> <name>LocStart</name></expr>;

<macro><name>LabelDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation IdentL</argument>, <argument>IdentifierInfo *II</argument>,
<argument>LabelStmt *S</argument>, <argument>SourceLocation StartL</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>NamedDecl</name><argument_list>(<argument><expr><name>Label</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>IdentL</name></expr></argument>, <argument><expr><name>II</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>TheStmt</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>, <macro><name>LocStart</name><argument_list>(<argument>StartL</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>LabelDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation IdentL</argument>, <argument>IdentifierInfo *II</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>LabelDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation IdentL</argument>, <argument>IdentifierInfo *II</argument>,
<argument>SourceLocation GnuLabelL</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>LabelDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>LabelStmt</name> <operator>*</operator><macro><name>getStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TheStmt</name></expr>;</return> }</block>
<name>void</name> <macro><name>setStmt</name><argument_list>(<argument>LabelStmt *T</argument>)</argument_list></macro> <block>{ <expr><name>TheStmt</name> <operator>=</operator> <name>T</name></expr>; }</block>

<name>bool</name> <macro><name>isGnuLocal</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LocStart</name> <operator>!=</operator> <call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setLocStart</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>LocStart</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>LocStart</name></expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isMSAsmLabel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name><name>MSAsmName</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>isResolvedMSAsmLabel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isMSAsmLabel</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>MSAsmNameResolved</name></expr>;</return> }</block>
<name>void</name> <macro><name>setMSAsmLabel</name><argument_list>(<argument>StringRef Name</argument>)</argument_list></macro></expr>;
<expr><name>StringRef</name> <macro><name>getMSAsmLabel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MSAsmName</name></expr>;</return> }</block>
<name>void</name> <macro><name>setMSAsmLabelResolved</name><argument_list>()</argument_list></macro> <block>{ <expr><name>MSAsmNameResolved</name> <operator>=</operator> <name>true</name></expr>; }</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>Label</name></expr>;</return> }</block>
}</expr>;


<expr><name>class</name> <name>NamespaceDecl</name> <operator>:</operator> <name>public</name> <name>NamedDecl</name></expr>, <expr><name>public</name> <name>DeclContext</name></expr>,
<expr><name>public</name> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>NamespaceDecl</name></expr></argument>&gt;</argument_list></name>
<block>{


<expr><name>SourceLocation</name> <name>LocStart</name></expr>;


<expr><name>SourceLocation</name> <name>RBraceLoc</name></expr>;





<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>NamespaceDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>AnonOrFirstNamespaceAndInline</name></expr>;

<macro><name>NamespaceDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>bool Inline</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation IdLoc</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>NamespaceDecl *PrevDecl</argument>)</argument_list></macro>;

<expr><name>using</name> <name>redeclarable_base</name> <operator>=</operator> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>NamespaceDecl</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>NamespaceDecl</name> <operator>*</operator><macro><name>getNextRedeclarationImpl</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>NamespaceDecl</name> <operator>*</operator><macro><name>getPreviousDeclImpl</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>NamespaceDecl</name> <operator>*</operator><macro><name>getMostRecentDeclImpl</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;

<expr><specifier>static</specifier> <name>NamespaceDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>bool Inline</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>IdentifierInfo *Id</argument>,
<argument>NamespaceDecl *PrevDecl</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>NamespaceDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>using</name> <name>redecl_range</name> <operator>=</operator> <name>redeclarable_base</name><operator>::</operator><name>redecl_range</name></expr>;
<expr><name>using</name> <name>redecl_iterator</name> <operator>=</operator> <name>redeclarable_base</name><operator>::</operator><name>redecl_iterator</name></expr>;

<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_begin</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_end</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getPreviousDecl</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getMostRecentDecl</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>isFirstDecl</name></expr>;










<expr><name>bool</name> <macro><name>isAnonymousNamespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name>getIdentifier</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>isInline</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>AnonOrFirstNamespaceAndInline</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>void</name> <macro><name>setInline</name><argument_list>(<argument>bool Inline</argument>)</argument_list></macro> <block>{
<expr><call><name><name>AnonOrFirstNamespaceAndInline</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>Inline</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>bool</name> <macro><name>isRedundantInlineQualifierFor</name><argument_list>(<argument>DeclarationName Name</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isInline</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<name>auto</name> <name>X</name> <operator>=</operator> <call><name>lookup</name><argument_list>(<argument><expr><name>Name</name></expr></argument>)</argument_list></call></block></expr>;
<expr><name>auto</name> <name>Y</name> <operator>=</operator> <call><name>getParent</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>lookup</name><argument_list>(<argument><expr><name>Name</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>std</name><operator>::</operator><call><name>distance</name><argument_list>(<argument><expr><call><name><name>X</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>X</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator>
<name>std</name><operator>::</operator><call><name>distance</name><argument_list>(<argument><expr><call><name><name>Y</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Y</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>NamespaceDecl</name> <operator>*</operator><call><name>getOriginalNamespace</name><argument_list>()</argument_list></call></expr>;


<expr><specifier>const</specifier> <name>NamespaceDecl</name> <operator>*</operator><macro><name>getOriginalNamespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>bool</name> <macro><name>isOriginalNamespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>NamespaceDecl</name> <operator>*</operator><macro><name>getAnonymousNamespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getOriginalNamespace</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>AnonOrFirstNamespaceAndInline</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setAnonymousNamespace</name><argument_list>(<argument>NamespaceDecl *D</argument>)</argument_list></macro> <block>{
<expr><call><name>getOriginalNamespace</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>AnonOrFirstNamespaceAndInline</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>NamespaceDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getOriginalNamespace</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>NamespaceDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getOriginalNamespace</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>LocStart</name></expr></argument>, <argument><expr><name>RBraceLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>LocStart</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getRBraceLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RBraceLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLocStart</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>LocStart</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>void</name> <macro><name>setRBraceLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RBraceLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>Namespace</name></expr>;</return> }</block>
<specifier>static</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>castToDeclContext</name><argument_list>(<argument>const NamespaceDecl *D</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>NamespaceDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>NamespaceDecl</name> <operator>*</operator><macro><name>castFromDeclContext</name><argument_list>(<argument>const DeclContext *DC</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>NamespaceDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>ValueDecl</name> <operator>:</operator> <name>public</name> <name>NamedDecl</name> <block>{
<expr><name>QualType</name> <name>DeclType</name></expr>;

<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>ValueDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>,
<argument>DeclarationName N</argument>, <argument>QualType T</argument>)</argument_list></macro>
<operator>:</operator> <call><name>NamedDecl</name><argument_list>(<argument><expr><name>DK</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>L</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>, <macro><name>DeclType</name><argument_list>(<argument>T</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DeclType</name></expr>;</return> }</block>
<name>void</name> <macro><name>setType</name><argument_list>(<argument>QualType newType</argument>)</argument_list></macro> <block>{ <expr><name>DeclType</name> <operator>=</operator> <name>newType</name></expr>; }</block>



<name>bool</name> <macro><name>isWeak</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>&gt;=</operator> <name>firstValue</name> <operator>&amp;&amp;</operator> <name>K</name> <operator>&lt;=</operator> <name>lastValue</name></expr>;</return> }</block>
}</expr>;



struct <expr><name>QualifierInfo</name> <block>{
<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;





<expr><name>unsigned</name> <name>NumTemplParamLists</name> <operator>=</operator> <literal type="number">0</literal></expr>;






<expr><name>TemplateParameterList</name><operator>*</operator><operator>*</operator> <name>TemplParamLists</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><call><name>QualifierInfo</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><call><name>QualifierInfo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>QualifierInfo</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><name>QualifierInfo</name><operator>&amp;</operator> <name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>QualifierInfo</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr>;


<expr><name>void</name> <call><name>setTemplateParameterListsInfo</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateParameterList</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>TPLists</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;



<expr><name>class</name> <name>DeclaratorDecl</name> <operator>:</operator> <name>public</name> <name>ValueDecl</name> <block>{



struct <expr><name>ExtInfo</name> <operator>:</operator> <name>public</name> <name>QualifierInfo</name> <block>{
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>TInfo</name></expr>;
<expr><name>Expr</name> <operator>*</operator><name>TrailingRequiresClause</name> <operator>=</operator> <name>nullptr</name></expr>;
}</block></expr>;

<expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>ExtInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>DeclInfo</name></expr>;



<expr><name>SourceLocation</name> <name>InnerLocStart</name></expr>;

<expr><name>bool</name> <macro><name>hasExtInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>DeclInfo</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>ExtInfo</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block>
<name>ExtInfo</name> <operator>*</operator><macro><name>getExtInfo</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name><name>DeclInfo</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>ExtInfo</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block>
<specifier>const</specifier> <name>ExtInfo</name> <operator>*</operator><macro><name>getExtInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>DeclInfo</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>ExtInfo</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block>

<name>protected</name><operator>:</operator>
<macro><name>DeclaratorDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>,
<argument>DeclarationName N</argument>, <argument>QualType T</argument>, <argument>TypeSourceInfo *TInfo</argument>,
<argument>SourceLocation StartL</argument>)</argument_list></macro>
<operator>:</operator> <call><name>ValueDecl</name><argument_list>(<argument><expr><name>DK</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>L</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>DeclInfo</name><argument_list>(<argument><expr><name>TInfo</name></expr></argument>)</argument_list></call></expr>, <macro><name>InnerLocStart</name><argument_list>(<argument>StartL</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;

<expr><name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasExtInfo</name><argument_list>()</argument_list></call>
<operator>?</operator> <call><name>getExtInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TInfo</name>
<operator>:</operator> <name><name>DeclInfo</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>TypeSourceInfo</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>

<name>void</name> <macro><name>setTypeSourceInfo</name><argument_list>(<argument>TypeSourceInfo *TI</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasExtInfo</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>getExtInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TInfo</name> <operator>=</operator> <name>TI</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>DeclInfo</name> <operator>=</operator> <name>TI</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
}</block>


<name>SourceLocation</name> <macro><name>getInnerLocStart</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>InnerLocStart</name></expr>;</return> }</block>
<name>void</name> <macro><name>setInnerLocStart</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>InnerLocStart</name> <operator>=</operator> <name>L</name></expr>; }</block>



<name>SourceLocation</name> <macro><name>getOuterLocStart</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getOuterLocStart</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>NestedNameSpecifier</name> <operator>*</operator><macro><name>getQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasExtInfo</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name>getExtInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call>
<operator>:</operator> <name>nullptr</name></expr>;</return>
}</block>




<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasExtInfo</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getExtInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>QualifierLoc</name></expr>
</then><else>: <expr><call><name>NestedNameSpecifierLoc</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>

<name>void</name> <macro><name>setQualifierInfo</name><argument_list>(<argument>NestedNameSpecifierLoc QualifierLoc</argument>)</argument_list></macro></expr>;




<expr><name>Expr</name> <operator>*</operator><macro><name>getTrailingRequiresClause</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasExtInfo</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getExtInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TrailingRequiresClause</name></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getTrailingRequiresClause</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasExtInfo</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getExtInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>TrailingRequiresClause</name></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<name>void</name> <call><name>setTrailingRequiresClause</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>TrailingRequiresClause</name></expr></argument>)</argument_list></call></expr>;

<expr><name>unsigned</name> <macro><name>getNumTemplateParameterLists</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasExtInfo</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getExtInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NumTemplParamLists</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
}</block>

<name>TemplateParameterList</name> <operator>*</operator><macro><name>getTemplateParameterList</name><argument_list>(<argument>unsigned index</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>index</name> <operator>&lt;</operator> <call><name>getNumTemplateParameterLists</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getExtInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name><name>TemplParamLists</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</return>
}</block>

<name>void</name> <call><name>setTemplateParameterListsInfo</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateParameterList</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>TPLists</name></expr></argument>)</argument_list></call></expr>;

<expr><name>SourceLocation</name> <macro><name>getTypeSpecStartLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>SourceLocation</name> <macro><name>getTypeSpecEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{
<return>return <expr><name>K</name> <operator>&gt;=</operator> <name>firstDeclarator</name> <operator>&amp;&amp;</operator> <name>K</name> <operator>&lt;=</operator> <name>lastDeclarator</name></expr>;</return>
}</block>
}</expr>;




struct <expr><name>EvaluatedStmt</name> <block>{

<expr><name>bool</name> <name>WasEvaluated</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>bool</name> <name>IsEvaluating</name> <operator>:</operator> <literal type="number">1</literal></expr>;





<expr><name>bool</name> <name>HasConstantInitialization</name> <operator>:</operator> <literal type="number">1</literal></expr>;






<expr><name>bool</name> <name>HasConstantDestruction</name> <operator>:</operator> <literal type="number">1</literal></expr>;



<expr><name>bool</name> <name>HasICEInit</name> <operator>:</operator> <literal type="number">1</literal></expr>;
<expr><name>bool</name> <name>CheckedForICEInit</name> <operator>:</operator> <literal type="number">1</literal></expr>;

<expr><name>Stmt</name> <operator>*</operator><name>Value</name></expr>;
<expr><name>APValue</name> <name>Evaluated</name></expr>;

<expr><call><name>EvaluatedStmt</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>WasEvaluated</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>IsEvaluating</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>HasConstantInitialization</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>HasConstantDestruction</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>HasICEInit</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>, <macro><name>CheckedForICEInit</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block></expr>
}</block></expr>;


<expr><name>class</name> <name>VarDecl</name> <operator>:</operator> <name>public</name> <name>DeclaratorDecl</name></expr>, <expr><name>public</name> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>

enum <name>InitializationStyle</name> <block>{

<expr><name>CInit</name></expr>,


<expr><name>CallInit</name></expr>,


<expr><name>ListInit</name></expr>
}</block></expr>;


enum <expr><name>TLSKind</name> <block>{

<expr><name>TLS_None</name></expr>,


<expr><name>TLS_Static</name></expr>,


<expr><name>TLS_Dynamic</name></expr>
}</block></expr>;




<expr><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getStorageClassSpecifierString</name><argument_list>(<argument>StorageClass SC</argument>)</argument_list></macro></expr>;

<expr><name>protected</name><operator>:</operator>







<name>using</name> <name>InitType</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>, <argument><expr><name>EvaluatedStmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;



<expr><name>mutable</name> <name>InitType</name> <name>Init</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTNodeImporter</name></expr>;
<expr><name>friend</name> <name>class</name> <name>StmtIteratorBase</name></expr>;

<expr><name>class</name> <name>VarDeclBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>VarDecl</name></expr>;

<expr><name>unsigned</name> <name>SClass</name> <operator>:</operator> <literal type="number">3</literal></expr>;
<expr><name>unsigned</name> <name>TSCSpec</name> <operator>:</operator> <literal type="number">2</literal></expr>;
<expr><name>unsigned</name> <name>InitStyle</name> <operator>:</operator> <literal type="number">2</literal></expr>;



<expr><name>unsigned</name> <name>ARCPseudoStrong</name> <operator>:</operator> <literal type="number">1</literal></expr>;
}</block></expr>;
enum <expr><block>{ <expr><name>NumVarDeclBits</name> <operator>=</operator> <literal type="number">8</literal></expr> }</block></expr>;

<expr><name>protected</name><operator>:</operator>
enum <block>{ <expr><name>NumParameterIndexBits</name> <operator>=</operator> <literal type="number">8</literal></expr> }</block></expr>;

enum <expr><name>DefaultArgKind</name> <block>{
<expr><name>DAK_None</name></expr>,
<expr><name>DAK_Unparsed</name></expr>,
<expr><name>DAK_Uninstantiated</name></expr>,
<expr><name>DAK_Normal</name></expr>
}</block></expr>;

enum <expr><block>{ <expr><name>NumScopeDepthOrObjCQualsBits</name> <operator>=</operator> <literal type="number">7</literal></expr> }</block></expr>;

<expr><name>class</name> <name>ParmVarDeclBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ParmVarDecl</name></expr>;

<expr><name>unsigned</name> <operator>:</operator> <name>NumVarDeclBits</name></expr>;



<expr><name>unsigned</name> <name>HasInheritedDefaultArg</name> <operator>:</operator> <literal type="number">1</literal></expr>;





<expr><name>unsigned</name> <name>DefaultArgKind</name> <operator>:</operator> <literal type="number">2</literal></expr>;


<expr><name>unsigned</name> <name>IsKNRPromoted</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>unsigned</name> <name>IsObjCMethodParam</name> <operator>:</operator> <literal type="number">1</literal></expr>;





<expr><name>unsigned</name> <name>ScopeDepthOrObjCQuals</name> <operator>:</operator> <name>NumScopeDepthOrObjCQualsBits</name></expr>;



<expr><name>unsigned</name> <name>ParameterIndex</name> <operator>:</operator> <name>NumParameterIndexBits</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>NonParmVarDeclBitfields</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ImplicitParamDecl</name></expr>;
<expr><name>friend</name> <name>class</name> <name>VarDecl</name></expr>;

<expr><name>unsigned</name> <operator>:</operator> <name>NumVarDeclBits</name></expr>;




<expr><name>unsigned</name> <name>IsThisDeclarationADemotedDefinition</name> <operator>:</operator> <literal type="number">1</literal></expr>;



<expr><name>unsigned</name> <name>ExceptionVar</name> <operator>:</operator> <literal type="number">1</literal></expr>;




<expr><name>unsigned</name> <name>NRVOVariable</name> <operator>:</operator> <literal type="number">1</literal></expr>;



<expr><name>unsigned</name> <name>CXXForRangeDecl</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>unsigned</name> <name>ObjCForDecl</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>unsigned</name> <name>IsInline</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>unsigned</name> <name>IsInlineSpecified</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>unsigned</name> <name>IsConstexpr</name> <operator>:</operator> <literal type="number">1</literal></expr>;



<expr><name>unsigned</name> <name>IsInitCapture</name> <operator>:</operator> <literal type="number">1</literal></expr>;




<expr><name>unsigned</name> <name>PreviousDeclInSameBlockScope</name> <operator>:</operator> <literal type="number">1</literal></expr>;



<expr><name>unsigned</name> <name>ImplicitParamKind</name> <operator>:</operator> <literal type="number">3</literal></expr>;

<expr><name>unsigned</name> <name>EscapingByref</name> <operator>:</operator> <literal type="number">1</literal></expr>;
}</block></expr>;

<expr>union <block>{
<expr><name>unsigned</name> <name>AllBits</name></expr>;
<expr><name>VarDeclBitfields</name> <name>VarDeclBits</name></expr>;
<expr><name>ParmVarDeclBitfields</name> <name>ParmVarDeclBits</name></expr>;
<expr><name>NonParmVarDeclBitfields</name> <name>NonParmVarDeclBits</name></expr>;
}</block></expr>;

<macro><name>VarDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>IdentifierInfo *Id</argument>, <argument>QualType T</argument>,
<argument>TypeSourceInfo *TInfo</argument>, <argument>StorageClass SC</argument>)</argument_list></macro>;

<expr><name>using</name> <name>redeclarable_base</name> <operator>=</operator> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>VarDecl</name> <operator>*</operator><macro><name>getNextRedeclarationImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getNextRedeclaration</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>VarDecl</name> <operator>*</operator><macro><name>getPreviousDeclImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>VarDecl</name> <operator>*</operator><macro><name>getMostRecentDeclImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>using</name> <name>redecl_range</name> <operator>=</operator> <name>redeclarable_base</name><operator>::</operator><name>redecl_range</name></expr>;
<expr><name>using</name> <name>redecl_iterator</name> <operator>=</operator> <name>redeclarable_base</name><operator>::</operator><name>redecl_iterator</name></expr>;

<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_begin</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_end</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getPreviousDecl</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getMostRecentDecl</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>isFirstDecl</name></expr>;

<expr><specifier>static</specifier> <name>VarDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation IdLoc</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>QualType T</argument>, <argument>TypeSourceInfo *TInfo</argument>,
<argument>StorageClass S</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>VarDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;



<expr><name>StorageClass</name> <macro><name>getStorageClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>StorageClass</name><operator>)</operator> <name><name>VarDeclBits</name><operator>.</operator><name>SClass</name></name></expr>;</return>
}</block>
<name>void</name> <macro><name>setStorageClass</name><argument_list>(<argument>StorageClass SC</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <macro><name>setTSCSpec</name><argument_list>(<argument>ThreadStorageClassSpecifier TSC</argument>)</argument_list></macro> <block>{
<expr><name><name>VarDeclBits</name><operator>.</operator><name>TSCSpec</name></name> <operator>=</operator> <name>TSC</name></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>VarDeclBits</name><operator>.</operator><name>TSCSpec</name></name> <operator>==</operator> <name>TSC</name> <operator>&amp;&amp;</operator> <literal type="string">"truncation"</literal></expr></argument>)</argument_list></call></expr>;
}</block>
<name>ThreadStorageClassSpecifier</name> <macro><name>getTSCSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ThreadStorageClassSpecifier</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>VarDeclBits</name><operator>.</operator><name>TSCSpec</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>TLSKind</name> <macro><name>getTLSKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>hasLocalStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getStorageClass</name><argument_list>()</argument_list></call> <operator>==</operator> <name>SC_None</name></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name>getType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAddressSpace</name><argument_list>()</argument_list></call> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>opencl_constant</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>!</operator><call><name>isFileVarDecl</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>getTSCSpec</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TSCS_unspecified</name></expr>;</return>
<expr_stmt/>}</block_content>


if (getStorageClass(</block></if></if_stmt>) <operator>==</operator> <name>SC_Register</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isLocalVarDeclOrParm</name><argument_list>()</argument_list></call>)</block></expr>
<return>return <expr><name>false</name></expr>;</return></block></expr>




<return>return <expr><call><name>getStorageClass</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>SC_Auto</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>isStaticLocal</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>getStorageClass</name><argument_list>()</argument_list></call> <operator>==</operator> <name>SC_Static</name> <operator>||</operator>

<operator>(</operator><call><name>getStorageClass</name><argument_list>()</argument_list></call> <operator>==</operator> <name>SC_None</name> <operator>&amp;&amp;</operator> <call><name>getTSCSpec</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TSCS_thread_local</name><operator>)</operator><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>isFileVarDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>hasExternalStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStorageClass</name><argument_list>()</argument_list></call> <operator>==</operator> <name>SC_Extern</name> <operator>||</operator>
<call><name>getStorageClass</name><argument_list>()</argument_list></call> <operator>==</operator> <name>SC_PrivateExtern</name></expr>;</return>
}</block>





<name>bool</name> <macro><name>hasGlobalStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>hasLocalStorage</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>StorageDuration</name> <macro><name>getStorageDuration</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasLocalStorage</name><argument_list>()</argument_list></call> <operator>?</operator> <name>SD_Automatic</name> <operator>:</operator>
<call><name>getTSCSpec</name><argument_list>()</argument_list></call> <operator>?</operator> <name>SD_Thread</name> <operator>:</operator> <name>SD_Static</name></expr>;</return>
}</block>


<name>LanguageLinkage</name> <macro><name>getLanguageLinkage</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isExternC</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isInExternCContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isInExternCXXContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;






<expr><name>bool</name> <macro><name>isLocalVarDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>Decl</name><operator>::</operator><name>Var</name> <operator>&amp;&amp;</operator> <call><name>getKind</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>Decl</name><operator>::</operator><name>Decomposition</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>DC</name> <init>= <expr><call><name>getLexicalDeclContext</name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>DC</name><operator>-&gt;</operator><name>getRedeclContext</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isFunctionOrMethod</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isLocalVarDeclOrParm</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isLocalVarDecl</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Decl</name><operator>::</operator><name>ParmVar</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isFunctionOrMethodVarDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>Decl</name><operator>::</operator><name>Var</name> <operator>&amp;&amp;</operator> <call><name>getKind</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>Decl</name><operator>::</operator><name>Decomposition</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><name>DC</name> <operator>=</operator> <call><name>getLexicalDeclContext</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getRedeclContext</name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<return>return <expr><call><name><name>DC</name><operator>-&gt;</operator><name>isFunctionOrMethod</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>DC</name><operator>-&gt;</operator><name>getDeclKind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>Decl</name><operator>::</operator><name>Block</name></expr>;</return>
}










bool <macro><name>isStaticDataMember</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{

<return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>Decl</name><operator>::</operator><name>ParmVar</name> <operator>&amp;&amp;</operator> <call><name>getDeclContext</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isRecord</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>VarDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<enum>enum <name>DefinitionKind</name> <block>{

<decl><name>DeclarationOnly</name></decl>,


<decl><name>TentativeDefinition</name></decl>,


<decl><name>Definition</name></decl>
}</block>;</enum>




<decl_stmt><decl><type><name>DefinitionKind</name></type> <name>isThisDeclarationADefinition</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<expr_stmt><expr><name>DefinitionKind</name> <macro><name>isThisDeclarationADefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isThisDeclarationADefinition</name><argument_list>(<argument><expr><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>DefinitionKind</name></type> <name>hasDefinition</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<expr_stmt><expr><name>DefinitionKind</name> <macro><name>hasDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasDefinition</name><argument_list>(<argument><expr><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<function_decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>getActingDefinition</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><macro><name>getActingDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getActingDefinition</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function_decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>getDefinition</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>getDefinition</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getDefinition</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<function><type><name>VarDecl</name> <modifier>*</modifier></type><name>getDefinition</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getDefinition</name><argument_list>(<argument><expr><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><macro><name>getDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getDefinition</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isOutOfLine</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isFileVarDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>Kind</name> <name>K</name> <operator>=</operator> <call><name>getKind</name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>K</name> <operator>==</operator> <name>ParmVar</name> <operator>||</operator> <name>K</name> <operator>==</operator> <name>ImplicitParam</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getLexicalDeclContext</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getRedeclContext</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isFileContext</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isStaticDataMember</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
}



const <expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getAnyInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>D</name></expr>;
<return>return <expr><call><name>getAnyInitializer</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>getAnyInitializer</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><operator>&amp;</operator><name>D</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasInit</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getInit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getInit</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function_decl><type><name>Expr</name> <modifier>*</modifier></type><name>getInit</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>Stmt</name> <modifier>*</modifier><modifier>*</modifier></type><name>getInitAddress</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>setInit</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>I</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>getInitializingDeclaration</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><macro><name>getInitializingDeclaration</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getInitializingDeclaration</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>








<decl_stmt><decl><type><name>bool</name></type> <name>mightBeUsableInConstantExpressions</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>isUsableInConstantExpressions</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>EvaluatedStmt</name> <operator>*</operator><macro><name>ensureEvaluatedStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>EvaluatedStmt</name> <operator>*</operator><macro><name>getEvaluatedStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>





<expr_stmt><expr><name>APValue</name> <operator>*</operator><macro><name>evaluateValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<decl_stmt><decl><type><name>APValue</name> <modifier>*</modifier></type><name>evaluateValue</name><argument_list>(<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>PartialDiagnosticAt</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Notes</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<expr_stmt><expr><name>APValue</name> <operator>*</operator><macro><name>getEvaluatedValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>







<decl_stmt><decl><type><name>bool</name></type> <name>evaluateDestruction</name><argument_list>(<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>PartialDiagnosticAt</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Notes</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>







<expr_stmt><expr><name>bool</name> <macro><name>hasConstantInitialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>hasICEInitializer</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>checkForConstantInitialization</name><argument_list>(
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>PartialDiagnosticAt</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Notes</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function><type><name>void</name></type> <name>setInitStyle</name><parameter_list>(<parameter><decl><type><name>InitializationStyle</name></type> <name>Style</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>VarDeclBits</name><operator>.</operator><name>InitStyle</name></name> <operator>=</operator> <name>Style</name></expr>;</expr_stmt>
</block_content>}</block></function>











<expr_stmt><expr><name>InitializationStyle</name> <macro><name>getInitStyle</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>InitializationStyle</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>VarDeclBits</name><operator>.</operator><name>InitStyle</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isDirectInit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getInitStyle</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>CInit</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isThisDeclarationADemotedDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>?</operator> <name>false</name> <operator>:</operator>
<name><name>NonParmVarDeclBits</name><operator>.</operator><name>IsThisDeclarationADemotedDefinition</name></name></expr>;</return>
}</block></expr></expr_stmt>






<function><type><name>void</name></type> <name>demoteThisDefinitionToDeclaration</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isThisDeclarationADefinition</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Not a definition!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Cannot demote ParmVarDecls!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>NonParmVarDeclBits</name><operator>.</operator><name>IsThisDeclarationADemotedDefinition</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>isExceptionVariable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>?</operator> <name>false</name> <operator>:</operator> <name><name>NonParmVarDeclBits</name><operator>.</operator><name>ExceptionVar</name></name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setExceptionVariable</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>EV</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>NonParmVarDeclBits</name><operator>.</operator><name>ExceptionVar</name></name> <operator>=</operator> <name>EV</name></expr>;</expr_stmt>
</block_content>}</block></function>











<expr_stmt><expr><name>bool</name> <macro><name>isNRVOVariable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>?</operator> <name>false</name> <operator>:</operator> <name><name>NonParmVarDeclBits</name><operator>.</operator><name>NRVOVariable</name></name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setNRVOVariable</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>NRVO</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>NonParmVarDeclBits</name><operator>.</operator><name>NRVOVariable</name></name> <operator>=</operator> <name>NRVO</name></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>isCXXForRangeDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>?</operator> <name>false</name> <operator>:</operator> <name><name>NonParmVarDeclBits</name><operator>.</operator><name>CXXForRangeDecl</name></name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setCXXForRangeDecl</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>FRD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>NonParmVarDeclBits</name><operator>.</operator><name>CXXForRangeDecl</name></name> <operator>=</operator> <name>FRD</name></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>isObjCForDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>NonParmVarDeclBits</name><operator>.</operator><name>ObjCForDecl</name></name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setObjCForDecl</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>FRD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>NonParmVarDeclBits</name><operator>.</operator><name>ObjCForDecl</name></name> <operator>=</operator> <name>FRD</name></expr>;</expr_stmt>
</block_content>}</block></function>








<expr_stmt><expr><name>bool</name> <macro><name>isARCPseudoStrong</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>VarDeclBits</name><operator>.</operator><name>ARCPseudoStrong</name></name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setARCPseudoStrong</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>PS</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>VarDeclBits</name><operator>.</operator><name>ARCPseudoStrong</name></name> <operator>=</operator> <name>PS</name></expr>;</expr_stmt> </block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>isInline</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>?</operator> <name>false</name> <operator>:</operator> <name><name>NonParmVarDeclBits</name><operator>.</operator><name>IsInline</name></name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isInlineSpecified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>?</operator> <name>false</name>
<operator>:</operator> <name><name>NonParmVarDeclBits</name><operator>.</operator><name>IsInlineSpecified</name></name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setInlineSpecified</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>NonParmVarDeclBits</name><operator>.</operator><name>IsInline</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>NonParmVarDeclBits</name><operator>.</operator><name>IsInlineSpecified</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setImplicitlyInline</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>NonParmVarDeclBits</name><operator>.</operator><name>IsInline</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>isConstexpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>?</operator> <name>false</name> <operator>:</operator> <name><name>NonParmVarDeclBits</name><operator>.</operator><name>IsConstexpr</name></name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setConstexpr</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>NonParmVarDeclBits</name><operator>.</operator><name>IsConstexpr</name></name> <operator>=</operator> <name>IC</name></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>isInitCapture</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call> <operator>?</operator> <name>false</name> <operator>:</operator> <name><name>NonParmVarDeclBits</name><operator>.</operator><name>IsInitCapture</name></name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setInitCapture</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>NonParmVarDeclBits</name><operator>.</operator><name>IsInitCapture</name></name> <operator>=</operator> <name>IC</name></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>isParameterPack</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isPreviousDeclInSameBlockScope</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>?</operator> <name>false</name>
<operator>:</operator> <name><name>NonParmVarDeclBits</name><operator>.</operator><name>PreviousDeclInSameBlockScope</name></name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setPreviousDeclInSameBlockScope</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Same</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>NonParmVarDeclBits</name><operator>.</operator><name>PreviousDeclInSameBlockScope</name></name> <operator>=</operator> <name>Same</name></expr>;</expr_stmt>
</block_content>}</block></function>




<expr_stmt><expr><name>bool</name> <macro><name>isEscapingByref</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isNonEscapingByref</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function><type><name>void</name></type> <name>setEscapingByref</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>NonParmVarDeclBits</name><operator>.</operator><name>EscapingByref</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>hasDependentAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>VarDecl</name> <operator>*</operator><macro><name>getTemplateInstantiationPattern</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>VarDecl</name> <operator>*</operator><macro><name>getInstantiatedFromStaticDataMember</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>TemplateSpecializationKind</name> <macro><name>getTemplateSpecializationKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>TemplateSpecializationKind</name>
<macro><name>getTemplateSpecializationKindForInstantiation</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>SourceLocation</name> <macro><name>getPointOfInstantiation</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>MemberSpecializationInfo</name> <operator>*</operator><macro><name>getMemberSpecializationInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<function_decl><type><name>void</name></type> <name>setTemplateSpecializationKind</name><parameter_list>(<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>setInstantiationOfStaticDataMember</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>,
<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name></decl></parameter>)</parameter_list>;</function_decl>












<expr_stmt><expr><name>VarTemplateDecl</name> <operator>*</operator><macro><name>getDescribedVarTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>setDescribedVarTemplate</name><parameter_list>(<parameter><decl><type><name>VarTemplateDecl</name> <modifier>*</modifier></type><name>Template</name></decl></parameter>)</parameter_list>;</function_decl>




<expr_stmt><expr><name>bool</name> <macro><name>isKnownToBeDefined</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isNoDestroy</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<expr_stmt><expr><name>QualType</name><operator>::</operator><name>DestructionKind</name> <macro><name>needsDestruction</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>K</name> <operator>&gt;=</operator> <name>firstVar</name> <operator>&amp;&amp;</operator> <name>K</name> <operator>&lt;=</operator> <name>lastVar</name></expr>;</return> </block_content>}</block></function>
};

<decl_stmt><decl><type><name>class</name></type> <name>ImplicitParamDecl</name> <range>: <expr><name>public</name> <name>VarDecl</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>



enum <name>ImplicitParamKind</name> <operator>:</operator> <name>unsigned</name> <block>{

<expr><name>ObjCSelf</name></expr>,


<expr><name>ObjCCmd</name></expr>,


<expr><name>CXXThis</name></expr>,


<expr><name>CXXVTT</name></expr>,


<expr><name>CapturedContext</name></expr>,


<expr><name>Other</name></expr>,
}</block></expr>;


<expr><specifier>static</specifier> <name>ImplicitParamDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>IdentifierInfo *Id</argument>,
<argument>QualType T</argument>, <argument>ImplicitParamKind ParamKind</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>ImplicitParamDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>QualType T</argument>,
<argument>ImplicitParamKind ParamKind</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>ImplicitParamDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<macro><name>ImplicitParamDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation IdLoc</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>QualType Type</argument>,
<argument>ImplicitParamKind ParamKind</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>VarDecl</name><argument_list>(<argument>ImplicitParam</argument>, <argument>C</argument>, <argument>DC</argument>, <argument>IdLoc</argument>, <argument>IdLoc</argument>, <argument>Id</argument>, <argument>Type</argument>,
<argument>nullptr</argument>, <argument>SC_None</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>NonParmVarDeclBits</name><operator>.</operator><name>ImplicitParamKind</name></name> <operator>=</operator> <name>ParamKind</name></expr>;
<expr><call><name>setImplicit</name><argument_list>()</argument_list></call></expr>;
}</block>

<macro><name>ImplicitParamDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>QualType Type</argument>, <argument>ImplicitParamKind ParamKind</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>VarDecl</name><argument_list>(<argument>ImplicitParam</argument>, <argument>C</argument>, <argument>nullptr</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>, <argument>nullptr</argument>, <argument>Type</argument>,
<argument>nullptr</argument>, <argument>SC_None</argument>)</argument_list></macro> <block>{
<expr><name><name>NonParmVarDeclBits</name><operator>.</operator><name>ImplicitParamKind</name></name> <operator>=</operator> <name>ParamKind</name></expr>;
<expr><call><name>setImplicit</name><argument_list>()</argument_list></call></expr>;
}</block>


<name>ImplicitParamKind</name> <macro><name>getParameterKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ImplicitParamKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>NonParmVarDeclBits</name><operator>.</operator><name>ImplicitParamKind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>ImplicitParam</name></expr>;</return> }</block>
}</expr>;


<expr><name>class</name> <name>ParmVarDecl</name> <operator>:</operator> <name>public</name> <name>VarDecl</name> <block>{
<expr><name>public</name><operator>:</operator>
enum <block>{ <expr><name>MaxFunctionScopeDepth</name> <operator>=</operator> <literal type="number">255</literal></expr> }</block></expr>;
enum <expr><block>{ <expr><name>MaxFunctionScopeIndex</name> <operator>=</operator> <literal type="number">255</literal></expr> }</block></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>ParmVarDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>IdentifierInfo *Id</argument>, <argument>QualType T</argument>,
<argument>TypeSourceInfo *TInfo</argument>, <argument>StorageClass S</argument>, <argument>Expr *DefArg</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>VarDecl</name><argument_list>(<argument>DK</argument>, <argument>C</argument>, <argument>DC</argument>, <argument>StartLoc</argument>, <argument>IdLoc</argument>, <argument>Id</argument>, <argument>T</argument>, <argument>TInfo</argument>, <argument>S</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>HasInheritedDefaultArg</name></name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>DefaultArgKind</name></name> <operator>==</operator> <name>DAK_None</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>IsKNRPromoted</name></name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>IsObjCMethodParam</name></name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setDefaultArg</name><argument_list>(<argument><expr><name>DefArg</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>ParmVarDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>IdentifierInfo *Id</argument>,
<argument>QualType T</argument>, <argument>TypeSourceInfo *TInfo</argument>,
<argument>StorageClass S</argument>, <argument>Expr *DefArg</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>ParmVarDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;

<expr><name>void</name> <macro><name>setObjCMethodScopeInfo</name><argument_list>(<argument>unsigned parameterIndex</argument>)</argument_list></macro> <block>{
<expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>IsObjCMethodParam</name></name> <operator>=</operator> <name>true</name></expr>;
<expr><call><name>setParameterIndex</name><argument_list>(<argument><expr><name>parameterIndex</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>setScopeInfo</name><argument_list>(<argument>unsigned scopeDepth</argument>, <argument>unsigned parameterIndex</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>ParmVarDeclBits</name><operator>.</operator><name>IsObjCMethodParam</name></name></expr></argument>)</argument_list></call></expr>;

<expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>ScopeDepthOrObjCQuals</name></name> <operator>=</operator> <name>scopeDepth</name></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>ScopeDepthOrObjCQuals</name></name> <operator>==</operator> <name>scopeDepth</name>
<operator>&amp;&amp;</operator> <literal type="string">"truncation!"</literal></expr></argument>)</argument_list></call></expr>;

<expr><call><name>setParameterIndex</name><argument_list>(<argument><expr><name>parameterIndex</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>bool</name> <macro><name>isObjCMethodParameter</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>IsObjCMethodParam</name></name></expr>;</return>
}</block>


<name>bool</name> <macro><name>isDestroyedInCallee</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>unsigned</name> <macro><name>getFunctionScopeDepth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>IsObjCMethodParam</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>ScopeDepthOrObjCQuals</name></name></expr>;</return>
}</block>

<specifier>static</specifier> <name>constexpr</name> <name>unsigned</name> <macro><name>getMaxFunctionScopeDepth</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>NumScopeDepthOrObjCQualsBits</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
}</block>


<name>unsigned</name> <macro><name>getFunctionScopeIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getParameterIndex</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ObjCDeclQualifier</name> <macro><name>getObjCDeclQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ParmVarDeclBits</name><operator>.</operator><name>IsObjCMethodParam</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>OBJC_TQ_None</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>ObjCDeclQualifier</name><argument_list>(<argument><expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>ScopeDepthOrObjCQuals</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>
<function><type><name>void</name></type> <name>setObjCDeclQualifier</name><parameter_list>(<parameter><decl><type><name>ObjCDeclQualifier</name></type> <name>QTVal</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>IsObjCMethodParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>ScopeDepthOrObjCQuals</name></name> <operator>=</operator> <name>QTVal</name></expr>;</expr_stmt>
</block_content>}</block></function>









<expr_stmt><expr><name>bool</name> <macro><name>isKNRPromoted</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>IsKNRPromoted</name></name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setKNRPromoted</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>promoted</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>IsKNRPromoted</name></name> <operator>=</operator> <name>promoted</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><name>Expr</name> <modifier>*</modifier></type><name>getDefaultArg</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getDefaultArg</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getDefaultArg</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function_decl><type><name>void</name></type> <name>setDefaultArg</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>defarg</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>SourceRange</name> <macro><name>getDefaultArgRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<function_decl><type><name>void</name></type> <name>setUninstantiatedDefaultArg</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Expr</name> <modifier>*</modifier></type><name>getUninstantiatedDefaultArg</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getUninstantiatedDefaultArg</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getUninstantiatedDefaultArg</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasDefaultArg</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>










<expr_stmt><expr><name>bool</name> <macro><name>hasUnparsedDefaultArg</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>DefaultArgKind</name></name> <operator>==</operator> <name>DAK_Unparsed</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasUninstantiatedDefaultArg</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>DefaultArgKind</name></name> <operator>==</operator> <name>DAK_Uninstantiated</name></expr>;</return>
}</block></expr></expr_stmt>





<function><type><name>void</name></type> <name>setUnparsedDefaultArg</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>DefaultArgKind</name></name> <operator>=</operator> <name>DAK_Unparsed</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>hasInheritedDefaultArg</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>HasInheritedDefaultArg</name></name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setHasInheritedDefaultArg</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>I</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>HasInheritedDefaultArg</name></name> <operator>=</operator> <name>I</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>QualType</name> <macro><name>getOriginalType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>





<function><type><name>void</name></type> <name>setOwningFunction</name><parameter_list>(<parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>setDeclContext</name><argument_list>(<argument><expr><name>FD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>K</name> <operator>==</operator> <name>ParmVar</name></expr>;</return> </block_content>}</block></function>

<label><name>private</name>:</label>
<enum>enum <block>{ <decl><name>ParameterIndexSentinel</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>NumParameterIndexBits</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl> }</block>;</enum>

<function><type><name>void</name></type> <name>setParameterIndex</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>parameterIndex</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parameterIndex</name> <operator>&gt;=</operator> <name>ParameterIndexSentinel</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>setParameterIndexLarge</name><argument_list>(<argument><expr><name>parameterIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>ParameterIndex</name></name> <operator>=</operator> <name>parameterIndex</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ParmVarDeclBits</name><operator>.</operator><name>ParameterIndex</name></name> <operator>==</operator> <name>parameterIndex</name> <operator>&amp;&amp;</operator> <literal type="string">"truncation!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><name>unsigned</name> <macro><name>getParameterIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>unsigned</name> <name>d</name> <operator>=</operator> <name><name>ParmVarDeclBits</name><operator>.</operator><name>ParameterIndex</name></name></expr>;
<return>return <expr><ternary><condition><expr><name>d</name> <operator>==</operator> <name>ParameterIndexSentinel</name></expr> ?</condition><then> <expr><call><name>getParameterIndexLarge</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>d</name></expr></else></ternary></expr>;</return>
}</block></expr></expr_stmt>

<function_decl><type><name>void</name></type> <name>setParameterIndexLarge</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>parameterIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>unsigned</name> <macro><name>getParameterIndexLarge</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
};

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>MultiVersionKind</name> <block>{<block_content>
<expr_stmt><expr><name>None</name></expr><operator>,</operator>
<expr><name>Target</name></expr><operator>,</operator>
<expr><name>CPUSpecific</name></expr><operator>,</operator>
<expr><name>CPUDispatch</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>











<decl_stmt><decl><type><name>class</name></type> <name>FunctionDecl</name> <range>: <expr><name>public</name> <name>DeclaratorDecl</name></expr></range></decl>,
<decl><type ref="prev"/><name>public</name> <name>DeclContext</name></decl>,
<decl><type ref="prev"/><name>public</name> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>


<label><name>public</name>:</label>

<enum>enum <name>TemplatedKind</name> <block>{

<decl><name>TK_NonTemplate</name></decl>,

<decl><name>TK_FunctionTemplate</name></decl>,


<decl><name>TK_MemberSpecialization</name></decl>,



<decl><name>TK_FunctionTemplateSpecialization</name></decl>,


<decl><name>TK_DependentFunctionTemplateSpecialization</name></decl>
}</block>;</enum>



<decl_stmt><decl><type><name>class</name> <name>DefaultedFunctionInfo</name></type> <name>final</name>
<range>: <expr><name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>DefaultedFunctionInfo</name></expr></argument>, <argument><expr><name>DeclAccessPair</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>TrailingObjects</name></expr>;
<expr><name>unsigned</name> <name>NumLookups</name></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>DefaultedFunctionInfo</name> <operator>*</operator><call><name>Create</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>DeclAccessPair</name></expr></argument>&gt;</argument_list></name> <name>Lookups</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>DeclAccessPair</name></expr></argument>&gt;</argument_list></name> <macro><name>getUnqualifiedLookups</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>DeclAccessPair</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>, <expr><name>NumLookups</name></expr>}</block></expr>;</return>
}</block>
}</expr>;

<expr><name>private</name><operator>:</operator>



<name>ParmVarDecl</name> <operator>*</operator><operator>*</operator><name>ParamInfo</name> <operator>=</operator> <name>nullptr</name></expr>;



<expr>union <block>{

<expr><name>LazyDeclStmtPtr</name> <name>Body</name></expr>;

<expr><name>DefaultedFunctionInfo</name> <operator>*</operator><name>DefaultedInfo</name></expr>;
}</block></expr>;

<expr><name>unsigned</name> <name>ODRHash</name></expr>;








<expr><name>SourceLocation</name> <name>EndRangeLoc</name></expr>;













<expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTemplateDecl</name> <operator>*</operator></expr></argument>,
<argument><expr><name>MemberSpecializationInfo</name> <operator>*</operator></expr></argument>,
<argument><expr><name>FunctionTemplateSpecializationInfo</name> <operator>*</operator></expr></argument>,
<argument><expr><name>DependentFunctionTemplateSpecializationInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>TemplateOrSpecialization</name></expr>;



<expr><name>DeclarationNameLoc</name> <name>DNLoc</name></expr>;






















<expr><name>void</name> <macro><name>setFunctionTemplateSpecialization</name><argument_list>(<argument>ASTContext &amp;C</argument>,
<argument>FunctionTemplateDecl *Template</argument>,
<argument>const TemplateArgumentList *TemplateArgs</argument>,
<argument>void *InsertPos</argument>,
<argument>TemplateSpecializationKind TSK</argument>,
<argument>const TemplateArgumentListInfo *TemplateArgsAsWritten</argument>,
<argument>SourceLocation PointOfInstantiation</argument>)</argument_list></macro></expr>;



<expr><name>void</name> <macro><name>setInstantiationOfMemberFunction</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>FunctionDecl *FD</argument>,
<argument>TemplateSpecializationKind TSK</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <call><name>setParams</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>NewParamInfo</name></expr></argument>)</argument_list></call></expr>;




<expr><name>bool</name> <macro><name>isDeletedBit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsDeleted</name></name></expr>;</return> }</block>


<name>bool</name> <macro><name>hasODRHash</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>HasODRHash</name></name></expr>;</return> }</block>


<name>void</name> <macro><name>setHasODRHash</name><argument_list>(<argument>bool B = true</argument>)</argument_list></macro> <block>{ <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>HasODRHash</name></name> <operator>=</operator> <name>B</name></expr>; }</block>

<name>protected</name><operator>:</operator>
<macro><name>FunctionDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>, <argument>QualType T</argument>,
<argument>TypeSourceInfo *TInfo</argument>, <argument>StorageClass S</argument>, <argument>bool isInlineSpecified</argument>,
<argument>ConstexprSpecKind ConstexprKind</argument>,
<argument>Expr *TrailingRequiresClause = nullptr</argument>)</argument_list></macro></expr>;

<expr><name>using</name> <name>redeclarable_base</name> <operator>=</operator> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>FunctionDecl</name> <operator>*</operator><macro><name>getNextRedeclarationImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getNextRedeclaration</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>FunctionDecl</name> <operator>*</operator><macro><name>getPreviousDeclImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>FunctionDecl</name> <operator>*</operator><macro><name>getMostRecentDeclImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;

<expr><name>using</name> <name>redecl_range</name> <operator>=</operator> <name>redeclarable_base</name><operator>::</operator><name>redecl_range</name></expr>;
<expr><name>using</name> <name>redecl_iterator</name> <operator>=</operator> <name>redeclarable_base</name><operator>::</operator><name>redecl_iterator</name></expr>;

<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_begin</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_end</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getPreviousDecl</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getMostRecentDecl</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>isFirstDecl</name></expr>;

<expr><specifier>static</specifier> <name>FunctionDecl</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation NLoc</argument>, <argument>DeclarationName N</argument>, <argument>QualType T</argument>,
<argument>TypeSourceInfo *TInfo</argument>, <argument>StorageClass SC</argument>, <argument>bool isInlineSpecified = false</argument>,
<argument>bool hasWrittenPrototype = true</argument>,
<argument>ConstexprSpecKind ConstexprKind = ConstexprSpecKind::Unspecified</argument>,
<argument>Expr *TrailingRequiresClause = nullptr</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <call><name>NameInfo</name><argument_list>(<argument><expr><name>N</name></expr></argument>, <argument><expr><name>NLoc</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>FunctionDecl</name><operator>::</operator><call><name>Create</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>NameInfo</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>TInfo</name></expr></argument>, <argument><expr><name>SC</name></expr></argument>,
<argument><expr><name>isInlineSpecified</name></expr></argument>, <argument><expr><name>hasWrittenPrototype</name></expr></argument>,
<argument><expr><name>ConstexprKind</name></expr></argument>, <argument><expr><name>TrailingRequiresClause</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>FunctionDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>, <argument>QualType T</argument>,
<argument>TypeSourceInfo *TInfo</argument>, <argument>StorageClass SC</argument>,
<argument>bool isInlineSpecified</argument>, <argument>bool hasWrittenPrototype</argument>,
<argument>ConstexprSpecKind ConstexprKind</argument>,
<argument>Expr *TrailingRequiresClause</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>FunctionDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>DeclarationNameInfo</name> <macro><name>getNameInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>DeclarationNameInfo</name><argument_list>(<argument><expr><call><name>getDeclName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DNLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>getNameForDiagnostic</name><argument_list>(<argument>raw_ostream &amp;OS</argument>, <argument>const PrintingPolicy &amp;Policy</argument>,
<argument>bool Qualified</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>setRangeEnd</name><argument_list>(<argument>SourceLocation E</argument>)</argument_list></macro> <block>{ <expr><name>EndRangeLoc</name> <operator>=</operator> <name>E</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getEllipsisLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>auto</name> <operator>*</operator><name>FPT</name> <operator>=</operator> <call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>FPT</name> <operator>&amp;&amp;</operator> <call><name><name>FPT</name><operator>-&gt;</operator><name>isVariadic</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>FPT</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;</expr_stmt>




















<decl_stmt><decl><type><name>bool</name></type> <name>hasBody</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><operator>&amp;</operator><name>Definition</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<expr><specifier>const</specifier> <name>FunctionDecl</name><operator>*</operator> <name>Definition</name></expr>;
<return>return <expr><call><name>hasBody</name><argument_list>(<argument><expr><name>Definition</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasTrivialBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>












<decl_stmt><decl><type><name>bool</name></type> <name>isDefined</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><operator>&amp;</operator><name>Definition</name></expr></argument>,
<argument><expr><name>bool</name> <name>CheckForPendingFriendDefinition</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isDefined</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>FunctionDecl</name><operator>*</operator> <name>Definition</name></expr>;
<return>return <expr><call><name>isDefined</name><argument_list>(<argument><expr><name>Definition</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>getDefinition</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>Definition</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isDefined</name><argument_list>(<argument><expr><name>Definition</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Definition</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>nullptr</name></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><macro><name>getDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getDefinition</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>







<decl_stmt><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>getBody</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><operator>&amp;</operator><name>Definition</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>Stmt</name> <operator>*</operator><macro><name>getBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<expr><specifier>const</specifier> <name>FunctionDecl</name><operator>*</operator> <name>Definition</name></expr>;
<return>return <expr><call><name>getBody</name><argument_list>(<argument><expr><name>Definition</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>










<expr_stmt><expr><name>bool</name> <macro><name>isThisDeclarationADefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isDeletedAsWritten</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isDefaulted</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name>doesThisDeclarationHaveABody</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>hasSkippedBody</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name>willHaveBody</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>hasDefiningAttr</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>isThisDeclarationInstantiatedFromAFriendDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>doesThisDeclarationHaveABody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><operator>!</operator><name><name>FunctionDeclBits</name><operator>.</operator><name>HasDefaultedFunctionInfo</name></name> <operator>&amp;&amp;</operator> <name>Body</name><operator>)</operator> <operator>||</operator>
<call><name>isLateTemplateParsed</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function_decl><type><name>void</name></type> <name>setBody</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>void</name></type> <name>setLazyBody</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>Offset</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>HasDefaultedFunctionInfo</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>Body</name> <operator>=</operator> <call><name>LazyDeclStmtPtr</name><argument_list>(<argument><expr><name>Offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>setDefaultedFunctionInfo</name><parameter_list>(<parameter><decl><type><name>DefaultedFunctionInfo</name> <modifier>*</modifier></type><name>Info</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>DefaultedFunctionInfo</name> <operator>*</operator><macro><name>getDefaultedFunctionInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isVariadic</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isVirtualAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsVirtualAsWritten</name></name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setVirtualAsWritten</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>V</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsVirtualAsWritten</name></name> <operator>=</operator> <name>V</name></expr>;</expr_stmt> </block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>isPure</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsPure</name></name></expr>;</return> }</block></expr></expr_stmt>
<function_decl><type><name>void</name></type> <name>setPure</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>P</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>bool</name> <macro><name>isLateTemplateParsed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsLateTemplateParsed</name></name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setLateTemplateParsed</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>ILT</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsLateTemplateParsed</name></name> <operator>=</operator> <name>ILT</name></expr>;</expr_stmt>
</block_content>}</block></function>





<expr_stmt><expr><name>bool</name> <macro><name>isTrivial</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsTrivial</name></name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setTrivial</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IT</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsTrivial</name></name> <operator>=</operator> <name>IT</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>isTrivialForCall</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsTrivialForCall</name></name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setTrivialForCall</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IT</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsTrivialForCall</name></name> <operator>=</operator> <name>IT</name></expr>;</expr_stmt> </block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>isDefaulted</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsDefaulted</name></name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setDefaulted</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>D</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsDefaulted</name></name> <operator>=</operator> <name>D</name></expr>;</expr_stmt> </block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>isExplicitlyDefaulted</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsExplicitlyDefaulted</name></name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setExplicitlyDefaulted</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>ED</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsExplicitlyDefaulted</name></name> <operator>=</operator> <name>ED</name></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>isUserProvided</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <operator>*</operator><name>DeclAsWritten</name> <operator>=</operator> <name>this</name></expr>;
<if_stmt><if>if <condition>(<decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Pattern</name> <init>= <expr><call><name>getTemplateInstantiationPattern</name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>DeclAsWritten</name> <operator>=</operator> <name>Pattern</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><operator>!</operator><operator>(</operator><call><name><name>DeclAsWritten</name><operator>-&gt;</operator><name>isDeleted</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>DeclAsWritten</name><operator>-&gt;</operator><name>getCanonicalDecl</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isDefaulted</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>hasImplicitReturnZero</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>HasImplicitReturnZero</name></name></expr>;</return>
}</block></expr></expr_stmt>




<function><type><name>void</name></type> <name>setHasImplicitReturnZero</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IRZ</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>HasImplicitReturnZero</name></name> <operator>=</operator> <name>IRZ</name></expr>;</expr_stmt>
</block_content>}</block></function>





<expr_stmt><expr><name>bool</name> <macro><name>hasPrototype</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasWrittenPrototype</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>hasInheritedPrototype</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasWrittenPrototype</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>HasWrittenPrototype</name></name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setHasWrittenPrototype</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>P</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>HasWrittenPrototype</name></name> <operator>=</operator> <name>P</name></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>hasInheritedPrototype</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>HasInheritedPrototype</name></name></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>void</name></type> <name>setHasInheritedPrototype</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>P</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>HasInheritedPrototype</name></name> <operator>=</operator> <name>P</name></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>isConstexpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getConstexprKind</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>ConstexprSpecKind</name><operator>::</operator><name>Unspecified</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setConstexprKind</name><parameter_list>(<parameter><decl><type><name>ConstexprSpecKind</name></type> <name>CSK</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>ConstexprKind</name></name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CSK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><name>ConstexprSpecKind</name> <macro><name>getConstexprKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ConstexprSpecKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>ConstexprKind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isConstexprSpecified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getConstexprKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ConstexprSpecKind</name><operator>::</operator><name>Constexpr</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isConsteval</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getConstexprKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ConstexprSpecKind</name><operator>::</operator><name>Consteval</name></expr>;</return>
}</block></expr></expr_stmt>







<expr_stmt><expr><name>bool</name> <macro><name>instantiationIsPending</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>InstantiationIsPending</name></name></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>void</name></type> <name>setInstantiationIsPending</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>InstantiationIsPending</name></name> <operator>=</operator> <name>IC</name></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>usesSEHTry</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>UsesSEHTry</name></name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setUsesSEHTry</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>UST</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>UsesSEHTry</name></name> <operator>=</operator> <name>UST</name></expr>;</expr_stmt> </block_content>}</block></function>




















<expr_stmt><expr><name>bool</name> <macro><name>isDeleted</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name><name>FunctionDeclBits</name><operator>.</operator><name>IsDeleted</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isDeletedAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsDeleted</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isDefaulted</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setDeletedAsWritten</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>D</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsDeleted</name></name> <operator>=</operator> <name>D</name></expr>;</expr_stmt> </block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>isMain</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isMSVCRTEntryPoint</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>














<expr_stmt><expr><name>bool</name> <macro><name>isReservedGlobalPlacementOperator</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>






















<decl_stmt><decl><type><name>bool</name></type> <name>isReplaceableGlobalAllocationFunction</name><argument_list>(
<argument><expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>AlignmentParam</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>bool</name> <operator>*</operator><name>IsNothrow</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isInlineBuiltinDeclaration</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isDestroyingOperatorDelete</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>LanguageLinkage</name> <macro><name>getLanguageLinkage</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isExternC</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isInExternCContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isInExternCXXContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isGlobal</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isNoReturn</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasSkippedBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>HasSkippedBody</name></name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setHasSkippedBody</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Skipped</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>HasSkippedBody</name></name> <operator>=</operator> <name>Skipped</name></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>willHaveBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>WillHaveBody</name></name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setWillHaveBody</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>V</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>WillHaveBody</name></name> <operator>=</operator> <name>V</name></expr>;</expr_stmt> </block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>isMultiVersion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name><name>FunctionDeclBits</name><operator>.</operator><name>IsMultiVersion</name></name></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>void</name></type> <name>setIsMultiVersion</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>V</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name><name>FunctionDeclBits</name><operator>.</operator><name>IsMultiVersion</name></name> <operator>=</operator> <name>V</name></expr>;</expr_stmt>
</block_content>}</block></function>




<expr_stmt><expr><name>MultiVersionKind</name> <macro><name>getMultiVersionKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>isCPUDispatchMultiVersion</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isCPUSpecificMultiVersion</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isTargetMultiVersion</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>







<decl_stmt><decl><type><name>void</name></type> <name>getAssociatedConstraints</name><argument_list>(<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>AC</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>TRC</name> <operator>=</operator> <call><name>getTrailingRequiresClause</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>AC</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>TRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>

<function_decl><type><name>void</name></type> <name>setPreviousDeclaration</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type> <name>PrevDecl</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>FunctionDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>getBuiltinID</name><argument_list>(<argument><expr><name>bool</name> <name>ConsiderWrapperFunctions</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>parameters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><name>ParamInfo</name></expr>, <macro><name>getNumParams</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>parameters</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><block>{<expr><name>ParamInfo</name></expr>, <macro><name>getNumParams</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name>using</name></type> <name>param_iterator</name> <init>= <expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>param_const_iterator</name> <init>= <expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>param_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>parameters</name><argument_list>()</argument_list></call><operator>.</operator><call><name>empty</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>param_iterator</name></type> <name>param_begin</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>parameters</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>param_iterator</name></type> <name>param_end</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>parameters</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><name>param_const_iterator</name> <macro><name>param_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>parameters</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>param_const_iterator</name> <macro><name>param_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>parameters</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>size_t</name> <macro><name>param_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>parameters</name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>




<expr_stmt><expr><name>unsigned</name> <macro><name>getNumParams</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ParmVarDecl</name> <modifier>*</modifier></type><name>getParamDecl</name><argument_list>(<argument><expr><name>unsigned</name> <name>i</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getNumParams</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Illegal param #"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>ParamInfo</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<function><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>getParamDecl</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getNumParams</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Illegal param #"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>ParamInfo</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setParams</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>NewParamInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>setParams</name><argument_list>(<argument><expr><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NewParamInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<expr_stmt><expr><name>unsigned</name> <macro><name>getMinRequiredArguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>







<expr_stmt><expr><name>bool</name> <macro><name>hasOneParamOrDefaultArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>





<expr_stmt><expr><name>FunctionTypeLoc</name> <macro><name>getFunctionTypeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>QualType</name> <macro><name>getReturnType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>castAs</name><argument_list type="generic">&lt;<argument><expr><name>FunctionType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getReturnType</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>SourceRange</name> <macro><name>getReturnTypeSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>





<expr_stmt><expr><name>SourceRange</name> <macro><name>getParametersSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>QualType</name> <macro><name>getDeclaredReturnType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <operator>*</operator><name>TSI</name> <operator>=</operator> <call><name>getTypeSourceInfo</name><argument_list>()</argument_list></call></expr>;
<expr><name>QualType</name> <name>T</name> <operator>=</operator> <ternary><condition><expr><name>TSI</name></expr> ?</condition><then> <expr><call><name><name>TSI</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>getType</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;
<return>return <expr><name><name>T</name><operator>-&gt;</operator><name>castAs</name></name><operator>&lt;</operator><name>FunctionType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>-&gt;</operator><call><name>getReturnType</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>ExceptionSpecificationType</name> <macro><name>getExceptionSpecType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <operator>*</operator><name>TSI</name> <operator>=</operator> <call><name>getTypeSourceInfo</name><argument_list>()</argument_list></call></expr>;
<expr><name>QualType</name> <name>T</name> <operator>=</operator> <ternary><condition><expr><name>TSI</name></expr> ?</condition><then> <expr><call><name><name>TSI</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>getType</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;
<expr><specifier>const</specifier> <name>auto</name> <operator>*</operator><name>FPT</name> <operator>=</operator> <name><name>T</name><operator>-&gt;</operator><name>getAs</name></name><operator>&lt;</operator><name>FunctionProtoType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;
<return>return <expr><ternary><condition><expr><name>FPT</name></expr> ?</condition><then> <expr><call><name><name>FPT</name><operator>-&gt;</operator><name>getExceptionSpecType</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>EST_None</name></expr></else></ternary></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>SourceRange</name> <macro><name>getExceptionSpecSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>QualType</name> <macro><name>getCallResultType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>castAs</name><argument_list type="generic">&lt;<argument><expr><name>FunctionType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getCallResultType</name><argument_list>(
<argument><expr><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>StorageClass</name> <macro><name>getStorageClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>StorageClass</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>SClass</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setStorageClass</name><parameter_list>(<parameter><decl><type><name>StorageClass</name></type> <name>SClass</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>SClass</name></name> <operator>=</operator> <name>SClass</name></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>isInlineSpecified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsInlineSpecified</name></name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setInlineSpecified</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsInlineSpecified</name></name> <operator>=</operator> <name>I</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsInline</name></name> <operator>=</operator> <name>I</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>setImplicitlyInline</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>I</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsInline</name></name> <operator>=</operator> <name>I</name></expr>;</expr_stmt> </block_content>}</block></function>




<expr_stmt><expr><name>bool</name> <macro><name>isInlined</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsInline</name></name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isInlineDefinitionExternallyVisible</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isMSExternInline</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>doesDeclarationForceExternallyVisibleDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isStatic</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getStorageClass</name><argument_list>()</argument_list></call> <operator>==</operator> <name>SC_Static</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isOverloadedOperator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getOverloadedOperator</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>OO_None</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>OverloadedOperatorKind</name> <macro><name>getOverloadedOperator</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><macro><name>getLiteralIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>






















<expr_stmt><expr><name>FunctionDecl</name> <operator>*</operator><macro><name>getInstantiatedFromMemberFunction</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>TemplatedKind</name> <macro><name>getTemplatedKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>MemberSpecializationInfo</name> <operator>*</operator><macro><name>getMemberSpecializationInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<function><type><name>void</name></type> <name>setInstantiationOfMemberFunction</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>,
<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>setInstantiationOfMemberFunction</name><argument_list>(<argument><expr><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>FD</name></expr></argument>, <argument><expr><name>TSK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>













<expr_stmt><expr><name>FunctionTemplateDecl</name> <operator>*</operator><macro><name>getDescribedFunctionTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>setDescribedFunctionTemplate</name><parameter_list>(<parameter><decl><type><name>FunctionTemplateDecl</name> <modifier>*</modifier></type><name>Template</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>bool</name> <macro><name>isFunctionTemplateSpecialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getPrimaryTemplate</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>FunctionTemplateSpecializationInfo</name> <operator>*</operator><macro><name>getTemplateSpecializationInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>isImplicitlyInstantiable</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isTemplateInstantiation</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>









<decl_stmt><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type>
<name>getTemplateInstantiationPattern</name><argument_list>(<argument><expr><name>bool</name> <name>ForDefinition</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<expr_stmt><expr><name>FunctionTemplateDecl</name> <operator>*</operator><macro><name>getPrimaryTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>






<expr_stmt><expr><specifier>const</specifier> <name>TemplateArgumentList</name> <operator>*</operator><macro><name>getTemplateSpecializationArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>








<expr_stmt><expr><specifier>const</specifier> <name>ASTTemplateArgumentListInfo</name><operator>*</operator>
<macro><name>getTemplateSpecializationArgsAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




















<function><type><name>void</name></type> <name>setFunctionTemplateSpecialization</name><parameter_list>(<parameter><decl><type><name>FunctionTemplateDecl</name> <modifier>*</modifier></type><name>Template</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentList</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>InsertPos</name></decl></parameter>,
<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name> <init>= <expr><name>TSK_ImplicitInstantiation</name></expr></init></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgsAsWritten</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>setFunctionTemplateSpecialization</name><argument_list>(<argument><expr><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Template</name></expr></argument>, <argument><expr><name>TemplateArgs</name></expr></argument>,
<argument><expr><name>InsertPos</name></expr></argument>, <argument><expr><name>TSK</name></expr></argument>, <argument><expr><name>TemplateArgsAsWritten</name></expr></argument>,
<argument><expr><name>PointOfInstantiation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function_decl><type><name>void</name></type> <name>setDependentTemplateSpecialization</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UnresolvedSetImpl</name> <modifier>&amp;</modifier></type><name>Templates</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>DependentFunctionTemplateSpecializationInfo</name> <operator>*</operator>
<macro><name>getDependentSpecializationInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>TemplateSpecializationKind</name> <macro><name>getTemplateSpecializationKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>TemplateSpecializationKind</name>
<macro><name>getTemplateSpecializationKindForInstantiation</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<function_decl><type><name>void</name></type> <name>setTemplateSpecializationKind</name><parameter_list>(<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>







<expr_stmt><expr><name>SourceLocation</name> <macro><name>getPointOfInstantiation</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isOutOfLine</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;</expr_stmt>





<expr_stmt><expr><name>unsigned</name> <macro><name>getMemoryFunctionKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<function_decl><type><name>unsigned</name></type> <name>getODRHash</name><parameter_list>()</parameter_list>;</function_decl>



<expr_stmt><expr><name>unsigned</name> <macro><name>getODRHash</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>K</name> <operator>&gt;=</operator> <name>firstFunction</name> <operator>&amp;&amp;</operator> <name>K</name> <operator>&lt;=</operator> <name>lastFunction</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>castToDeclContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>castFromDeclContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
};


<decl_stmt><decl><type><name>class</name></type> <name>FieldDecl</name> <range>: <expr><name>public</name> <name>DeclaratorDecl</name></expr></range></decl>, <decl><type ref="prev"/><name>public</name> <name><name>Mergeable</name><argument_list type="generic">&lt;<argument><expr><name>FieldDecl</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>BitField</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>Mutable</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mutable</name> <name>unsigned</name></type> <name>CachedFieldIndex</name> <range>: <expr><literal type="number">30</literal></expr></range></decl>;</decl_stmt>





<enum>enum <name>InitStorageKind</name> <block>{



<decl><name>ISK_NoInit</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>)</operator> <name>ICIS_NoInit</name></expr></init></decl>,



<decl><name>ISK_InClassCopyInit</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>)</operator> <name>ICIS_CopyInit</name></expr></init></decl>,



<decl><name>ISK_InClassListInit</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>)</operator> <name>ICIS_ListInit</name></expr></init></decl>,



<decl><name>ISK_CapturedVLAType</name></decl>,
}</block>;</enum>



<struct>struct <name>InitAndBitWidth</name> <block>{
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BitWidth</name></decl>;</decl_stmt>
}</block>;</struct>










<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>InitStorageKind</name></expr></argument>&gt;</argument_list></name> <name>InitStorage</name></expr>;</expr_stmt>

<label><name>protected</name>:</label>
<macro><name>FieldDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>IdentifierInfo *Id</argument>,
<argument>QualType T</argument>, <argument>TypeSourceInfo *TInfo</argument>, <argument>Expr *BW</argument>, <argument>bool Mutable</argument>,
<argument>InClassInitStyle InitStyle</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>DeclaratorDecl</name><argument_list>(<argument><expr><name>DK</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>IdLoc</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>TInfo</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>BitField</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Mutable</name><argument_list>(<argument><expr><name>Mutable</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>CachedFieldIndex</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>InitStorage</name><argument_list>(<argument>nullptr</argument>, <argument>(InitStorageKind) InitStyle</argument>)</argument_list></macro> <expr><block>{
<if_stmt><if>if <condition>(<expr><name>BW</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setBitWidth</name><argument_list>(<argument><expr><name>BW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclWriter</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>FieldDecl</name> <modifier>*</modifier></type><name>Create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>IdLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Id</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BW</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Mutable</name></decl></parameter>,
<parameter><decl><type><name>InClassInitStyle</name></type> <name>InitStyle</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>FieldDecl</name> <modifier>*</modifier></type><name>CreateDeserialized</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>unsigned</name> <macro><name>getFieldIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isMutable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Mutable</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isBitField</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BitField</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isUnnamedBitfield</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isBitField</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>getDeclName</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>





<expr_stmt><expr><name>bool</name> <macro><name>isAnonymousStructOrUnion</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getBitWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>BitField</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<name>void</name> <operator>*</operator><name>Ptr</name> <operator>=</operator> <call><name><name>InitStorage</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getInClassInitStyle</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>InitAndBitWidth</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Ptr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>BitWidth</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>getBitWidthValue</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<function><type><name>void</name></type> <name>setBitWidth</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Width</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>hasCapturedVLAType</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>BitField</name> <operator>&amp;&amp;</operator>
<literal type="string">"bit width or captured type already set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>Width</name> <operator>&amp;&amp;</operator> <literal type="string">"no bit width specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>InitStorage</name></macro><expr_stmt><expr><operator>.</operator><macro><name>setPointer</name><argument_list>(
<argument>InitStorage.getInt()
? new (getASTContext())
InitAndBitWidth{getInClassInitializer()</argument>, <argument>Width}
: static_cast&lt;void*&gt;(Width)</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>BitField</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>removeBitWidth</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isBitField</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"no bitfield width to remove"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>InitStorage</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><call><name>getInClassInitializer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BitField</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>




<decl_stmt><decl><type><name>bool</name></type> <name>isZeroLengthBitField</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>isZeroSize</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>InClassInitStyle</name> <macro><name>getInClassInitStyle</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>InitStorageKind</name> <name>storageKind</name> <operator>=</operator> <call><name><name>InitStorage</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><operator>(</operator><ternary><condition><expr><name>storageKind</name> <operator>==</operator> <name>ISK_CapturedVLAType</name></expr>
?</condition><then> <expr><name>ICIS_NoInit</name></expr> </then><else>: <expr><operator>(</operator><name>InClassInitStyle</name><operator>)</operator> <name>storageKind</name></expr></else></ternary><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasInClassInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getInClassInitStyle</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>ICIS_NoInit</name></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getInClassInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasInClassInitializer</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<name>void</name> <operator>*</operator><name>Ptr</name> <operator>=</operator> <call><name><name>InitStorage</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>BitField</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>InitAndBitWidth</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Ptr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>Init</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>;</return>
}


void <macro><name>setInClassInitializer</name><argument_list>(<argument>Expr *Init</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasInClassInitializer</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>getInClassInitializer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>BitField</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>InitAndBitWidth</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>InitStorage</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>Init</name> <operator>=</operator> <name>Init</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>InitStorage</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block>


<function><type><name>void</name></type> <name>removeInClassInitializer</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasInClassInitializer</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"no initializer to remove"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>InitStorage</name><operator>.</operator><name>setPointerAndInt</name></name><argument_list>(<argument><expr><call><name>getBitWidth</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ISK_NoInit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>hasCapturedVLAType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>InitStorage</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ISK_CapturedVLAType</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>VariableArrayType</name> <operator>*</operator><macro><name>getCapturedVLAType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasCapturedVLAType</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VariableArrayType</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>InitStorage</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>:</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>


<function_decl><type><name>void</name></type> <name>setCapturedVLAType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VariableArrayType</name> <modifier>*</modifier></type><name>VLAType</name></decl></parameter>)</parameter_list>;</function_decl>






<expr_stmt><expr><specifier>const</specifier> <name>RecordDecl</name> <operator>*</operator><macro><name>getParent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>RecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDeclContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>RecordDecl</name> <modifier>*</modifier></type><name>getParent</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>RecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDeclContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;</expr_stmt>


<function><type><name>FieldDecl</name> <modifier>*</modifier></type><name>getCanonicalDecl</name><parameter_list>()</parameter_list> override <block>{<block_content> <return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>K</name> <operator>&gt;=</operator> <name>firstField</name> <operator>&amp;&amp;</operator> <name>K</name> <operator>&lt;=</operator> <name>lastField</name></expr>;</return> </block_content>}</block></function>
};





<decl_stmt><decl><type><name>class</name></type> <name>EnumConstantDecl</name> <range>: <expr><name>public</name> <name>ValueDecl</name></expr></range></decl>, <decl><type ref="prev"/><name>public</name> <name><name>Mergeable</name><argument_list type="generic">&lt;<argument><expr><name>EnumConstantDecl</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<decl_stmt><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Init</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>APSInt</name> <name>Val</name></expr>;</expr_stmt>

<label><name>protected</name>:</label>
<macro><name>EnumConstantDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>QualType T</argument>, <argument>Expr *E</argument>,
<argument>const llvm::APSInt &amp;V</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>ValueDecl</name><argument_list>(<argument><expr><name>EnumConstant</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>L</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>, <argument><expr><name>T</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Init</name><argument_list>(<argument><expr><operator>(</operator><name>Stmt</name><operator>*</operator><operator>)</operator><name>E</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Val</name><argument_list>(<argument>V</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>StmtIteratorBase</name></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EnumConstantDecl</name> <modifier>*</modifier></type><name>Create</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>EnumDecl</name> <operator>*</operator><name>DC</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>L</name></expr></argument>, <argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>Id</name></expr></argument>,
<argument><expr><name>QualType</name> <name>T</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>APSInt</name> <operator>&amp;</operator><name>V</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>EnumConstantDecl</name> <modifier>*</modifier></type><name>CreateDeserialized</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getInitExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><specifier>const</specifier> <name>Expr</name><operator>*</operator><operator>)</operator> <name>Init</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>getInitExpr</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator> <name>Init</name></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>APSInt</name> <operator>&amp;</operator><macro><name>getInitVal</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Val</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setInitExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Init</name> <operator>=</operator> <operator>(</operator><name>Stmt</name><operator>*</operator><operator>)</operator> <name>E</name></expr>;</expr_stmt> </block_content>}</block></function>
<decl_stmt><decl><type><name>void</name></type> <name>setInitVal</name><argument_list>(<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>APSInt</name> <operator>&amp;</operator><name>V</name></expr></argument>)</argument_list> <block>{<block_content> <expr_stmt><expr><name>Val</name> <operator>=</operator> <name>V</name></expr>;</expr_stmt> </block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;</expr_stmt>


<function><type><name>EnumConstantDecl</name> <modifier>*</modifier></type><name>getCanonicalDecl</name><parameter_list>()</parameter_list> override <block>{<block_content> <return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>EnumConstantDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>K</name> <operator>==</operator> <name>EnumConstant</name></expr>;</return> </block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>IndirectFieldDecl</name> <range>: <expr><name>public</name> <name>ValueDecl</name></expr></range></decl>,
<decl><type ref="prev"/><name>public</name> <name><name>Mergeable</name><argument_list type="generic">&lt;<argument><expr><name>IndirectFieldDecl</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier><modifier>*</modifier></type><name>Chaining</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ChainingSize</name></decl>;</decl_stmt>

<macro><name>IndirectFieldDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>,
<argument>DeclarationName N</argument>, <argument>QualType T</argument>,
<argument>MutableArrayRef&lt;NamedDecl *&gt; CH</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclReader</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>IndirectFieldDecl</name> <modifier>*</modifier></type><name>Create</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>DeclContext</name> <operator>*</operator><name>DC</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>L</name></expr></argument>, <argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>Id</name></expr></argument>,
<argument><expr><name>QualType</name> <name>T</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CH</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>IndirectFieldDecl</name> <modifier>*</modifier></type><name>CreateDeserialized</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>using</name></type> <name>chain_iterator</name> <init>= <expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>chain</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><name>Chaining</name></expr></argument>, <argument><expr><name>ChainingSize</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>chain_iterator</name> <macro><name>chain_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>chain</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>chain_iterator</name> <macro><name>chain_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>chain</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>getChainingSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ChainingSize</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>FieldDecl</name> <operator>*</operator><macro><name>getAnonField</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>chain</name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>FieldDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>chain</name><argument_list>()</argument_list></call><operator>.</operator><call><name>back</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>VarDecl</name> <operator>*</operator><macro><name>getVarDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>chain</name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>chain</name><argument_list>()</argument_list></call><operator>.</operator><call><name>front</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>IndirectFieldDecl</name> <modifier>*</modifier></type><name>getCanonicalDecl</name><parameter_list>()</parameter_list> override <block>{<block_content> <return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>IndirectFieldDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>K</name> <operator>==</operator> <name>IndirectField</name></expr>;</return> </block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>TypeDecl</name> <range>: <expr><name>public</name> <name>NamedDecl</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;





<expr><name>mutable</name> <specifier>const</specifier> <name>Type</name> <operator>*</operator><name>TypeForDecl</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>SourceLocation</name> <name>LocStart</name></expr>;

<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>TypeDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>, <argument>IdentifierInfo *Id</argument>,
<argument>SourceLocation StartL = SourceLocation()</argument>)</argument_list></macro>
<operator>:</operator> <call><name>NamedDecl</name><argument_list>(<argument><expr><name>DK</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>L</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>)</argument_list></call></expr>, <macro><name>LocStart</name><argument_list>(<argument>StartL</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>




<specifier>const</specifier> <name>Type</name> <operator>*</operator><macro><name>getTypeForDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TypeForDecl</name></expr>;</return> }</block>
<name>void</name> <macro><name>setTypeForDecl</name><argument_list>(<argument>const Type *TD</argument>)</argument_list></macro> <block>{ <expr><name>TypeForDecl</name> <operator>=</operator> <name>TD</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>LocStart</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLocStart</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>LocStart</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>LocStart</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>LocStart</name></expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>&gt;=</operator> <name>firstType</name> <operator>&amp;&amp;</operator> <name>K</name> <operator>&lt;=</operator> <name>lastType</name></expr>;</return> }</block>
}</expr>;


<expr><name>class</name> <name>TypedefNameDecl</name> <operator>:</operator> <name>public</name> <name>TypeDecl</name></expr>, <expr><name>public</name> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>TypedefNameDecl</name></expr></argument>&gt;</argument_list></name> <block>{
struct <macro><name>alignas</name><argument_list>(<argument><literal type="number">8</literal></argument>)</argument_list></macro> <expr><name>ModedTInfo</name> <block>{
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>first</name></expr>;
<expr><name>QualType</name> <name>second</name></expr>;
}</block></expr>;



<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;
<argument><expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>ModedTInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name>
<name>MaybeModedTInfo</name></expr>;

<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>TypedefNameDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation IdLoc</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>TypeSourceInfo *TInfo</argument>)</argument_list></macro>
<operator>:</operator> <call><name>TypeDecl</name><argument_list>(<argument><expr><name>DK</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>IdLoc</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>redeclarable_base</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>,
<macro><name>MaybeModedTInfo</name><argument_list>(<argument>TInfo</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro> <expr><block>{}</block>

<name>using</name> <name>redeclarable_base</name> <operator>=</operator> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>TypedefNameDecl</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>TypedefNameDecl</name> <operator>*</operator><macro><name>getNextRedeclarationImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getNextRedeclaration</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>TypedefNameDecl</name> <operator>*</operator><macro><name>getPreviousDeclImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>TypedefNameDecl</name> <operator>*</operator><macro><name>getMostRecentDeclImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>using</name> <name>redecl_range</name> <operator>=</operator> <name>redeclarable_base</name><operator>::</operator><name>redecl_range</name></expr>;
<expr><name>using</name> <name>redecl_iterator</name> <operator>=</operator> <name>redeclarable_base</name><operator>::</operator><name>redecl_iterator</name></expr>;

<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_begin</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_end</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getPreviousDecl</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getMostRecentDecl</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>isFirstDecl</name></expr>;

<expr><name>bool</name> <macro><name>isModed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>MaybeModedTInfo</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>is</name><argument_list type="generic">&lt;<argument><expr><name>ModedTInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isModed</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name><name>MaybeModedTInfo</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>ModedTInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>first</name>
<operator>:</operator> <call><name><name>MaybeModedTInfo</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>QualType</name> <macro><name>getUnderlyingType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>isModed</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>MaybeModedTInfo</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>ModedTInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>second</name></expr>
</then><else>: <expr><call><name><name>MaybeModedTInfo</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call>
<operator>.</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call>
<operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>

<name>void</name> <macro><name>setTypeSourceInfo</name><argument_list>(<argument>TypeSourceInfo *newType</argument>)</argument_list></macro> <block>{
<expr><call><name><name>MaybeModedTInfo</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><name>newType</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>setModedTypeSourceInfo</name><argument_list>(<argument>TypeSourceInfo *unmodedTSI</argument>, <argument>QualType modedTy</argument>)</argument_list></macro> <block>{
<macro><name>MaybeModedTInfo</name></macro><expr><operator>.</operator><macro><name>setPointer</name><argument_list>(<argument>new (getASTContext(), <literal type="number">8</literal>)
ModedTInfo({unmodedTSI, modedTy})</argument>)</argument_list></macro></expr>;
}</block>


<name>TypedefNameDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{ <return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>TypedefNameDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return> }</block>






<name>TagDecl</name> <operator>*</operator><macro><name>getAnonDeclWithTypedefName</name><argument_list>(<argument>bool AnyRedecl = false</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isTransparentTag</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>MaybeModedTInfo</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>MaybeModedTInfo</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <literal type="number">0x2</literal></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>isTransparentTagSlow</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{
<return>return <expr><name>K</name> <operator>&gt;=</operator> <name>firstTypedefName</name> <operator>&amp;&amp;</operator> <name>K</name> <operator>&lt;=</operator> <name>lastTypedefName</name></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>bool</name> <macro><name>isTransparentTagSlow</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>TypedefDecl</name> <range>: <expr><name>public</name> <name>TypedefNameDecl</name> <block>{
<macro><name>TypedefDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>IdentifierInfo *Id</argument>, <argument>TypeSourceInfo *TInfo</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>TypedefNameDecl</name><argument_list>(<argument>Typedef</argument>, <argument>C</argument>, <argument>DC</argument>, <argument>StartLoc</argument>, <argument>IdLoc</argument>, <argument>Id</argument>, <argument>TInfo</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>TypedefDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation IdLoc</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>TypeSourceInfo *TInfo</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>TypedefDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;


<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>Typedef</name></expr>;</return> }</block>
}</expr>;



<expr><name>class</name> <name>TypeAliasDecl</name> <operator>:</operator> <name>public</name> <name>TypedefNameDecl</name> <block>{

<expr><name>TypeAliasTemplateDecl</name> <operator>*</operator><name>Template</name></expr>;

<macro><name>TypeAliasDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>IdentifierInfo *Id</argument>, <argument>TypeSourceInfo *TInfo</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>TypedefNameDecl</name><argument_list>(<argument><expr><name>TypeAlias</name></expr></argument>, <argument><expr><name>C</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>IdLoc</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>, <argument><expr><name>TInfo</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Template</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>TypeAliasDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation IdLoc</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>TypeSourceInfo *TInfo</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>TypeAliasDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;

<expr><name>TypeAliasTemplateDecl</name> <operator>*</operator><macro><name>getDescribedAliasTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Template</name></expr>;</return> }</block>
<name>void</name> <macro><name>setDescribedAliasTemplate</name><argument_list>(<argument>TypeAliasTemplateDecl *TAT</argument>)</argument_list></macro> <block>{ <expr><name>Template</name> <operator>=</operator> <name>TAT</name></expr>; }</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>TypeAlias</name></expr>;</return> }</block>
}</expr>;


<expr><name>class</name> <name>TagDecl</name> <operator>:</operator> <name>public</name> <name>TypeDecl</name></expr>,
<expr><name>public</name> <name>DeclContext</name></expr>,
<expr><name>public</name> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>TagDecl</name></expr></argument>&gt;</argument_list></name> <block>{


<expr><name>public</name><operator>:</operator>

<name>using</name> <name>TagKind</name> <operator>=</operator> <name>TagTypeKind</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>SourceRange</name> <name>BraceRange</name></expr>;



<expr><name>using</name> <name>ExtInfo</name> <operator>=</operator> <name>QualifierInfo</name></expr>;









<expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>TypedefNameDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>ExtInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>TypedefNameDeclOrQualifier</name></expr>;

<expr><name>bool</name> <macro><name>hasExtInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>TypedefNameDeclOrQualifier</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>ExtInfo</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block>
<name>ExtInfo</name> <operator>*</operator><macro><name>getExtInfo</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name><name>TypedefNameDeclOrQualifier</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>ExtInfo</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block>
<specifier>const</specifier> <name>ExtInfo</name> <operator>*</operator><macro><name>getExtInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>TypedefNameDeclOrQualifier</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>ExtInfo</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>

<name>protected</name><operator>:</operator>
<macro><name>TagDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>TagKind TK</argument>, <argument>const ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation L</argument>, <argument>IdentifierInfo *Id</argument>, <argument>TagDecl *PrevDecl</argument>,
<argument>SourceLocation StartL</argument>)</argument_list></macro></expr>;

<expr><name>using</name> <name>redeclarable_base</name> <operator>=</operator> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>TagDecl</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>TagDecl</name> <operator>*</operator><macro><name>getNextRedeclarationImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getNextRedeclaration</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>TagDecl</name> <operator>*</operator><macro><name>getPreviousDeclImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>TagDecl</name> <operator>*</operator><macro><name>getMostRecentDeclImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>




<name>void</name> <call><name>completeDefinition</name><argument_list>()</argument_list></call></expr>;


<expr><name>void</name> <macro><name>setBeingDefined</name><argument_list>(<argument>bool V = true</argument>)</argument_list></macro> <block>{ <expr><name><name>TagDeclBits</name><operator>.</operator><name>IsBeingDefined</name></name> <operator>=</operator> <name>V</name></expr>; }</block>





<name>void</name> <macro><name>setMayHaveOutOfDateDef</name><argument_list>(<argument>bool V = true</argument>)</argument_list></macro> <block>{
<expr><name><name>TagDeclBits</name><operator>.</operator><name>MayHaveOutOfDateDef</name></name> <operator>=</operator> <name>V</name></expr>;
}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;

<expr><name>using</name> <name>redecl_range</name> <operator>=</operator> <name>redeclarable_base</name><operator>::</operator><name>redecl_range</name></expr>;
<expr><name>using</name> <name>redecl_iterator</name> <operator>=</operator> <name>redeclarable_base</name><operator>::</operator><name>redecl_iterator</name></expr>;

<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_begin</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_end</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getPreviousDecl</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getMostRecentDecl</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>isFirstDecl</name></expr>;

<expr><name>SourceRange</name> <macro><name>getBraceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BraceRange</name></expr>;</return> }</block>
<name>void</name> <macro><name>setBraceRange</name><argument_list>(<argument>SourceRange R</argument>)</argument_list></macro> <block>{ <expr><name>BraceRange</name> <operator>=</operator> <name>R</name></expr>; }</block>



<name>SourceLocation</name> <macro><name>getInnerLocStart</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>SourceLocation</name> <macro><name>getOuterLocStart</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;

<expr><name>TagDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><specifier>const</specifier> <name>TagDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>TagDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isThisDeclarationADefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isCompleteDefinition</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>isCompleteDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>TagDeclBits</name><operator>.</operator><name>IsCompleteDefinition</name></name></expr>;</return> }</block>


<name>void</name> <macro><name>setCompleteDefinition</name><argument_list>(<argument>bool V = true</argument>)</argument_list></macro> <block>{
<expr><name><name>TagDeclBits</name><operator>.</operator><name>IsCompleteDefinition</name></name> <operator>=</operator> <name>V</name></expr>;
}</block>



<name>bool</name> <macro><name>isCompleteDefinitionRequired</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>TagDeclBits</name><operator>.</operator><name>IsCompleteDefinitionRequired</name></name></expr>;</return>
}</block>



<name>void</name> <macro><name>setCompleteDefinitionRequired</name><argument_list>(<argument>bool V = true</argument>)</argument_list></macro> <block>{
<expr><name><name>TagDeclBits</name><operator>.</operator><name>IsCompleteDefinitionRequired</name></name> <operator>=</operator> <name>V</name></expr>;
}</block>


<name>bool</name> <macro><name>isBeingDefined</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>TagDeclBits</name><operator>.</operator><name>IsBeingDefined</name></name></expr>;</return> }</block>



<name>bool</name> <macro><name>isEmbeddedInDeclarator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>TagDeclBits</name><operator>.</operator><name>IsEmbeddedInDeclarator</name></name></expr>;</return>
}</block>



<name>void</name> <macro><name>setEmbeddedInDeclarator</name><argument_list>(<argument>bool isInDeclarator</argument>)</argument_list></macro> <block>{
<expr><name><name>TagDeclBits</name><operator>.</operator><name>IsEmbeddedInDeclarator</name></name> <operator>=</operator> <name>isInDeclarator</name></expr>;
}</block>


<name>bool</name> <macro><name>isFreeStanding</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>TagDeclBits</name><operator>.</operator><name>IsFreeStanding</name></name></expr>;</return> }</block>


<name>void</name> <macro><name>setFreeStanding</name><argument_list>(<argument>bool isFreeStanding = true</argument>)</argument_list></macro> <block>{
<expr><name><name>TagDeclBits</name><operator>.</operator><name>IsFreeStanding</name></name> <operator>=</operator> <name>isFreeStanding</name></expr>;
}</block>





<name>bool</name> <macro><name>mayHaveOutOfDateDef</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>TagDeclBits</name><operator>.</operator><name>MayHaveOutOfDateDef</name></name></expr>;</return> }</block>




<name>bool</name> <macro><name>isDependentType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isDependentContext</name><argument_list>()</argument_list></call></expr>;</return> }</block>






<name>void</name> <call><name>startDefinition</name><argument_list>()</argument_list></call></expr>;









<expr><name>TagDecl</name> <operator>*</operator><macro><name>getDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>StringRef</name> <macro><name>getKindName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TypeWithKeyword</name><operator>::</operator><call><name>getTagTypeKindName</name><argument_list>(<argument><expr><call><name>getTagKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>TagKind</name> <macro><name>getTagKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TagKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>TagDeclBits</name><operator>.</operator><name>TagDeclKind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setTagKind</name><argument_list>(<argument>TagKind TK</argument>)</argument_list></macro> <block>{ <expr><name><name>TagDeclBits</name><operator>.</operator><name>TagDeclKind</name></name> <operator>=</operator> <name>TK</name></expr>; }</block>

<name>bool</name> <macro><name>isStruct</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTagKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TTK_Struct</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isInterface</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTagKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TTK_Interface</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTagKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TTK_Class</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isUnion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTagKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TTK_Union</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isEnum</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTagKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TTK_Enum</name></expr>;</return> }</block>
















<name>bool</name> <macro><name>hasNameForLinkage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>getDeclName</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>getTypedefNameForAnonDecl</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block>

<name>TypedefNameDecl</name> <operator>*</operator><macro><name>getTypedefNameForAnonDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasExtInfo</name><argument_list>()</argument_list></call> <operator>?</operator> <name>nullptr</name>
<operator>:</operator> <name><name>TypedefNameDeclOrQualifier</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>TypedefNameDecl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>

<name>void</name> <call><name>setTypedefNameForAnonDecl</name><argument_list>(<argument><expr><name>TypedefNameDecl</name> <operator>*</operator><name>TDD</name></expr></argument>)</argument_list></call></expr>;



<expr><name>NestedNameSpecifier</name> <operator>*</operator><macro><name>getQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasExtInfo</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getExtInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>




<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasExtInfo</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getExtInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>QualifierLoc</name></expr>
</then><else>: <expr><call><name>NestedNameSpecifierLoc</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>

<name>void</name> <macro><name>setQualifierInfo</name><argument_list>(<argument>NestedNameSpecifierLoc QualifierLoc</argument>)</argument_list></macro></expr>;

<expr><name>unsigned</name> <macro><name>getNumTemplateParameterLists</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasExtInfo</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getExtInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>NumTemplParamLists</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
}</block>

<name>TemplateParameterList</name> <operator>*</operator><macro><name>getTemplateParameterList</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getNumTemplateParameterLists</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getExtInfo</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name><name>TemplParamLists</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
}</block>

<name>void</name> <call><name>setTemplateParameterListsInfo</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateParameterList</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>TPLists</name></expr></argument>)</argument_list></call></expr>;


<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>&gt;=</operator> <name>firstTag</name> <operator>&amp;&amp;</operator> <name>K</name> <operator>&lt;=</operator> <name>lastTag</name></expr>;</return> }</block>

<specifier>static</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>castToDeclContext</name><argument_list>(<argument>const TagDecl *D</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>TagDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>TagDecl</name> <operator>*</operator><macro><name>castFromDeclContext</name><argument_list>(<argument>const DeclContext *DC</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TagDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>EnumDecl</name> <operator>:</operator> <name>public</name> <name>TagDecl</name> <block>{

















<expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator></expr></argument>, <argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>IntegerType</name></expr>;





<expr><name>QualType</name> <name>PromotionType</name></expr>;




<expr><name>MemberSpecializationInfo</name> <operator>*</operator><name>SpecializationInfo</name> <operator>=</operator> <name>nullptr</name></expr>;




<expr><name>unsigned</name> <name>ODRHash</name></expr>;

<macro><name>EnumDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>IdentifierInfo *Id</argument>, <argument>EnumDecl *PrevDecl</argument>,
<argument>bool Scoped</argument>, <argument>bool ScopedUsingClassTag</argument>, <argument>bool Fixed</argument>)</argument_list></macro>;

<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>void</name> <macro><name>setInstantiationOfMemberEnum</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>EnumDecl *ED</argument>,
<argument>TemplateSpecializationKind TSK</argument>)</argument_list></macro></expr>;



<expr><name>void</name> <macro><name>setNumPositiveBits</name><argument_list>(<argument>unsigned Num</argument>)</argument_list></macro> <block>{
<expr><name><name>EnumDeclBits</name><operator>.</operator><name>NumPositiveBits</name></name> <operator>=</operator> <name>Num</name></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>EnumDeclBits</name><operator>.</operator><name>NumPositiveBits</name></name> <operator>==</operator> <name>Num</name> <operator>&amp;&amp;</operator> <literal type="string">"can't store this bitcount"</literal></expr></argument>)</argument_list></call></expr>;
}</block>



<name>void</name> <macro><name>setNumNegativeBits</name><argument_list>(<argument>unsigned Num</argument>)</argument_list></macro> <block>{ <expr><name><name>EnumDeclBits</name><operator>.</operator><name>NumNegativeBits</name></name> <operator>=</operator> <name>Num</name></expr>; }</block>

<name>public</name><operator>:</operator>


<name>void</name> <macro><name>setScoped</name><argument_list>(<argument>bool Scoped = true</argument>)</argument_list></macro> <block>{ <expr><name><name>EnumDeclBits</name><operator>.</operator><name>IsScoped</name></name> <operator>=</operator> <name>Scoped</name></expr>; }</block>





<name>void</name> <macro><name>setScopedUsingClassTag</name><argument_list>(<argument>bool ScopedUCT = true</argument>)</argument_list></macro> <block>{
<expr><name><name>EnumDeclBits</name><operator>.</operator><name>IsScopedUsingClassTag</name></name> <operator>=</operator> <name>ScopedUCT</name></expr>;
}</block>



<name>void</name> <macro><name>setFixed</name><argument_list>(<argument>bool Fixed = true</argument>)</argument_list></macro> <block>{ <expr><name><name>EnumDeclBits</name><operator>.</operator><name>IsFixed</name></name> <operator>=</operator> <name>Fixed</name></expr>; }</block>

<name>private</name><operator>:</operator>

<name>bool</name> <macro><name>hasODRHash</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>EnumDeclBits</name><operator>.</operator><name>HasODRHash</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setHasODRHash</name><argument_list>(<argument>bool Hash = true</argument>)</argument_list></macro> <block>{ <expr><name><name>EnumDeclBits</name><operator>.</operator><name>HasODRHash</name></name> <operator>=</operator> <name>Hash</name></expr>; }</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;

<expr><name>EnumDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>EnumDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TagDecl</name><operator>::</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>EnumDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>EnumDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>EnumDecl</name> <operator>*</operator><macro><name>getPreviousDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>EnumDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TagDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>EnumDecl</name> <operator>*</operator><macro><name>getPreviousDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>EnumDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>EnumDecl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>EnumDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TagDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>EnumDecl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>EnumDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>EnumDecl</name> <operator>*</operator><macro><name>getDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>EnumDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TagDecl</name><operator>::</operator><call><name>getDefinition</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>EnumDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation IdLoc</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>EnumDecl *PrevDecl</argument>,
<argument>bool IsScoped</argument>, <argument>bool IsScopedUsingClassTag</argument>,
<argument>bool IsFixed</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>EnumDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;






<expr><name>void</name> <macro><name>completeDefinition</name><argument_list>(<argument>QualType NewType</argument>,
<argument>QualType PromotionType</argument>,
<argument>unsigned NumPositiveBits</argument>,
<argument>unsigned NumNegativeBits</argument>)</argument_list></macro></expr>;


<expr><name>using</name> <name>enumerator_iterator</name> <operator>=</operator> <name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>EnumConstantDecl</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>enumerator_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>EnumConstantDecl</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>enumerator_range</name> <macro><name>enumerators</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>enumerator_range</name><argument_list>(<argument><expr><call><name>enumerator_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>enumerator_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>enumerator_iterator</name> <macro><name>enumerator_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>EnumDecl</name> <operator>*</operator><name>E</name> <operator>=</operator> <call><name>getDefinition</name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>E</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>E</name> <operator>=</operator> <name>this</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>enumerator_iterator</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>decls_begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>enumerator_iterator</name> <macro><name>enumerator_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>EnumDecl</name> <operator>*</operator><name>E</name> <operator>=</operator> <call><name>getDefinition</name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>E</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>E</name> <operator>=</operator> <name>this</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>enumerator_iterator</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>decls_end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>QualType</name> <macro><name>getPromotionType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PromotionType</name></expr>;</return> }</block>


<name>void</name> <macro><name>setPromotionType</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <block>{ <expr><name>PromotionType</name> <operator>=</operator> <name>T</name></expr>; }</block>




<name>QualType</name> <macro><name>getIntegerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IntegerType</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>Type</name> <modifier>*</modifier></type><name>T</name> <init>= <expr><name><name>IntegerType</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><specifier>const</specifier> <name>Type</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name><name>IntegerType</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>TypeSourceInfo</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getUnqualifiedType</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>


<function><type><name>void</name></type> <name>setIntegerType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>IntegerType</name> <operator>=</operator> <call><name><name>T</name><operator>.</operator><name>getTypePtrOrNull</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>


<function><type><name>void</name></type> <name>setIntegerTypeSourceInfo</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>IntegerType</name> <operator>=</operator> <name>TInfo</name></expr>;</expr_stmt> </block_content>}</block></function>



<expr_stmt><expr><name>TypeSourceInfo</name> <operator>*</operator><macro><name>getIntegerTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>IntegerType</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>TypeSourceInfo</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>SourceRange</name> <macro><name>getIntegerTypeRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;</expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getNumPositiveBits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>EnumDeclBits</name><operator>.</operator><name>NumPositiveBits</name></name></expr>;</return> }</block></expr></expr_stmt>










<expr_stmt><expr><name>unsigned</name> <macro><name>getNumNegativeBits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>EnumDeclBits</name><operator>.</operator><name>NumNegativeBits</name></name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isScoped</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>EnumDeclBits</name><operator>.</operator><name>IsScoped</name></name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isScopedUsingClassTag</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>EnumDeclBits</name><operator>.</operator><name>IsScopedUsingClassTag</name></name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isFixed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>EnumDeclBits</name><operator>.</operator><name>IsFixed</name></name></expr>;</return> }</block></expr></expr_stmt>

<function_decl><type><name>unsigned</name></type> <name>getODRHash</name><parameter_list>()</parameter_list>;</function_decl>


<expr_stmt><expr><name>bool</name> <macro><name>isComplete</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{


<return>return <expr><call><name>isCompleteDefinition</name><argument_list>()</argument_list></call> <operator>||</operator> <name>IntegerType</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isClosed</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isClosedFlag</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isClosedNonFlag</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>EnumDecl</name> <operator>*</operator><macro><name>getTemplateInstantiationPattern</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>EnumDecl</name> <operator>*</operator><macro><name>getInstantiatedFromMemberEnum</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>TemplateSpecializationKind</name> <macro><name>getTemplateSpecializationKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<function_decl><type><name>void</name></type> <name>setTemplateSpecializationKind</name><parameter_list>(<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<expr_stmt><expr><name>MemberSpecializationInfo</name> <operator>*</operator><macro><name>getMemberSpecializationInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>SpecializationInfo</name></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>void</name></type> <name>setInstantiationOfMemberEnum</name><parameter_list>(<parameter><decl><type><name>EnumDecl</name> <modifier>*</modifier></type><name>ED</name></decl></parameter>,
<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>setInstantiationOfMemberEnum</name><argument_list>(<argument><expr><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ED</name></expr></argument>, <argument><expr><name>TSK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>K</name> <operator>==</operator> <name>Enum</name></expr>;</return> </block_content>}</block></function>
};





<decl_stmt><decl><type><name>class</name></type> <name>RecordDecl</name> <range>: <expr><name>public</name> <name>TagDecl</name> <block>{


<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>DeclContext</name></expr>;




enum <expr><name>ArgPassingKind</name> <operator>:</operator> <name>unsigned</name> <block>{

<expr><name>APK_CanPassInRegs</name></expr>,








<expr><name>APK_CannotPassInRegs</name></expr>,




<expr><name>APK_CanNeverPassInRegs</name></expr>
}</block></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>RecordDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>TagKind TK</argument>, <argument>const ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation IdLoc</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>RecordDecl *PrevDecl</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>RecordDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>TagKind TK</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation IdLoc</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>RecordDecl* PrevDecl = nullptr</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>RecordDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>RecordDecl</name> <operator>*</operator><macro><name>getPreviousDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>RecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TagDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>RecordDecl</name> <operator>*</operator><macro><name>getPreviousDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>RecordDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>RecordDecl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>RecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TagDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>RecordDecl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>RecordDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasFlexibleArrayMember</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>RecordDeclBits</name><operator>.</operator><name>HasFlexibleArrayMember</name></name></expr>;</return>
}</block>

<name>void</name> <macro><name>setHasFlexibleArrayMember</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{
<expr><name><name>RecordDeclBits</name><operator>.</operator><name>HasFlexibleArrayMember</name></name> <operator>=</operator> <name>V</name></expr>;
}</block>












<name>bool</name> <macro><name>isAnonymousStructOrUnion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>RecordDeclBits</name><operator>.</operator><name>AnonymousStructOrUnion</name></name></expr>;</return>
}</block>

<name>void</name> <macro><name>setAnonymousStructOrUnion</name><argument_list>(<argument>bool Anon</argument>)</argument_list></macro> <block>{
<expr><name><name>RecordDeclBits</name><operator>.</operator><name>AnonymousStructOrUnion</name></name> <operator>=</operator> <name>Anon</name></expr>;
}</block>

<name>bool</name> <macro><name>hasObjectMember</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>RecordDeclBits</name><operator>.</operator><name>HasObjectMember</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setHasObjectMember</name><argument_list>(<argument>bool val</argument>)</argument_list></macro> <block>{ <expr><name><name>RecordDeclBits</name><operator>.</operator><name>HasObjectMember</name></name> <operator>=</operator> <name>val</name></expr>; }</block>

<name>bool</name> <macro><name>hasVolatileMember</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>RecordDeclBits</name><operator>.</operator><name>HasVolatileMember</name></name></expr>;</return> }</block>

<name>void</name> <macro><name>setHasVolatileMember</name><argument_list>(<argument>bool val</argument>)</argument_list></macro> <block>{
<expr><name><name>RecordDeclBits</name><operator>.</operator><name>HasVolatileMember</name></name> <operator>=</operator> <name>val</name></expr>;
}</block>

<name>bool</name> <macro><name>hasLoadedFieldsFromExternalStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>RecordDeclBits</name><operator>.</operator><name>LoadedFieldsFromExternalStorage</name></name></expr>;</return>
}</block>

<name>void</name> <macro><name>setHasLoadedFieldsFromExternalStorage</name><argument_list>(<argument>bool val</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name><name>RecordDeclBits</name><operator>.</operator><name>LoadedFieldsFromExternalStorage</name></name> <operator>=</operator> <name>val</name></expr>;
}</block>


<name>bool</name> <macro><name>isNonTrivialToPrimitiveDefaultInitialize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>RecordDeclBits</name><operator>.</operator><name>NonTrivialToPrimitiveDefaultInitialize</name></name></expr>;</return>
}</block>

<name>void</name> <macro><name>setNonTrivialToPrimitiveDefaultInitialize</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{
<expr><name><name>RecordDeclBits</name><operator>.</operator><name>NonTrivialToPrimitiveDefaultInitialize</name></name> <operator>=</operator> <name>V</name></expr>;
}</block>

<name>bool</name> <macro><name>isNonTrivialToPrimitiveCopy</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>RecordDeclBits</name><operator>.</operator><name>NonTrivialToPrimitiveCopy</name></name></expr>;</return>
}</block>

<name>void</name> <macro><name>setNonTrivialToPrimitiveCopy</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{
<expr><name><name>RecordDeclBits</name><operator>.</operator><name>NonTrivialToPrimitiveCopy</name></name> <operator>=</operator> <name>V</name></expr>;
}</block>

<name>bool</name> <macro><name>isNonTrivialToPrimitiveDestroy</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>RecordDeclBits</name><operator>.</operator><name>NonTrivialToPrimitiveDestroy</name></name></expr>;</return>
}</block>

<name>void</name> <macro><name>setNonTrivialToPrimitiveDestroy</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{
<expr><name><name>RecordDeclBits</name><operator>.</operator><name>NonTrivialToPrimitiveDestroy</name></name> <operator>=</operator> <name>V</name></expr>;
}</block>

<name>bool</name> <macro><name>hasNonTrivialToPrimitiveDefaultInitializeCUnion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>RecordDeclBits</name><operator>.</operator><name>HasNonTrivialToPrimitiveDefaultInitializeCUnion</name></name></expr>;</return>
}</block>

<name>void</name> <macro><name>setHasNonTrivialToPrimitiveDefaultInitializeCUnion</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{
<expr><name><name>RecordDeclBits</name><operator>.</operator><name>HasNonTrivialToPrimitiveDefaultInitializeCUnion</name></name> <operator>=</operator> <name>V</name></expr>;
}</block>

<name>bool</name> <macro><name>hasNonTrivialToPrimitiveDestructCUnion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>RecordDeclBits</name><operator>.</operator><name>HasNonTrivialToPrimitiveDestructCUnion</name></name></expr>;</return>
}</block>

<name>void</name> <macro><name>setHasNonTrivialToPrimitiveDestructCUnion</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{
<expr><name><name>RecordDeclBits</name><operator>.</operator><name>HasNonTrivialToPrimitiveDestructCUnion</name></name> <operator>=</operator> <name>V</name></expr>;
}</block>

<name>bool</name> <macro><name>hasNonTrivialToPrimitiveCopyCUnion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>RecordDeclBits</name><operator>.</operator><name>HasNonTrivialToPrimitiveCopyCUnion</name></name></expr>;</return>
}</block>

<name>void</name> <macro><name>setHasNonTrivialToPrimitiveCopyCUnion</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{
<expr><name><name>RecordDeclBits</name><operator>.</operator><name>HasNonTrivialToPrimitiveCopyCUnion</name></name> <operator>=</operator> <name>V</name></expr>;
}</block>




<name>bool</name> <macro><name>canPassInRegisters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getArgPassingRestrictions</name><argument_list>()</argument_list></call> <operator>==</operator> <name>APK_CanPassInRegs</name></expr>;</return>
}</block>

<name>ArgPassingKind</name> <macro><name>getArgPassingRestrictions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ArgPassingKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>RecordDeclBits</name><operator>.</operator><name>ArgPassingRestrictions</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setArgPassingRestrictions</name><argument_list>(<argument>ArgPassingKind Kind</argument>)</argument_list></macro> <block>{
<expr><name><name>RecordDeclBits</name><operator>.</operator><name>ArgPassingRestrictions</name></name> <operator>=</operator> <name>Kind</name></expr>;
}</block>

<name>bool</name> <macro><name>isParamDestroyedInCallee</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>RecordDeclBits</name><operator>.</operator><name>ParamDestroyedInCallee</name></name></expr>;</return>
}</block>

<name>void</name> <macro><name>setParamDestroyedInCallee</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{
<expr><name><name>RecordDeclBits</name><operator>.</operator><name>ParamDestroyedInCallee</name></name> <operator>=</operator> <name>V</name></expr>;
}</block>














<name>bool</name> <macro><name>isInjectedClassName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isLambda</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isCapturedRecord</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>void</name> <call><name>setCapturedRecord</name><argument_list>()</argument_list></call></expr>;









<expr><name>RecordDecl</name> <operator>*</operator><macro><name>getDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>RecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TagDecl</name><operator>::</operator><call><name>getDefinition</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>bool</name> <macro><name>isOrContainsUnion</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>using</name> <name>field_iterator</name> <operator>=</operator> <name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>FieldDecl</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>field_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>FieldDecl</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>field_range</name> <macro><name>fields</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>field_range</name><argument_list>(<argument><expr><call><name>field_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>field_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>field_iterator</name> <macro><name>field_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>field_iterator</name> <macro><name>field_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>field_iterator</name><argument_list>(<argument><expr><call><name>decl_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>field_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>field_begin</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name>field_end</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>virtual</name> <name>void</name> <call><name>completeDefinition</name><argument_list>()</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{
<return>return <expr><name>K</name> <operator>&gt;=</operator> <name>firstRecord</name> <operator>&amp;&amp;</operator> <name>K</name> <operator>&lt;=</operator> <name>lastRecord</name></expr>;</return>
}</block>




<name>bool</name> <macro><name>isMsStruct</name><argument_list>(<argument>const ASTContext &amp;C</argument>)</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>bool</name> <macro><name>mayInsertExtraPadding</name><argument_list>(<argument>bool EmitRemark = false</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><macro><name>findFirstNamedDataMember</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>private</name><operator>:</operator>

<name>void</name> <macro><name>LoadFieldsFromExternalStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>FileScopeAsmDecl</name> <range>: <expr><name>public</name> <name>Decl</name> <block>{
<expr><name>StringLiteral</name> <operator>*</operator><name>AsmString</name></expr>;
<expr><name>SourceLocation</name> <name>RParenLoc</name></expr>;

<macro><name>FileScopeAsmDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>StringLiteral *asmstring</argument>,
<argument>SourceLocation StartL</argument>, <argument>SourceLocation EndL</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Decl</name><argument_list>(<argument><expr><name>FileScopeAsm</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>StartL</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>AsmString</name><argument_list>(<argument><expr><name>asmstring</name></expr></argument>)</argument_list></call></expr>, <macro><name>RParenLoc</name><argument_list>(<argument>EndL</argument>)</argument_list></macro> <expr><block>{}</block>

<name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>FileScopeAsmDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>StringLiteral *Str</argument>, <argument>SourceLocation AsmLoc</argument>,
<argument>SourceLocation RParenLoc</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>FileScopeAsmDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>SourceLocation</name> <macro><name>getAsmLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getAsmLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRParenLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>StringLiteral</name> <operator>*</operator><macro><name>getAsmString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AsmString</name></expr>;</return> }</block>
<name>StringLiteral</name> <operator>*</operator><macro><name>getAsmString</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>AsmString</name></expr>;</return> }</block>
<name>void</name> <macro><name>setAsmString</name><argument_list>(<argument>StringLiteral *Asm</argument>)</argument_list></macro> <block>{ <expr><name>AsmString</name> <operator>=</operator> <name>Asm</name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>FileScopeAsm</name></expr>;</return> }</block>
}</expr>;




<expr><name>class</name> <name>BlockDecl</name> <operator>:</operator> <name>public</name> <name>Decl</name></expr>, <expr><name>public</name> <name>DeclContext</name> <block>{


<expr><name>public</name><operator>:</operator>


<name>class</name> <name>Capture</name> <block>{
enum <expr><block>{
<expr><name>flag_isByRef</name> <operator>=</operator> <literal type="number">0x1</literal></expr>,
<expr><name>flag_isNested</name> <operator>=</operator> <literal type="number">0x2</literal></expr>
}</block></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>VariableAndFlags</name></expr>;




<expr><name>Expr</name> <operator>*</operator><name>CopyExpr</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>Capture</name><argument_list>(<argument>VarDecl *variable</argument>, <argument>bool byRef</argument>, <argument>bool nested</argument>, <argument>Expr *copy</argument>)</argument_list></macro>
<operator>:</operator> <call><name>VariableAndFlags</name><argument_list>(<argument><expr><name>variable</name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><name>byRef</name></expr> ?</condition><then> <expr><name>flag_isByRef</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>nested</name></expr> ?</condition><then> <expr><name>flag_isNested</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>,
<macro><name>CopyExpr</name><argument_list>(<argument>copy</argument>)</argument_list></macro> <expr><block>{}</block>


<name>VarDecl</name> <operator>*</operator><macro><name>getVariable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>VariableAndFlags</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>bool</name> <macro><name>isByRef</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>VariableAndFlags</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>flag_isByRef</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isEscapingByref</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getVariable</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isEscapingByref</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isNonEscapingByref</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getVariable</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isNonEscapingByref</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isNested</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>VariableAndFlags</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>flag_isNested</name></expr>;</return> }</block>

<name>bool</name> <macro><name>hasCopyExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CopyExpr</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block>
<name>Expr</name> <operator>*</operator><macro><name>getCopyExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CopyExpr</name></expr>;</return> }</block>
<name>void</name> <macro><name>setCopyExpr</name><argument_list>(<argument>Expr *e</argument>)</argument_list></macro> <block>{ <expr><name>CopyExpr</name> <operator>=</operator> <name>e</name></expr>; }</block>
}</expr>;

<expr><name>private</name><operator>:</operator>



<name>ParmVarDecl</name> <operator>*</operator><operator>*</operator><name>ParamInfo</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>unsigned</name> <name>NumParams</name> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>Stmt</name> <operator>*</operator><name>Body</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>SignatureAsWritten</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><specifier>const</specifier> <name>Capture</name> <operator>*</operator><name>Captures</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>unsigned</name> <name>NumCaptures</name> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>unsigned</name> <name>ManglingNumber</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>Decl</name> <operator>*</operator><name>ManglingContextDecl</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>BlockDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation CaretLoc</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>BlockDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>BlockDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>SourceLocation</name> <macro><name>getCaretLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>isVariadic</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>BlockDeclBits</name><operator>.</operator><name>IsVariadic</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setIsVariadic</name><argument_list>(<argument>bool value</argument>)</argument_list></macro> <block>{ <expr><name><name>BlockDeclBits</name><operator>.</operator><name>IsVariadic</name></name> <operator>=</operator> <name>value</name></expr>; }</block>

<name>CompoundStmt</name> <operator>*</operator><macro><name>getCompoundBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>CompoundStmt</name><operator>*</operator><operator>)</operator> <name>Body</name></expr>;</return> }</block>
<name>Stmt</name> <operator>*</operator><macro><name>getBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><operator>(</operator><name>Stmt</name><operator>*</operator><operator>)</operator> <name>Body</name></expr>;</return> }</block>
<name>void</name> <macro><name>setBody</name><argument_list>(<argument>CompoundStmt *B</argument>)</argument_list></macro> <block>{ <expr><name>Body</name> <operator>=</operator> <operator>(</operator><name>Stmt</name><operator>*</operator><operator>)</operator> <name>B</name></expr>; }</block>

<name>void</name> <macro><name>setSignatureAsWritten</name><argument_list>(<argument>TypeSourceInfo *Sig</argument>)</argument_list></macro> <block>{ <expr><name>SignatureAsWritten</name> <operator>=</operator> <name>Sig</name></expr>; }</block>
<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getSignatureAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SignatureAsWritten</name></expr>;</return> }</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>parameters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><name>ParamInfo</name></expr>, <macro><name>getNumParams</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block>
<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>parameters</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><block>{<expr><name>ParamInfo</name></expr>, <macro><name>getNumParams</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block>


<name>using</name> <name>param_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>param_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name></expr>;

<expr><name>bool</name> <macro><name>param_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>parameters</name><argument_list>()</argument_list></call><operator>.</operator><call><name>empty</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>param_iterator</name> <macro><name>param_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>parameters</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>param_iterator</name> <macro><name>param_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>parameters</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>param_const_iterator</name> <macro><name>param_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>parameters</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>param_const_iterator</name> <macro><name>param_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>parameters</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>size_t</name> <macro><name>param_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>parameters</name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>unsigned</name> <macro><name>getNumParams</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumParams</name></expr>;</return> }</block>

<specifier>const</specifier> <name>ParmVarDecl</name> <operator>*</operator><macro><name>getParamDecl</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getNumParams</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Illegal param #"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>ParamInfo</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
}</block>
<name>ParmVarDecl</name> <operator>*</operator><macro><name>getParamDecl</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getNumParams</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Illegal param #"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>ParamInfo</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
}</block>

<name>void</name> <call><name>setParams</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>NewParamInfo</name></expr></argument>)</argument_list></call></expr>;



<expr><name>bool</name> <macro><name>hasCaptures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumCaptures</name> <operator>||</operator> <call><name>capturesCXXThis</name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>unsigned</name> <macro><name>getNumCaptures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumCaptures</name></expr>;</return> }</block>

<name>using</name> <name>capture_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Capture</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name></expr>;

<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Capture</name></expr></argument>&gt;</argument_list></name> <macro><name>captures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><block>{<expr><name>Captures</name></expr>, <expr><name>NumCaptures</name></expr>}</block></expr>;</return> }</block>

<name>capture_const_iterator</name> <macro><name>capture_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>captures</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>capture_const_iterator</name> <macro><name>capture_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>captures</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>capturesCXXThis</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>BlockDeclBits</name><operator>.</operator><name>CapturesCXXThis</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setCapturesCXXThis</name><argument_list>(<argument>bool B = true</argument>)</argument_list></macro> <block>{ <expr><name><name>BlockDeclBits</name><operator>.</operator><name>CapturesCXXThis</name></name> <operator>=</operator> <name>B</name></expr>; }</block>

<name>bool</name> <macro><name>blockMissingReturnType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>BlockDeclBits</name><operator>.</operator><name>BlockMissingReturnType</name></name></expr>;</return>
}</block>

<name>void</name> <macro><name>setBlockMissingReturnType</name><argument_list>(<argument>bool val = true</argument>)</argument_list></macro> <block>{
<expr><name><name>BlockDeclBits</name><operator>.</operator><name>BlockMissingReturnType</name></name> <operator>=</operator> <name>val</name></expr>;
}</block>

<name>bool</name> <macro><name>isConversionFromLambda</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>BlockDeclBits</name><operator>.</operator><name>IsConversionFromLambda</name></name></expr>;</return>
}</block>

<name>void</name> <macro><name>setIsConversionFromLambda</name><argument_list>(<argument>bool val = true</argument>)</argument_list></macro> <block>{
<expr><name><name>BlockDeclBits</name><operator>.</operator><name>IsConversionFromLambda</name></name> <operator>=</operator> <name>val</name></expr>;
}</block>

<name>bool</name> <macro><name>doesNotEscape</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>BlockDeclBits</name><operator>.</operator><name>DoesNotEscape</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setDoesNotEscape</name><argument_list>(<argument>bool B = true</argument>)</argument_list></macro> <block>{ <expr><name><name>BlockDeclBits</name><operator>.</operator><name>DoesNotEscape</name></name> <operator>=</operator> <name>B</name></expr>; }</block>

<name>bool</name> <macro><name>canAvoidCopyToHeap</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>BlockDeclBits</name><operator>.</operator><name>CanAvoidCopyToHeap</name></name></expr>;</return>
}</block>
<name>void</name> <macro><name>setCanAvoidCopyToHeap</name><argument_list>(<argument>bool B = true</argument>)</argument_list></macro> <block>{
<expr><name><name>BlockDeclBits</name><operator>.</operator><name>CanAvoidCopyToHeap</name></name> <operator>=</operator> <name>B</name></expr>;
}</block>

<name>bool</name> <macro><name>capturesVariable</name><argument_list>(<argument>const VarDecl *var</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>void</name> <macro><name>setCaptures</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>ArrayRef&lt;Capture&gt; Captures</argument>,
<argument>bool CapturesCXXThis</argument>)</argument_list></macro></expr>;

<expr><name>unsigned</name> <macro><name>getBlockManglingNumber</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ManglingNumber</name></expr>;</return> }</block>

<name>Decl</name> <operator>*</operator><macro><name>getBlockManglingContextDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ManglingContextDecl</name></expr>;</return> }</block>

<name>void</name> <macro><name>setBlockMangling</name><argument_list>(<argument>unsigned Number</argument>, <argument>Decl *Ctx</argument>)</argument_list></macro> <block>{
<expr><name>ManglingNumber</name> <operator>=</operator> <name>Number</name></expr>;
<expr><name>ManglingContextDecl</name> <operator>=</operator> <name>Ctx</name></expr>;
}</block>

<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;


<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>Block</name></expr>;</return> }</block>
<specifier>static</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>castToDeclContext</name><argument_list>(<argument>const BlockDecl *D</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>BlockDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>BlockDecl</name> <operator>*</operator><macro><name>castFromDeclContext</name><argument_list>(<argument>const DeclContext *DC</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>BlockDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>CapturedDecl</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Decl</name></expr>,
<expr><name>public</name> <name>DeclContext</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>CapturedDecl</name></expr></argument>, <argument><expr><name>ImplicitParamDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>protected</name><operator>:</operator>
<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;ImplicitParamDecl&gt;</argument>)</argument_list></macro> <block>{
<return>return <expr><name>NumParams</name></expr>;</return>
}</block>

<name>private</name><operator>:</operator>

<name>unsigned</name> <name>NumParams</name></expr>;


<expr><name>unsigned</name> <name>ContextParam</name></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>BodyAndNothrow</name></expr>;

<expr><name>explicit</name> <macro><name>CapturedDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>unsigned NumParams</argument>)</argument_list></macro></expr>;

<expr><name>ImplicitParamDecl</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><macro><name>getParams</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ImplicitParamDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ImplicitParamDecl</name> <operator>*</operator><operator>*</operator><macro><name>getParams</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ImplicitParamDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;

<expr><specifier>static</specifier> <name>CapturedDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>unsigned NumParams</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>CapturedDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>,
<argument>unsigned NumParams</argument>)</argument_list></macro></expr>;

<expr><name>Stmt</name> <operator>*</operator><macro><name>getBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <call><name>setBody</name><argument_list>(<argument><expr><name>Stmt</name> <operator>*</operator><name>B</name></expr></argument>)</argument_list></call></expr>;

<expr><name>bool</name> <macro><name>isNothrow</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <macro><name>setNothrow</name><argument_list>(<argument>bool Nothrow = true</argument>)</argument_list></macro></expr>;

<expr><name>unsigned</name> <macro><name>getNumParams</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumParams</name></expr>;</return> }</block>

<name>ImplicitParamDecl</name> <operator>*</operator><macro><name>getParam</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <name>NumParams</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getParams</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</return>
}</block>
<name>void</name> <macro><name>setParam</name><argument_list>(<argument>unsigned i</argument>, <argument>ImplicitParamDecl *P</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <name>NumParams</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getParams</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name>P</name></expr>;
}</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ImplicitParamDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>parameters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><call><name>getParams</name><argument_list>()</argument_list></call></expr>, <macro><name>getNumParams</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block>
<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ImplicitParamDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>parameters</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><block>{<expr><call><name>getParams</name><argument_list>()</argument_list></call></expr>, <macro><name>getNumParams</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block>


<name>ImplicitParamDecl</name> <operator>*</operator><macro><name>getContextParam</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>ContextParam</name> <operator>&lt;</operator> <name>NumParams</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getParam</name><argument_list>(<argument><expr><name>ContextParam</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>setContextParam</name><argument_list>(<argument>unsigned i</argument>, <argument>ImplicitParamDecl *P</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <name>NumParams</name></expr></argument>)</argument_list></call></expr>;
<expr><name>ContextParam</name> <operator>=</operator> <name>i</name></expr>;
<expr><call><name>setParam</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>unsigned</name> <macro><name>getContextParamPosition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ContextParam</name></expr>;</return> }</block>

<name>using</name> <name>param_iterator</name> <operator>=</operator> <name>ImplicitParamDecl</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr>;
<expr><name>using</name> <name>param_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>param_iterator</name></expr></argument>&gt;</argument_list></name></expr>;


<expr><name>param_iterator</name> <macro><name>param_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getParams</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>param_iterator</name> <macro><name>param_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getParams</name><argument_list>()</argument_list></call> <operator>+</operator> <name>NumParams</name></expr>;</return> }</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>Captured</name></expr>;</return> }</block>
<specifier>static</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>castToDeclContext</name><argument_list>(<argument>const CapturedDecl *D</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CapturedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>CapturedDecl</name> <operator>*</operator><macro><name>castFromDeclContext</name><argument_list>(<argument>const DeclContext *DC</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>CapturedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;











<expr><name>class</name> <name>ImportDecl</name> <name>final</name> <operator>:</operator> <name>public</name> <name>Decl</name></expr>,
<expr><name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ImportDecl</name></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>Module</name> <operator>*</operator><name>ImportedModule</name> <operator>=</operator> <name>nullptr</name></expr>;









<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>ImportDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>NextLocalImportAndComplete</name></expr>;

<macro><name>ImportDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>, <argument>Module *Imported</argument>,
<argument>ArrayRef&lt;SourceLocation&gt; IdentifierLocs</argument>)</argument_list></macro>;

<macro><name>ImportDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>, <argument>Module *Imported</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>;

<macro><name>ImportDecl</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Decl</name><argument_list>(<argument>Import</argument>, <argument>Empty</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>isImportComplete</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>NextLocalImportAndComplete</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>setImportComplete</name><argument_list>(<argument>bool C</argument>)</argument_list></macro> <block>{ <expr><call><name><name>NextLocalImportAndComplete</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>; }</block>



<name>ImportDecl</name> <operator>*</operator><macro><name>getNextLocalImport</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>NextLocalImportAndComplete</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setNextLocalImport</name><argument_list>(<argument>ImportDecl *Import</argument>)</argument_list></macro> <block>{
<expr><call><name><name>NextLocalImportAndComplete</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><name>Import</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>

<specifier>static</specifier> <name>ImportDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>Module *Imported</argument>,
<argument>ArrayRef&lt;SourceLocation&gt; IdentifierLocs</argument>)</argument_list></macro></expr>;



<expr><specifier>static</specifier> <name>ImportDecl</name> <operator>*</operator><macro><name>CreateImplicit</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>Module *Imported</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>ImportDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>,
<argument>unsigned NumLocations</argument>)</argument_list></macro></expr>;


<expr><name>Module</name> <operator>*</operator><macro><name>getImportedModule</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ImportedModule</name></expr>;</return> }</block>






<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <macro><name>getIdentifierLocs</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>Import</name></expr>;</return> }</block>
}</expr>;







<expr><name>class</name> <name>ExportDecl</name> <name>final</name> <operator>:</operator> <name>public</name> <name>Decl</name></expr>, <expr><name>public</name> <name>DeclContext</name> <block>{
<expr><name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;

<expr><name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;


<expr><name>SourceLocation</name> <name>RBraceLoc</name></expr>;

<macro><name>ExportDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation ExportLoc</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Decl</name><argument_list>(<argument><expr><name>Export</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>ExportLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>DeclContext</name><argument_list>(<argument><expr><name>Export</name></expr></argument>)</argument_list></call></expr>,
<macro><name>RBraceLoc</name><argument_list>(<argument>SourceLocation()</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>ExportDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation ExportLoc</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>ExportDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>SourceLocation</name> <macro><name>getExportLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getRBraceLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RBraceLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRBraceLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RBraceLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>bool</name> <macro><name>hasBraces</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>RBraceLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasBraces</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>RBraceLoc</name></expr>;</return></block_content></block></if></if_stmt></block></expr>


<return>return <expr><ternary><condition><expr><call><name>decls_empty</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>decls_begin</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>Export</name></expr>;</return> }</block>
<specifier>static</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>castToDeclContext</name><argument_list>(<argument>const ExportDecl *D</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExportDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>ExportDecl</name> <operator>*</operator><macro><name>castFromDeclContext</name><argument_list>(<argument>const DeclContext *DC</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExportDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>EmptyDecl</name> <operator>:</operator> <name>public</name> <name>Decl</name> <block>{
<macro><name>EmptyDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Decl</name><argument_list>(<argument>Empty</argument>, <argument>DC</argument>, <argument>L</argument>)</argument_list></macro> <expr><block>{}</block>

<name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>EmptyDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation L</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>EmptyDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>Empty</name></expr>;</return> }</block>
}</expr>;



<expr><specifier>inline</specifier> <specifier>const</specifier> <name>StreamingDiagnostic</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><specifier>const</specifier> <name>StreamingDiagnostic</name> <operator>&amp;</operator><name>PD</name>,
<specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>ND</name><operator>)</operator> <block>{
<expr><call><name><name>PD</name><operator>.</operator><name>AddTaggedVal</name></name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>intptr_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ND</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>DiagnosticsEngine</name><operator>::</operator><name>ak_nameddecl</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>PD</name></expr>;</return>
}</block>

<name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>decl_type</name></expr></argument>&gt;</argument_list></name>
<name>void</name> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>decl_type</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>setPreviousDecl</name><argument_list>(<argument>decl_type *PrevDecl</argument>)</argument_list></macro> <block>{


<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>RedeclLink</name><operator>.</operator><name>isFirst</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"setPreviousDecl on a decl already in a redeclaration chain"</literal></expr></argument>)</argument_list></call></expr>;

<if_stmt><if>if <condition>(<expr><name>PrevDecl</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>First</name> <operator>=</operator> <call><name><name>PrevDecl</name><operator>-&gt;</operator><name>getFirstDecl</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>First</name><operator>-&gt;</operator><name>RedeclLink</name><operator>.</operator><name>isFirst</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Expected first"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>decl_type</name> <modifier>*</modifier></type><name>MostRecent</name> <init>= <expr><call><name><name>First</name><operator>-&gt;</operator><name>getNextRedeclaration</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>RedeclLink</name> <operator>=</operator> <call><name>PreviousDeclLink</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>decl_type</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>MostRecent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>decl_type</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>IdentifierNamespace</name> <operator>|=</operator>
<call><name><name>MostRecent</name><operator>-&gt;</operator><name>getIdentifierNamespace</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator>
<operator>(</operator><name>Decl</name><operator>::</operator><name>IDNS_Ordinary</name> <operator>|</operator> <name>Decl</name><operator>::</operator><name>IDNS_Tag</name> <operator>|</operator> <name>Decl</name><operator>::</operator><name>IDNS_Type</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt/>}</block_content> else <block>{<block_content>

<expr_stmt><expr><name>First</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>decl_type</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>


First-&gt;RedeclLink.setLatest(static_cast&lt;decl_type*&gt;(this</block></block></if></if_stmt>))</block></expr>;

<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>decl_type</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>decl_type</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>isLinkageValid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>







<specifier>inline</specifier> <name>bool</name> <macro><name>IsEnumDeclComplete</name><argument_list>(<argument>EnumDecl *ED</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>ED</name><operator>-&gt;</operator><name>isComplete</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>





<specifier>inline</specifier> <name>bool</name> <macro><name>IsEnumDeclScoped</name><argument_list>(<argument>EnumDecl *ED</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>ED</name><operator>-&gt;</operator><name>isScoped</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>




<specifier>static</specifier> <name>constexpr</name> <name>StringRef</name> <macro><name>getOpenMPVariantManglingSeparatorStr</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><literal type="string">"$ompvariant"</literal></expr>;</return>
}</block>

}</expr></block></expr></block></expr></block></expr></block></expr></block></expr></range></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
