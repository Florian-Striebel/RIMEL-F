<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Sema/Initialization.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_SEMA_INITIALIZATION_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_SEMA_INITIALIZATION_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Attr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclAccessPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclarationName.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/IdentifierTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LangOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Specifiers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/Overload.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/Ownership.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>APValue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXBaseSpecifier</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXConstructorDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCMethodDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Sema</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>alignas</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list> <name>InitializedEntity</name> <block>{<block_content>
<label><name>public</name>:</label>

<enum>enum <name>EntityKind</name> <block>{

<decl><name>EK_Variable</name></decl>,


<decl><name>EK_Parameter</name></decl>,


<decl><name>EK_TemplateParameter</name></decl>,


<decl><name>EK_Result</name></decl>,


<decl><name>EK_StmtExprResult</name></decl>,



<decl><name>EK_Exception</name></decl>,



<decl><name>EK_Member</name></decl>,


<decl><name>EK_ArrayElement</name></decl>,



<decl><name>EK_New</name></decl>,


<decl><name>EK_Temporary</name></decl>,


<decl><name>EK_Base</name></decl>,


<decl><name>EK_Delegating</name></decl>,



<decl><name>EK_VectorElement</name></decl>,



<decl><name>EK_BlockElement</name></decl>,



<decl><name>EK_LambdaToBlockConversionBlockElement</name></decl>,



<decl><name>EK_ComplexElement</name></decl>,



<decl><name>EK_LambdaCapture</name></decl>,



<decl><name>EK_CompoundLiteralInit</name></decl>,



<decl><name>EK_RelatedResult</name></decl>,



<decl><name>EK_Parameter_CF_Audited</name></decl>,



<decl><name>EK_Binding</name></decl>,




}</block>;</enum>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>EntityKind</name></type> <name>Kind</name></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>InitializedEntity</name> <modifier>*</modifier></type><name>Parent</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>Type</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>mutable</name> <name>unsigned</name></type> <name>ManglingNumber</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<struct>struct <name>LN</name> <block>{




<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Location</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>NRVO</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>VD</name> <block>{

<decl_stmt><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>VariableOrMember</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>IsImplicitFieldInit</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>IsDefaultMemberInit</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>C</name> <block>{

<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>VarID</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Location</name></decl>;</decl_stmt>
}</block>;</struct>

<union>union <block>{


<decl_stmt><decl><type><name>VD</name></type> <name>Variable</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>MethodDecl</name></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <name>Parameter</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TypeInfo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>LN</name></name></type> <name>LocAndNRVO</name></decl>;</decl_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXBaseSpecifier</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <name>Base</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>Index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>C</name></name></type> <name>Capture</name></decl>;</decl_stmt>
}</block>;</union>

<macro><name>InitializedEntity</name><argument_list>()</argument_list></macro> <block>{<block_content/>}</block><empty_stmt>;</empty_stmt>


<macro><name>InitializedEntity</name><argument_list>(<argument>VarDecl *Var</argument>, <argument>EntityKind EK = EK_Variable</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Kind</name><argument_list>(<argument><expr><name>EK</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><call><name><name>Var</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>Variable</name><block>{<expr><name>Var</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block> <block>{}</block>




<macro><name>InitializedEntity</name><argument_list>(<argument>EntityKind Kind</argument>, <argument>SourceLocation Loc</argument>, <argument>QualType Type</argument>,
<argument>bool NRVO = false</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Type</name><argument_list>(<argument>Type</argument>)</argument_list></macro> <expr><block>{
<macro><name>new</name> <argument_list>(<argument>&amp;LocAndNRVO</argument>)</argument_list></macro> <expr><name>LN</name></expr>;
<expr><name><name>LocAndNRVO</name><operator>.</operator><name>Location</name></name> <operator>=</operator> <name>Loc</name></expr>;
<expr><name><name>LocAndNRVO</name><operator>.</operator><name>NRVO</name></name> <operator>=</operator> <name>NRVO</name></expr>;
}</block>


<macro><name>InitializedEntity</name><argument_list>(<argument>FieldDecl *Member</argument>, <argument>const InitializedEntity *Parent</argument>,
<argument>bool Implicit</argument>, <argument>bool DefaultMemberInit</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>EK_Member</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Parent</name><argument_list>(<argument><expr><name>Parent</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Type</name><argument_list>(<argument><expr><call><name><name>Member</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><name>Variable</name><block>{<expr><name>Member</name></expr>, <expr><name>Implicit</name></expr>, <expr><name>DefaultMemberInit</name></expr>}</block> <block>{}</block>


<macro><name>InitializedEntity</name><argument_list>(<argument>ASTContext &amp;Context</argument>, <argument>unsigned Index</argument>,
<argument>const InitializedEntity &amp;Parent</argument>)</argument_list></macro></expr>;</expr_stmt>


<macro><name>InitializedEntity</name><argument_list>(<argument>IdentifierInfo *VarID</argument>, <argument>QualType FieldType</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Kind</name><argument_list>(<argument><expr><name>EK_LambdaCapture</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Type</name><argument_list>(<argument>FieldType</argument>)</argument_list></macro> <expr><block>{
<macro><name>new</name> <argument_list>(<argument>&amp;Capture</argument>)</argument_list></macro> <expr><name>C</name></expr>;
<expr><name><name>Capture</name><operator>.</operator><name>VarID</name></name> <operator>=</operator> <name>VarID</name></expr>;
<expr><name><name>Capture</name><operator>.</operator><name>Location</name></name> <operator>=</operator> <name>Loc</name></expr>;
}</block>

<name>public</name><operator>:</operator>

<specifier>static</specifier> <name>InitializedEntity</name> <macro><name>InitializeVariable</name><argument_list>(<argument>VarDecl *Var</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>InitializedEntity</name><argument_list>(<argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function><type><specifier>static</specifier> <name>InitializedEntity</name></type> <name>InitializeParameter</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>,
<parameter><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>Parm</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializeParameter</name><argument_list>(<argument><expr><name>Context</name></expr></argument>, <argument><expr><name>Parm</name></expr></argument>, <argument><expr><call><name><name>Parm</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>InitializedEntity</name></type>
<name>InitializeParameter</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>Parm</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>Consumed</name> <init>= <expr><operator>(</operator><call><name><name>Context</name><operator>.</operator><name>getLangOpts</name></name><argument_list>()</argument_list></call><operator>.</operator><name>ObjCAutoRefCount</name> <operator>&amp;&amp;</operator>
<name><name>Parm</name><operator>-&gt;</operator><name>hasAttr</name></name><operator>&lt;</operator><name>NSConsumedAttr</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>InitializedEntity</name></type> <name>Entity</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Entity</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>EK_Parameter</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Entity</name><operator>.</operator><name>Type</name></name> <operator>=</operator>
<call><name><name>Context</name><operator>.</operator><name>getVariableArrayDecayedType</name></name><argument_list>(<argument><expr><call><name><name>Type</name><operator>.</operator><name>getUnqualifiedType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Entity</name><operator>.</operator><name>Parent</name></name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Entity</name><operator>.</operator><name>Parameter</name></name> <operator>=</operator> <block>{<expr><name>Parm</name></expr>, <expr><name>Consumed</name></expr>}</block></expr>;</expr_stmt>
<return>return <expr><name>Entity</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>InitializedEntity</name></type> <name>InitializeParameter</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Consumed</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>InitializedEntity</name></type> <name>Entity</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Entity</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>EK_Parameter</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Entity</name><operator>.</operator><name>Type</name></name> <operator>=</operator> <call><name><name>Context</name><operator>.</operator><name>getVariableArrayDecayedType</name></name><argument_list>(<argument><expr><name>Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Entity</name><operator>.</operator><name>Parent</name></name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Entity</name><operator>.</operator><name>Parameter</name></name> <operator>=</operator> <block>{<expr><name>nullptr</name></expr>, <expr><name>Consumed</name></expr>}</block></expr>;</expr_stmt>
<return>return <expr><name>Entity</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializedEntity</name></type>
<name>InitializeTemplateParameter</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>NonTypeTemplateParmDecl</name> <modifier>*</modifier></type><name>Param</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>InitializedEntity</name></type> <name>Entity</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Entity</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>EK_TemplateParameter</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Entity</name><operator>.</operator><name>Type</name></name> <operator>=</operator> <name>T</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Entity</name><operator>.</operator><name>Parent</name></name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Entity</name><operator>.</operator><name>Variable</name></name> <operator>=</operator> <block>{<expr><name>Param</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr>;</expr_stmt>
<return>return <expr><name>Entity</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializedEntity</name></type> <name>InitializeResult</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ReturnLoc</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializedEntity</name><argument_list>(<argument><expr><name>EK_Result</name></expr></argument>, <argument><expr><name>ReturnLoc</name></expr></argument>, <argument><expr><name>Type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>InitializedEntity</name></type> <name>InitializeStmtExprResult</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ReturnLoc</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializedEntity</name><argument_list>(<argument><expr><name>EK_StmtExprResult</name></expr></argument>, <argument><expr><name>ReturnLoc</name></expr></argument>, <argument><expr><name>Type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>InitializedEntity</name></type> <name>InitializeBlock</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>BlockVarLoc</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializedEntity</name><argument_list>(<argument><expr><name>EK_BlockElement</name></expr></argument>, <argument><expr><name>BlockVarLoc</name></expr></argument>, <argument><expr><name>Type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>InitializedEntity</name></type> <name>InitializeLambdaToBlock</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>BlockVarLoc</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializedEntity</name><argument_list>(<argument><expr><name>EK_LambdaToBlockConversionBlockElement</name></expr></argument>,
<argument><expr><name>BlockVarLoc</name></expr></argument>, <argument><expr><name>Type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializedEntity</name></type> <name>InitializeException</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ThrowLoc</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializedEntity</name><argument_list>(<argument><expr><name>EK_Exception</name></expr></argument>, <argument><expr><name>ThrowLoc</name></expr></argument>, <argument><expr><name>Type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializedEntity</name></type> <name>InitializeNew</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>NewLoc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializedEntity</name><argument_list>(<argument><expr><name>EK_New</name></expr></argument>, <argument><expr><name>NewLoc</name></expr></argument>, <argument><expr><name>Type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializedEntity</name></type> <name>InitializeTemporary</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializeTemporary</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>Type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializedEntity</name></type> <name>InitializeTemporary</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TypeInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializeTemporary</name><argument_list>(<argument><expr><name>TypeInfo</name></expr></argument>, <argument><expr><call><name><name>TypeInfo</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializedEntity</name></type> <name>InitializeTemporary</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TypeInfo</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>InitializedEntity</name></type> <name>Result</name><argument_list>(<argument><expr><name>EK_Temporary</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Type</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>TypeInfo</name></name> <operator>=</operator> <name>TypeInfo</name></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializedEntity</name></type> <name>InitializeRelatedResult</name><parameter_list>(<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>InitializedEntity</name></type> <name>Result</name><argument_list>(<argument><expr><name>EK_RelatedResult</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Type</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>MethodDecl</name></name> <operator>=</operator> <name>MD</name></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></function>


<function_decl><type><specifier>static</specifier> <name>InitializedEntity</name></type>
<name>InitializeBase</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXBaseSpecifier</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsInheritedVirtualBase</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>InitializedEntity</name> <modifier>*</modifier></type><name>Parent</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function><type><specifier>static</specifier> <name>InitializedEntity</name></type> <name>InitializeDelegation</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializedEntity</name><argument_list>(<argument><expr><name>EK_Delegating</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializedEntity</name></type>
<name>InitializeMember</name><parameter_list>(<parameter><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>Member</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>InitializedEntity</name> <modifier>*</modifier></type><name>Parent</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Implicit</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializedEntity</name><argument_list>(<argument><expr><name>Member</name></expr></argument>, <argument><expr><name>Parent</name></expr></argument>, <argument><expr><name>Implicit</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializedEntity</name></type>
<name>InitializeMember</name><parameter_list>(<parameter><decl><type><name>IndirectFieldDecl</name> <modifier>*</modifier></type><name>Member</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>InitializedEntity</name> <modifier>*</modifier></type><name>Parent</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Implicit</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializedEntity</name><argument_list>(<argument><expr><call><name><name>Member</name><operator>-&gt;</operator><name>getAnonField</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Parent</name></expr></argument>, <argument><expr><name>Implicit</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializedEntity</name></type>
<name>InitializeMemberFromDefaultMemberInitializer</name><parameter_list>(<parameter><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>Member</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializedEntity</name><argument_list>(<argument><expr><name>Member</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializedEntity</name></type> <name>InitializeElement</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Index</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>InitializedEntity</name> <modifier>&amp;</modifier></type><name>Parent</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializedEntity</name><argument_list>(<argument><expr><name>Context</name></expr></argument>, <argument><expr><name>Index</name></expr></argument>, <argument><expr><name>Parent</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializedEntity</name></type> <name>InitializeBinding</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Binding</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializedEntity</name><argument_list>(<argument><expr><name>Binding</name></expr></argument>, <argument><expr><name>EK_Binding</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>InitializedEntity</name></type> <name>InitializeLambdaCapture</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>VarID</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>FieldType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializedEntity</name><argument_list>(<argument><expr><name>VarID</name></expr></argument>, <argument><expr><name>FieldType</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializedEntity</name></type> <name>InitializeCompoundLiteralInit</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSI</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>InitializedEntity</name></type> <name>Result</name><argument_list>(<argument><expr><name>EK_CompoundLiteralInit</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TSI</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>TypeInfo</name></name> <operator>=</operator> <name>TSI</name></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></function>


<expr_stmt><expr><name>EntityKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block></expr></expr_stmt>




<expr_stmt><expr><specifier>const</specifier> <name>InitializedEntity</name> <operator>*</operator><macro><name>getParent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Parent</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Type</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>Kind</name> <operator>==</operator> <name>EK_Temporary</name> <operator>||</operator> <name>Kind</name> <operator>==</operator> <name>EK_CompoundLiteralInit</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>TypeInfo</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><name>nullptr</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name>DeclarationName</name> <macro><name>getName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>ValueDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>ObjCMethodDecl</name> <operator>*</operator><macro><name>getMethodDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MethodDecl</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>allowsNRVO</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isParameterKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EK_Parameter</name> <operator>||</operator>
<call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EK_Parameter_CF_Audited</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isParamOrTemplateParamKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isParameterKind</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EK_TemplateParameter</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isParameterConsumed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isParameterKind</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Not a parameter"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Parameter</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>CXXBaseSpecifier</name> <operator>*</operator><macro><name>getBaseSpecifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EK_Base</name> <operator>&amp;&amp;</operator> <literal type="string">"Not a base specifier"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Base</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isInheritedVirtualBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EK_Base</name> <operator>&amp;&amp;</operator> <literal type="string">"Not a base specifier"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Base</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isVariableLengthArrayNew</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EK_New</name> <operator>&amp;&amp;</operator> <call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>IncompleteArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getAsArrayTypeUnsafe</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isImplicitMemberInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EK_Member</name> <operator>&amp;&amp;</operator> <name><name>Variable</name><operator>.</operator><name>IsImplicitFieldInit</name></name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isDefaultMemberInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EK_Member</name> <operator>&amp;&amp;</operator> <name><name>Variable</name><operator>.</operator><name>IsDefaultMemberInit</name></name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>SourceLocation</name> <macro><name>getReturnLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EK_Result</name> <operator>&amp;&amp;</operator> <literal type="string">"No 'return' location!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>LocAndNRVO</name><operator>.</operator><name>Location</name></name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>SourceLocation</name> <macro><name>getThrowLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EK_Exception</name> <operator>&amp;&amp;</operator> <literal type="string">"No 'throw' location!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>LocAndNRVO</name><operator>.</operator><name>Location</name></name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getElementIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EK_ArrayElement</name> <operator>||</operator> <call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EK_VectorElement</name> <operator>||</operator>
<call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EK_ComplexElement</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Index</name></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>void</name></type> <name>setElementIndex</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Index</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EK_ArrayElement</name> <operator>||</operator> <call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EK_VectorElement</name> <operator>||</operator>
<call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EK_ComplexElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>Index</name></name> <operator>=</operator> <name>Index</name></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>StringRef</name> <macro><name>getCapturedVarName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EK_LambdaCapture</name> <operator>&amp;&amp;</operator> <literal type="string">"Not a lambda capture!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><ternary><condition><expr><name><name>Capture</name><operator>.</operator><name>VarID</name></name></expr> ?</condition><then> <expr><call><name><name>Capture</name><operator>.</operator><name>VarID</name><operator>-&gt;</operator><name>getName</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="string">"this"</literal></expr></else></ternary></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>SourceLocation</name> <macro><name>getCaptureLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EK_LambdaCapture</name> <operator>&amp;&amp;</operator> <literal type="string">"Not a lambda capture!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>Capture</name><operator>.</operator><name>Location</name></name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setParameterCFAudited</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Kind</name> <operator>=</operator> <name>EK_Parameter_CF_Audited</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>unsigned</name> <macro><name>allocateManglingNumber</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>++</operator><name>ManglingNumber</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>unsigned</name></type> <name>dumpImpl</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>InitializationKind</name> <block>{<block_content>
<label><name>public</name>:</label>

<enum>enum <name>InitKind</name> <block>{

<decl><name>IK_Direct</name></decl>,


<decl><name>IK_DirectList</name></decl>,


<decl><name>IK_Copy</name></decl>,


<decl><name>IK_Default</name></decl>,


<decl><name>IK_Value</name></decl>
}</block>;</enum>

<label><name>private</name>:</label>

<enum>enum <name>InitContext</name> <block>{

<decl><name>IC_Normal</name></decl>,


<decl><name>IC_ExplicitConvs</name></decl>,


<decl><name>IC_Implicit</name></decl>,


<decl><name>IC_StaticCast</name></decl>,


<decl><name>IC_CStyleCast</name></decl>,


<decl><name>IC_FunctionalCast</name></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>InitKind</name></type> <name>Kind</name> <range>: <expr><literal type="number">8</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>InitContext</name></type> <name>Context</name> <range>: <expr><literal type="number">8</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name><name>Locations</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<macro><name>InitializationKind</name><argument_list>(<argument>InitKind Kind</argument>, <argument>InitContext Context</argument>, <argument>SourceLocation Loc1</argument>,
<argument>SourceLocation Loc2</argument>, <argument>SourceLocation Loc3</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Kind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Context</name><argument_list>(<argument>Context</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>Locations</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>Loc1</name></expr>;
<expr><name><name>Locations</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>Loc2</name></expr>;
<expr><name><name>Locations</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>Loc3</name></expr>;
}</block>

<name>public</name><operator>:</operator>

<specifier>static</specifier> <name>InitializationKind</name> <macro><name>CreateDirect</name><argument_list>(<argument>SourceLocation InitLoc</argument>,
<argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation RParenLoc</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>InitializationKind</name><argument_list>(<argument><expr><name>IK_Direct</name></expr></argument>, <argument><expr><name>IC_Normal</name></expr></argument>,
<argument><expr><name>InitLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>InitializationKind</name></type> <name>CreateDirectList</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>InitLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializationKind</name><argument_list>(<argument><expr><name>IK_DirectList</name></expr></argument>, <argument><expr><name>IC_Normal</name></expr></argument>, <argument><expr><name>InitLoc</name></expr></argument>, <argument><expr><name>InitLoc</name></expr></argument>,
<argument><expr><name>InitLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>InitializationKind</name></type> <name>CreateDirectList</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>InitLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LBraceLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBraceLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializationKind</name><argument_list>(<argument><expr><name>IK_DirectList</name></expr></argument>, <argument><expr><name>IC_Normal</name></expr></argument>, <argument><expr><name>InitLoc</name></expr></argument>, <argument><expr><name>LBraceLoc</name></expr></argument>,
<argument><expr><name>RBraceLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>InitializationKind</name></type> <name>CreateCast</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>TypeRange</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializationKind</name><argument_list>(<argument><expr><name>IK_Direct</name></expr></argument>, <argument><expr><name>IC_StaticCast</name></expr></argument>, <argument><expr><call><name><name>TypeRange</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TypeRange</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>TypeRange</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializationKind</name></type> <name>CreateCStyleCast</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>TypeRange</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>InitList</name></decl></parameter>)</parameter_list> <block>{<block_content>


<return>return <expr><call><name>InitializationKind</name><argument_list>(<argument><expr><ternary><condition><expr><name>InitList</name></expr> ?</condition><then> <expr><name>IK_DirectList</name></expr> </then><else>: <expr><name>IK_Direct</name></expr></else></ternary></expr></argument>,
<argument><expr><name>IC_CStyleCast</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><call><name><name>TypeRange</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TypeRange</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializationKind</name></type> <name>CreateFunctionalCast</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>TypeRange</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>InitList</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializationKind</name><argument_list>(<argument><expr><ternary><condition><expr><name>InitList</name></expr> ?</condition><then> <expr><name>IK_DirectList</name></expr> </then><else>: <expr><name>IK_Direct</name></expr></else></ternary></expr></argument>,
<argument><expr><name>IC_FunctionalCast</name></expr></argument>, <argument><expr><call><name><name>TypeRange</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TypeRange</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>TypeRange</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializationKind</name></type> <name>CreateCopy</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>InitLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EqualLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowExplicitConvs</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializationKind</name><argument_list>(<argument><expr><name>IK_Copy</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>AllowExplicitConvs</name></expr>?</condition><then> <expr><name>IC_ExplicitConvs</name></expr> </then><else>: <expr><name>IC_Normal</name></expr></else></ternary></expr></argument>,
<argument><expr><name>InitLoc</name></expr></argument>, <argument><expr><name>EqualLoc</name></expr></argument>, <argument><expr><name>EqualLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializationKind</name></type> <name>CreateDefault</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>InitLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializationKind</name><argument_list>(<argument><expr><name>IK_Default</name></expr></argument>, <argument><expr><name>IC_Normal</name></expr></argument>, <argument><expr><name>InitLoc</name></expr></argument>, <argument><expr><name>InitLoc</name></expr></argument>, <argument><expr><name>InitLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>InitializationKind</name></type> <name>CreateValue</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>InitLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isImplicit</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InitializationKind</name><argument_list>(<argument><expr><name>IK_Value</name></expr></argument>, <argument><expr><ternary><condition><expr><name>isImplicit</name></expr> ?</condition><then> <expr><name>IC_Implicit</name></expr> </then><else>: <expr><name>IC_Normal</name></expr></else></ternary></expr></argument>,
<argument><expr><name>InitLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>InitializationKind</name></type> <name>CreateForInit</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>DirectInit</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Init</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>CreateDefault</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>DirectInit</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>CreateCopy</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><call><name><name>Init</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>InitListExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>CreateDirectList</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><call><name><name>Init</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Init</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>CreateDirect</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><call><name><name>Init</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Init</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<expr_stmt><expr><name>InitKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Kind</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isExplicitCast</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Context</name> <operator>&gt;=</operator> <name>IC_StaticCast</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isStaticCast</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Context</name> <operator>==</operator> <name>IC_StaticCast</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isCStyleOrFunctionalCast</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Context</name> <operator>&gt;=</operator> <name>IC_CStyleCast</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isCStyleCast</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Context</name> <operator>==</operator> <name>IC_CStyleCast</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isFunctionalCast</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Context</name> <operator>==</operator> <name>IC_FunctionalCast</name></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>isImplicitValueInit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Context</name> <operator>==</operator> <name>IC_Implicit</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Locations</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceRange</name> <macro><name>getRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name><name>Locations</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>Locations</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEqualLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Kind</name> <operator>==</operator> <name>IK_Copy</name> <operator>&amp;&amp;</operator> <literal type="string">"Only copy initialization has an '='"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>Locations</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isCopyInit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>IK_Copy</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>AllowExplicit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>isCopyInit</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>





<expr_stmt><expr><name>bool</name> <macro><name>allowExplicitConversionFunctionsInRefBinding</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name>isCopyInit</name><argument_list>()</argument_list></call> <operator>||</operator> <name>Context</name> <operator>==</operator> <name>IC_ExplicitConvs</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasParenOrBraceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Kind</name> <operator>==</operator> <name>IK_Direct</name> <operator>||</operator> <name>Kind</name> <operator>==</operator> <name>IK_Value</name> <operator>||</operator> <name>Kind</name> <operator>==</operator> <name>IK_DirectList</name></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>SourceRange</name> <macro><name>getParenOrBraceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasParenOrBraceRange</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Only direct, value, and direct-list "</literal>
<literal type="string">"initialization have parentheses or "</literal>
<literal type="string">"braces"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name><name>Locations</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>Locations</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>InitializationSequence</name> <block>{<block_content>
<label><name>public</name>:</label>

<enum>enum <name>SequenceKind</name> <block>{


<decl><name>FailedSequence</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,




<decl><name>DependentSequence</name></decl>,


<decl><name>NormalSequence</name></decl>
}</block>;</enum>



<enum>enum <name>StepKind</name> <block>{


<decl><name>SK_ResolveAddressOfOverloadedFunction</name></decl>,


<decl><name>SK_CastDerivedToBasePRValue</name></decl>,


<decl><name>SK_CastDerivedToBaseXValue</name></decl>,


<decl><name>SK_CastDerivedToBaseLValue</name></decl>,


<decl><name>SK_BindReference</name></decl>,


<decl><name>SK_BindReferenceToTemporary</name></decl>,




<decl><name>SK_ExtraneousCopyToTemporary</name></decl>,



<decl><name>SK_FinalCopy</name></decl>,



<decl><name>SK_UserConversion</name></decl>,


<decl><name>SK_QualificationConversionPRValue</name></decl>,


<decl><name>SK_QualificationConversionXValue</name></decl>,


<decl><name>SK_QualificationConversionLValue</name></decl>,


<decl><name>SK_FunctionReferenceConversion</name></decl>,


<decl><name>SK_AtomicConversion</name></decl>,


<decl><name>SK_ConversionSequence</name></decl>,


<decl><name>SK_ConversionSequenceNoNarrowing</name></decl>,


<decl><name>SK_ListInitialization</name></decl>,


<decl><name>SK_UnwrapInitList</name></decl>,


<decl><name>SK_RewrapInitList</name></decl>,


<decl><name>SK_ConstructorInitialization</name></decl>,



<decl><name>SK_ConstructorInitializationFromList</name></decl>,


<decl><name>SK_ZeroInitialization</name></decl>,


<decl><name>SK_CAssignment</name></decl>,


<decl><name>SK_StringInit</name></decl>,



<decl><name>SK_ObjCObjectConversion</name></decl>,


<decl><name>SK_ArrayLoopIndex</name></decl>,


<decl><name>SK_ArrayLoopInit</name></decl>,


<decl><name>SK_ArrayInit</name></decl>,


<decl><name>SK_GNUArrayInit</name></decl>,



<decl><name>SK_ParenthesizedArrayInit</name></decl>,


<decl><name>SK_PassByIndirectCopyRestore</name></decl>,


<decl><name>SK_PassByIndirectRestore</name></decl>,


<decl><name>SK_ProduceObjCObject</name></decl>,


<decl><name>SK_StdInitializerList</name></decl>,



<decl><name>SK_StdInitializerListConstructorCall</name></decl>,


<decl><name>SK_OCLSamplerInit</name></decl>,


<decl><name>SK_OCLZeroOpaqueType</name></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>class</name></type> <name>Step</name> <block>{<block_content>
<label><name>public</name>:</label>

<decl_stmt><decl><type><name>StepKind</name></type> <name>Kind</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>Type</name></decl>;</decl_stmt>

<struct>struct <name>F</name> <block>{
<decl_stmt><decl><type><name>bool</name></type> <name>HadMultipleCandidates</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Function</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl>;</decl_stmt>
}</block>;</struct>

<union>union <block>{










<decl_stmt><decl><type><name><name>struct</name> <name>F</name></name></type> <name>Function</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>ImplicitConversionSequence</name> <modifier>*</modifier></type><name>ICS</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>InitListExpr</name> <modifier>*</modifier></type><name>WrappingSyntacticList</name></decl>;</decl_stmt>
}</block>;</union>

<function_decl><type><name>void</name></type> <name>Destroy</name><parameter_list>()</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name><name>enum</name> <name>SequenceKind</name></name></type> <name>SequenceKind</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Step</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>Steps</name></decl>;</decl_stmt>

<label><name>public</name>:</label>

<enum>enum <name>FailureKind</name> <block>{

<decl><name>FK_TooManyInitsForReference</name></decl>,


<decl><name>FK_ParenthesizedListInitForReference</name></decl>,


<decl><name>FK_ArrayNeedsInitList</name></decl>,



<decl><name>FK_ArrayNeedsInitListOrStringLiteral</name></decl>,



<decl><name>FK_ArrayNeedsInitListOrWideStringLiteral</name></decl>,


<decl><name>FK_NarrowStringIntoWideCharArray</name></decl>,


<decl><name>FK_WideStringIntoCharArray</name></decl>,



<decl><name>FK_IncompatWideStringIntoWideChar</name></decl>,


<decl><name>FK_PlainStringIntoUTF8Char</name></decl>,


<decl><name>FK_UTF8StringIntoPlainChar</name></decl>,


<decl><name>FK_ArrayTypeMismatch</name></decl>,


<decl><name>FK_NonConstantArrayInit</name></decl>,


<decl><name>FK_AddressOfOverloadFailed</name></decl>,


<decl><name>FK_ReferenceInitOverloadFailed</name></decl>,


<decl><name>FK_NonConstLValueReferenceBindingToTemporary</name></decl>,


<decl><name>FK_NonConstLValueReferenceBindingToBitfield</name></decl>,


<decl><name>FK_NonConstLValueReferenceBindingToVectorElement</name></decl>,


<decl><name>FK_NonConstLValueReferenceBindingToMatrixElement</name></decl>,



<decl><name>FK_NonConstLValueReferenceBindingToUnrelated</name></decl>,


<decl><name>FK_RValueReferenceBindingToLValue</name></decl>,


<decl><name>FK_ReferenceInitDropsQualifiers</name></decl>,


<decl><name>FK_ReferenceAddrspaceMismatchTemporary</name></decl>,


<decl><name>FK_ReferenceInitFailed</name></decl>,


<decl><name>FK_ConversionFailed</name></decl>,


<decl><name>FK_ConversionFromPropertyFailed</name></decl>,


<decl><name>FK_TooManyInitsForScalar</name></decl>,


<decl><name>FK_ParenthesizedListInitForScalar</name></decl>,


<decl><name>FK_ReferenceBindingToInitList</name></decl>,



<decl><name>FK_InitListBadDestinationType</name></decl>,


<decl><name>FK_UserConversionOverloadFailed</name></decl>,


<decl><name>FK_ConstructorOverloadFailed</name></decl>,


<decl><name>FK_ListConstructorOverloadFailed</name></decl>,


<decl><name>FK_DefaultInitOfConst</name></decl>,


<decl><name>FK_Incomplete</name></decl>,


<decl><name>FK_VariableLengthArrayHasInitializer</name></decl>,


<decl><name>FK_ListInitializationFailed</name></decl>,



<decl><name>FK_PlaceholderType</name></decl>,



<decl><name>FK_AddressOfUnaddressableFunction</name></decl>,


<decl><name>FK_ExplicitConstructor</name></decl>,
}</block>;</enum>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>FailureKind</name></type> <name>Failure</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>OverloadingResult</name></type> <name>FailedOverloadResult</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>OverloadCandidateSet</name></type> <name>FailedCandidateSet</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>FailedIncompleteType</name></decl>;</decl_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>ZeroInitializationFixit</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ZeroInitializationFixitLoc</name></decl>;</decl_stmt>

<label><name>public</name>:</label>


<decl_stmt><decl><type><name>void</name></type> <name>SetZeroInitializationFixit</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>Fixit</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>L</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name>ZeroInitializationFixit</name> <operator>=</operator> <name>Fixit</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ZeroInitializationFixitLoc</name> <operator>=</operator> <name>L</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>


<function_decl><type><name>void</name></type> <name>PrintInitLocationNote</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>InitializedEntity</name> <modifier>&amp;</modifier></type><name>Entity</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>



















<macro><name>InitializationSequence</name><argument_list>(<argument>Sema &amp;S</argument>,
<argument>const InitializedEntity &amp;Entity</argument>,
<argument>const InitializationKind &amp;Kind</argument>,
<argument>MultiExprArg Args</argument>,
<argument>bool TopLevelOfInitList = false</argument>,
<argument>bool TreatUnavailableAsInvalid = true</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<function_decl><type><name>void</name></type> <name>InitializeFrom</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>InitializedEntity</name> <modifier>&amp;</modifier></type><name>Entity</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>InitializationKind</name> <modifier>&amp;</modifier></type><name>Kind</name></decl></parameter>, <parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>TopLevelOfInitList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>TreatUnavailableAsInvalid</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><operator>~</operator><call><name>InitializationSequence</name><argument_list>()</argument_list></call></expr>;</expr_stmt>






















<function_decl><type><name>ExprResult</name></type> <name>Perform</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>InitializedEntity</name> <modifier>&amp;</modifier></type><name>Entity</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>InitializationKind</name> <modifier>&amp;</modifier></type><name>Kind</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>QualType</name> <modifier>*</modifier></type><name>ResultType</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>Diagnose</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>InitializedEntity</name> <modifier>&amp;</modifier></type><name>Entity</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>InitializationKind</name> <modifier>&amp;</modifier></type><name>Kind</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>)</parameter_list>;</function_decl>


enum <expr_stmt><expr><name>SequenceKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SequenceKind</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setSequenceKind</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>SequenceKind</name></name></type> <name>SK</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>SequenceKind</name> <operator>=</operator> <name>SK</name></expr>;</expr_stmt> </block_content>}</block></function>


<expr_stmt><expr><name>explicit</name> <name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>Failed</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>Failed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SequenceKind</name> <operator>==</operator> <name>FailedSequence</name></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>step_iterator</name> <init>= <expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Step</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>step_iterator</name> <macro><name>step_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Steps</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>step_iterator</name> <macro><name>step_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Steps</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>step_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>step_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>step_range</name> <macro><name>steps</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><block>{<expr><call><name>step_begin</name><argument_list>()</argument_list></call></expr>, <macro><name>step_end</name><argument_list>()</argument_list></macro>}</block></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isDirectReferenceBinding</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isAmbiguous</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isConstructorInitialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>






<function_decl><type><name>void</name></type> <name>AddAddressOverloadResolutionStep</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Function</name></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name></type> <name>Found</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>HadMultipleCandidates</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>void</name></type> <name>AddDerivedToBaseCastStep</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>BaseType</name></decl></parameter>,
<parameter><decl><type><name>ExprValueKind</name></type> <name>Category</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>void</name></type> <name>AddReferenceBindingStep</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>BindingTemporary</name></decl></parameter>)</parameter_list>;</function_decl>











<function_decl><type><name>void</name></type> <name>AddExtraneousCopyToTemporary</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>AddFinalCopy</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>AddUserConversionStep</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Function</name></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>HadMultipleCandidates</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>AddQualificationConversionStep</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>,
<parameter><decl><type><name>ExprValueKind</name></type> <name>Category</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>AddFunctionReferenceConversionStep</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>AddAtomicConversionStep</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddConversionSequenceStep</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ImplicitConversionSequence</name> <modifier>&amp;</modifier></type><name>ICS</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>TopLevelOfInitList</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddListInitializationStep</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>void</name></type> <name>AddConstructorInitializationStep</name><parameter_list>(<parameter><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Constructor</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>HadMultipleCandidates</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>FromInitList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>AsInitList</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddZeroInitializationStep</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>void</name></type> <name>AddCAssignmentStep</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddStringInitStep</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>AddObjCObjectConversionStep</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddArrayInitLoopStep</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>EltTy</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddArrayInitStep</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsGNUExtension</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddParenthesizedArrayInitStep</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddPassByIndirectCopyRestoreStep</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shouldCopy</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>AddProduceObjCObjectStep</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>AddStdInitializerListConstructionStep</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>AddOCLSamplerInitStep</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>AddOCLZeroOpaqueTypeStep</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>RewrapReferenceInitList</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>InitListExpr</name> <modifier>*</modifier></type><name>Syntactic</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>void</name></type> <name>SetFailed</name><parameter_list>(<parameter><decl><type><name>FailureKind</name></type> <name>Failure</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SequenceKind</name> <operator>=</operator> <name>FailedSequence</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>Failure</name></name> <operator>=</operator> <name>Failure</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>Failure</name> <operator>!=</operator> <name>FK_Incomplete</name> <operator>||</operator> <operator>!</operator><call><name><name>FailedIncompleteType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Incomplete type failure requires a type!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function_decl><type><name>void</name></type> <name>SetOverloadFailure</name><parameter_list>(<parameter><decl><type><name>FailureKind</name></type> <name>Failure</name></decl></parameter>, <parameter><decl><type><name>OverloadingResult</name></type> <name>Result</name></decl></parameter>)</parameter_list>;</function_decl>



<function><type><name>OverloadCandidateSet</name> <modifier>&amp;</modifier></type><name>getFailedCandidateSet</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><name>FailedCandidateSet</name></expr>;</return>
</block_content>}</block></function>



<expr_stmt><expr><name>OverloadingResult</name> <macro><name>getFailedOverloadResult</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>FailedOverloadResult</name></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>void</name></type> <name>setIncompleteTypeFailure</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>IncompleteType</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>FailedIncompleteType</name> <operator>=</operator> <name>IncompleteType</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SetFailed</name><argument_list>(<argument><expr><name>FK_Incomplete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>FailureKind</name> <macro><name>getFailureKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Failed</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Not an initialization failure!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Failure</name></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>dump</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<expr_stmt><expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
