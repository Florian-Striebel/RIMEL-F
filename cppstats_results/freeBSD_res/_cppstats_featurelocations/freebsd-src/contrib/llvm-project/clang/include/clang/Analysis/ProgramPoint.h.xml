<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Analysis/ProgramPoint.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_ANALYSIS_PROGRAMPOINT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_ANALYSIS_PROGRAMPOINT_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/AnalysisDeclContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/CFG.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/FoldingSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerIntPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/DataTypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>AnalysisDeclContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LocationContext</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>ProgramPointTag</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>ProgramPointTag</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>tagKind</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>TagKind</name><argument_list>(<argument>tagKind</argument>)</argument_list></macro> <block>{}</block>
<name>virtual</name> <operator>~</operator><call><name>ProgramPointTag</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>virtual</name> <name>StringRef</name> <macro><name>getTagDescription</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>void</name> <operator>*</operator><macro><name>getTagKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TagKind</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>TagKind</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>SimpleProgramPointTag</name> <range>: <expr><name>public</name> <name>ProgramPointTag</name> <block>{
<expr><name>std</name><operator>::</operator><name>string</name> <name>Desc</name></expr>;
<expr><name>public</name><operator>:</operator>
<macro><name>SimpleProgramPointTag</name><argument_list>(<argument>StringRef MsgProvider</argument>, <argument>StringRef Msg</argument>)</argument_list></macro></expr>;
<expr><name>StringRef</name> <macro><name>getTagDescription</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>ProgramPoint</name> <block>{<block_content>
<label><name>public</name>:</label>
<enum>enum <name>Kind</name> <block>{ <decl><name>BlockEdgeKind</name></decl>,
<decl><name>BlockEntranceKind</name></decl>,
<decl><name>BlockExitKind</name></decl>,
<decl><name>PreStmtKind</name></decl>,
<decl><name>PreStmtPurgeDeadSymbolsKind</name></decl>,
<decl><name>PostStmtPurgeDeadSymbolsKind</name></decl>,
<decl><name>PostStmtKind</name></decl>,
<decl><name>PreLoadKind</name></decl>,
<decl><name>PostLoadKind</name></decl>,
<decl><name>PreStoreKind</name></decl>,
<decl><name>PostStoreKind</name></decl>,
<decl><name>PostConditionKind</name></decl>,
<decl><name>PostLValueKind</name></decl>,
<decl><name>PostAllocatorCallKind</name></decl>,
<decl><name>MinPostStmtKind</name> <init>= <expr><name>PostStmtKind</name></expr></init></decl>,
<decl><name>MaxPostStmtKind</name> <init>= <expr><name>PostAllocatorCallKind</name></expr></init></decl>,
<decl><name>PostInitializerKind</name></decl>,
<decl><name>CallEnterKind</name></decl>,
<decl><name>CallExitBeginKind</name></decl>,
<decl><name>CallExitEndKind</name></decl>,
<decl><name>FunctionExitKind</name></decl>,
<decl><name>PreImplicitCallKind</name></decl>,
<decl><name>PostImplicitCallKind</name></decl>,
<decl><name>MinImplicitCallKind</name> <init>= <expr><name>PreImplicitCallKind</name></expr></init></decl>,
<decl><name>MaxImplicitCallKind</name> <init>= <expr><name>PostImplicitCallKind</name></expr></init></decl>,
<decl><name>LoopExitKind</name></decl>,
<decl><name>EpsilonKind</name></decl>}</block>;</enum>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>Data1</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>Data2</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>L</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>Tag</name></expr>;</expr_stmt>

<label><name>protected</name>:</label>
<expr_stmt><expr><call><name>ProgramPoint</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<macro><name>ProgramPoint</name><argument_list>(<argument>const void *P</argument>,
<argument>Kind k</argument>,
<argument>const LocationContext *l</argument>,
<argument>const ProgramPointTag *tag = nullptr</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Data1</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>Data2</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator> <name>k</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3</literal></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>L</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator> <name>k</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3</literal></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>Tag</name><argument_list>(<argument>tag</argument>, <argument>(((unsigned) k) &gt;&gt; <literal type="number">4</literal>) &amp; <literal type="number">0x3</literal></argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>k</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getLocationContext</name><argument_list>()</argument_list></call> <operator>==</operator> <name>l</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getData1</name><argument_list>()</argument_list></call> <operator>==</operator> <name>P</name></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>ProgramPoint</name><argument_list>(<argument>const void *P1</argument>,
<argument>const void *P2</argument>,
<argument>Kind k</argument>,
<argument>const LocationContext *l</argument>,
<argument>const ProgramPointTag *tag = nullptr</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Data1</name><argument_list>(<argument><expr><name>P1</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>Data2</name><argument_list>(<argument><expr><name>P2</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator> <name>k</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3</literal></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>L</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator> <name>k</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3</literal></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>Tag</name><argument_list>(<argument>tag</argument>, <argument>(((unsigned) k) &gt;&gt; <literal type="number">4</literal>) &amp; <literal type="number">0x3</literal></argument>)</argument_list></macro> <expr><block>{}</block>

<name>protected</name><operator>:</operator>
<specifier>const</specifier> <name>void</name> <operator>*</operator><macro><name>getData1</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Data1</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>void</name> <operator>*</operator><macro><name>getData2</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Data2</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setData2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>Data2</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<label><name>public</name>:</label>


<decl_stmt><decl><type><name>ProgramPoint</name></type> <name>withTag</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><name>tag</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>ProgramPoint</name><argument_list>(<argument><expr><call><name>getData1</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getData2</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getKind</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getLocationContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>T</name> <macro><name>castAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>T</name><operator>::</operator><call><name>isKind</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>T</name> <name>t</name></expr>;
<expr><name>ProgramPoint</name><operator>&amp;</operator> <name>PP</name> <operator>=</operator> <name>t</name></expr>;
<expr><name>PP</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;
<return>return <expr><name>t</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>getAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>T</name><operator>::</operator><call><name>isKind</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>None</name></expr>;</return></block_content></block></if></if_stmt>
<name>T</name> <name>t</name></block></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ProgramPoint</name><modifier>&amp;</modifier></type> <name>PP</name> <init>= <expr><name>t</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>PP</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;</expr_stmt>
<return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>unsigned</name> <name>x</name> <operator>=</operator> <call><name><name>Tag</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>x</name> <operator>&lt;&lt;=</operator> <literal type="number">2</literal></expr>;
<expr><name>x</name> <operator>|=</operator> <call><name><name>L</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>x</name> <operator>&lt;&lt;=</operator> <literal type="number">2</literal></expr>;
<expr><name>x</name> <operator>|=</operator> <call><name><name>Data2</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><operator>(</operator><name>Kind</name><operator>)</operator> <name>x</name></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>bool</name></type> <name>isPurgeKind</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>Kind</name></type> <name>K</name> <init>= <expr><call><name>getKind</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>K</name> <operator>==</operator> <name>PostStmtPurgeDeadSymbolsKind</name> <operator>||</operator>
<name>K</name> <operator>==</operator> <name>PreStmtPurgeDeadSymbolsKind</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><macro><name>getTag</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Tag</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><macro><name>getLocationContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>L</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><macro><name>getStackFrame</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocationContext</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getStackFrame</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getHashValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <name>ID</name></expr>;
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>ID</name><operator>.</operator><name>ComputeHash</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>ProgramPoint</name> <operator>&amp;</operator> <name>RHS</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>Data1</name> <operator>==</operator> <name><name>RHS</name><operator>.</operator><name>Data1</name></name> <operator>&amp;&amp;</operator>
<name>Data2</name> <operator>==</operator> <name><name>RHS</name><operator>.</operator><name>Data2</name></name> <operator>&amp;&amp;</operator>
<name>L</name> <operator>==</operator> <name><name>RHS</name><operator>.</operator><name>L</name></name> <operator>&amp;&amp;</operator>
<name>Tag</name> <operator>==</operator> <name><name>RHS</name><operator>.</operator><name>Tag</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>ProgramPoint</name> <operator>&amp;</operator><name>RHS</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>Data1</name> <operator>!=</operator> <name><name>RHS</name><operator>.</operator><name>Data1</name></name> <operator>||</operator>
<name>Data2</name> <operator>!=</operator> <name><name>RHS</name><operator>.</operator><name>Data2</name></name> <operator>||</operator>
<name>L</name> <operator>!=</operator> <name><name>RHS</name><operator>.</operator><name>L</name></name> <operator>||</operator>
<name>Tag</name> <operator>!=</operator> <name><name>RHS</name><operator>.</operator><name>Tag</name></name></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name><operator>&amp;</operator> <name>ID</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator> <call><name>getKind</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name>getData1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name>getData2</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name>getLocationContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name>getTag</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>printJson</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>raw_ostream</name> <operator>&amp;</operator><name>Out</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>NL</name> <operator>=</operator> <literal type="string">"\n"</literal></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>LLVM_DUMP_METHOD</name> <name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ProgramPoint</name></type> <name>getProgramPoint</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>ProgramPoint</name><operator>::</operator><name>Kind</name> <name>K</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LC</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><name>tag</name></expr></argument>)</argument_list></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>BlockEntrance</name> <range>: <expr><name>public</name> <name>ProgramPoint</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>BlockEntrance</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><name>B</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>L</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><name>tag</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ProgramPoint</name><argument_list>(<argument>B</argument>, <argument>BlockEntranceKind</argument>, <argument>L</argument>, <argument>tag</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>B</name> <operator>&amp;&amp;</operator> <literal type="string">"BlockEntrance requires non-null block"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><macro><name>getBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CFGBlock</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getData1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>CFGElement</name></expr></argument>&gt;</argument_list></name> <macro><name>getFirstElement</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><name>B</name> <operator>=</operator> <call><name>getBlock</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><ternary><condition><expr><call><name><name>B</name><operator>-&gt;</operator><name>empty</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>CFGElement</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name><name>B</name><operator>-&gt;</operator><name>front</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>BlockEntrance</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>BlockEntranceKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>BlockExit</name> <operator>:</operator> <name>public</name> <name>ProgramPoint</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>BlockExit</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><name>B</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>L</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ProgramPoint</name><argument_list>(<argument>B</argument>, <argument>BlockExitKind</argument>, <argument>L</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><macro><name>getBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CFGBlock</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getData1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getTerminator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getBlock</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTerminatorStmt</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>BlockExit</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>BlockExitKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>StmtPoint</name> <operator>:</operator> <name>public</name> <name>ProgramPoint</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>StmtPoint</name><argument_list>(<argument>const Stmt *S</argument>, <argument>const void *p2</argument>, <argument>Kind k</argument>, <argument>const LocationContext *L</argument>,
<argument>const ProgramPointTag *tag</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>ProgramPoint</name><argument_list>(<argument>S</argument>, <argument>p2</argument>, <argument>k</argument>, <argument>L</argument>, <argument>tag</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><specifier>const</specifier> <name>Stmt</name><operator>*</operator><operator>)</operator> <call><name>getData1</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>const</specifier> <name>T</name><operator>*</operator> <macro><name>getStmtAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getStmt</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>protected</name><operator>:</operator>
<call><name>StmtPoint</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<expr><name>unsigned</name> <name>k</name> <operator>=</operator> <call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>k</name> <operator>&gt;=</operator> <name>PreStmtKind</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;=</operator> <name>MaxPostStmtKind</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>PreStmt</name> <operator>:</operator> <name>public</name> <name>StmtPoint</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PreStmt</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>L</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><name>tag</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>SubStmt</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>StmtPoint</name><argument_list>(<argument>S</argument>, <argument>SubStmt</argument>, <argument>PreStmtKind</argument>, <argument>L</argument>, <argument>tag</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getSubStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><specifier>const</specifier> <name>Stmt</name><operator>*</operator><operator>)</operator> <call><name>getData2</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>PreStmt</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PreStmtKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>PostStmt</name> <operator>:</operator> <name>public</name> <name>StmtPoint</name> <block>{
<expr><name>protected</name><operator>:</operator>
<call><name>PostStmt</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<macro><name>PostStmt</name><argument_list>(<argument>const Stmt *S</argument>, <argument>const void *data</argument>, <argument>Kind k</argument>, <argument>const LocationContext *L</argument>,
<argument>const ProgramPointTag *tag = nullptr</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>StmtPoint</name><argument_list>(<argument>S</argument>, <argument>data</argument>, <argument>k</argument>, <argument>L</argument>, <argument>tag</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>explicit</name> <macro><name>PostStmt</name><argument_list>(<argument>const Stmt *S</argument>, <argument>Kind k</argument>, <argument>const LocationContext *L</argument>,
<argument>const ProgramPointTag *tag = nullptr</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>StmtPoint</name><argument_list>(<argument>S</argument>, <argument>nullptr</argument>, <argument>k</argument>, <argument>L</argument>, <argument>tag</argument>)</argument_list></macro> <block>{}</block>

<name>explicit</name> <call><name>PostStmt</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>L</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><name>tag</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>StmtPoint</name><argument_list>(<argument>S</argument>, <argument>nullptr</argument>, <argument>PostStmtKind</argument>, <argument>L</argument>, <argument>tag</argument>)</argument_list></macro> <block>{}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<expr><name>unsigned</name> <name>k</name> <operator>=</operator> <call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>k</name> <operator>&gt;=</operator> <name>MinPostStmtKind</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;=</operator> <name>MaxPostStmtKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>FunctionExitPoint</name> <operator>:</operator> <name>public</name> <name>ProgramPoint</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>FunctionExitPoint</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ReturnStmt</name> <operator>*</operator><name>S</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LC</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><name>tag</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ProgramPoint</name><argument_list>(<argument>S</argument>, <argument>FunctionExitKind</argument>, <argument>LC</argument>, <argument>tag</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><macro><name>getBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>&amp;</operator><call><name>getLocationContext</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getCFG</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getExit</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>ReturnStmt</name> <operator>*</operator><macro><name>getStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ReturnStmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getData1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>FunctionExitPoint</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>FunctionExitKind</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>PostCondition</name> <operator>:</operator> <name>public</name> <name>PostStmt</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PostCondition</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>L</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><name>tag</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>PostStmt</name><argument_list>(<argument>S</argument>, <argument>PostConditionKind</argument>, <argument>L</argument>, <argument>tag</argument>)</argument_list></macro> <block>{}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>PostCondition</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PostConditionKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>LocationCheck</name> <operator>:</operator> <name>public</name> <name>StmtPoint</name> <block>{
<expr><name>protected</name><operator>:</operator>
<call><name>LocationCheck</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<macro><name>LocationCheck</name><argument_list>(<argument>const Stmt *S</argument>, <argument>const LocationContext *L</argument>,
<argument>ProgramPoint::Kind K</argument>, <argument>const ProgramPointTag *tag</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>StmtPoint</name><argument_list>(<argument>S</argument>, <argument>nullptr</argument>, <argument>K</argument>, <argument>L</argument>, <argument>tag</argument>)</argument_list></macro> <expr><block>{}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;location</argument>)</argument_list></macro> <block>{
<expr><name>unsigned</name> <name>k</name> <operator>=</operator> <call><name><name>location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>k</name> <operator>==</operator> <name>PreLoadKind</name> <operator>||</operator> <name>k</name> <operator>==</operator> <name>PreStoreKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>PreLoad</name> <operator>:</operator> <name>public</name> <name>LocationCheck</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PreLoad</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>L</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><name>tag</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>LocationCheck</name><argument_list>(<argument>S</argument>, <argument>L</argument>, <argument>PreLoadKind</argument>, <argument>tag</argument>)</argument_list></macro> <block>{}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>PreLoad</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PreLoadKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>PreStore</name> <operator>:</operator> <name>public</name> <name>LocationCheck</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PreStore</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>L</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><name>tag</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>LocationCheck</name><argument_list>(<argument>S</argument>, <argument>L</argument>, <argument>PreStoreKind</argument>, <argument>tag</argument>)</argument_list></macro> <block>{}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>PreStore</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PreStoreKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>PostLoad</name> <operator>:</operator> <name>public</name> <name>PostStmt</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PostLoad</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>L</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><name>tag</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>PostStmt</name><argument_list>(<argument>S</argument>, <argument>PostLoadKind</argument>, <argument>L</argument>, <argument>tag</argument>)</argument_list></macro> <block>{}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>PostLoad</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PostLoadKind</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>PostStore</name> <operator>:</operator> <name>public</name> <name>PostStmt</name> <block>{
<expr><name>public</name><operator>:</operator>



<call><name>PostStore</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>L</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator><name>Loc</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><name>tag</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>PostStmt</name><argument_list>(<argument>S</argument>, <argument>PostStoreKind</argument>, <argument>L</argument>, <argument>tag</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getData2</name><argument_list>()</argument_list></call> <operator>==</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setData2</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>



<specifier>const</specifier> <name>void</name> <operator>*</operator><macro><name>getLocationValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getData2</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>PostStore</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PostStoreKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>PostLValue</name> <operator>:</operator> <name>public</name> <name>PostStmt</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PostLValue</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>L</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><name>tag</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>PostStmt</name><argument_list>(<argument>S</argument>, <argument>PostLValueKind</argument>, <argument>L</argument>, <argument>tag</argument>)</argument_list></macro> <block>{}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>PostLValue</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PostLValueKind</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>PreStmtPurgeDeadSymbols</name> <operator>:</operator> <name>public</name> <name>StmtPoint</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PreStmtPurgeDeadSymbols</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>L</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><name>tag</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>StmtPoint</name><argument_list>(<argument>S</argument>, <argument>nullptr</argument>, <argument>PreStmtPurgeDeadSymbolsKind</argument>, <argument>L</argument>, <argument>tag</argument>)</argument_list></macro> <block>{ }</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>PreStmtPurgeDeadSymbols</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PreStmtPurgeDeadSymbolsKind</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>PostStmtPurgeDeadSymbols</name> <operator>:</operator> <name>public</name> <name>StmtPoint</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PostStmtPurgeDeadSymbols</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>L</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><name>tag</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>StmtPoint</name><argument_list>(<argument>S</argument>, <argument>nullptr</argument>, <argument>PostStmtPurgeDeadSymbolsKind</argument>, <argument>L</argument>, <argument>tag</argument>)</argument_list></macro> <block>{ }</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>PostStmtPurgeDeadSymbols</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PostStmtPurgeDeadSymbolsKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>BlockEdge</name> <operator>:</operator> <name>public</name> <name>ProgramPoint</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>BlockEdge</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><name>B1</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><name>B2</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>L</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ProgramPoint</name><argument_list>(<argument>B1</argument>, <argument>B2</argument>, <argument>BlockEdgeKind</argument>, <argument>L</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>B1</name> <operator>&amp;&amp;</operator> <literal type="string">"BlockEdge: source block must be non-null"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>B2</name> <operator>&amp;&amp;</operator> <literal type="string">"BlockEdge: destination block must be non-null"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><macro><name>getSrc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CFGBlock</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getData1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><macro><name>getDst</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CFGBlock</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getData2</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>BlockEdge</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>BlockEdgeKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>PostInitializer</name> <operator>:</operator> <name>public</name> <name>ProgramPoint</name> <block>{
<expr><name>public</name><operator>:</operator>





<call><name>PostInitializer</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXCtorInitializer</name> <operator>*</operator><name>I</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator><name>Loc</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>L</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ProgramPoint</name><argument_list>(<argument>I</argument>, <argument>Loc</argument>, <argument>PostInitializerKind</argument>, <argument>L</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>CXXCtorInitializer</name> <operator>*</operator><macro><name>getInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXCtorInitializer</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getData1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<specifier>const</specifier> <name>void</name> <operator>*</operator><macro><name>getLocationValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getData2</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>PostInitializer</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PostInitializerKind</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>ImplicitCallPoint</name> <operator>:</operator> <name>public</name> <name>ProgramPoint</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>ImplicitCallPoint</name><argument_list>(<argument>const Decl *D</argument>, <argument>SourceLocation Loc</argument>, <argument>Kind K</argument>,
<argument>const LocationContext *L</argument>, <argument>const ProgramPointTag *Tag</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>ProgramPoint</name><argument_list>(<argument>Loc.getPtrEncoding()</argument>, <argument>D</argument>, <argument>K</argument>, <argument>L</argument>, <argument>Tag</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getData2</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>SourceLocation</name><operator>::</operator><call><name>getFromPtrEncoding</name><argument_list>(<argument><expr><call><name>getData1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>protected</name><operator>:</operator>
<call><name>ImplicitCallPoint</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>MinImplicitCallKind</name> <operator>&amp;&amp;</operator>
<call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>MaxImplicitCallKind</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>PreImplicitCall</name> <operator>:</operator> <name>public</name> <name>ImplicitCallPoint</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>PreImplicitCall</name><argument_list>(<argument>const Decl *D</argument>, <argument>SourceLocation Loc</argument>, <argument>const LocationContext *L</argument>,
<argument>const ProgramPointTag *Tag = nullptr</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>ImplicitCallPoint</name><argument_list>(<argument>D</argument>, <argument>Loc</argument>, <argument>PreImplicitCallKind</argument>, <argument>L</argument>, <argument>Tag</argument>)</argument_list></macro> <block>{}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>PreImplicitCall</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PreImplicitCallKind</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>PostImplicitCall</name> <operator>:</operator> <name>public</name> <name>ImplicitCallPoint</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>PostImplicitCall</name><argument_list>(<argument>const Decl *D</argument>, <argument>SourceLocation Loc</argument>, <argument>const LocationContext *L</argument>,
<argument>const ProgramPointTag *Tag = nullptr</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>ImplicitCallPoint</name><argument_list>(<argument>D</argument>, <argument>Loc</argument>, <argument>PostImplicitCallKind</argument>, <argument>L</argument>, <argument>Tag</argument>)</argument_list></macro> <block>{}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>PostImplicitCall</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PostImplicitCallKind</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>PostAllocatorCall</name> <operator>:</operator> <name>public</name> <name>StmtPoint</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PostAllocatorCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>L</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><name>Tag</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>StmtPoint</name><argument_list>(<argument>S</argument>, <argument>nullptr</argument>, <argument>PostAllocatorCallKind</argument>, <argument>L</argument>, <argument>Tag</argument>)</argument_list></macro> <block>{}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>PostAllocatorCall</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>PostAllocatorCallKind</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>CallEnter</name> <operator>:</operator> <name>public</name> <name>ProgramPoint</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>CallEnter</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>stmt</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><name>calleeCtx</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>callerCtx</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ProgramPoint</name><argument_list>(<argument>stmt</argument>, <argument>calleeCtx</argument>, <argument>CallEnterKind</argument>, <argument>callerCtx</argument>, <argument>nullptr</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getCallExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getData1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><macro><name>getCalleeContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getData2</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><macro><name>getEntry</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><name>CalleeCtx</name> <operator>=</operator> <call><name>getCalleeContext</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>CFG</name> <operator>*</operator><name>CalleeCFG</name> <operator>=</operator> <call><name><name>CalleeCtx</name><operator>-&gt;</operator><name>getCFG</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><operator>&amp;</operator><operator>(</operator><call><name><name>CalleeCFG</name><operator>-&gt;</operator><name>getEntry</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>CallEnter</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CallEnterKind</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>CallExitBegin</name> <operator>:</operator> <name>public</name> <name>ProgramPoint</name> <block>{
<expr><name>public</name><operator>:</operator>

<call><name>CallExitBegin</name><argument_list>(<argument><expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><name>L</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ReturnStmt</name> <operator>*</operator><name>RS</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ProgramPoint</name><argument_list>(<argument>RS</argument>, <argument>CallExitBeginKind</argument>, <argument>L</argument>, <argument>nullptr</argument>)</argument_list></macro> <block>{ }</block>

<specifier>const</specifier> <name>ReturnStmt</name> <operator>*</operator><macro><name>getReturnStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ReturnStmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getData1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>CallExitBegin</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CallExitBeginKind</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>CallExitEnd</name> <operator>:</operator> <name>public</name> <name>ProgramPoint</name> <block>{
<expr><name>public</name><operator>:</operator>

<call><name>CallExitEnd</name><argument_list>(<argument><expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><name>CalleeCtx</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>CallerCtx</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ProgramPoint</name><argument_list>(<argument>CalleeCtx</argument>, <argument>CallExitEndKind</argument>, <argument>CallerCtx</argument>, <argument>nullptr</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><macro><name>getCalleeContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getData1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>CallExitEnd</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CallExitEndKind</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>LoopExit</name> <operator>:</operator> <name>public</name> <name>ProgramPoint</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>LoopExit</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>LoopStmt</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LC</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ProgramPoint</name><argument_list>(<argument>LoopStmt</argument>, <argument>nullptr</argument>, <argument>LoopExitKind</argument>, <argument>LC</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getLoopStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getData1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>LoopExit</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>LoopExitKind</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>EpsilonPoint</name> <operator>:</operator> <name>public</name> <name>ProgramPoint</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>EpsilonPoint</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>L</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator><name>Data1</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator><name>Data2</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><name>tag</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ProgramPoint</name><argument_list>(<argument>Data1</argument>, <argument>Data2</argument>, <argument>EpsilonKind</argument>, <argument>L</argument>, <argument>tag</argument>)</argument_list></macro> <block>{}</block>

<specifier>const</specifier> <name>void</name> <operator>*</operator><macro><name>getData</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getData1</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ProgramPoint</name></expr>;
<expr><call><name>EpsilonPoint</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isKind</name><argument_list>(<argument>const ProgramPoint &amp;Location</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Location</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>EpsilonKind</name></expr>;</return>
}</block>
}</expr>;

}</block>


<name>namespace</name> <name>llvm</name> <block>{

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>DenseMapInfo</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>ProgramPoint</name></expr></argument>&gt;</argument_list></name> <block>{

<expr><specifier>static</specifier> <specifier>inline</specifier> <name>clang</name><operator>::</operator><name>ProgramPoint</name> <macro><name>getEmptyKey</name><argument_list>()</argument_list></macro> <block>{
<expr><name>uintptr_t</name> <name>x</name> <operator>=</operator>
<call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>uintptr_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>DenseMapInfo</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>getEmptyKey</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><literal type="number">0x7</literal></expr>;
<return>return <expr><name>clang</name><operator>::</operator><call><name>BlockEntrance</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>CFGBlock</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <specifier>inline</specifier> <name>clang</name><operator>::</operator><name>ProgramPoint</name> <macro><name>getTombstoneKey</name><argument_list>()</argument_list></macro> <block>{
<expr><name>uintptr_t</name> <name>x</name> <operator>=</operator>
<call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>uintptr_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>DenseMapInfo</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>getTombstoneKey</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><literal type="number">0x7</literal></expr>;
<return>return <expr><name>clang</name><operator>::</operator><call><name>BlockEntrance</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>CFGBlock</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>unsigned</name> <macro><name>getHashValue</name><argument_list>(<argument>const clang::ProgramPoint &amp;Loc</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Loc</name><operator>.</operator><name>getHashValue</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isEqual</name><argument_list>(<argument>const clang::ProgramPoint &amp;L</argument>,
<argument>const clang::ProgramPoint &amp;R</argument>)</argument_list></macro> <block>{
<return>return <expr><name>L</name> <operator>==</operator> <name>R</name></expr>;</return>
}</block>

}</expr>;

}</block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></range></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
