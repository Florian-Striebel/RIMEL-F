<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyCommon.h">



















<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYCOMMON_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYCOMMON_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/Analyses/PostOrderCFGView.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/Analyses/ThreadSafetyTIL.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/Analyses/ThreadSafetyTraverse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/Analyses/ThreadSafetyUtil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/AnalysisDeclContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/CFG.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sstream&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>AbstractConditionalOperator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ArraySubscriptExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BinaryOperator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CallExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CastExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXDestructorDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXMemberCallExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXOperatorCallExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXThisExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DeclRefExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DeclStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MemberExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Stmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UnaryOperator</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>threadSafety</name> <block>{<block_content>


<decl_stmt><decl><type><name>namespace</name></type> <name>sx</name> <block>{<block_content>

<decl_stmt><decl><type><specifier>inline</specifier> <name>bool</name></type> <name>equals</name><argument_list>(<argument><expr><specifier>const</specifier> <name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><name>E1</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><name>E2</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><name>til</name><operator>::</operator><name>EqualsComparator</name><operator>::</operator><call><name>compareExprs</name><argument_list>(<argument><expr><name>E1</name></expr></argument>, <argument><expr><name>E2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>inline</specifier> <name>bool</name></type> <name>matches</name><argument_list>(<argument><expr><specifier>const</specifier> <name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><name>E1</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><name>E2</name></expr></argument>)</argument_list> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>til</name><operator>::</operator><name>Wildcard</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>til</name><operator>::</operator><name>Wildcard</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E2</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>til</name><operator>::</operator><name>Wildcard</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>til</name><operator>::</operator><name>Wildcard</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E1</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>til</name><operator>::</operator><name>MatchComparator</name><operator>::</operator><call><name>compareExprs</name><argument_list>(<argument><expr><name>E1</name></expr></argument>, <argument><expr><name>E2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>inline</specifier> <name>bool</name></type> <name>partiallyMatches</name><argument_list>(<argument><expr><specifier>const</specifier> <name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><name>E1</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><name>E2</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>PE1</name> <init>= <expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>til</name><operator>::</operator><name>Project</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PE1</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>PE2</name> <init>= <expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>til</name><operator>::</operator><name>Project</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PE2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name><name>PE1</name><operator>-&gt;</operator><name>clangDecl</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>PE2</name><operator>-&gt;</operator><name>clangDecl</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>std</name><operator>::</operator><name>string</name> <macro><name>toString</name><argument_list>(<argument>const til::SExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>std</name><operator>::</operator><name>stringstream</name> <name>ss</name></expr>;
<expr><name>til</name><operator>::</operator><name>StdPrinter</name><operator>::</operator><call><name>print</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>ss</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>CFGVisitor</name> <block>{<block_content>

<function><type><name>void</name></type> <name>enterCFG</name><parameter_list>(<parameter><decl><type><name>CFG</name> <modifier>*</modifier></type><name>Cfg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>First</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>


<function><type><name>void</name></type> <name>enterCFGBlock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>


<function><type><name>bool</name></type> <name>visitPredecessors</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>true</name></expr>;</return> </block_content>}</block></function>


<function><type><name>void</name></type> <name>handlePredecessor</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>Pred</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>


<function><type><name>void</name></type> <name>handlePredecessorBackEdge</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>Pred</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>


<function><type><name>void</name></type> <name>enterCFGBlockBody</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>


<function><type><name>void</name></type> <name>handleStatement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>


<function><type><name>void</name></type> <name>handleDestructorCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>DD</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>


<function><type><name>void</name></type> <name>exitCFGBlockBody</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>


<function><type><name>bool</name></type> <name>visitSuccessors</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>true</name></expr>;</return> </block_content>}</block></function>


<function><type><name>void</name></type> <name>handleSuccessor</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>Succ</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>


<function><type><name>void</name></type> <name>handleSuccessorBackEdge</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>Succ</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>


<function><type><name>void</name></type> <name>exitCFGBlock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>


<function><type><name>void</name></type> <name>exitCFG</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>Last</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>CFGWalker</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>CFGWalker</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>



<function><type><name>bool</name></type> <name>init</name><parameter_list>(<parameter><decl><type><name>AnalysisDeclContext</name> <modifier>&amp;</modifier></type><name>AC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>ACtx</name> <operator>=</operator> <operator>&amp;</operator><name>AC</name></expr>;</expr_stmt>
<expr_stmt><expr><name>CFGraph</name> <operator>=</operator> <call><name><name>AC</name><operator>.</operator><name>getCFG</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CFGraph</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>AC</name><operator>.</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>SortedGraph</name> <operator>=</operator> <name><name>AC</name><operator>.</operator><name>getAnalysis</name></name><operator>&lt;</operator><name>PostOrderCFGView</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>SortedGraph</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Visitor</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>walk</name><parameter_list>(<parameter><decl><type><name>Visitor</name> <modifier>&amp;</modifier></type><name>V</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>PostOrderCFGView</name><operator>::</operator><name>CFGBlockSet</name> <call><name>VisitedBlocks</name><argument_list>(<argument><expr><name>CFGraph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>V</name><operator>.</operator><name>enterCFG</name></name><argument_list>(<argument><expr><name>CFGraph</name></expr></argument>, <argument><expr><call><name>getDecl</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><call><name><name>CFGraph</name><operator>-&gt;</operator><name>getEntry</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>CurrBlock</name> <range>: <expr><operator>*</operator><name>SortedGraph</name></expr></range></decl></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name><name>VisitedBlocks</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>CurrBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>V</name><operator>.</operator><name>enterCFGBlock</name></name><argument_list>(<argument><expr><name>CurrBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>V</name><operator>.</operator><name>visitPredecessors</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>CFGBlock</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>BackEdges</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>CFGBlock</name><operator>::</operator><name>const_pred_iterator</name> <name>SI</name> <operator>=</operator> <call><name><name>CurrBlock</name><operator>-&gt;</operator><name>pred_begin</name></name><argument_list>()</argument_list></call></expr><operator>,</operator>
<expr><name>SE</name> <operator>=</operator> <call><name><name>CurrBlock</name><operator>-&gt;</operator><name>pred_end</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>SI</name> <operator>!=</operator> <name>SE</name></expr>;</condition> <incr><expr><operator>++</operator><name>SI</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>SI</name> <operator>==</operator> <name>nullptr</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>VisitedBlocks</name><operator>.</operator><name>alreadySet</name></name><argument_list>(<argument><expr><operator>*</operator><name>SI</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>BackEdges</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><operator>*</operator><name>SI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name><name>V</name><operator>.</operator><name>handlePredecessor</name></name><argument_list>(<argument><expr><operator>*</operator><name>SI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>Blk</name> <operator>:</operator> <name>BackEdges</name></expr></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>V</name><operator>.</operator><name>handlePredecessorBackEdge</name></name><argument_list>(<argument><expr><name>Blk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name><name>V</name><operator>.</operator><name>enterCFGBlockBody</name></name><argument_list>(<argument><expr><name>CurrBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>BI</name> <range>: <expr><operator>*</operator><name>CurrBlock</name></expr></range></decl></init>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><call><name><name>BI</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CFGElement</name><operator>::</operator><name>Statement</name></expr>:</case>
<expr_stmt><expr><call><name><name>V</name><operator>.</operator><name>handleStatement</name></name><argument_list>(<argument><expr><name><name>BI</name><operator>.</operator><name>castAs</name></name><operator>&lt;</operator><name>CFGStmt</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>.</operator><call><name>getStmt</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>CFGElement</name><operator>::</operator><name>AutomaticObjectDtor</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>CFGAutomaticObjDtor</name></type> <name>AD</name> <init>= <expr><name><name>BI</name><operator>.</operator><name>castAs</name></name><operator>&lt;</operator><name>CFGAutomaticObjDtor</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>DD</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXDestructorDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>AD</name><operator>.</operator><name>getDestructorDecl</name></name><argument_list>(<argument><expr><call><name><name>ACtx</name><operator>-&gt;</operator><name>getASTContext</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>VD</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>AD</name><operator>.</operator><name>getVarDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>V</name><operator>.</operator><name>handleDestructorCall</name></name><argument_list>(<argument><expr><name>VD</name></expr></argument>, <argument><expr><name>DD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>

<expr_stmt><expr><call><name><name>V</name><operator>.</operator><name>exitCFGBlockBody</name></name><argument_list>(<argument><expr><name>CurrBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>V</name><operator>.</operator><name>visitSuccessors</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>CFGBlock</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>ForwardEdges</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>CFGBlock</name><operator>::</operator><name>const_succ_iterator</name> <name>SI</name> <operator>=</operator> <call><name><name>CurrBlock</name><operator>-&gt;</operator><name>succ_begin</name></name><argument_list>()</argument_list></call></expr><operator>,</operator>
<expr><name>SE</name> <operator>=</operator> <call><name><name>CurrBlock</name><operator>-&gt;</operator><name>succ_end</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>SI</name> <operator>!=</operator> <name>SE</name></expr>;</condition> <incr><expr><operator>++</operator><name>SI</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>SI</name> <operator>==</operator> <name>nullptr</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>VisitedBlocks</name><operator>.</operator><name>alreadySet</name></name><argument_list>(<argument><expr><operator>*</operator><name>SI</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>ForwardEdges</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><operator>*</operator><name>SI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name><name>V</name><operator>.</operator><name>handleSuccessorBackEdge</name></name><argument_list>(<argument><expr><operator>*</operator><name>SI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>Blk</name> <operator>:</operator> <name>ForwardEdges</name></expr></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>V</name><operator>.</operator><name>handleSuccessor</name></name><argument_list>(<argument><expr><name>Blk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name><name>V</name><operator>.</operator><name>exitCFGBlock</name></name><argument_list>(<argument><expr><name>CurrBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name><name>V</name><operator>.</operator><name>exitCFG</name></name><argument_list>(<argument><expr><operator>&amp;</operator><call><name><name>CFGraph</name><operator>-&gt;</operator><name>getExit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>CFG</name> <operator>*</operator><macro><name>getGraph</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CFGraph</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>CFG</name> <modifier>*</modifier></type><name>getGraph</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>CFGraph</name></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>ACtx</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>PostOrderCFGView</name> <operator>*</operator><macro><name>getSortedGraph</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SortedGraph</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>CFG</name> <modifier>*</modifier></type><name>CFGraph</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AnalysisDeclContext</name> <modifier>*</modifier></type><name>ACtx</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PostOrderCFGView</name> <modifier>*</modifier></type><name>SortedGraph</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>CapabilityExpr</name> <block>{<block_content>
<label><name>private</name>:</label>

<expr_stmt><expr><specifier>const</specifier> <name>til</name><operator>::</operator><name>SExpr</name><operator>*</operator> <name>CapExpr</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>Negated</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>CapabilityExpr</name><argument_list>(<argument>const til::SExpr *E</argument>, <argument>bool Neg</argument>)</argument_list></macro> : <expr_stmt><expr><call><name>CapExpr</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Negated</name><argument_list>(<argument>Neg</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>const</specifier> <name>til</name><operator>::</operator><name>SExpr</name><operator>*</operator> <macro><name>sexpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CapExpr</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>negative</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Negated</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>CapabilityExpr</name> <name>operator</name><operator>!</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name>CapabilityExpr</name><argument_list>(<argument><expr><name>CapExpr</name></expr></argument>, <argument><expr><operator>!</operator><name>Negated</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>equals</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CapabilityExpr</name> <operator>&amp;</operator><name>other</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><operator>(</operator><name>Negated</name> <operator>==</operator> <name><name>other</name><operator>.</operator><name>Negated</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name>sx</name><operator>::</operator><call><name>equals</name><argument_list>(<argument><expr><name>CapExpr</name></expr></argument>, <argument><expr><name><name>other</name><operator>.</operator><name>CapExpr</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>matches</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CapabilityExpr</name> <operator>&amp;</operator><name>other</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><operator>(</operator><name>Negated</name> <operator>==</operator> <name><name>other</name><operator>.</operator><name>Negated</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name>sx</name><operator>::</operator><call><name>matches</name><argument_list>(<argument><expr><name>CapExpr</name></expr></argument>, <argument><expr><name><name>other</name><operator>.</operator><name>CapExpr</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>matchesUniv</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CapabilityExpr</name> <operator>&amp;</operator><name>CapE</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>isUniversal</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>matches</name><argument_list>(<argument><expr><name>CapE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>partiallyMatches</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CapabilityExpr</name> <operator>&amp;</operator><name>other</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><operator>(</operator><name>Negated</name> <operator>==</operator> <name><name>other</name><operator>.</operator><name>Negated</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
<name>sx</name><operator>::</operator><call><name>partiallyMatches</name><argument_list>(<argument><expr><name>CapExpr</name></expr></argument>, <argument><expr><name><name>other</name><operator>.</operator><name>CapExpr</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>ValueDecl</name><operator>*</operator> <macro><name>valueDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>Negated</name> <operator>||</operator> <name>CapExpr</name> <operator>==</operator> <name>nullptr</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>P</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>til</name><operator>::</operator><name>Project</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CapExpr</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>P</name><operator>-&gt;</operator><name>clangDecl</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>P</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>til</name><operator>::</operator><name>LiteralPtr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CapExpr</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>P</name><operator>-&gt;</operator><name>clangDecl</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>nullptr</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>toString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>Negated</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="string">"!"</literal> <operator>+</operator> <name>sx</name><operator>::</operator><call><name>toString</name><argument_list>(<argument><expr><name>CapExpr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>sx</name><operator>::</operator><call><name>toString</name><argument_list>(<argument><expr><name>CapExpr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>shouldIgnore</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CapExpr</name> <operator>==</operator> <name>nullptr</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isInvalid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>sexpr</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>til</name><operator>::</operator><name>Undefined</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>sexpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isUniversal</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>sexpr</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>til</name><operator>::</operator><name>Wildcard</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>sexpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>SExprBuilder</name> <block>{<block_content>
<label><name>public</name>:</label>









<struct>struct <name>CallingContext</name> <block>{

<decl_stmt><decl><type><name>CallingContext</name> <modifier>*</modifier></type><name>Prev</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>AttrDecl</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>SelfArg</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumArgs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>FunArgs</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>SelfArrow</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CallingContext</name><argument_list>(<argument><expr><name>CallingContext</name> <operator>*</operator><name>P</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>D</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Prev</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>AttrDecl</name><argument_list>(<argument>D</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>

<macro><name>SExprBuilder</name><argument_list>(<argument>til::MemRegionRef A</argument>)</argument_list></macro> : <macro><name>Arena</name><argument_list>(<argument>A</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>SelfVar</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>Arena</argument>)</argument_list></macro> <name>til</name><operator>::</operator><call><name>Variable</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SelfVar</name><operator>-&gt;</operator><name>setKind</name></name><argument_list>(<argument><expr><name>til</name><operator>::</operator><name>Variable</name><operator>::</operator><name>VK_SFun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>



<function_decl><type><name>CapabilityExpr</name></type> <name>translateAttrExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>AttrExp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>DeclExp</name></decl></parameter>, <parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>SelfD</name><init>=<expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>CapabilityExpr</name></type> <name>translateAttrExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>AttrExp</name></decl></parameter>, <parameter><decl><type><name>CallingContext</name> <modifier>*</modifier></type><name>Ctx</name></decl></parameter>)</parameter_list>;</function_decl>




<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>translate</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>CallingContext</name> <operator>*</operator><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>SCFG</name> <operator>*</operator><call><name>buildCFG</name><argument_list>(<argument><expr><name>CFGWalker</name> <operator>&amp;</operator><name>Walker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>lookupStmt</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>til</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><macro><name>lookupBlock</name><argument_list>(<argument>const CFGBlock *B</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>BlockMap</name><index>[<expr><call><name><name>B</name><operator>-&gt;</operator><name>getBlockID</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>til</name><operator>::</operator><name>SCFG</name> <operator>*</operator><macro><name>getCFG</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Scfg</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>SCFG</name> <operator>*</operator><macro><name>getCFG</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Scfg</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CFGWalker</name></decl>;</decl_stmt>

<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>translateDeclRefExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclRefExpr</name> <operator>*</operator><name>DRE</name></expr></argument>,
<argument><expr><name>CallingContext</name> <operator>*</operator><name>Ctx</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>translateCXXThisExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXThisExpr</name> <operator>*</operator><name>TE</name></expr></argument>, <argument><expr><name>CallingContext</name> <operator>*</operator><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>translateMemberExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MemberExpr</name> <operator>*</operator><name>ME</name></expr></argument>, <argument><expr><name>CallingContext</name> <operator>*</operator><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>translateObjCIVarRefExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCIvarRefExpr</name> <operator>*</operator><name>IVRE</name></expr></argument>,
<argument><expr><name>CallingContext</name> <operator>*</operator><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>translateCallExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CallExpr</name> <operator>*</operator><name>CE</name></expr></argument>, <argument><expr><name>CallingContext</name> <operator>*</operator><name>Ctx</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>SelfE</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>translateCXXMemberCallExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXMemberCallExpr</name> <operator>*</operator><name>ME</name></expr></argument>,
<argument><expr><name>CallingContext</name> <operator>*</operator><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>translateCXXOperatorCallExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXOperatorCallExpr</name> <operator>*</operator><name>OCE</name></expr></argument>,
<argument><expr><name>CallingContext</name> <operator>*</operator><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>translateUnaryOperator</name><argument_list>(<argument><expr><specifier>const</specifier> <name>UnaryOperator</name> <operator>*</operator><name>UO</name></expr></argument>,
<argument><expr><name>CallingContext</name> <operator>*</operator><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><macro><name>translateBinOp</name><argument_list>(<argument>til::TIL_BinaryOpcode Op</argument>,
<argument>const BinaryOperator *BO</argument>,
<argument>CallingContext *Ctx</argument>, <argument>bool Reverse = false</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><macro><name>translateBinAssign</name><argument_list>(<argument>til::TIL_BinaryOpcode Op</argument>,
<argument>const BinaryOperator *BO</argument>,
<argument>CallingContext *Ctx</argument>, <argument>bool Assign = false</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>translateBinaryOperator</name><argument_list>(<argument><expr><specifier>const</specifier> <name>BinaryOperator</name> <operator>*</operator><name>BO</name></expr></argument>,
<argument><expr><name>CallingContext</name> <operator>*</operator><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>translateCastExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CastExpr</name> <operator>*</operator><name>CE</name></expr></argument>, <argument><expr><name>CallingContext</name> <operator>*</operator><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>translateArraySubscriptExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ArraySubscriptExpr</name> <operator>*</operator><name>E</name></expr></argument>,
<argument><expr><name>CallingContext</name> <operator>*</operator><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>translateAbstractConditionalOperator</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>AbstractConditionalOperator</name> <operator>*</operator><name>C</name></expr></argument>, <argument><expr><name>CallingContext</name> <operator>*</operator><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>translateDeclStmt</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclStmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>CallingContext</name> <operator>*</operator><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>StatementMap</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator></expr></argument>, <argument><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>LVarIndexMap</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>NameVarPair</name> <init>= <expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>LVarDefinitionMap</name> <init>= <expr><name><name>CopyOnWriteVector</name><argument_list type="generic">&lt;<argument><expr><name>NameVarPair</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<struct>struct <name>BlockInfo</name> <block>{
<decl_stmt><decl><type><name>LVarDefinitionMap</name></type> <name>ExitMap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>HasBackEdges</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>UnprocessedSuccessors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>ProcessedPredecessors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BlockInfo</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<expr_stmt><expr><call><name>BlockInfo</name><argument_list>(<argument><expr><name>BlockInfo</name> <operator>&amp;&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<decl_stmt><decl><type><name>BlockInfo</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><name>BlockInfo</name> <operator>&amp;&amp;</operator><operator>)</operator> <operator>=</operator> default</expr></init></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><name>void</name></type> <name>enterCFG</name><parameter_list>(<parameter><decl><type><name>CFG</name> <modifier>*</modifier></type><name>Cfg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>First</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>enterCFGBlock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>bool</name></type> <name>visitPredecessors</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>true</name></expr>;</return> </block_content>}</block></function>
<function_decl><type><name>void</name></type> <name>handlePredecessor</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>Pred</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>handlePredecessorBackEdge</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>Pred</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>enterCFGBlockBody</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>handleStatement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>handleDestructorCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>DD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>exitCFGBlockBody</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>bool</name></type> <name>visitSuccessors</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>true</name></expr>;</return> </block_content>}</block></function>
<function_decl><type><name>void</name></type> <name>handleSuccessor</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>Succ</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>handleSuccessorBackEdge</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>Succ</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>exitCFGBlock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>exitCFG</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>Last</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>insertStmt</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>SMap</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>make_pair</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>getCurrentLVarDefinition</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><name>VD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>addStatement</name><argument_list>(<argument><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><name>E</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><name>VD</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>lookupVarDecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><name>VD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>addVarDecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><name>VD</name></expr></argument>, <argument><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><call><name>updateVarDecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><name>VD</name></expr></argument>, <argument><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>makePhiNodeVar</name><argument_list>(<argument><expr><name>unsigned</name> <name>i</name></expr></argument>, <argument><expr><name>unsigned</name> <name>NPreds</name></expr></argument>, <argument><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>mergeEntryMap</name><parameter_list>(<parameter><decl><type><name>LVarDefinitionMap</name></type> <name>Map</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>mergeEntryMapBackEdge</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>mergePhiNodesBackEdge</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CFGBlock</name> <modifier>*</modifier></type><name>Blk</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name>CapabilityExprMode</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>til</name><operator>::</operator><name>MemRegionRef</name> <name>Arena</name></expr>;</expr_stmt>


<expr_stmt><expr><name>til</name><operator>::</operator><name>Variable</name> <operator>*</operator><name>SelfVar</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>til</name><operator>::</operator><name>SCFG</name> <operator>*</operator><name>Scfg</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>StatementMap</name></type> <name>SMap</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>LVarIndexMap</name></type> <name>LVarIdxMap</name></decl>;</decl_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>til</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>BlockMap</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>BlockInfo</name></expr></argument>&gt;</argument_list></name> <name>BBInfo</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>LVarDefinitionMap</name></type> <name>CurrentLVarMap</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>til</name><operator>::</operator><name>Phi</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CurrentArguments</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>til</name><operator>::</operator><name>SExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CurrentInstructions</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>til</name><operator>::</operator><name>Phi</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>IncompleteArgs</name></expr>;</expr_stmt>
<expr_stmt><expr><name>til</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>CurrentBB</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>BlockInfo</name> <modifier>*</modifier></type><name>CurrentBlockInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<function_decl><type><name>void</name></type> <name>printSCFG</name><parameter_list>(<parameter><decl><type><name>CFGWalker</name> <modifier>&amp;</modifier></type><name>Walker</name></decl></parameter>)</parameter_list>;</function_decl>

}
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
