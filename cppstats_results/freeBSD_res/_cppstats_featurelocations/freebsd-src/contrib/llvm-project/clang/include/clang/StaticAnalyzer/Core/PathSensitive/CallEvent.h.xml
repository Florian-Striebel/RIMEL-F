<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h">













<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_CALLEVENT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_CALLEVENT_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclBase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Stmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/IdentifierTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/ProgramState_Fwd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/SVals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/IntrusiveRefCntPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerIntPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerUnion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/STLExtras.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Allocator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/ErrorHandling.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>LocationContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ProgramPoint</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ProgramPointTag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>StackFrameContext</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>ento</name> <block>{<block_content>

<enum>enum <name>CallEventKind</name> <block>{
<decl><name>CE_Function</name></decl>,
<decl><name>CE_CXXMember</name></decl>,
<decl><name>CE_CXXMemberOperator</name></decl>,
<decl><name>CE_CXXDestructor</name></decl>,
<decl><name>CE_BEG_CXX_INSTANCE_CALLS</name> <init>= <expr><name>CE_CXXMember</name></expr></init></decl>,
<decl><name>CE_END_CXX_INSTANCE_CALLS</name> <init>= <expr><name>CE_CXXDestructor</name></expr></init></decl>,
<decl><name>CE_CXXConstructor</name></decl>,
<decl><name>CE_CXXInheritedConstructor</name></decl>,
<decl><name>CE_BEG_CXX_CONSTRUCTOR_CALLS</name> <init>= <expr><name>CE_CXXConstructor</name></expr></init></decl>,
<decl><name>CE_END_CXX_CONSTRUCTOR_CALLS</name> <init>= <expr><name>CE_CXXInheritedConstructor</name></expr></init></decl>,
<decl><name>CE_CXXAllocator</name></decl>,
<decl><name>CE_CXXDeallocator</name></decl>,
<decl><name>CE_BEG_FUNCTION_CALLS</name> <init>= <expr><name>CE_Function</name></expr></init></decl>,
<decl><name>CE_END_FUNCTION_CALLS</name> <init>= <expr><name>CE_CXXDeallocator</name></expr></init></decl>,
<decl><name>CE_Block</name></decl>,
<decl><name>CE_ObjCMessage</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><name>class</name></type> <name>CallEvent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CallDescription</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name> <operator>=</operator> <name>CallEvent</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>CallEventRef</name> <range>: <expr><name>public</name> <name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>CallEventRef</name><argument_list>(<argument><expr><specifier>const</specifier> <name>T</name> <operator>*</operator><name>Call</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>IntrusiveRefCntPtr</name></macro><operator>&lt;</operator><specifier>const</specifier> <name>T</name><operator>&gt;</operator><operator>(</operator><name>Call</name><operator>)</operator> <block>{}</block>
<call><name>CallEventRef</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CallEventRef</name> <operator>&amp;</operator><name>Orig</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>IntrusiveRefCntPtr</name></macro><operator>&lt;</operator><specifier>const</specifier> <name>T</name><operator>&gt;</operator><operator>(</operator><name>Orig</name><operator>)</operator> <block>{}</block>

<name><name>CallEventRef</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>cloneWithState</name><argument_list>(<argument>ProgramStateRef State</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>get</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>template</name> <call><name><name>cloneWithState</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>State</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>SuperT</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>CallEventRef</name></macro><operator>&lt;</operator><name>SuperT</name><operator>&gt;</operator> <operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>RuntimeDefinition</name> <block>{


<expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name> <operator>=</operator> <name>nullptr</name></expr>;





<expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><name>R</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>RuntimeDefinition</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><call><name>RuntimeDefinition</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>InD</name></expr></argument>)</argument_list></call><operator>:</operator> <macro><name>D</name><argument_list>(<argument>InD</argument>)</argument_list></macro> <block>{}</block>
<call><name>RuntimeDefinition</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>InD</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><name>InR</name></expr></argument>)</argument_list></call><operator>:</operator> <call><name>D</name><argument_list>(<argument><expr><name>InD</name></expr></argument>)</argument_list></call></expr>, <macro><name>R</name><argument_list>(<argument>InR</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>D</name></expr>;</return> }</block>




<name>bool</name> <macro><name>mayHaveOtherDefinitions</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>R</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block>



<specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><macro><name>getDispatchRegion</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>R</name></expr>;</return> }</block>
}</expr>;










<expr><name>class</name> <name>CallEvent</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>using</name> <name>Kind</name> <operator>=</operator> <name>CallEventKind</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>ProgramStateRef</name> <name>State</name></expr>;
<expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LCtx</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Origin</name></expr>;

<expr><name>protected</name><operator>:</operator>

<specifier>const</specifier> <name>void</name> <operator>*</operator><name>Data</name></expr>;




<expr><name>SourceLocation</name> <name>Location</name></expr>;

<expr><name>private</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>friend</name> struct <name>llvm</name><operator>::</operator><name>IntrusiveRefCntPtrInfo</name></expr>;

<expr><name>mutable</name> <name>unsigned</name> <name>RefCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>void</name> <macro><name>Retain</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <expr><operator>++</operator><name>RefCount</name></expr>; }</block>
<name>void</name> <macro><name>Release</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>protected</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CallEventManager</name></expr>;

<macro><name>CallEvent</name><argument_list>(<argument>const Expr *E</argument>, <argument>ProgramStateRef state</argument>, <argument>const LocationContext *lctx</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>State</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>, <expr><call><name>LCtx</name><argument_list>(<argument><expr><name>lctx</name></expr></argument>)</argument_list></call></expr>, <macro><name>Origin</name><argument_list>(<argument>E</argument>)</argument_list></macro> <expr><block>{}</block>

<macro><name>CallEvent</name><argument_list>(<argument>const Decl *D</argument>, <argument>ProgramStateRef state</argument>, <argument>const LocationContext *lctx</argument>)</argument_list></macro>
<operator>:</operator> <call><name>State</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>, <expr><call><name>LCtx</name><argument_list>(<argument><expr><name>lctx</name></expr></argument>)</argument_list></call></expr>, <macro><name>Origin</name><argument_list>(<argument>D</argument>)</argument_list></macro> <expr><block>{}</block>


<call><name>CallEvent</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CallEvent</name> <operator>&amp;</operator><name>Original</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>State</name><argument_list>(<argument><expr><name><name>Original</name><operator>.</operator><name>State</name></name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LCtx</name><argument_list>(<argument><expr><name><name>Original</name><operator>.</operator><name>LCtx</name></name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Origin</name><argument_list>(<argument><expr><name><name>Original</name><operator>.</operator><name>Origin</name></name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Data</name><argument_list>(<argument><expr><name><name>Original</name><operator>.</operator><name>Data</name></name></expr></argument>)</argument_list></call></expr>, <macro><name>Location</name><argument_list>(<argument>Original.Location</argument>)</argument_list></macro> <expr><block>{}</block>


<name>virtual</name> <name>void</name> <macro><name>cloneTo</name><argument_list>(<argument>void *Dest</argument>)</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;


<expr><name>SVal</name> <macro><name>getSVal</name><argument_list>(<argument>const Stmt *S</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getState</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getSVal</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><call><name>getLocationContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>ValueList</name> <operator>=</operator> <name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>SVal</name></expr></argument>&gt;</argument_list></name></expr>;



<expr><name>virtual</name> <name>void</name> <macro><name>getExtraInvalidatedValues</name><argument_list>(<argument>ValueList &amp;Values</argument>,
<argument>RegionAndSymbolInvalidationTraits *ETraits</argument>)</argument_list></macro> <specifier>const</specifier> <block>{}</block>

<name>public</name><operator>:</operator>
<name>CallEvent</name> <operator>&amp;</operator><name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>CallEvent</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr>;
<expr><name>virtual</name> <operator>~</operator><call><name>CallEvent</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;


<expr><name>virtual</name> <name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>virtual</name> <name>StringRef</name> <macro><name>getKindAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name>virtual</name> <specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Origin</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><specifier>const</specifier> <name>Decl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>


<specifier>const</specifier> <name>ProgramStateRef</name> <operator>&amp;</operator><macro><name>getState</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>State</name></expr>;</return>
}</block>


<specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><macro><name>getLocationContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>LCtx</name></expr>;</return>
}</block>



<name>virtual</name> <name>RuntimeDefinition</name> <macro><name>getRuntimeDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name>virtual</name> <specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getOriginExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Origin</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><specifier>const</specifier> <name>Expr</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>






<name>virtual</name> <name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;


<expr><name>bool</name> <macro><name>isInSystemHeader</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name> <operator>=</operator> <call><name>getDecl</name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>D</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<name>SourceLocation</name> <name>Loc</name> <operator>=</operator> <call><name><name>D</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></block></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Loc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>SourceManager</name> <modifier>&amp;</modifier></type><name>SM</name> <init>=
<expr><call><name>getState</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getStateManager</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getContext</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSourceManager</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>SM</name><operator>.</operator><name>isInSystemHeader</name></name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>



if (const auto *FD = dyn_cast&lt;FunctionDecl&gt;(D</block></if></if_stmt>))</block></expr>
<return>return <expr><call><name><name>FD</name><operator>-&gt;</operator><name>isOverloadedOperator</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>FD</name><operator>-&gt;</operator><name>isImplicit</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>FD</name><operator>-&gt;</operator><name>isGlobal</name></name><argument_list>()</argument_list></call></expr>;</return></block></expr>

<return>return <expr><name>false</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>






<decl_stmt><decl><type><name>bool</name></type> <name>isCalled</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CallDescription</name> <operator>&amp;</operator><name>CD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>FirstCallDesc</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>CallDescs</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>isCalled</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FirstCallDesc</name> <operator>&amp;</operator><name>First</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CallDescs</name> <operator>&amp;</operator><operator>...</operator> <name>Rest</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>isCalled</name><argument_list>(<argument><expr><name>First</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isCalled</name><argument_list>(<argument><expr><name>Rest</name><operator>...</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name>virtual</name> <name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getSourceRange</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>SVal</name></type> <name>getArgSVal</name><argument_list>(<argument><expr><name>unsigned</name> <name>Index</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>virtual</name> <specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>getArgExpr</name><argument_list>(<argument><expr><name>unsigned</name> <name>Index</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><name>nullptr</name></expr>;</return> </block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name>virtual</name> <name>SourceRange</name></type> <name>getArgSourceRange</name><argument_list>(<argument><expr><name>unsigned</name> <name>Index</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>QualType</name> <macro><name>getResultType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>





<expr_stmt><expr><name>SVal</name> <macro><name>getReturnValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>hasNonNullArgumentsWithType</name><argument_list>(<argument><expr><call><call><name>bool</name> <argument_list>(<argument><expr><operator>*</operator><name>Condition</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>QualType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasNonZeroCallbackArg</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasVoidPointerToNonConstArg</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>






<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>argumentsMayEscape</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasNonZeroCallbackArg</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

















<decl_stmt><decl><type><name>bool</name></type> <name>isGlobalCFunction</name><argument_list>(<argument><expr><name>StringRef</name> <name>SpecificName</name> <operator>=</operator> <call><name>StringRef</name><argument_list>()</argument_list></call></expr></argument>)</argument_list> const</decl>;</decl_stmt>








<expr_stmt><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><macro><name>getCalleeIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>auto</name> <operator>*</operator><name>ND</name> <operator>=</operator> <call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ND</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name><name>ND</name><operator>-&gt;</operator><name>getIdentifier</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>ProgramPoint</name></type> <name>getProgramPoint</name><argument_list>(<argument><expr><name>bool</name> <name>IsPreVisit</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><name>Tag</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>ProgramStateRef</name></type> <name>invalidateRegions</name><argument_list>(<argument><expr><name>unsigned</name> <name>BlockCount</name></expr></argument>,
<argument><expr><name>ProgramStateRef</name> <name>Orig</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>FrameBindingTy</name> <init>= <expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>SVal</name></expr></argument>, <argument><expr><name>SVal</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>BindingsTy</name> <init>= <expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>FrameBindingTy</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>getInitialStackFrameContents</name><argument_list>(<argument><expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><name>CalleeCtx</name></expr></argument>,
<argument><expr><name>BindingsTy</name> <operator>&amp;</operator><name>Bindings</name></expr></argument>)</argument_list> const <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>CallEventRef</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>cloneWithState</name><argument_list>(<argument><expr><name>ProgramStateRef</name> <name>NewState</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>CallEventRef</name><argument_list type="generic">&lt;&gt;</argument_list></name></type> <name>cloneWithState</name><argument_list>(<argument><expr><name>ProgramStateRef</name> <name>NewState</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>cloneWithState</name><argument_list type="generic">&lt;<argument><expr><name>CallEvent</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>NewState</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isCallStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><specifier>static</specifier> <name>QualType</name></type> <name>getDeclaredResultType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isVariadic</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>AnalysisDeclContext</name> <operator>*</operator><macro><name>getCalleeAnalysisDeclContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>





<decl_stmt><decl><type><specifier>const</specifier> <name>StackFrameContext</name> <modifier>*</modifier></type><name>getCalleeStackFrame</name><argument_list>(<argument><expr><name>unsigned</name> <name>BlockCount</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<decl_stmt><decl><type><specifier>const</specifier> <name>ParamVarRegion</name> <modifier>*</modifier></type><name>getParameterLocation</name><argument_list>(<argument><expr><name>unsigned</name> <name>Index</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>BlockCount</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>







<decl_stmt><decl><type><name>bool</name></type> <name>isArgumentConstructedDirectly</name><argument_list>(<argument><expr><name>unsigned</name> <name>Index</name></expr></argument>)</argument_list> const <block>{<block_content>

<return>return <expr><name>ExprEngine</name><operator>::</operator><macro><name>getObjectUnderConstruction</name><argument_list>(
<argument>getState()</argument>, <argument>{getOriginExpr()</argument>, <argument>Index}</argument>, <argument>getLocationContext()</argument>)</argument_list></macro><operator>.</operator><call><name>hasValue</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<decl_stmt><decl><type><name>virtual</name> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type>
<name>getAdjustedParameterIndex</name><argument_list>(<argument><expr><name>unsigned</name> <name>ASTArgumentIndex</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>ASTArgumentIndex</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name>virtual</name> <name>unsigned</name></type> <name>getASTArgumentIndex</name><argument_list>(<argument><expr><name>unsigned</name> <name>CallArgumentIndex</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>CallArgumentIndex</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<expr_stmt><expr><specifier>const</specifier> <name>ConstructionContext</name> <operator>*</operator><macro><name>getConstructionContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>SVal</name></expr></argument>&gt;</argument_list></name> <macro><name>getReturnValueUnderConstruction</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<label><name>private</name>:</label>
<struct>struct <name>GetTypeFn</name> <block>{
<expr_stmt><expr><name>QualType</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><name>ParmVarDecl</name> <operator>*</operator><name>PD</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>PD</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
}</block>;</struct>

<label><name>public</name>:</label>





<expr_stmt><expr><name>virtual</name> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>parameters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>param_type_iterator</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>mapped_iterator</name><argument_list type="generic">&lt;<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr></argument>, <argument><expr><name>GetTypeFn</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>






<expr_stmt><expr><name>param_type_iterator</name> <macro><name>param_type_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>map_iterator</name><argument_list>(<argument><expr><call><name>parameters</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>GetTypeFn</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>param_type_iterator</name> <macro><name>param_type_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>map_iterator</name><argument_list>(<argument><expr><call><name>parameters</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>GetTypeFn</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>dump</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>Out</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<expr_stmt><expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>AnyFunctionCall</name> <range>: <expr><name>public</name> <name>CallEvent</name> <block>{
<expr><name>protected</name><operator>:</operator>
<macro><name>AnyFunctionCall</name><argument_list>(<argument>const Expr *E</argument>, <argument>ProgramStateRef St</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CallEvent</name><argument_list>(<argument>E</argument>, <argument>St</argument>, <argument>LCtx</argument>)</argument_list></macro> <block>{}</block>
<macro><name>AnyFunctionCall</name><argument_list>(<argument>const Decl *D</argument>, <argument>ProgramStateRef St</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CallEvent</name><argument_list>(<argument>D</argument>, <argument>St</argument>, <argument>LCtx</argument>)</argument_list></macro> <block>{}</block>
<call><name>AnyFunctionCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>AnyFunctionCall</name> <operator>&amp;</operator><name>Other</name></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>public</name><operator>:</operator>


<specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CallEvent</name><operator>::</operator><call><name>getDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>RuntimeDefinition</name> <macro><name>getRuntimeDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>bool</name> <macro><name>argumentsMayEscape</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>getInitialStackFrameContents</name><argument_list>(<argument>const StackFrameContext *CalleeCtx</argument>,
<argument>BindingsTy &amp;Bindings</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>parameters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const CallEvent *CA</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>CA</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>CE_BEG_FUNCTION_CALLS</name> <operator>&amp;&amp;</operator>
<call><name><name>CA</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>CE_END_FUNCTION_CALLS</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>SimpleFunctionCall</name> <operator>:</operator> <name>public</name> <name>AnyFunctionCall</name> <block>{
<expr><name>friend</name> <name>class</name> <name>CallEventManager</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>SimpleFunctionCall</name><argument_list>(<argument>const CallExpr *CE</argument>, <argument>ProgramStateRef St</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>AnyFunctionCall</name><argument_list>(<argument>CE</argument>, <argument>St</argument>, <argument>LCtx</argument>)</argument_list></macro> <block>{}</block>
<call><name>SimpleFunctionCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>SimpleFunctionCall</name> <operator>&amp;</operator><name>Other</name></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>void</name> <macro><name>cloneTo</name><argument_list>(<argument>void *Dest</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<macro><name>new</name> <argument_list>(<argument>Dest</argument>)</argument_list></macro> <expr><call><name>SimpleFunctionCall</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>CallExpr</name> <operator>*</operator><macro><name>getOriginExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CallExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>AnyFunctionCall</name><operator>::</operator><call><name>getOriginExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNumArgs</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getArgExpr</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getArg</name><argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>CE_Function</name></expr>;</return> }</block>
<name>StringRef</name> <macro><name>getKindAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><literal type="string">"SimpleFunctionCall"</literal></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const CallEvent *CA</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>CA</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CE_Function</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>BlockCall</name> <operator>:</operator> <name>public</name> <name>CallEvent</name> <block>{
<expr><name>friend</name> <name>class</name> <name>CallEventManager</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>BlockCall</name><argument_list>(<argument>const CallExpr *CE</argument>, <argument>ProgramStateRef St</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CallEvent</name><argument_list>(<argument>CE</argument>, <argument>St</argument>, <argument>LCtx</argument>)</argument_list></macro> <block>{}</block>
<call><name>BlockCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>BlockCall</name> <operator>&amp;</operator><name>Other</name></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>void</name> <macro><name>cloneTo</name><argument_list>(<argument>void *Dest</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <macro><name>new</name> <argument_list>(<argument>Dest</argument>)</argument_list></macro> <expr><call><name>BlockCall</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>void</name> <macro><name>getExtraInvalidatedValues</name><argument_list>(<argument>ValueList &amp;Values</argument>,
<argument>RegionAndSymbolInvalidationTraits *ETraits</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>const</specifier> <name>CallExpr</name> <operator>*</operator><macro><name>getOriginExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CallExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CallEvent</name><operator>::</operator><call><name>getOriginExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNumArgs</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getArgExpr</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getArg</name><argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<specifier>const</specifier> <name>BlockDataRegion</name> <operator>*</operator><macro><name>getBlockRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>const</specifier> <name>BlockDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<expr><specifier>const</specifier> <name>BlockDataRegion</name> <operator>*</operator><name>BR</name> <operator>=</operator> <call><name>getBlockRegion</name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>BR</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>BR</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isConversionFromLambda</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>BlockDecl</name> <operator>*</operator><name>BD</name> <operator>=</operator> <call><name>getDecl</name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>BD</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name><name>BD</name><operator>-&gt;</operator><name>isConversionFromLambda</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<specifier>const</specifier> <name>VarRegion</name> <operator>*</operator><macro><name>getRegionStoringCapturedLambda</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isConversionFromLambda</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>BlockDataRegion</name> <operator>*</operator><name>BR</name> <operator>=</operator> <call><name>getBlockRegion</name><argument_list>()</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>BR</name> <operator>&amp;&amp;</operator> <literal type="string">"Block converted from lambda must have a block region"</literal></expr></argument>)</argument_list></call></expr>;

<expr><name>auto</name> <name>I</name> <operator>=</operator> <call><name><name>BR</name><operator>-&gt;</operator><name>referenced_vars_begin</name></name><argument_list>()</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>!=</operator> <call><name><name>BR</name><operator>-&gt;</operator><name>referenced_vars_end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;

<return>return <expr><call><name><name>I</name><operator>.</operator><name>getCapturedRegion</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>RuntimeDefinition</name> <macro><name>getRuntimeDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isConversionFromLambda</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>RuntimeDefinition</name><argument_list>(<argument><expr><call><name>getDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>




















<specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>LambdaVD</name> <operator>=</operator> <call><name>getRegionStoringCapturedLambda</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getDecl</name><argument_list>()</argument_list></call></block></expr>;
<expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>LambdaDecl</name> <operator>=</operator> <call><name><name>LambdaVD</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getAsCXXRecordDecl</name><argument_list>()</argument_list></call></expr>;
<expr><name>CXXMethodDecl</name><operator>*</operator> <name>LambdaCallOperator</name> <operator>=</operator> <call><name><name>LambdaDecl</name><operator>-&gt;</operator><name>getLambdaCallOperator</name></name><argument_list>()</argument_list></call></expr>;

<return>return <expr><call><name>RuntimeDefinition</name><argument_list>(<argument><expr><name>LambdaCallOperator</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>argumentsMayEscape</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>getInitialStackFrameContents</name><argument_list>(<argument><expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><name>CalleeCtx</name></expr></argument>,
<argument><expr><name>BindingsTy</name> <operator>&amp;</operator><name>Bindings</name></expr></argument>)</argument_list> const <name>override</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>parameters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;</expr_stmt>

<expr_stmt><expr><name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>CE_Block</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>StringRef</name> <macro><name>getKindAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><literal type="string">"BlockCall"</literal></expr>;</return> }</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallEvent</name> <modifier>*</modifier></type><name>CA</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>CA</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CE_Block</name></expr>;</return> </block_content>}</block></function>
};



<decl_stmt><decl><type><name>class</name></type> <name>CXXInstanceCall</name> <range>: <expr><name>public</name> <name>AnyFunctionCall</name> <block>{
<expr><name>protected</name><operator>:</operator>
<macro><name>CXXInstanceCall</name><argument_list>(<argument>const CallExpr *CE</argument>, <argument>ProgramStateRef St</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>AnyFunctionCall</name><argument_list>(<argument>CE</argument>, <argument>St</argument>, <argument>LCtx</argument>)</argument_list></macro> <block>{}</block>
<macro><name>CXXInstanceCall</name><argument_list>(<argument>const FunctionDecl *D</argument>, <argument>ProgramStateRef St</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>AnyFunctionCall</name><argument_list>(<argument>D</argument>, <argument>St</argument>, <argument>LCtx</argument>)</argument_list></macro> <block>{}</block>
<call><name>CXXInstanceCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXInstanceCall</name> <operator>&amp;</operator><name>Other</name></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>void</name> <macro><name>getExtraInvalidatedValues</name><argument_list>(<argument>ValueList &amp;Values</argument>,
<argument>RegionAndSymbolInvalidationTraits *ETraits</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>

<name>virtual</name> <specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getCXXThisExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block>


<name>virtual</name> <name>SVal</name> <macro><name>getCXXThisVal</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>RuntimeDefinition</name> <macro><name>getRuntimeDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>getInitialStackFrameContents</name><argument_list>(<argument>const StackFrameContext *CalleeCtx</argument>,
<argument>BindingsTy &amp;Bindings</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const CallEvent *CA</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>CA</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>CE_BEG_CXX_INSTANCE_CALLS</name> <operator>&amp;&amp;</operator>
<call><name><name>CA</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>CE_END_CXX_INSTANCE_CALLS</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>CXXMemberCall</name> <operator>:</operator> <name>public</name> <name>CXXInstanceCall</name> <block>{
<expr><name>friend</name> <name>class</name> <name>CallEventManager</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>CXXMemberCall</name><argument_list>(<argument>const CXXMemberCallExpr *CE</argument>, <argument>ProgramStateRef St</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CXXInstanceCall</name><argument_list>(<argument>CE</argument>, <argument>St</argument>, <argument>LCtx</argument>)</argument_list></macro> <block>{}</block>
<call><name>CXXMemberCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXMemberCall</name> <operator>&amp;</operator><name>Other</name></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>void</name> <macro><name>cloneTo</name><argument_list>(<argument>void *Dest</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <macro><name>new</name> <argument_list>(<argument>Dest</argument>)</argument_list></macro> <expr><call><name>CXXMemberCall</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>CXXMemberCallExpr</name> <operator>*</operator><macro><name>getOriginExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXMemberCallExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CXXInstanceCall</name><operator>::</operator><call><name>getOriginExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>CE</name> <init>= <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>CE</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><literal type="number">0</literal></expr>;</return>
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getArgExpr</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getArg</name><argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getCXXThisExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>RuntimeDefinition</name> <macro><name>getRuntimeDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>CE_CXXMember</name></expr>;</return> }</block>
<name>StringRef</name> <macro><name>getKindAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><literal type="string">"CXXMemberCall"</literal></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const CallEvent *CA</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>CA</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CE_CXXMember</name></expr>;</return>
}</block>
}</expr>;





<expr><name>class</name> <name>CXXMemberOperatorCall</name> <operator>:</operator> <name>public</name> <name>CXXInstanceCall</name> <block>{
<expr><name>friend</name> <name>class</name> <name>CallEventManager</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>CXXMemberOperatorCall</name><argument_list>(<argument>const CXXOperatorCallExpr *CE</argument>, <argument>ProgramStateRef St</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CXXInstanceCall</name><argument_list>(<argument>CE</argument>, <argument>St</argument>, <argument>LCtx</argument>)</argument_list></macro> <block>{}</block>
<call><name>CXXMemberOperatorCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXMemberOperatorCall</name> <operator>&amp;</operator><name>Other</name></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>void</name> <macro><name>cloneTo</name><argument_list>(<argument>void *Dest</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<macro><name>new</name> <argument_list>(<argument>Dest</argument>)</argument_list></macro> <expr><call><name>CXXMemberOperatorCall</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>CXXOperatorCallExpr</name> <operator>*</operator><macro><name>getOriginExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXOperatorCallExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CXXInstanceCall</name><operator>::</operator><call><name>getOriginExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getArgExpr</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getArg</name><argument_list>(<argument><expr><name>Index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getCXXThisExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>CE_CXXMemberOperator</name></expr>;</return> }</block>
<name>StringRef</name> <macro><name>getKindAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><literal type="string">"CXXMemberOperatorCall"</literal></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const CallEvent *CA</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>CA</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CE_CXXMemberOperator</name></expr>;</return>
}</block>

<name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name>
<macro><name>getAdjustedParameterIndex</name><argument_list>(<argument>unsigned ASTArgumentIndex</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{


<return>return <expr><operator>(</operator><name>ASTArgumentIndex</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>?</operator> <call><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ASTArgumentIndex</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call>
<operator>:</operator> <name>None</name></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getASTArgumentIndex</name><argument_list>(<argument>unsigned CallArgumentIndex</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{


<return>return <expr><name>CallArgumentIndex</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
}</block>

<name>OverloadedOperatorKind</name> <macro><name>getOverloadedOperator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getOperator</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;





<expr><name>class</name> <name>CXXDestructorCall</name> <operator>:</operator> <name>public</name> <name>CXXInstanceCall</name> <block>{
<expr><name>friend</name> <name>class</name> <name>CallEventManager</name></expr>;

<expr><name>protected</name><operator>:</operator>
<name>using</name> <name>DtorDataTy</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></expr>;








<macro><name>CXXDestructorCall</name><argument_list>(<argument>const CXXDestructorDecl *DD</argument>, <argument>const Stmt *Trigger</argument>,
<argument>const MemRegion *Target</argument>, <argument>bool IsBaseDestructor</argument>,
<argument>ProgramStateRef St</argument>, <argument>const LocationContext *LCtx</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CXXInstanceCall</name><argument_list>(<argument>DD</argument>, <argument>St</argument>, <argument>LCtx</argument>)</argument_list></macro> <expr><block>{
<expr><name>Data</name> <operator>=</operator> <call><name>DtorDataTy</name><argument_list>(<argument><expr><name>Target</name></expr></argument>, <argument><expr><name>IsBaseDestructor</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getOpaqueValue</name><argument_list>()</argument_list></call></expr>;
<expr><name>Location</name> <operator>=</operator> <call><name><name>Trigger</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;
}</block>

<call><name>CXXDestructorCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXDestructorCall</name> <operator>&amp;</operator><name>Other</name></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>void</name> <macro><name>cloneTo</name><argument_list>(<argument>void *Dest</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{<macro><name>new</name> <argument_list>(<argument>Dest</argument>)</argument_list></macro> <expr><call><name>CXXDestructorCall</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;}</block>

<name>public</name><operator>:</operator>
<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>Location</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><literal type="number">0</literal></expr>;</return> }</block>

<name>RuntimeDefinition</name> <macro><name>getRuntimeDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;


<expr><name>SVal</name> <macro><name>getCXXThisVal</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;


<expr><name>bool</name> <macro><name>isBaseDestructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>DtorDataTy</name><operator>::</operator><call><name>getFromOpaqueValue</name><argument_list>(<argument><expr><name>Data</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getInt</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>CE_CXXDestructor</name></expr>;</return> }</block>
<name>StringRef</name> <macro><name>getKindAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><literal type="string">"CXXDestructorCall"</literal></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const CallEvent *CA</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>CA</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CE_CXXDestructor</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>AnyCXXConstructorCall</name> <operator>:</operator> <name>public</name> <name>AnyFunctionCall</name> <block>{
<expr><name>protected</name><operator>:</operator>
<macro><name>AnyCXXConstructorCall</name><argument_list>(<argument>const Expr *E</argument>, <argument>const MemRegion *Target</argument>,
<argument>ProgramStateRef St</argument>, <argument>const LocationContext *LCtx</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>AnyFunctionCall</name><argument_list>(<argument>E</argument>, <argument>St</argument>, <argument>LCtx</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>E</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>CXXInheritedCtorInitExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;

<expr><name>Data</name> <operator>=</operator> <name>Target</name></expr>;
}</block>

<name>void</name> <macro><name>getExtraInvalidatedValues</name><argument_list>(<argument>ValueList &amp;Values</argument>,
<argument>RegionAndSymbolInvalidationTraits *ETraits</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>getInitialStackFrameContents</name><argument_list>(<argument>const StackFrameContext *CalleeCtx</argument>,
<argument>BindingsTy &amp;Bindings</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>

<name>SVal</name> <macro><name>getCXXThisVal</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const CallEvent *Call</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Call</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>CE_BEG_CXX_CONSTRUCTOR_CALLS</name> <operator>&amp;&amp;</operator>
<call><name><name>Call</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>CE_END_CXX_CONSTRUCTOR_CALLS</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>CXXConstructorCall</name> <operator>:</operator> <name>public</name> <name>AnyCXXConstructorCall</name> <block>{
<expr><name>friend</name> <name>class</name> <name>CallEventManager</name></expr>;

<expr><name>protected</name><operator>:</operator>







<macro><name>CXXConstructorCall</name><argument_list>(<argument>const CXXConstructExpr *CE</argument>, <argument>const MemRegion *Target</argument>,
<argument>ProgramStateRef St</argument>, <argument>const LocationContext *LCtx</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>AnyCXXConstructorCall</name><argument_list>(<argument>CE</argument>, <argument>Target</argument>, <argument>St</argument>, <argument>LCtx</argument>)</argument_list></macro> <block>{}</block>

<call><name>CXXConstructorCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXConstructorCall</name> <operator>&amp;</operator><name>Other</name></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>void</name> <macro><name>cloneTo</name><argument_list>(<argument>void *Dest</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <macro><name>new</name> <argument_list>(<argument>Dest</argument>)</argument_list></macro> <expr><call><name>CXXConstructorCall</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>CXXConstructExpr</name> <operator>*</operator><macro><name>getOriginExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>AnyFunctionCall</name><operator>::</operator><call><name>getOriginExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>CXXConstructorDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getConstructor</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNumArgs</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getArgExpr</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getArg</name><argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>CE_CXXConstructor</name></expr>;</return> }</block>
<name>StringRef</name> <macro><name>getKindAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><literal type="string">"CXXConstructorCall"</literal></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const CallEvent *CA</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>CA</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CE_CXXConstructor</name></expr>;</return>
}</block>
}</expr>;





















<expr><name>class</name> <name>CXXInheritedConstructorCall</name> <operator>:</operator> <name>public</name> <name>AnyCXXConstructorCall</name> <block>{
<expr><name>friend</name> <name>class</name> <name>CallEventManager</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>CXXInheritedConstructorCall</name><argument_list>(<argument>const CXXInheritedCtorInitExpr *CE</argument>,
<argument>const MemRegion *Target</argument>, <argument>ProgramStateRef St</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>AnyCXXConstructorCall</name><argument_list>(<argument>CE</argument>, <argument>Target</argument>, <argument>St</argument>, <argument>LCtx</argument>)</argument_list></macro> <block>{}</block>

<call><name>CXXInheritedConstructorCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXInheritedConstructorCall</name> <operator>&amp;</operator><name>Other</name></expr></argument>)</argument_list></call> <operator>=</operator>
default</expr>;

<expr><name>void</name> <macro><name>cloneTo</name><argument_list>(<argument>void *Dest</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<macro><name>new</name> <argument_list>(<argument>Dest</argument>)</argument_list></macro> <expr><call><name>CXXInheritedConstructorCall</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>CXXInheritedCtorInitExpr</name> <operator>*</operator><macro><name>getOriginExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXInheritedCtorInitExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>AnyFunctionCall</name><operator>::</operator><call><name>getOriginExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>CXXConstructorDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getConstructor</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><macro><name>getInheritingStackFrame</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><specifier>const</specifier> <name>CXXConstructExpr</name> <operator>*</operator><macro><name>getInheritingConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getInheritingStackFrame</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getCallSite</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getInheritingConstructor</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNumArgs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getArgExpr</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getInheritingConstructor</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getArg</name><argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SVal</name> <macro><name>getArgSVal</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getState</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getSVal</name><argument_list>(
<argument><expr><call><name>getArgExpr</name><argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>getInheritingStackFrame</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getParent</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getStackFrame</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>CE_CXXInheritedConstructor</name></expr>;</return> }</block>
<name>StringRef</name> <macro><name>getKindAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><literal type="string">"CXXInheritedConstructorCall"</literal></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const CallEvent *CA</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>CA</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CE_CXXInheritedConstructor</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>CXXAllocatorCall</name> <operator>:</operator> <name>public</name> <name>AnyFunctionCall</name> <block>{
<expr><name>friend</name> <name>class</name> <name>CallEventManager</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>CXXAllocatorCall</name><argument_list>(<argument>const CXXNewExpr *E</argument>, <argument>ProgramStateRef St</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>AnyFunctionCall</name><argument_list>(<argument>E</argument>, <argument>St</argument>, <argument>LCtx</argument>)</argument_list></macro> <block>{}</block>
<call><name>CXXAllocatorCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXAllocatorCall</name> <operator>&amp;</operator><name>Other</name></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>void</name> <macro><name>cloneTo</name><argument_list>(<argument>void *Dest</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <macro><name>new</name> <argument_list>(<argument>Dest</argument>)</argument_list></macro> <expr><call><name>CXXAllocatorCall</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>CXXNewExpr</name> <operator>*</operator><macro><name>getOriginExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXNewExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>AnyFunctionCall</name><operator>::</operator><call><name>getOriginExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getOperatorNew</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SVal</name> <macro><name>getObjectUnderConstruction</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ExprEngine</name><operator>::</operator><call><name>getObjectUnderConstruction</name><argument_list>(<argument><expr><call><name>getState</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getLocationContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>getValue</name><argument_list>()</argument_list></call></expr>;</return>
}</block>




<name>unsigned</name> <macro><name>getNumImplicitArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>passAlignment</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNumPlacementArgs</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumImplicitArgs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getArgExpr</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{

<if_stmt><if>if <condition>(<expr><name>Index</name> <operator>&lt;</operator> <call><name>getNumImplicitArgs</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getPlacementArg</name><argument_list>(<argument><expr><name>Index</name> <operator>-</operator> <call><name>getNumImplicitArgs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getPlacementArgExpr</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getPlacementArg</name><argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>CE_CXXAllocator</name></expr>;</return> }</block>
<name>StringRef</name> <macro><name>getKindAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><literal type="string">"CXXAllocatorCall"</literal></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const CallEvent *CE</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>CE</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CE_CXXAllocator</name></expr>;</return>
}</block>
}</expr>;











<expr><name>class</name> <name>CXXDeallocatorCall</name> <operator>:</operator> <name>public</name> <name>AnyFunctionCall</name> <block>{
<expr><name>friend</name> <name>class</name> <name>CallEventManager</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>CXXDeallocatorCall</name><argument_list>(<argument>const CXXDeleteExpr *E</argument>, <argument>ProgramStateRef St</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>AnyFunctionCall</name><argument_list>(<argument>E</argument>, <argument>St</argument>, <argument>LCtx</argument>)</argument_list></macro> <block>{}</block>
<call><name>CXXDeallocatorCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXDeallocatorCall</name> <operator>&amp;</operator><name>Other</name></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>void</name> <macro><name>cloneTo</name><argument_list>(<argument>void *Dest</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<macro><name>new</name> <argument_list>(<argument>Dest</argument>)</argument_list></macro> <expr><call><name>CXXDeallocatorCall</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>CXXDeleteExpr</name> <operator>*</operator><macro><name>getOriginExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXDeleteExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>AnyFunctionCall</name><operator>::</operator><call><name>getOriginExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getOperatorDelete</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><call><name>getDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNumParams</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getArgExpr</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{

<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getArgument</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>CE_CXXDeallocator</name></expr>;</return> }</block>
<name>StringRef</name> <macro><name>getKindAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><literal type="string">"CXXDeallocatorCall"</literal></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const CallEvent *CE</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>CE</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CE_CXXDeallocator</name></expr>;</return>
}</block>
}</expr>;





enum <expr><name>ObjCMessageKind</name> <block>{
<expr><name>OCM_PropertyAccess</name></expr>,
<expr><name>OCM_Subscript</name></expr>,
<expr><name>OCM_Message</name></expr>
}</block></expr>;




<expr><name>class</name> <name>ObjCMethodCall</name> <operator>:</operator> <name>public</name> <name>CallEvent</name> <block>{
<expr><name>friend</name> <name>class</name> <name>CallEventManager</name></expr>;

<expr><specifier>const</specifier> <name>PseudoObjectExpr</name> <operator>*</operator><macro><name>getContainingPseudoObjectExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>ObjCMethodCall</name><argument_list>(<argument>const ObjCMessageExpr *Msg</argument>, <argument>ProgramStateRef St</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CallEvent</name><argument_list>(<argument>Msg</argument>, <argument>St</argument>, <argument>LCtx</argument>)</argument_list></macro> <block>{
<expr><name>Data</name> <operator>=</operator> <name>nullptr</name></expr>;
}</block>

<call><name>ObjCMethodCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCMethodCall</name> <operator>&amp;</operator><name>Other</name></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>void</name> <macro><name>cloneTo</name><argument_list>(<argument>void *Dest</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <macro><name>new</name> <argument_list>(<argument>Dest</argument>)</argument_list></macro> <expr><call><name>ObjCMethodCall</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>void</name> <macro><name>getExtraInvalidatedValues</name><argument_list>(<argument>ValueList &amp;Values</argument>,
<argument>RegionAndSymbolInvalidationTraits *ETraits</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;


<expr><name>virtual</name> <name>bool</name> <macro><name>canBeOverridenInSubclass</name><argument_list>(<argument>ObjCInterfaceDecl *IDecl</argument>,
<argument>Selector Sel</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>const</specifier> <name>ObjCMessageExpr</name> <operator>*</operator><macro><name>getOriginExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMessageExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CallEvent</name><operator>::</operator><call><name>getOriginExpr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>ObjCMethodDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getMethodDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNumArgs</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getArgExpr</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getArg</name><argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isInstanceMessage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isInstanceMessage</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ObjCMethodFamily</name> <macro><name>getMethodFamily</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getMethodFamily</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>Selector</name> <macro><name>getSelector</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getSelector</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;


<expr><name>SVal</name> <macro><name>getReceiverSVal</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;





<expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getReceiverInterface</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getOriginExpr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getReceiverInterface</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>isReceiverSelfOrSuper</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>ObjCMessageKind</name> <macro><name>getMessageKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>bool</name> <macro><name>isSetter</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<switch>switch <condition>(<expr><call><name>getMessageKind</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OCM_Message</name></expr>:</case>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"This is not a pseudo-object access!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><name>OCM_PropertyAccess</name></expr>:</case>
<return>return <expr><call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
<case>case <expr><name>OCM_Subscript</name></expr>:</case>
<return>return <expr><call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</return>
<expr_stmt/>}</block_content>
llvm_unreachable("Unknown message kind"</block></switch>)</block></expr>;
}</block>




<specifier>const</specifier> <name>ObjCPropertyDecl</name> <operator>*</operator><macro><name>getAccessedProperty</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>RuntimeDefinition</name> <macro><name>getRuntimeDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>bool</name> <macro><name>argumentsMayEscape</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>getInitialStackFrameContents</name><argument_list>(<argument>const StackFrameContext *CalleeCtx</argument>,
<argument>BindingsTy &amp;Bindings</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>parameters</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>CE_ObjCMessage</name></expr>;</return> }</block>
<name>StringRef</name> <macro><name>getKindAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><literal type="string">"ObjCMethodCall"</literal></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const CallEvent *CA</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>CA</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CE_ObjCMessage</name></expr>;</return>
}</block>
}</expr>;

enum <expr><name>CallDescriptionFlags</name> <operator>:</operator> <name>int</name> <block>{




<expr><name>CDF_MaybeBuiltin</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal></expr>,
}</block></expr>;



<expr><name>class</name> <name>CallDescription</name> <block>{
<expr><name>friend</name> <name>CallEvent</name></expr>;

<expr><name>mutable</name> <name>IdentifierInfo</name> <operator>*</operator><name>II</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>mutable</name> <name>bool</name> <name>IsLookupDone</name> <operator>=</operator> <name>false</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>QualifiedName</name></expr>;
<expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>RequiredArgs</name></expr>;
<expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name> <name>RequiredParams</name></expr>;
<expr><name>int</name> <name>Flags</name></expr>;


<expr><specifier>static</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name> <macro><name>readRequiredParams</name><argument_list>(<argument>Optional&lt;unsigned&gt; RequiredArgs</argument>,
<argument>Optional&lt;size_t&gt; RequiredParams</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>RequiredParams</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>RequiredParams</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<expr><name>RequiredArgs</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>RequiredArgs</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>None</name></expr>;</return>
}</block>

<name>public</name><operator>:</operator>










<macro><name>CallDescription</name><argument_list>(<argument>int Flags</argument>, <argument>ArrayRef&lt;const char *&gt; QualifiedName</argument>,
<argument>Optional&lt;unsigned&gt; RequiredArgs = None</argument>,
<argument>Optional&lt;size_t&gt; RequiredParams = None</argument>)</argument_list></macro>
<operator>:</operator> <call><name>QualifiedName</name><argument_list>(<argument><expr><name>QualifiedName</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>RequiredArgs</name><argument_list>(<argument><expr><name>RequiredArgs</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>RequiredParams</name><argument_list>(<argument><expr><call><name>readRequiredParams</name><argument_list>(<argument><expr><name>RequiredArgs</name></expr></argument>, <argument><expr><name>RequiredParams</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>Flags</name><argument_list>(<argument>Flags</argument>)</argument_list></macro> <expr><block>{}</block>


<call><name>CallDescription</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>QualifiedName</name></expr></argument>,
<argument><expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>RequiredArgs</name> <operator>=</operator> <name>None</name></expr></argument>,
<argument><expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name> <name>RequiredParams</name> <operator>=</operator> <name>None</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CallDescription</name><argument_list>(<argument><literal type="number">0</literal></argument>, <argument>QualifiedName</argument>, <argument>RequiredArgs</argument>, <argument>RequiredParams</argument>)</argument_list></macro> <block>{}</block>


<name>StringRef</name> <macro><name>getFunctionName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>QualifiedName</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>CallDescriptionMap</name> <block>{





<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>CallDescription</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>LinearMap</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>CallDescriptionMap</name><argument_list>(
<argument><expr><name>std</name><operator>::</operator><name><name>initializer_list</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>CallDescription</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <operator>&amp;&amp;</operator><name>List</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>LinearMap</name><argument_list>(<argument>List</argument>)</argument_list></macro> <block>{}</block>

<operator>~</operator><call><name>CallDescriptionMap</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;



<expr><call><name>CallDescriptionMap</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CallDescriptionMap</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><name>CallDescriptionMap</name> <operator>&amp;</operator><name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>CallDescription</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr>;

<expr><specifier>const</specifier> <name>T</name> <operator>*</operator><macro><name>lookup</name><argument_list>(<argument>const CallEvent &amp;Call</argument>)</argument_list></macro> <specifier>const</specifier> <block>{


<for>for <control>(<init><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>CallDescription</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>I</name> <operator>:</operator> <name>LinearMap</name></expr></init>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Call</name><operator>.</operator><name>isCalled</name></name><argument_list>(<argument><expr><name><name>I</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>&amp;</operator><name><name>I</name><operator>.</operator><name>second</name></name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for></block></expr>

<return>return <expr><name>nullptr</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>CallEventManager</name> <block>{
<expr><name>friend</name> <name>class</name> <name>CallEvent</name></expr>;

<expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name> <operator>&amp;</operator><name>Alloc</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>Cache</name></expr>;

<expr><name>using</name> <name>CallEventTemplateTy</name> <operator>=</operator> <name>SimpleFunctionCall</name></expr>;

<expr><name>void</name> <macro><name>reclaim</name><argument_list>(<argument>const void *Memory</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Cache</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Memory</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<name>void</name> <operator>*</operator><macro><name>allocate</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Cache</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>Alloc</name><operator>.</operator><name>Allocate</name></name><operator>&lt;</operator><name>CallEventTemplateTy</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name><name>Cache</name><operator>.</operator><name>pop_back_val</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>Arg</name></expr></argument>&gt;</argument_list></name>
<name>T</name> <operator>*</operator><macro><name>create</name><argument_list>(<argument>Arg A</argument>, <argument>ProgramStateRef St</argument>, <argument>const LocationContext *LCtx</argument>)</argument_list></macro> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CallEventTemplateTy</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"CallEvent subclasses are not all the same size"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <macro><name>new</name> <argument_list>(<argument>allocate()</argument>)</argument_list></macro> <expr><call><name>T</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>St</name></expr></argument>, <argument><expr><name>LCtx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>Arg1</name></expr></argument>, <argument><expr><name>typename</name> <name>Arg2</name></expr></argument>&gt;</argument_list></name>
<name>T</name> <operator>*</operator><macro><name>create</name><argument_list>(<argument>Arg1 A1</argument>, <argument>Arg2 A2</argument>, <argument>ProgramStateRef St</argument>, <argument>const LocationContext *LCtx</argument>)</argument_list></macro> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CallEventTemplateTy</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"CallEvent subclasses are not all the same size"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <macro><name>new</name> <argument_list>(<argument>allocate()</argument>)</argument_list></macro> <expr><call><name>T</name><argument_list>(<argument><expr><name>A1</name></expr></argument>, <argument><expr><name>A2</name></expr></argument>, <argument><expr><name>St</name></expr></argument>, <argument><expr><name>LCtx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>Arg1</name></expr></argument>, <argument><expr><name>typename</name> <name>Arg2</name></expr></argument>, <argument><expr><name>typename</name> <name>Arg3</name></expr></argument>&gt;</argument_list></name>
<name>T</name> <operator>*</operator><macro><name>create</name><argument_list>(<argument>Arg1 A1</argument>, <argument>Arg2 A2</argument>, <argument>Arg3 A3</argument>, <argument>ProgramStateRef St</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CallEventTemplateTy</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"CallEvent subclasses are not all the same size"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <macro><name>new</name> <argument_list>(<argument>allocate()</argument>)</argument_list></macro> <expr><call><name>T</name><argument_list>(<argument><expr><name>A1</name></expr></argument>, <argument><expr><name>A2</name></expr></argument>, <argument><expr><name>A3</name></expr></argument>, <argument><expr><name>St</name></expr></argument>, <argument><expr><name>LCtx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>Arg1</name></expr></argument>, <argument><expr><name>typename</name> <name>Arg2</name></expr></argument>, <argument><expr><name>typename</name> <name>Arg3</name></expr></argument>,
<argument><expr><name>typename</name> <name>Arg4</name></expr></argument>&gt;</argument_list></name>
<name>T</name> <operator>*</operator><macro><name>create</name><argument_list>(<argument>Arg1 A1</argument>, <argument>Arg2 A2</argument>, <argument>Arg3 A3</argument>, <argument>Arg4 A4</argument>, <argument>ProgramStateRef St</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CallEventTemplateTy</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"CallEvent subclasses are not all the same size"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <macro><name>new</name> <argument_list>(<argument>allocate()</argument>)</argument_list></macro> <expr><call><name>T</name><argument_list>(<argument><expr><name>A1</name></expr></argument>, <argument><expr><name>A2</name></expr></argument>, <argument><expr><name>A3</name></expr></argument>, <argument><expr><name>A4</name></expr></argument>, <argument><expr><name>St</name></expr></argument>, <argument><expr><name>LCtx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<call><name>CallEventManager</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name> <operator>&amp;</operator><name>alloc</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>Alloc</name><argument_list>(<argument>alloc</argument>)</argument_list></macro> <block>{}</block>


<name><name>CallEventRef</name><argument_list type="generic">&lt;&gt;</argument_list></name>
<macro><name>getCaller</name><argument_list>(<argument>const StackFrameContext *CalleeCtx</argument>, <argument>ProgramStateRef State</argument>)</argument_list></macro></expr>;



<expr><name><name>CallEventRef</name><argument_list type="generic">&lt;&gt;</argument_list></name>
<macro><name>getCall</name><argument_list>(<argument>const Stmt *S</argument>, <argument>ProgramStateRef State</argument>,
<argument>const LocationContext *LC</argument>)</argument_list></macro></expr>;

<expr><name><name>CallEventRef</name><argument_list type="generic">&lt;&gt;</argument_list></name>
<macro><name>getSimpleCall</name><argument_list>(<argument>const CallExpr *E</argument>, <argument>ProgramStateRef State</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro></expr>;

<expr><name><name>CallEventRef</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodCall</name></expr></argument>&gt;</argument_list></name>
<macro><name>getObjCMethodCall</name><argument_list>(<argument>const ObjCMessageExpr *E</argument>, <argument>ProgramStateRef State</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>create</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodCall</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>State</name></expr></argument>, <argument><expr><name>LCtx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>CallEventRef</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructorCall</name></expr></argument>&gt;</argument_list></name>
<macro><name>getCXXConstructorCall</name><argument_list>(<argument>const CXXConstructExpr *E</argument>, <argument>const MemRegion *Target</argument>,
<argument>ProgramStateRef State</argument>, <argument>const LocationContext *LCtx</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>create</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructorCall</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>Target</name></expr></argument>, <argument><expr><name>State</name></expr></argument>, <argument><expr><name>LCtx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>CallEventRef</name><argument_list type="generic">&lt;<argument><expr><name>CXXInheritedConstructorCall</name></expr></argument>&gt;</argument_list></name>
<macro><name>getCXXInheritedConstructorCall</name><argument_list>(<argument>const CXXInheritedCtorInitExpr *E</argument>,
<argument>const MemRegion *Target</argument>, <argument>ProgramStateRef State</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>create</name><argument_list type="generic">&lt;<argument><expr><name>CXXInheritedConstructorCall</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>Target</name></expr></argument>, <argument><expr><name>State</name></expr></argument>, <argument><expr><name>LCtx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>CallEventRef</name><argument_list type="generic">&lt;<argument><expr><name>CXXDestructorCall</name></expr></argument>&gt;</argument_list></name>
<macro><name>getCXXDestructorCall</name><argument_list>(<argument>const CXXDestructorDecl *DD</argument>, <argument>const Stmt *Trigger</argument>,
<argument>const MemRegion *Target</argument>, <argument>bool IsBase</argument>,
<argument>ProgramStateRef State</argument>, <argument>const LocationContext *LCtx</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>create</name><argument_list type="generic">&lt;<argument><expr><name>CXXDestructorCall</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DD</name></expr></argument>, <argument><expr><name>Trigger</name></expr></argument>, <argument><expr><name>Target</name></expr></argument>, <argument><expr><name>IsBase</name></expr></argument>, <argument><expr><name>State</name></expr></argument>, <argument><expr><name>LCtx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>CallEventRef</name><argument_list type="generic">&lt;<argument><expr><name>CXXAllocatorCall</name></expr></argument>&gt;</argument_list></name>
<macro><name>getCXXAllocatorCall</name><argument_list>(<argument>const CXXNewExpr *E</argument>, <argument>ProgramStateRef State</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>create</name><argument_list type="generic">&lt;<argument><expr><name>CXXAllocatorCall</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>State</name></expr></argument>, <argument><expr><name>LCtx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>CallEventRef</name><argument_list type="generic">&lt;<argument><expr><name>CXXDeallocatorCall</name></expr></argument>&gt;</argument_list></name>
<macro><name>getCXXDeallocatorCall</name><argument_list>(<argument>const CXXDeleteExpr *E</argument>, <argument>ProgramStateRef State</argument>,
<argument>const LocationContext *LCtx</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>create</name><argument_list type="generic">&lt;<argument><expr><name>CXXDeallocatorCall</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>State</name></expr></argument>, <argument><expr><name>LCtx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>CallEventRef</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name>CallEvent</name><operator>::</operator><macro><name>cloneWithState</name><argument_list>(<argument>ProgramStateRef NewState</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Cloning to unrelated type"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CallEvent</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"Subclasses may not add fields"</literal></expr></argument>)</argument_list></call></expr>;

<if_stmt><if>if <condition>(<expr><name>NewState</name> <operator>==</operator> <name>State</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>CallEventManager</name> <operator>&amp;</operator><name>Mgr</name> <operator>=</operator> <call><name><name>State</name><operator>-&gt;</operator><name>getStateManager</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCallEventManager</name><argument_list>()</argument_list></call></block></expr>;
<expr><name>T</name> <operator>*</operator><name>Copy</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Mgr</name><operator>.</operator><name>allocate</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>cloneTo</name><argument_list>(<argument><expr><name>Copy</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Copy</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>this</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Bad copy"</literal></expr></argument>)</argument_list></call></expr>;

<expr><name><name>Copy</name><operator>-&gt;</operator><name>State</name></name> <operator>=</operator> <name>NewState</name></expr>;
<return>return <expr><name>Copy</name></expr>;</return>
}</block>

<specifier>inline</specifier> <name>void</name> <name>CallEvent</name><operator>::</operator><macro><name>Release</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>RefCount</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="string">"Reference count is already zero."</literal></expr></argument>)</argument_list></call></expr>;
<expr><operator>--</operator><name>RefCount</name></expr>;

<if_stmt><if>if <condition>(<expr><name>RefCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<name>CallEventManager</name> <operator>&amp;</operator><name>Mgr</name> <operator>=</operator> <call><name><name>State</name><operator>-&gt;</operator><name>getStateManager</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCallEventManager</name><argument_list>()</argument_list></call></block></expr>;
<expr><call><name><name>Mgr</name><operator>.</operator><name>reclaim</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;

<expr><name><name>this</name><operator>-&gt;</operator><name/></name>~<call><name>CallEvent</name><argument_list>()</argument_list></call></expr>;
}</block></expr>

}</block></expr>

}</block>

<name>namespace</name> <name>llvm</name> <block>{


<expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> struct <name><name>simplify_type</name><argument_list type="generic">&lt; <argument><expr><name>clang</name><operator>::</operator><name>ento</name><operator>::</operator><name><name>CallEventRef</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>using</name> <name>SimpleType</name> <operator>=</operator> <specifier>const</specifier> <name>T</name> <operator>*</operator></expr>;

<expr><specifier>static</specifier> <name>SimpleType</name>
<macro><name>getSimplifiedValue</name><argument_list>(<argument>clang::ento::CallEventRef&lt;T&gt; Val</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Val</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;

}</block></expr></block></expr></block></expr></block></expr></block></expr></range></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
