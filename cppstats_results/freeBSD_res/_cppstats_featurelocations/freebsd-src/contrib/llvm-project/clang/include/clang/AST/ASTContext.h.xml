<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/ASTContext.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_ASTCONTEXT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_ASTCONTEXT_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTContextAllocate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTFwd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/CanonicalType.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/CommentCommandTraits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ComparisonCategories.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclBase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclarationName.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExternalASTSource.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/NestedNameSpecifier.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/PrettyPrinter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/RawCommentList.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TemplateName.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/AddressSpaces.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/AttrKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/IdentifierTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LangOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Linkage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/NoSanitizeList.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OperatorKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/PartialDiagnostic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/ProfileList.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Specifiers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TargetCXXABI.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/XRayLists.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/APSInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/FoldingSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/IntrusiveRefCntPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/MapVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/None.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerIntPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerUnion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/TinyPtrVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Triple.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/AlignOf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Allocator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/TypeSize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iterator&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;type_traits&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>APFixedPoint</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FixedPointSemantics</name></decl>;</decl_stmt>
<struct_decl>struct <name>fltSemantics</name>;</struct_decl>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>unsigned</name> <name>N</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>SmallPtrSet</name></decl>;</decl_stmt>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>APValue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTMutationListener</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTRecordLayout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>AtomicExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BlockExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BuiltinTemplateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CharUnits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ConceptDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXABI</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXConstructorDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXMethodDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXRecordDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DiagnosticsEngine</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ParentMapContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DynTypedNode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DynTypedNodeList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>GlobalDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ItaniumMangleContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MangleContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MangleNumberingContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MaterializeTemporaryExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MemberSpecializationInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Module</name></decl>;</decl_stmt>
<struct_decl>struct <name>MSGuidDeclParts</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCCategoryDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCCategoryImplDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCContainerDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCImplDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCImplementationDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCInterfaceDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCIvarDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCMethodDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCPropertyDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCPropertyImplDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCProtocolDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCTypeParamDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>OMPTraitInfo</name></decl>;</decl_stmt>
<struct_decl>struct <name>ParsedTargetAttr</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>Preprocessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Stmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>StoredDeclsMap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TargetAttr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TargetInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateParameterList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateTemplateParmDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateTypeParmDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UnresolvedSetIterator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UsingShadowDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VarTemplateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VTableContextBase</name></decl>;</decl_stmt>
<struct_decl>struct <name>BlockVarCopyInit</name>;</struct_decl>

<decl_stmt><decl><type><name>namespace</name></type> <name>Builtin</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>Context</name></decl>;</decl_stmt>

</block_content>}</block></decl></decl_stmt>

<enum_decl>enum <name>BuiltinTemplateKind</name> : <type><name>int</name></type>;</enum_decl>
<enum_decl>enum <name>OpenCLTypeKind</name> : <type><name>uint8_t</name></type>;</enum_decl>

<decl_stmt><decl><type><name>namespace</name></type> <name>comments</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>FullComment</name></decl>;</decl_stmt>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>interp</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>Context</name></decl>;</decl_stmt>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>serialization</name> <block>{<block_content>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>AbstractTypeReader</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>

<struct>struct <name>TypeInfo</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>Width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>Align</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>AlignIsRequired</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypeInfo</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>AlignIsRequired</name><argument_list>(<argument>false</argument>)</argument_list></macro> <block>{}</block>
<macro><name>TypeInfo</name><argument_list>(<argument>uint64_t Width</argument>, <argument>unsigned Align</argument>, <argument>bool AlignIsRequired</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Width</name><argument_list>(<argument><expr><name>Width</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Align</name><argument_list>(<argument><expr><name>Align</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>AlignIsRequired</name><argument_list>(<argument>AlignIsRequired</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>

<struct>struct <name>TypeInfoChars</name> <block>{
<decl_stmt><decl><type><name>CharUnits</name></type> <name>Width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharUnits</name></type> <name>Align</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>AlignIsRequired</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypeInfoChars</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>AlignIsRequired</name><argument_list>(<argument>false</argument>)</argument_list></macro> <block>{}</block>
<macro><name>TypeInfoChars</name><argument_list>(<argument>CharUnits Width</argument>, <argument>CharUnits Align</argument>, <argument>bool AlignIsRequired</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Width</name><argument_list>(<argument><expr><name>Width</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Align</name><argument_list>(<argument><expr><name>Align</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>AlignIsRequired</name><argument_list>(<argument>AlignIsRequired</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>



<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name> <range>: <expr><name>public</name> <name><name>RefCountedBase</name><argument_list type="generic">&lt;<argument><expr><name>ASTContext</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>NestedNameSpecifier</name></expr>;

<expr><name>mutable</name> <name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Type</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name> <name>Types</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>ExtQuals</name></expr></argument>&gt;</argument_list></name> <name>ExtQualNodes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>ComplexType</name></expr></argument>&gt;</argument_list></name> <name>ComplexTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>PointerType</name></expr></argument>&gt;</argument_list></name> <name>PointerTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>AdjustedType</name></expr></argument>&gt;</argument_list></name> <name>AdjustedTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>BlockPointerType</name></expr></argument>&gt;</argument_list></name> <name>BlockPointerTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>LValueReferenceType</name></expr></argument>&gt;</argument_list></name> <name>LValueReferenceTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>RValueReferenceType</name></expr></argument>&gt;</argument_list></name> <name>RValueReferenceTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>MemberPointerType</name></expr></argument>&gt;</argument_list></name> <name>MemberPointerTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>ContextualFoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>ConstantArrayType</name></expr></argument>, <argument><expr><name>ASTContext</name> <operator>&amp;</operator></expr></argument>&gt;</argument_list></name>
<name>ConstantArrayTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>IncompleteArrayType</name></expr></argument>&gt;</argument_list></name> <name>IncompleteArrayTypes</name></expr>;
<expr><name>mutable</name> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>VariableArrayType</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>VariableArrayTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>DependentSizedArrayType</name></expr></argument>&gt;</argument_list></name> <name>DependentSizedArrayTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>DependentSizedExtVectorType</name></expr></argument>&gt;</argument_list></name>
<name>DependentSizedExtVectorTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>DependentAddressSpaceType</name></expr></argument>&gt;</argument_list></name>
<name>DependentAddressSpaceTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>VectorType</name></expr></argument>&gt;</argument_list></name> <name>VectorTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>DependentVectorType</name></expr></argument>&gt;</argument_list></name> <name>DependentVectorTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>ConstantMatrixType</name></expr></argument>&gt;</argument_list></name> <name>MatrixTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>DependentSizedMatrixType</name></expr></argument>&gt;</argument_list></name> <name>DependentSizedMatrixTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>FunctionNoProtoType</name></expr></argument>&gt;</argument_list></name> <name>FunctionNoProtoTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>ContextualFoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name></expr></argument>, <argument><expr><name>ASTContext</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name>
<name>FunctionProtoTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>DependentTypeOfExprType</name></expr></argument>&gt;</argument_list></name> <name>DependentTypeOfExprTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>DependentDecltypeType</name></expr></argument>&gt;</argument_list></name> <name>DependentDecltypeTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>TemplateTypeParmType</name></expr></argument>&gt;</argument_list></name> <name>TemplateTypeParmTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>ObjCTypeParamType</name></expr></argument>&gt;</argument_list></name> <name>ObjCTypeParamTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>SubstTemplateTypeParmType</name></expr></argument>&gt;</argument_list></name>
<name>SubstTemplateTypeParmTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>SubstTemplateTypeParmPackType</name></expr></argument>&gt;</argument_list></name>
<name>SubstTemplateTypeParmPackTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>ContextualFoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>TemplateSpecializationType</name></expr></argument>, <argument><expr><name>ASTContext</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name>
<name>TemplateSpecializationTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>ParenType</name></expr></argument>&gt;</argument_list></name> <name>ParenTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>ElaboratedType</name></expr></argument>&gt;</argument_list></name> <name>ElaboratedTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>DependentNameType</name></expr></argument>&gt;</argument_list></name> <name>DependentNameTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>ContextualFoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>DependentTemplateSpecializationType</name></expr></argument>,
<argument><expr><name>ASTContext</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name>
<name>DependentTemplateSpecializationTypes</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>PackExpansionType</name></expr></argument>&gt;</argument_list></name> <name>PackExpansionTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectTypeImpl</name></expr></argument>&gt;</argument_list></name> <name>ObjCObjectTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectPointerType</name></expr></argument>&gt;</argument_list></name> <name>ObjCObjectPointerTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>DependentUnaryTransformType</name></expr></argument>&gt;</argument_list></name>
<name>DependentUnaryTransformTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>ContextualFoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>AutoType</name></expr></argument>, <argument><expr><name>ASTContext</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <name>AutoTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>DeducedTemplateSpecializationType</name></expr></argument>&gt;</argument_list></name>
<name>DeducedTemplateSpecializationTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>AtomicType</name></expr></argument>&gt;</argument_list></name> <name>AtomicTypes</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>AttributedType</name></expr></argument>&gt;</argument_list></name> <name>AttributedTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>PipeType</name></expr></argument>&gt;</argument_list></name> <name>PipeTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>ExtIntType</name></expr></argument>&gt;</argument_list></name> <name>ExtIntTypes</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>DependentExtIntType</name></expr></argument>&gt;</argument_list></name> <name>DependentExtIntTypes</name></expr>;

<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>QualifiedTemplateName</name></expr></argument>&gt;</argument_list></name> <name>QualifiedTemplateNames</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>DependentTemplateName</name></expr></argument>&gt;</argument_list></name> <name>DependentTemplateNames</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>SubstTemplateTemplateParmStorage</name></expr></argument>&gt;</argument_list></name>
<name>SubstTemplateTemplateParms</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>ContextualFoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>SubstTemplateTemplateParmPackStorage</name></expr></argument>,
<argument><expr><name>ASTContext</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name>
<name>SubstTemplateTemplateParmPacks</name></expr>;




<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>NestedNameSpecifier</name></expr></argument>&gt;</argument_list></name> <name>NestedNameSpecifiers</name></expr>;
<expr><name>mutable</name> <name>NestedNameSpecifier</name> <operator>*</operator><name>GlobalNestedNameSpecifier</name> <operator>=</operator> <name>nullptr</name></expr>;




<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>RecordDecl</name><operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTRecordLayout</name><operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>ASTRecordLayouts</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ObjCContainerDecl</name><operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTRecordLayout</name><operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>ObjCLayouts</name></expr>;


<expr><name>using</name> <name>TypeInfoMap</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator></expr></argument>, <argument><expr>struct <name>TypeInfo</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>mutable</name> <name>TypeInfoMap</name> <name>MemoizedTypeInfo</name></expr>;




<expr><name>using</name> <name>UnadjustedAlignMap</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>mutable</name> <name>UnadjustedAlignMap</name> <name>MemoizedUnadjustedAlign</name></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name><operator>*</operator></expr></argument>, <argument><expr><name>LazyDeclPtr</name></expr></argument>&gt;</argument_list></name> <name>KeyFunctions</name></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>ObjCContainerDecl</name><operator>*</operator></expr></argument>, <argument><expr><name>ObjCImplDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ObjCImpls</name></expr>;



<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ObjCMethodDecl</name><operator>*</operator></expr></argument>,<argument><expr><specifier>const</specifier> <name>ObjCMethodDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ObjCMethodRedecls</name></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>BlockVarCopyInit</name></expr></argument>&gt;</argument_list></name> <name>BlockVarCopyInits</name></expr>;


<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>MSGuidDecl</name></expr></argument>&gt;</argument_list></name> <name>MSGuidDecls</name></expr>;


<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>TemplateParamObjectDecl</name></expr></argument>&gt;</argument_list></name> <name>TemplateParamObjectDecls</name></expr>;





<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>StringLiteral</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>StringLiteralCache</name></expr>;



<expr><name>mutable</name> <name>std</name><operator>::</operator><name>string</name> <name>CUIDHash</name></expr>;



<expr><name>class</name> <name>CanonicalTemplateTemplateParm</name> <operator>:</operator> <name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>TemplateTemplateParmDecl</name> <operator>*</operator><name>Parm</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>CanonicalTemplateTemplateParm</name><argument_list>(<argument><expr><name>TemplateTemplateParmDecl</name> <operator>*</operator><name>Parm</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>Parm</name><argument_list>(<argument>Parm</argument>)</argument_list></macro> <block>{}</block>

<name>TemplateTemplateParmDecl</name> <operator>*</operator><macro><name>getParam</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Parm</name></expr>;</return> }</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>const ASTContext &amp;C</argument>)</argument_list></macro> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>C</name></expr></argument>, <argument><expr><name>Parm</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <call><name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>,
<argument><expr><name>TemplateTemplateParmDecl</name> <operator>*</operator><name>Parm</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>ContextualFoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>CanonicalTemplateTemplateParm</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ASTContext</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name>
<name>CanonTemplateTemplateParms</name></expr>;

<expr><name>TemplateTemplateParmDecl</name> <operator>*</operator>
<macro><name>getCanonicalTemplateTemplateParmDecl</name><argument_list>(<argument>TemplateTemplateParmDecl *TTP</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>mutable</name> <name>TypedefDecl</name> <operator>*</operator><name>Int128Decl</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>mutable</name> <name>TypedefDecl</name> <operator>*</operator><name>UInt128Decl</name> <operator>=</operator> <name>nullptr</name></expr>;



<expr><name>mutable</name> <name>TypedefDecl</name> <operator>*</operator><name>BuiltinVaListDecl</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>mutable</name> <name>TypedefDecl</name> <operator>*</operator><name>BuiltinMSVaListDecl</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>mutable</name> <name>TypedefDecl</name> <operator>*</operator><name>ObjCIdDecl</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>mutable</name> <name>TypedefDecl</name> <operator>*</operator><name>ObjCSelDecl</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>mutable</name> <name>TypedefDecl</name> <operator>*</operator><name>ObjCClassDecl</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>mutable</name> <name>ObjCInterfaceDecl</name> <operator>*</operator><name>ObjCProtocolClassDecl</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>mutable</name> <name>TypedefDecl</name> <operator>*</operator><name>BOOLDecl</name> <operator>=</operator> <name>nullptr</name></expr>;



<expr><name>QualType</name> <name>ObjCIdRedefinitionType</name></expr>;
<expr><name>QualType</name> <name>ObjCClassRedefinitionType</name></expr>;
<expr><name>QualType</name> <name>ObjCSelRedefinitionType</name></expr>;


<expr><name>mutable</name> <name>IdentifierInfo</name> <operator>*</operator><name>BoolName</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>mutable</name> <name>IdentifierInfo</name> <operator>*</operator><name>NSObjectName</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>IdentifierInfo</name> <operator>*</operator><name>NSCopyingName</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>mutable</name> <name>IdentifierInfo</name> <operator>*</operator><name>MakeIntegerSeqName</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>mutable</name> <name>IdentifierInfo</name> <operator>*</operator><name>TypePackElementName</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>QualType</name> <name>ObjCConstantStringType</name></expr>;
<expr><name>mutable</name> <name>RecordDecl</name> <operator>*</operator><name>CFConstantStringTagDecl</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>mutable</name> <name>TypedefDecl</name> <operator>*</operator><name>CFConstantStringTypeDecl</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>mutable</name> <name>QualType</name> <name>ObjCSuperType</name></expr>;

<expr><name>QualType</name> <name>ObjCNSStringType</name></expr>;


<expr><name>TypedefDecl</name> <operator>*</operator><name>ObjCInstanceTypeDecl</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>TypeDecl</name> <operator>*</operator><name>FILEDecl</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>TypeDecl</name> <operator>*</operator><name>jmp_bufDecl</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>TypeDecl</name> <operator>*</operator><name>sigjmp_bufDecl</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>TypeDecl</name> <operator>*</operator><name>ucontext_tDecl</name> <operator>=</operator> <name>nullptr</name></expr>;





<expr><name>mutable</name> <name>RecordDecl</name> <operator>*</operator><name>BlockDescriptorType</name> <operator>=</operator> <name>nullptr</name></expr>;





<expr><name>mutable</name> <name>RecordDecl</name> <operator>*</operator><name>BlockDescriptorExtendedType</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>FunctionDecl</name> <operator>*</operator><name>cudaConfigureCallDecl</name> <operator>=</operator> <name>nullptr</name></expr>;





<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name><operator>*</operator></expr></argument>, <argument><expr><name>AttrVec</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>DeclAttrs</name></expr>;




<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name><operator>*</operator></expr></argument>, <argument><expr><name>Decl</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>MergedDecls</name></expr>;




<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name><operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name><name>TinyPtrVector</name><argument_list type="generic">&lt;<argument><expr><name>Module</name><operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>MergedDefModules</name></expr>;





struct <expr><name>PerModuleInitializers</name> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>Initializers</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>uint32_t</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>LazyInitializers</name></expr>;

<expr><name>void</name> <call><name>resolve</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>Module</name><operator>*</operator></expr></argument>, <argument><expr><name>PerModuleInitializers</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ModuleInitializers</name></expr>;

<expr><name>ASTContext</name> <operator>&amp;</operator><macro><name>this_</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><operator>*</operator><name>this</name></expr>;</return> }</block>

<name>public</name><operator>:</operator>

<name>using</name> <name>TemplateOrSpecializationInfo</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>VarTemplateDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>MemberSpecializationInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTWriter</name></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name></expr></argument>&gt;</argument_list></name> <name>friend</name> <name>class</name> <name>serialization</name><operator>::</operator><name>AbstractTypeReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>CXXRecordDecl</name></expr>;
<expr><name>friend</name> <name>class</name> <name>IncrementalParser</name></expr>;































<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>TemplateOrSpecializationInfo</name></expr></argument>&gt;</argument_list></name>
<name>TemplateOrInstantiation</name></expr>;
























<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>InstantiatedFromUsingDecl</name></expr>;








<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>UsingEnumDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>UsingEnumDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>InstantiatedFromUsingEnumDecl</name></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>UsingShadowDecl</name><operator>*</operator></expr></argument>, <argument><expr><name>UsingShadowDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>InstantiatedFromUsingShadowDecl</name></expr>;

<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>FieldDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>FieldDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>InstantiatedFromUnnamedFieldDecl</name></expr>;







<expr><name>using</name> <name>CXXMethodVector</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>TinyPtrVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXMethodDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXMethodDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>CXXMethodVector</name></expr></argument>&gt;</argument_list></name> <name>OverriddenMethods</name></expr>;




<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MangleNumberingContext</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>MangleNumberingContexts</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MangleNumberingContext</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>ExtraMangleNumberingContexts</name></expr>;



<expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>MangleNumbers</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>StaticLocalNumbers</name></expr>;

<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name>
<name>DeviceLambdaManglingNumbers</name></expr>;



<expr><name>using</name> <name>ParameterIndexTable</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>ParameterIndexTable</name> <name>ParamIndices</name></expr>;

<expr><name>ImportDecl</name> <operator>*</operator><name>FirstLocalImport</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>ImportDecl</name> <operator>*</operator><name>LastLocalImport</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>TranslationUnitDecl</name> <operator>*</operator><name>TUDecl</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>mutable</name> <name>ExternCContextDecl</name> <operator>*</operator><name>ExternCContext</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>mutable</name> <name>BuiltinTemplateDecl</name> <operator>*</operator><name>MakeIntegerSeqDecl</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>mutable</name> <name>BuiltinTemplateDecl</name> <operator>*</operator><name>TypePackElementDecl</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>SourceManager</name> <operator>&amp;</operator><name>SourceMgr</name></expr>;



<expr><name>LangOptions</name> <operator>&amp;</operator><name>LangOpts</name></expr>;



<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>NoSanitizeList</name></expr></argument>&gt;</argument_list></name> <name>NoSanitizeL</name></expr>;



<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>XRayFunctionFilter</name></expr></argument>&gt;</argument_list></name> <name>XRayFilter</name></expr>;



<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ProfileList</name></expr></argument>&gt;</argument_list></name> <name>ProfList</name></expr>;





<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name> <name>BumpAlloc</name></expr>;


<expr><name>PartialDiagnostic</name><operator>::</operator><name>DiagStorageAllocator</name> <name>DiagAllocator</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CXXABI</name></expr></argument>&gt;</argument_list></name> <name>ABI</name></expr>;
<expr><name>CXXABI</name> <operator>*</operator><call><name>createCXXABI</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TargetInfo</name> <operator>&amp;</operator><name>T</name></expr></argument>)</argument_list></call></expr>;


<expr><specifier>const</specifier> <name>LangASMap</name> <operator>*</operator><name>AddrSpaceMap</name> <operator>=</operator> <name>nullptr</name></expr>;



<expr><name>bool</name> <name>AddrSpaceMapMangling</name></expr>;

<expr><specifier>const</specifier> <name>TargetInfo</name> <operator>*</operator><name>Target</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><specifier>const</specifier> <name>TargetInfo</name> <operator>*</operator><name>AuxTarget</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>clang</name><operator>::</operator><name>PrintingPolicy</name> <name>PrintingPolicy</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>interp</name><operator>::</operator><name>Context</name></expr></argument>&gt;</argument_list></name> <name>InterpContext</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ParentMapContext</name></expr></argument>&gt;</argument_list></name> <name>ParentMapCtx</name></expr>;


<expr><name>DeclListNode</name> <operator>*</operator><name>ListNodeFreeList</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>IdentifierTable</name> <operator>&amp;</operator><name>Idents</name></expr>;
<expr><name>SelectorTable</name> <operator>&amp;</operator><name>Selectors</name></expr>;
<expr><name>Builtin</name><operator>::</operator><name>Context</name> <operator>&amp;</operator><name>BuiltinInfo</name></expr>;
<expr><specifier>const</specifier> <name>TranslationUnitKind</name> <name>TUKind</name></expr>;
<expr><name>mutable</name> <name>DeclarationNameTable</name> <name>DeclarationNames</name></expr>;
<expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>ExternalASTSource</name></expr></argument>&gt;</argument_list></name> <name>ExternalSource</name></expr>;
<expr><name>ASTMutationListener</name> <operator>*</operator><name>Listener</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>interp</name><operator>::</operator><name>Context</name> <operator>&amp;</operator><call><name>getInterpContext</name><argument_list>()</argument_list></call></expr>;


<expr><name>ParentMapContext</name> <operator>&amp;</operator><call><name>getParentMapContext</name><argument_list>()</argument_list></call></expr>;



















<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getTraversalScope</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TraversalScope</name></expr>;</return> }</block>
<name>void</name> <call><name>setTraversalScope</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator></expr></argument>)</argument_list></call></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>NodeT</name></expr></argument>&gt;</argument_list></name> <name>DynTypedNodeList</name> <call><name>getParents</name><argument_list>(<argument><expr><specifier>const</specifier> <name>NodeT</name> <operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>const</specifier> <name>clang</name><operator>::</operator><name>PrintingPolicy</name> <operator>&amp;</operator><macro><name>getPrintingPolicy</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PrintingPolicy</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setPrintingPolicy</name><argument_list>(<argument>const clang::PrintingPolicy &amp;Policy</argument>)</argument_list></macro> <block>{
<expr><name>PrintingPolicy</name> <operator>=</operator> <name>Policy</name></expr>;
}</block>

<name>SourceManager</name><operator>&amp;</operator> <macro><name>getSourceManager</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>SourceMgr</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SourceManager</name><operator>&amp;</operator> <macro><name>getSourceManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SourceMgr</name></expr>;</return> }</block>

<name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name> <operator>&amp;</operator><macro><name>getAllocator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>BumpAlloc</name></expr>;</return>
}</block>

<name>void</name> <operator>*</operator><macro><name>Allocate</name><argument_list>(<argument>size_t Size</argument>, <argument>unsigned Align = <literal type="number">8</literal></argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>BumpAlloc</name><operator>.</operator><name>Allocate</name></name><argument_list>(<argument><expr><name>Size</name></expr></argument>, <argument><expr><name>Align</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>T</name> <operator>*</operator><macro><name>Allocate</name><argument_list>(<argument>size_t Num = <literal type="number">1</literal></argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Allocate</name><argument_list>(<argument><expr><name>Num</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>alignof</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>Deallocate</name><argument_list>(<argument>void *Ptr</argument>)</argument_list></macro> <specifier>const</specifier> <block>{}</block>



<name>DeclListNode</name> <operator>*</operator><macro><name>AllocateDeclListNode</name><argument_list>(<argument>clang::NamedDecl *ND</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<decl><type><name>DeclListNode</name> <modifier>*</modifier></type><name>Alloc</name> <init>= <expr><name>ListNodeFreeList</name></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ListNodeFreeList</name> <operator>=</operator> <name><name>Alloc</name><operator>-&gt;</operator><name>Rest</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>DeclListNode</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Alloc</name><operator>-&gt;</operator><name>D</name></name> <operator>=</operator> <name>ND</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Alloc</name><operator>-&gt;</operator><name>Rest</name></name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<return>return <expr><name>Alloc</name></expr>;</return>
<expr_stmt/>}</block_content>
return new (*this</block></if></if_stmt>) <call><name>DeclListNode</name><argument_list>(<argument><expr><name>ND</name></expr></argument>)</argument_list></call></block></expr>;
}</block>


<name>void</name> <macro><name>DeallocateDeclListNode</name><argument_list>(<argument>DeclListNode *N</argument>)</argument_list></macro> <block>{
<expr><name><name>N</name><operator>-&gt;</operator><name>Rest</name></name> <operator>=</operator> <name>ListNodeFreeList</name></expr>;
<expr><name>ListNodeFreeList</name> <operator>=</operator> <name>N</name></expr>;
}</block>



<name>size_t</name> <macro><name>getASTAllocatedMemory</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>BumpAlloc</name><operator>.</operator><name>getTotalMemory</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>


<expr_stmt><expr><name>size_t</name> <macro><name>getSideTableAllocatedMemory</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>PartialDiagnostic</name><operator>::</operator><name>DiagStorageAllocator</name> <operator>&amp;</operator><macro><name>getDiagAllocator</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>DiagAllocator</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>TargetInfo</name> <operator>&amp;</operator><macro><name>getTargetInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>Target</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>TargetInfo</name> <operator>*</operator><macro><name>getAuxTargetInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AuxTarget</name></expr>;</return> }</block></expr></expr_stmt>





<decl_stmt><decl><type><name>QualType</name></type> <name>getIntTypeForBitwidth</name><argument_list>(<argument><expr><name>unsigned</name> <name>DestWidth</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>Signed</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<decl_stmt><decl><type><name>QualType</name></type> <name>getRealTypeForBitwidth</name><argument_list>(<argument><expr><name>unsigned</name> <name>DestWidth</name></expr></argument>, <argument><expr><name>bool</name> <name>ExplicitIEEE</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>AtomicUsesUnsupportedLibcall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>AtomicExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>LangOptions</name><operator>&amp;</operator> <macro><name>getLangOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LangOpts</name></expr>;</return> }</block></expr></expr_stmt>





<expr_stmt><expr><name>bool</name> <macro><name>isDependenceAllowed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>LangOpts</name><operator>.</operator><name>CPlusPlus</name></name> <operator>||</operator> <name><name>LangOpts</name><operator>.</operator><name>RecoveryAST</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>NoSanitizeList</name> <operator>&amp;</operator><macro><name>getNoSanitizeList</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>NoSanitizeL</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>XRayFunctionFilter</name> <operator>&amp;</operator><macro><name>getXRayFilter</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>*</operator><name>XRayFilter</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>ProfileList</name> <operator>&amp;</operator><macro><name>getProfileList</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>ProfList</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><macro><name>getDiagnostics</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<decl_stmt><decl><type><name>FullSourceLoc</name></type> <name>getFullLoc</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>FullSourceLoc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>,<argument><expr><name>SourceMgr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<expr_stmt><expr><name>TargetCXXABI</name><operator>::</operator><name>Kind</name> <macro><name>getCXXABIKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<decl_stmt><decl><type><name>RawCommentList</name></type> <name>Comments</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>mutable</name> <name>bool</name></type> <name>CommentsLoaded</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>





<expr_stmt><expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>RawComment</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>DeclRawComments</name></expr>;</expr_stmt>






<expr_stmt><expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>RedeclChainComments</name></expr>;</expr_stmt>








<expr_stmt><expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CommentlessRedeclChains</name></expr>;</expr_stmt>



<expr_stmt><expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>comments</name><operator>::</operator><name>FullComment</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ParsedComments</name></expr>;</expr_stmt>






<decl_stmt><decl><type><name>void</name></type> <name>cacheRawCommentForDecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>&amp;</operator><name>OriginalD</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>RawComment</name> <operator>&amp;</operator><name>Comment</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<decl_stmt><decl><type><name>RawComment</name> <modifier>*</modifier></type><name>getRawCommentForDeclNoCacheImpl</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>SourceLocation</name> <name>RepresentativeLocForDecl</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>RawComment</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>CommentsInFile</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>RawComment</name> <modifier>*</modifier></type><name>getRawCommentForDeclNoCache</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<label><name>public</name>:</label>
<function_decl><type><name>void</name></type> <name>addComment</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RawComment</name> <modifier>&amp;</modifier></type><name>RC</name></decl></parameter>)</parameter_list>;</function_decl>






<decl_stmt><decl><type><specifier>const</specifier> <name>RawComment</name> <modifier>*</modifier></type>
<name>getRawCommentForAnyRedecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><operator>*</operator><name>OriginalDecl</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>








<function_decl><type><name>void</name></type> <name>attachCommentsToJustParsedDecls</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Decls</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Preprocessor</name> <modifier>*</modifier></type><name>PP</name></decl></parameter>)</parameter_list>;</function_decl>






<expr_stmt><expr><name>comments</name><operator>::</operator><name>FullComment</name> <operator>*</operator><macro><name>getCommentForDecl</name><argument_list>(<argument>const Decl *D</argument>,
<argument>const Preprocessor *PP</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>comments</name><operator>::</operator><name>FullComment</name> <operator>*</operator><macro><name>getLocalCommentForDeclUncached</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>comments</name><operator>::</operator><name>FullComment</name> <operator>*</operator><macro><name>cloneFullComment</name><argument_list>(<argument>comments::FullComment *FC</argument>,
<argument>const Decl *D</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><name>mutable</name> <name>comments</name><operator>::</operator><name>CommandTraits</name> <name>CommentCommandTraits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>import_iterator</name> <block>{<block_content>
<decl_stmt><decl><type><name>ImportDecl</name> <modifier>*</modifier></type><name>Import</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>using</name></type> <name>value_type</name> <init>= <expr><name>ImportDecl</name> <operator>*</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>reference</name> <init>= <expr><name>ImportDecl</name> <operator>*</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>pointer</name> <init>= <expr><name>ImportDecl</name> <operator>*</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>difference_type</name> <init>= <expr><name>int</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>iterator_category</name> <init>= <expr><name>std</name><operator>::</operator><name>forward_iterator_tag</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>import_iterator</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>import_iterator</name><argument_list>(<argument><expr><name>ImportDecl</name> <operator>*</operator><name>Import</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>Import</name><argument_list>(<argument>Import</argument>)</argument_list></macro> <block>{}</block>

<name>reference</name> <name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>Import</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>pointer</name> <name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>)</block_content> const <block>{<block_content> <return>return <expr><name>Import</name></expr>;</return> </block_content>}</block>

import_iterator &amp;operator++(</block></decl>) <block>{<block_content>
<expr_stmt><expr><name>Import</name> <operator>=</operator> <name>ASTContext</name><operator>::</operator><call><name>getNextLocalImport</name><argument_list>(<argument><expr><name>Import</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></decl_stmt>

<expr_stmt><expr><name>import_iterator</name> <name>operator</name><operator>++</operator><operator>(</operator><name>int</name><operator>)</operator> <block>{
<expr><name>import_iterator</name> <call><name>Other</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>++</operator><operator>(</operator><operator>*</operator><name>this</name><operator>)</operator></expr>;
<return>return <expr><name>Other</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><name>import_iterator</name> <name>X</name><operator>,</operator> <name>import_iterator</name> <name>Y</name><operator>)</operator> <block>{
<return>return <expr><name><name>X</name><operator>.</operator><name>Import</name></name> <operator>==</operator> <name><name>Y</name><operator>.</operator><name>Import</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><name>import_iterator</name> <name>X</name><operator>,</operator> <name>import_iterator</name> <name>Y</name><operator>)</operator> <block>{
<return>return <expr><name><name>X</name><operator>.</operator><name>Import</name></name> <operator>!=</operator> <name><name>Y</name><operator>.</operator><name>Import</name></name></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><name>comments</name><operator>::</operator><name>CommandTraits</name> <operator>&amp;</operator><macro><name>getCommentCommandTraits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>CommentCommandTraits</name></expr>;</return>
}</block></expr></expr_stmt>


<function_decl><type><name>AttrVec</name><modifier>&amp;</modifier></type> <name>getDeclAttrs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>eraseDeclAttrs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>MemberSpecializationInfo</name> <modifier>*</modifier></type><name>getInstantiatedFromStaticDataMember</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>Var</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>setInstantiatedFromStaticDataMember</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Inst</name></decl></parameter>, <parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Tmpl</name></decl></parameter>,
<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TemplateOrSpecializationInfo</name></type>
<name>getTemplateOrSpecializationInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>Var</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>setTemplateOrSpecializationInfo</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Inst</name></decl></parameter>,
<parameter><decl><type><name>TemplateOrSpecializationInfo</name></type> <name>TSI</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>getInstantiatedFromUsingDecl</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Inst</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>setInstantiatedFromUsingDecl</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Inst</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Pattern</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>UsingEnumDecl</name> <modifier>*</modifier></type><name>getInstantiatedFromUsingEnumDecl</name><parameter_list>(<parameter><decl><type><name>UsingEnumDecl</name> <modifier>*</modifier></type><name>Inst</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>setInstantiatedFromUsingEnumDecl</name><parameter_list>(<parameter><decl><type><name>UsingEnumDecl</name> <modifier>*</modifier></type><name>Inst</name></decl></parameter>,
<parameter><decl><type><name>UsingEnumDecl</name> <modifier>*</modifier></type><name>Pattern</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>UsingShadowDecl</name> <modifier>*</modifier></type><name>getInstantiatedFromUsingShadowDecl</name><parameter_list>(<parameter><decl><type><name>UsingShadowDecl</name> <modifier>*</modifier></type><name>Inst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>setInstantiatedFromUsingShadowDecl</name><parameter_list>(<parameter><decl><type><name>UsingShadowDecl</name> <modifier>*</modifier></type><name>Inst</name></decl></parameter>,
<parameter><decl><type><name>UsingShadowDecl</name> <modifier>*</modifier></type><name>Pattern</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>getInstantiatedFromUnnamedFieldDecl</name><parameter_list>(<parameter><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>Field</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>setInstantiatedFromUnnamedFieldDecl</name><parameter_list>(<parameter><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>Inst</name></decl></parameter>, <parameter><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>Tmpl</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>using</name></type> <name>overridden_cxx_method_iterator</name> <init>= <expr><name>CXXMethodVector</name><operator>::</operator><name>const_iterator</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>overridden_cxx_method_iterator</name></type>
<name>overridden_methods_begin</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXMethodDecl</name> <operator>*</operator><name>Method</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>overridden_cxx_method_iterator</name></type>
<name>overridden_methods_end</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXMethodDecl</name> <operator>*</operator><name>Method</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>overridden_methods_size</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXMethodDecl</name> <operator>*</operator><name>Method</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>overridden_method_range</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>overridden_cxx_method_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>overridden_method_range</name></type> <name>overridden_methods</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXMethodDecl</name> <operator>*</operator><name>Method</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>addOverriddenMethod</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>Overridden</name></decl></parameter>)</parameter_list>;</function_decl>








<decl_stmt><decl><type><name>void</name></type> <name>getOverriddenMethods</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>Method</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Overridden</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>addedLocalImportDecl</name><parameter_list>(<parameter><decl><type><name>ImportDecl</name> <modifier>*</modifier></type><name>Import</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>ImportDecl</name> <modifier>*</modifier></type><name>getNextLocalImport</name><parameter_list>(<parameter><decl><type><name>ImportDecl</name> <modifier>*</modifier></type><name>Import</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>Import</name><operator>-&gt;</operator><name>getNextLocalImport</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>using</name></type> <name>import_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>import_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>import_range</name> <macro><name>local_imports</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>import_range</name><argument_list>(<argument><expr><call><name>import_iterator</name><argument_list>(<argument><expr><name>FirstLocalImport</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>import_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>Decl</name> <modifier>*</modifier></type><name>getPrimaryMergedDecl</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Result</name> <init>= <expr><call><name><name>MergedDecls</name><operator>.</operator><name>lookup</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><name>Result</name></expr> ?</condition><then> <expr><name>Result</name></expr> </then><else>: <expr><name>D</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setPrimaryMergedDecl</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Primary</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>MergedDecls</name><index>[<expr><name>D</name></expr>]</index></name> <operator>=</operator> <name>Primary</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function_decl><type><name>void</name></type> <name>mergeDefinitionIntoModule</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ND</name></decl></parameter>, <parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>M</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>NotifyListeners</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>deduplicateMergedDefinitonsFor</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ND</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Module</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>getModulesWithMergedDefinition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>Def</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type> <name>addModuleInitializer</name><parameter_list>(<parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>M</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>addLazyModuleInitializers</name><parameter_list>(<parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>M</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>uint32_t</name></expr></argument>&gt;</argument_list></name></type> <name>IDs</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>getModuleInitializers</name><parameter_list>(<parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>M</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>TranslationUnitDecl</name> <operator>*</operator><macro><name>getTranslationUnitDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>TUDecl</name><operator>-&gt;</operator><name>getMostRecentDecl</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>addTranslationUnitDecl</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>TUDecl</name> <operator>||</operator> <name>TUKind</name> <operator>==</operator> <name>TU_Incremental</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>TranslationUnitDecl</name> <modifier>*</modifier></type><name>NewTUDecl</name> <init>= <expr><name>TranslationUnitDecl</name><operator>::</operator><call><name>Create</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>TraversalScope</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>TraversalScope</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>TUDecl</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>TraversalScope</name> <operator>=</operator> <block>{<expr><name>NewTUDecl</name></expr>}</block></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>TUDecl</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>NewTUDecl</name><operator>-&gt;</operator><name>setPreviousDecl</name></name><argument_list>(<argument><expr><name>TUDecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>TUDecl</name> <operator>=</operator> <name>NewTUDecl</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>ExternCContextDecl</name> <operator>*</operator><macro><name>getExternCContextDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>BuiltinTemplateDecl</name> <operator>*</operator><macro><name>getMakeIntegerSeqDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>BuiltinTemplateDecl</name> <operator>*</operator><macro><name>getTypePackElementDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<decl_stmt><decl><type><name>CanQualType</name></type> <name>VoidTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>BoolTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>CharTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>WCharTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>WideCharTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>WIntTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>Char8Ty</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>Char16Ty</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>Char32Ty</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>SignedCharTy</name></decl>, <decl><type ref="prev"/><name>ShortTy</name></decl>, <decl><type ref="prev"/><name>IntTy</name></decl>, <decl><type ref="prev"/><name>LongTy</name></decl>, <decl><type ref="prev"/><name>LongLongTy</name></decl>, <decl><type ref="prev"/><name>Int128Ty</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>UnsignedCharTy</name></decl>, <decl><type ref="prev"/><name>UnsignedShortTy</name></decl>, <decl><type ref="prev"/><name>UnsignedIntTy</name></decl>, <decl><type ref="prev"/><name>UnsignedLongTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>UnsignedLongLongTy</name></decl>, <decl><type ref="prev"/><name>UnsignedInt128Ty</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>FloatTy</name></decl>, <decl><type ref="prev"/><name>DoubleTy</name></decl>, <decl><type ref="prev"/><name>LongDoubleTy</name></decl>, <decl><type ref="prev"/><name>Float128Ty</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>ShortAccumTy</name></decl>, <decl><type ref="prev"/><name>AccumTy</name></decl>,
<decl><type ref="prev"/><name>LongAccumTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>UnsignedShortAccumTy</name></decl>, <decl><type ref="prev"/><name>UnsignedAccumTy</name></decl>, <decl><type ref="prev"/><name>UnsignedLongAccumTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>ShortFractTy</name></decl>, <decl><type ref="prev"/><name>FractTy</name></decl>, <decl><type ref="prev"/><name>LongFractTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>UnsignedShortFractTy</name></decl>, <decl><type ref="prev"/><name>UnsignedFractTy</name></decl>, <decl><type ref="prev"/><name>UnsignedLongFractTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>SatShortAccumTy</name></decl>, <decl><type ref="prev"/><name>SatAccumTy</name></decl>, <decl><type ref="prev"/><name>SatLongAccumTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>SatUnsignedShortAccumTy</name></decl>, <decl><type ref="prev"/><name>SatUnsignedAccumTy</name></decl>,
<decl><type ref="prev"/><name>SatUnsignedLongAccumTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>SatShortFractTy</name></decl>, <decl><type ref="prev"/><name>SatFractTy</name></decl>, <decl><type ref="prev"/><name>SatLongFractTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>SatUnsignedShortFractTy</name></decl>, <decl><type ref="prev"/><name>SatUnsignedFractTy</name></decl>,
<decl><type ref="prev"/><name>SatUnsignedLongFractTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>HalfTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>BFloat16Ty</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>Float16Ty</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>FloatComplexTy</name></decl>, <decl><type ref="prev"/><name>DoubleComplexTy</name></decl>, <decl><type ref="prev"/><name>LongDoubleComplexTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>Float128ComplexTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>VoidPtrTy</name></decl>, <decl><type ref="prev"/><name>NullPtrTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>DependentTy</name></decl>, <decl><type ref="prev"/><name>OverloadTy</name></decl>, <decl><type ref="prev"/><name>BoundMemberTy</name></decl>, <decl><type ref="prev"/><name>UnknownAnyTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>BuiltinFnTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>PseudoObjectTy</name></decl>, <decl><type ref="prev"/><name>ARCUnbridgedCastTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>ObjCBuiltinIdTy</name></decl>, <decl><type ref="prev"/><name>ObjCBuiltinClassTy</name></decl>, <decl><type ref="prev"/><name>ObjCBuiltinSelTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>ObjCBuiltinBoolTy</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMAGE_TYPE</name><parameter_list>(<parameter><type><name>ImgType</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>, <parameter><type><name>SingletonId</name></type></parameter>, <parameter><type><name>Access</name></type></parameter>, <parameter><type><name>Suffix</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CanQualType SingletonId;</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenCLImageTypes.def"</cpp:file></cpp:include>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>OCLSamplerTy</name></decl>, <decl><type ref="prev"/><name>OCLEventTy</name></decl>, <decl><type ref="prev"/><name>OCLClkEventTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>OCLQueueTy</name></decl>, <decl><type ref="prev"/><name>OCLReserveIDTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>IncompleteMatrixIdxTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>OMPArraySectionTy</name></decl>, <decl><type ref="prev"/><name>OMPArrayShapingTy</name></decl>, <decl><type ref="prev"/><name>OMPIteratorTy</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXT_OPAQUE_TYPE</name><parameter_list>(<parameter><type><name>ExtType</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>, <parameter><type><name>Ext</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CanQualType Id##Ty;</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenCLExtensionTypes.def"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVE_TYPE</name><parameter_list>(<parameter><type><name>Name</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>, <parameter><type><name>SingletonId</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CanQualType SingletonId;</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/AArch64SVEACLETypes.def"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PPC_VECTOR_TYPE</name><parameter_list>(<parameter><type><name>Name</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>, <parameter><type><name>Size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CanQualType Id##Ty;</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/PPCTypes.def"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RVV_TYPE</name><parameter_list>(<parameter><type><name>Name</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>, <parameter><type><name>SingletonId</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CanQualType SingletonId;</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/RISCVVTypes.def"</cpp:file></cpp:include>


<decl_stmt><decl><type><name>mutable</name> <name>QualType</name></type> <name>AutoDeductTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mutable</name> <name>QualType</name></type> <name>AutoRRefDeductTy</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>mutable</name> <name>Decl</name> <modifier>*</modifier></type><name>VaListTagDecl</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>mutable</name> <name>TagDecl</name> <modifier>*</modifier></type><name>MSGuidTagDecl</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseSet</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CUDADeviceVarODRUsedByHost</name></expr>;</expr_stmt>

<macro><name>ASTContext</name><argument_list>(<argument>LangOptions &amp;LOpts</argument>, <argument>SourceManager &amp;SM</argument>, <argument>IdentifierTable &amp;idents</argument>,
<argument>SelectorTable &amp;sels</argument>, <argument>Builtin::Context &amp;builtins</argument>,
<argument>TranslationUnitKind TUKind</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>ASTContext</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>~</operator><call><name>ASTContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>






<function_decl><type><name>void</name></type> <name>setExternalSource</name><parameter_list>(<parameter><decl><type><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>ExternalASTSource</name></expr></argument>&gt;</argument_list></name></type> <name>Source</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>ExternalASTSource</name> <operator>*</operator><macro><name>getExternalSource</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>ExternalSource</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>






<function><type><name>void</name></type> <name>setASTMutationListener</name><parameter_list>(<parameter><decl><type><name>ASTMutationListener</name> <modifier>*</modifier></type><name>Listener</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>Listener</name></name> <operator>=</operator> <name>Listener</name></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>ASTMutationListener</name> <operator>*</operator><macro><name>getASTMutationListener</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Listener</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>void</name> <macro><name>PrintStats</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Type</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <macro><name>getTypes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Types</name></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><name>BuiltinTemplateDecl</name> <modifier>*</modifier></type><name>buildBuiltinTemplateDecl</name><argument_list>(<argument><expr><name>BuiltinTemplateKind</name> <name>BTK</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>II</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>RecordDecl</name> <modifier>*</modifier></type><name>buildImplicitRecord</name><argument_list>(<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>,
<argument><expr><name>RecordDecl</name><operator>::</operator><name>TagKind</name> <name>TK</name> <operator>=</operator> <name>TTK_Struct</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>TypedefDecl</name> <modifier>*</modifier></type><name>buildImplicitTypedef</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>, <argument><expr><name>StringRef</name> <name>Name</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>TypedefDecl</name> <operator>*</operator><macro><name>getInt128Decl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>TypedefDecl</name> <operator>*</operator><macro><name>getUInt128Decl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>





<label><name>private</name>:</label>

<decl_stmt><decl><type><name>QualType</name></type> <name>getExtQualType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>Base</name></expr></argument>, <argument><expr><name>Qualifiers</name> <name>Quals</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getTypeDeclTypeSlow</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TypeDecl</name> <operator>*</operator><name>Decl</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getPipeType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>, <argument><expr><name>bool</name> <name>ReadOnly</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<label><name>public</name>:</label>






<decl_stmt><decl><type><name>QualType</name></type> <name>getAddrSpaceQualType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>, <argument><expr><name>LangAS</name> <name>AddressSpace</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<decl_stmt><decl><type><name>QualType</name></type> <name>removeAddrSpaceQualType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>QualType</name></type> <name>applyObjCProtocolQualifiers</name><argument_list>(<argument><expr><name>QualType</name> <name>type</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>protocols</name></expr></argument>, <argument><expr><name>bool</name> <operator>&amp;</operator><name>hasError</name></expr></argument>,
<argument><expr><name>bool</name> <name>allowOnPointerType</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<decl_stmt><decl><type><name>QualType</name></type> <name>getObjCGCQualType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>, <argument><expr><name>Qualifiers</name><operator>::</operator><name>GC</name> <name>gcAttr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>removePtrSizeAddrSpace</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<decl_stmt><decl><type><name>QualType</name></type> <name>getRestrictType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>T</name><operator>.</operator><name>withFastQualifiers</name></name><argument_list>(<argument><expr><name>Qualifiers</name><operator>::</operator><name>Restrict</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>






<decl_stmt><decl><type><name>QualType</name></type> <name>getVolatileType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>T</name><operator>.</operator><name>withFastQualifiers</name></name><argument_list>(<argument><expr><name>Qualifiers</name><operator>::</operator><name>Volatile</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>








<decl_stmt><decl><type><name>QualType</name></type> <name>getConstType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><call><name><name>T</name><operator>.</operator><name>withConst</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>FunctionType</name> <modifier>*</modifier></type><name>adjustFunctionType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionType</name> <operator>*</operator><name>Fn</name></expr></argument>,
<argument><expr><name>FunctionType</name><operator>::</operator><name>ExtInfo</name> <name>EInfo</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>CanQualType</name></type> <name>getCanonicalFunctionResultType</name><argument_list>(<argument><expr><name>QualType</name> <name>ResultType</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>adjustDeducedFunctionResultType</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ResultType</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name>QualType</name></type> <name>getFunctionTypeWithExceptionSpec</name><argument_list>(
<argument><expr><name>QualType</name> <name>Orig</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>FunctionProtoType</name><operator>::</operator><name>ExceptionSpecInfo</name> <operator>&amp;</operator><name>ESI</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>bool</name></type> <name>hasSameFunctionTypeIgnoringExceptionSpec</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>U</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>void</name></type> <name>adjustExceptionSpec</name><argument_list>(<argument><expr><name>FunctionDecl</name> <operator>*</operator><name>FD</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionProtoType</name><operator>::</operator><name>ExceptionSpecInfo</name> <operator>&amp;</operator><name>ESI</name></expr></argument>,
<argument><expr><name>bool</name> <name>AsWritten</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<function_decl><type><name>QualType</name></type> <name>getFunctionTypeWithoutPtrSizes</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>hasSameFunctionTypeIgnoringPtrSizes</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>U</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>QualType</name></type> <name>getComplexType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>getComplexType</name><argument_list>(<argument><expr><name>CanQualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>CanQualType</name><operator>::</operator><call><name>CreateUnsafe</name><argument_list>(<argument><expr><call><name>getComplexType</name><argument_list>(<argument><expr><operator>(</operator><name>QualType</name><operator>)</operator> <name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getPointerType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>getPointerType</name><argument_list>(<argument><expr><name>CanQualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>CanQualType</name><operator>::</operator><call><name>CreateUnsafe</name><argument_list>(<argument><expr><call><name>getPointerType</name><argument_list>(<argument><expr><operator>(</operator><name>QualType</name><operator>)</operator> <name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getAdjustedType</name><argument_list>(<argument><expr><name>QualType</name> <name>Orig</name></expr></argument>, <argument><expr><name>QualType</name> <name>New</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>getAdjustedType</name><argument_list>(<argument><expr><name>CanQualType</name> <name>Orig</name></expr></argument>, <argument><expr><name>CanQualType</name> <name>New</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>CanQualType</name><operator>::</operator><call><name>CreateUnsafe</name><argument_list>(
<argument><expr><call><name>getAdjustedType</name><argument_list>(<argument><expr><operator>(</operator><name>QualType</name><operator>)</operator><name>Orig</name></expr></argument>, <argument><expr><operator>(</operator><name>QualType</name><operator>)</operator><name>New</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name>QualType</name></type> <name>getDecayedType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>getDecayedType</name><argument_list>(<argument><expr><name>CanQualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>CanQualType</name><operator>::</operator><call><name>CreateUnsafe</name><argument_list>(<argument><expr><call><name>getDecayedType</name><argument_list>(<argument><expr><operator>(</operator><name>QualType</name><operator>)</operator> <name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getAtomicType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getBlockPointerType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<expr_stmt><expr><name>QualType</name> <macro><name>getBlockDescriptorType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>getReadPipeType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>getWritePipeType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getExtIntType</name><argument_list>(<argument><expr><name>bool</name> <name>Unsigned</name></expr></argument>, <argument><expr><name>unsigned</name> <name>NumBits</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getDependentExtIntType</name><argument_list>(<argument><expr><name>bool</name> <name>Unsigned</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>BitsExpr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<expr_stmt><expr><name>QualType</name> <macro><name>getBlockDescriptorExtendedType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<decl_stmt><decl><type><name>OpenCLTypeKind</name></type> <name>getOpenCLTypeKind</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>LangAS</name></type> <name>getOpenCLTypeAddrSpace</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function><type><name>void</name></type> <name>setcudaConfigureCallDecl</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>cudaConfigureCallDecl</name> <operator>=</operator> <name>FD</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>getcudaConfigureCallDecl</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><name>cudaConfigureCallDecl</name></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name>bool</name></type> <name>BlockRequiresCopying</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>bool</name></type> <name>getByrefLifetime</name><argument_list>(<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>,
<argument><expr><name>Qualifiers</name><operator>::</operator><name>ObjCLifetime</name> <operator>&amp;</operator><name>Lifetime</name></expr></argument>,
<argument><expr><name>bool</name> <operator>&amp;</operator><name>HasByrefExtendedLayout</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getLValueReferenceType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>, <argument><expr><name>bool</name> <name>SpelledAsLValue</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list>
const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getRValueReferenceType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>QualType</name></type> <name>getMemberPointerType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>Cls</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getVariableArrayType</name><argument_list>(<argument><expr><name>QualType</name> <name>EltTy</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>NumElts</name></expr></argument>,
<argument><expr><name>ArrayType</name><operator>::</operator><name>ArraySizeModifier</name> <name>ASM</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>IndexTypeQuals</name></expr></argument>,
<argument><expr><name>SourceRange</name> <name>Brackets</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<decl_stmt><decl><type><name>QualType</name></type> <name>getDependentSizedArrayType</name><argument_list>(<argument><expr><name>QualType</name> <name>EltTy</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>NumElts</name></expr></argument>,
<argument><expr><name>ArrayType</name><operator>::</operator><name>ArraySizeModifier</name> <name>ASM</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>IndexTypeQuals</name></expr></argument>,
<argument><expr><name>SourceRange</name> <name>Brackets</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getIncompleteArrayType</name><argument_list>(<argument><expr><name>QualType</name> <name>EltTy</name></expr></argument>,
<argument><expr><name>ArrayType</name><operator>::</operator><name>ArraySizeModifier</name> <name>ASM</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>IndexTypeQuals</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getConstantArrayType</name><argument_list>(<argument><expr><name>QualType</name> <name>EltTy</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>APInt</name> <operator>&amp;</operator><name>ArySize</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>SizeExpr</name></expr></argument>,
<argument><expr><name>ArrayType</name><operator>::</operator><name>ArraySizeModifier</name> <name>ASM</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>IndexTypeQuals</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getStringLiteralArrayType</name><argument_list>(<argument><expr><name>QualType</name> <name>EltTy</name></expr></argument>, <argument><expr><name>unsigned</name> <name>Length</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>getVariableArrayDecayedType</name><argument_list>(<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<struct>struct <name>BuiltinVectorTypeInfo</name> <block>{
<decl_stmt><decl><type><name>QualType</name></type> <name>ElementType</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>ElementCount</name> <name>EC</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumVectors</name></decl>;</decl_stmt>
<macro><name>BuiltinVectorTypeInfo</name><argument_list>(<argument>QualType ElementType</argument>, <argument>llvm::ElementCount EC</argument>,
<argument>unsigned NumVectors</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>ElementType</name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>EC</name><argument_list>(<argument><expr><name>EC</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>NumVectors</name><argument_list>(<argument>NumVectors</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>



<decl_stmt><decl><type><name>BuiltinVectorTypeInfo</name></type>
<name>getBuiltinVectorTypeInfo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>BuiltinType</name> <operator>*</operator><name>VecTy</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>QualType</name></type> <name>getScalableVectorType</name><argument_list>(<argument><expr><name>QualType</name> <name>EltTy</name></expr></argument>, <argument><expr><name>unsigned</name> <name>NumElts</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>QualType</name></type> <name>getVectorType</name><argument_list>(<argument><expr><name>QualType</name> <name>VectorType</name></expr></argument>, <argument><expr><name>unsigned</name> <name>NumElts</name></expr></argument>,
<argument><expr><name>VectorType</name><operator>::</operator><name>VectorKind</name> <name>VecKind</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>getDependentVectorType</name><argument_list>(<argument><expr><name>QualType</name> <name>VectorType</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>SizeExpr</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>AttrLoc</name></expr></argument>,
<argument><expr><name>VectorType</name><operator>::</operator><name>VectorKind</name> <name>VecKind</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>QualType</name></type> <name>getExtVectorType</name><argument_list>(<argument><expr><name>QualType</name> <name>VectorType</name></expr></argument>, <argument><expr><name>unsigned</name> <name>NumElts</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<decl_stmt><decl><type><name>QualType</name></type> <name>getDependentSizedExtVectorType</name><argument_list>(<argument><expr><name>QualType</name> <name>VectorType</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>SizeExpr</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>AttrLoc</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<decl_stmt><decl><type><name>QualType</name></type> <name>getConstantMatrixType</name><argument_list>(<argument><expr><name>QualType</name> <name>ElementType</name></expr></argument>, <argument><expr><name>unsigned</name> <name>NumRows</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>NumColumns</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getDependentSizedMatrixType</name><argument_list>(<argument><expr><name>QualType</name> <name>ElementType</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>RowExpr</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>ColumnExpr</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>AttrLoc</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getDependentAddressSpaceType</name><argument_list>(<argument><expr><name>QualType</name> <name>PointeeType</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>AddrSpaceExpr</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>AttrLoc</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>getFunctionNoProtoType</name><argument_list>(<argument><expr><name>QualType</name> <name>ResultTy</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionType</name><operator>::</operator><name>ExtInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getFunctionNoProtoType</name><argument_list>(<argument><expr><name>QualType</name> <name>ResultTy</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getFunctionNoProtoType</name><argument_list>(<argument><expr><name>ResultTy</name></expr></argument>, <argument><expr><name>FunctionType</name><operator>::</operator><call><name>ExtInfo</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>getFunctionType</name><argument_list>(<argument><expr><name>QualType</name> <name>ResultTy</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionProtoType</name><operator>::</operator><name>ExtProtoInfo</name> <operator>&amp;</operator><name>EPI</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getFunctionTypeInternal</name><argument_list>(<argument><expr><name>ResultTy</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>, <argument><expr><name>EPI</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>adjustStringLiteralBaseType</name><argument_list>(<argument><expr><name>QualType</name> <name>StrLTy</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>QualType</name></type> <name>getFunctionTypeInternal</name><argument_list>(<argument><expr><name>QualType</name> <name>ResultTy</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionProtoType</name><operator>::</operator><name>ExtProtoInfo</name> <operator>&amp;</operator><name>EPI</name></expr></argument>,
<argument><expr><name>bool</name> <name>OnlyWantCanonical</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<label><name>public</name>:</label>


<decl_stmt><decl><type><name>QualType</name></type> <name>getTypeDeclType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TypeDecl</name> <operator>*</operator><name>Decl</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TypeDecl</name> <operator>*</operator><name>PrevDecl</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>Decl</name> <operator>&amp;&amp;</operator> <literal type="string">"Passed null for Decl param"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>Decl</name><operator>-&gt;</operator><name>TypeForDecl</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name><name>Decl</name><operator>-&gt;</operator><name>TypeForDecl</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>PrevDecl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>PrevDecl</name><operator>-&gt;</operator><name>TypeForDecl</name></name> <operator>&amp;&amp;</operator> <literal type="string">"previous decl has no TypeForDecl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Decl</name><operator>-&gt;</operator><name>TypeForDecl</name></name> <operator>=</operator> <name><name>PrevDecl</name><operator>-&gt;</operator><name>TypeForDecl</name></name></expr>;</expr_stmt>
<return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name><name>PrevDecl</name><operator>-&gt;</operator><name>TypeForDecl</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>getTypeDeclTypeSlow</name><argument_list>(<argument><expr><name>Decl</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getTypedefType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TypedefNameDecl</name> <operator>*</operator><name>Decl</name></expr></argument>,
<argument><expr><name>QualType</name> <name>Underlying</name> <operator>=</operator> <call><name>QualType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getRecordType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RecordDecl</name> <operator>*</operator><name>Decl</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getEnumType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>EnumDecl</name> <operator>*</operator><name>Decl</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getInjectedClassNameType</name><argument_list>(<argument><expr><name>CXXRecordDecl</name> <operator>*</operator><name>Decl</name></expr></argument>, <argument><expr><name>QualType</name> <name>TST</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getAttributedType</name><argument_list>(<argument><expr><name>attr</name><operator>::</operator><name>Kind</name> <name>attrKind</name></expr></argument>,
<argument><expr><name>QualType</name> <name>modifiedType</name></expr></argument>,
<argument><expr><name>QualType</name> <name>equivalentType</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getSubstTemplateTypeParmType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TemplateTypeParmType</name> <operator>*</operator><name>Replaced</name></expr></argument>,
<argument><expr><name>QualType</name> <name>Replacement</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<function_decl><type><name>QualType</name></type> <name>getSubstTemplateTypeParmPackType</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>TemplateTypeParmType</name> <modifier>*</modifier></type><name>Replaced</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgument</name> <modifier>&amp;</modifier></type><name>ArgPack</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>QualType</name></type>
<name>getTemplateTypeParmType</name><argument_list>(<argument><expr><name>unsigned</name> <name>Depth</name></expr></argument>, <argument><expr><name>unsigned</name> <name>Index</name></expr></argument>,
<argument><expr><name>bool</name> <name>ParameterPack</name></expr></argument>,
<argument><expr><name>TemplateTypeParmDecl</name> <operator>*</operator><name>ParmDecl</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getTemplateSpecializationType</name><argument_list>(<argument><expr><name>TemplateName</name> <name>T</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><name>QualType</name> <name>Canon</name> <operator>=</operator> <call><name>QualType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type>
<name>getCanonicalTemplateSpecializationType</name><argument_list>(<argument><expr><name>TemplateName</name> <name>T</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getTemplateSpecializationType</name><argument_list>(<argument><expr><name>TemplateName</name> <name>T</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <operator>&amp;</operator><name>Args</name></expr></argument>,
<argument><expr><name>QualType</name> <name>Canon</name> <operator>=</operator> <call><name>QualType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type>
<name>getTemplateSpecializationTypeInfo</name><argument_list>(<argument><expr><name>TemplateName</name> <name>T</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>TLoc</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <operator>&amp;</operator><name>Args</name></expr></argument>,
<argument><expr><name>QualType</name> <name>Canon</name> <operator>=</operator> <call><name>QualType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getParenType</name><argument_list>(<argument><expr><name>QualType</name> <name>NamedType</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getMacroQualifiedType</name><argument_list>(<argument><expr><name>QualType</name> <name>UnderlyingTy</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>MacroII</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getElaboratedType</name><argument_list>(<argument><expr><name>ElaboratedTypeKeyword</name> <name>Keyword</name></expr></argument>,
<argument><expr><name>NestedNameSpecifier</name> <operator>*</operator><name>NNS</name></expr></argument>, <argument><expr><name>QualType</name> <name>NamedType</name></expr></argument>,
<argument><expr><name>TagDecl</name> <operator>*</operator><name>OwnedTagDecl</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>getDependentNameType</name><argument_list>(<argument><expr><name>ElaboratedTypeKeyword</name> <name>Keyword</name></expr></argument>,
<argument><expr><name>NestedNameSpecifier</name> <operator>*</operator><name>NNS</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>Name</name></expr></argument>,
<argument><expr><name>QualType</name> <name>Canon</name> <operator>=</operator> <call><name>QualType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getDependentTemplateSpecializationType</name><argument_list>(<argument><expr><name>ElaboratedTypeKeyword</name> <name>Keyword</name></expr></argument>,
<argument><expr><name>NestedNameSpecifier</name> <operator>*</operator><name>NNS</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>Name</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <operator>&amp;</operator><name>Args</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>getDependentTemplateSpecializationType</name><argument_list>(
<argument><expr><name>ElaboratedTypeKeyword</name> <name>Keyword</name></expr></argument>, <argument><expr><name>NestedNameSpecifier</name> <operator>*</operator><name>NNS</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>Name</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function_decl><type><name>TemplateArgument</name></type> <name>getInjectedTemplateArg</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ParamDecl</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>getInjectedTemplateArgs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateParameterList</name> <modifier>*</modifier></type><name>Params</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Args</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>QualType</name></type> <name>getPackExpansionType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Pattern</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ExpectPackInType</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>QualType</name></type> <name>getObjCInterfaceType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><name>Decl</name></expr></argument>,
<argument><expr><name>ObjCInterfaceDecl</name> <operator>*</operator><name>PrevDecl</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>getObjCObjectType</name><argument_list>(<argument><expr><name>QualType</name> <name>Base</name></expr></argument>,
<argument><expr><name>ObjCProtocolDecl</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><name>Protocols</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>NumProtocols</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getObjCObjectType</name><argument_list>(<argument><expr><name>QualType</name> <name>Base</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <name>typeArgs</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>protocols</name></expr></argument>,
<argument><expr><name>bool</name> <name>isKindOf</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getObjCTypeParamType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCTypeParamDecl</name> <operator>*</operator><name>Decl</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>protocols</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>adjustObjCTypeParamBoundType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCTypeParamDecl</name> <operator>*</operator><name>Orig</name></expr></argument>,
<argument><expr><name>ObjCTypeParamDecl</name> <operator>*</operator><name>New</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function_decl><type><name>bool</name></type> <name>ObjCObjectAdoptsQTypeProtocols</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>QT</name></decl></parameter>, <parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>QIdProtocolsAdoptObjCObjectProtocols</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>QT</name></decl></parameter>,
<parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>IDecl</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>QualType</name></type> <name>getObjCObjectPointerType</name><argument_list>(<argument><expr><name>QualType</name> <name>OIT</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>getTypeOfExprType</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>e</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>getTypeOfType</name><argument_list>(<argument><expr><name>QualType</name> <name>t</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>getDecltypeType</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>e</name></expr></argument>, <argument><expr><name>QualType</name> <name>UnderlyingType</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>getUnaryTransformType</name><argument_list>(<argument><expr><name>QualType</name> <name>BaseType</name></expr></argument>, <argument><expr><name>QualType</name> <name>UnderlyingType</name></expr></argument>,
<argument><expr><name>UnaryTransformType</name><operator>::</operator><name>UTTKind</name> <name>UKind</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>getAutoType</name><argument_list>(<argument><expr><name>QualType</name> <name>DeducedType</name></expr></argument>, <argument><expr><name>AutoTypeKeyword</name> <name>Keyword</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsDependent</name></expr></argument>, <argument><expr><name>bool</name> <name>IsPack</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>ConceptDecl</name> <operator>*</operator><name>TypeConstraintConcept</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>TypeConstraintArgs</name> <operator>=</operator><block>{}</block></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>QualType</name> <macro><name>getAutoDeductType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>QualType</name> <macro><name>getAutoRRefDeductType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>getDeducedTemplateSpecializationType</name><argument_list>(<argument><expr><name>TemplateName</name> <name>Template</name></expr></argument>,
<argument><expr><name>QualType</name> <name>DeducedType</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsDependent</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getTagDeclType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TagDecl</name> <operator>*</operator><name>Decl</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<expr_stmt><expr><name>CanQualType</name> <macro><name>getSizeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>CanQualType</name> <macro><name>getSignedSizeType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>CanQualType</name> <macro><name>getIntMaxType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>CanQualType</name> <macro><name>getUIntMaxType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>QualType</name> <macro><name>getWCharType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>WCharTy</name></expr>;</return> }</block></expr></expr_stmt>




<expr_stmt><expr><name>QualType</name> <macro><name>getWideCharType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>WideCharTy</name></expr>;</return> }</block></expr></expr_stmt>




<expr_stmt><expr><name>QualType</name> <macro><name>getSignedWCharType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>QualType</name> <macro><name>getUnsignedWCharType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>QualType</name> <macro><name>getWIntType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>WIntTy</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>QualType</name> <macro><name>getIntPtrType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>QualType</name> <macro><name>getUIntPtrType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>QualType</name> <macro><name>getPointerDiffType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>QualType</name> <macro><name>getUnsignedPointerDiffType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>QualType</name> <macro><name>getProcessIDType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>QualType</name> <macro><name>getCFConstantStringType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>QualType</name> <macro><name>getObjCSuperType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<function><type><name>void</name></type> <name>setObjCSuperType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>ST</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>ObjCSuperType</name> <operator>=</operator> <name>ST</name></expr>;</expr_stmt> </block_content>}</block></function>



<expr_stmt><expr><name>QualType</name> <macro><name>getRawCFConstantStringType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>CFConstantStringTypeDecl</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getTypedefType</name><argument_list>(<argument><expr><name>CFConstantStringTypeDecl</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return>
}
void <macro><name>setCFConstantStringType</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><name>TypedefDecl</name> <operator>*</operator><macro><name>getCFConstantStringDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>RecordDecl</name> <operator>*</operator><macro><name>getCFConstantStringTagDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<function_decl><type><name>void</name></type> <name>setObjCConstantStringInterface</name><parameter_list>(<parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>QualType</name> <macro><name>getObjCConstantStringInterface</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ObjCConstantStringType</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>QualType</name> <macro><name>getObjCNSStringType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ObjCNSStringType</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setObjCNSStringType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>ObjCNSStringType</name> <operator>=</operator> <name>T</name></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>QualType</name> <macro><name>getObjCIdRedefinitionType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>ObjCIdRedefinitionType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getObjCIdType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>ObjCIdRedefinitionType</name></expr>;</return>
}


void <macro><name>setObjCIdRedefinitionType</name><argument_list>(<argument>QualType RedefType</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>ObjCIdRedefinitionType</name> <operator>=</operator> <name>RedefType</name></expr>;</expr_stmt>
</block_content>}</block>



<expr_stmt><expr><name>QualType</name> <macro><name>getObjCClassRedefinitionType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>ObjCClassRedefinitionType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getObjCClassType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>ObjCClassRedefinitionType</name></expr>;</return>
}


void <macro><name>setObjCClassRedefinitionType</name><argument_list>(<argument>QualType RedefType</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>ObjCClassRedefinitionType</name> <operator>=</operator> <name>RedefType</name></expr>;</expr_stmt>
</block_content>}</block>



<expr_stmt><expr><name>QualType</name> <macro><name>getObjCSelRedefinitionType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>ObjCSelRedefinitionType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getObjCSelType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>ObjCSelRedefinitionType</name></expr>;</return>
}


void <macro><name>setObjCSelRedefinitionType</name><argument_list>(<argument>QualType RedefType</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>ObjCSelRedefinitionType</name> <operator>=</operator> <name>RedefType</name></expr>;</expr_stmt>
</block_content>}</block>


<expr_stmt><expr><name>IdentifierInfo</name> <operator>*</operator><macro><name>getNSObjectName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NSObjectName</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>NSObjectName</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>Idents</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"NSObject"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>

<return>return <expr><name>NSObjectName</name></expr>;</return>
}


IdentifierInfo <expr_stmt><expr><operator>*</operator><macro><name>getNSCopyingName</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NSCopyingName</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>NSCopyingName</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>Idents</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"NSCopying"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>

<return>return <expr><name>NSCopyingName</name></expr>;</return>
}

CanQualType <macro><name>getNSUIntegerType</name><argument_list>()</argument_list></macro> <decl_stmt><decl><type><specifier>const</specifier></type></decl>;</decl_stmt>

<expr_stmt><expr><name>CanQualType</name> <macro><name>getNSIntegerType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>IdentifierInfo</name> <operator>*</operator><macro><name>getBoolName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>BoolName</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>BoolName</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>Idents</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"bool"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>BoolName</name></expr>;</return>
}

IdentifierInfo <expr_stmt><expr><operator>*</operator><macro><name>getMakeIntegerSeqName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>MakeIntegerSeqName</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>MakeIntegerSeqName</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>Idents</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"__make_integer_seq"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>MakeIntegerSeqName</name></expr>;</return>
}

IdentifierInfo <expr_stmt><expr><operator>*</operator><macro><name>getTypePackElementName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TypePackElementName</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>TypePackElementName</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>Idents</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"__type_pack_element"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>TypePackElementName</name></expr>;</return>
}



QualType <macro><name>getObjCInstanceType</name><argument_list>()</argument_list></macro> <block>{<block_content>
<return>return <expr><call><name>getTypeDeclType</name><argument_list>(<argument><expr><call><name>getObjCInstanceTypeDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>



<function_decl><type><name>TypedefDecl</name> <modifier>*</modifier></type><name>getObjCInstanceTypeDecl</name><parameter_list>()</parameter_list>;</function_decl>


<function><type><name>void</name></type> <name>setFILEDecl</name><parameter_list>(<parameter><decl><type><name>TypeDecl</name> <modifier>*</modifier></type><name>FILEDecl</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>FILEDecl</name></name> <operator>=</operator> <name>FILEDecl</name></expr>;</expr_stmt> </block_content>}</block></function>


<expr_stmt><expr><name>QualType</name> <macro><name>getFILEType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>FILEDecl</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getTypeDeclType</name><argument_list>(<argument><expr><name>FILEDecl</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return>
}


void <macro><name>setjmp_bufDecl</name><argument_list>(<argument>TypeDecl *jmp_bufDecl</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>jmp_bufDecl</name></name> <operator>=</operator> <name>jmp_bufDecl</name></expr>;</expr_stmt>
</block_content>}</block>


<expr_stmt><expr><name>QualType</name> <macro><name>getjmp_bufType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>jmp_bufDecl</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getTypeDeclType</name><argument_list>(<argument><expr><name>jmp_bufDecl</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return>
}


void <macro><name>setsigjmp_bufDecl</name><argument_list>(<argument>TypeDecl *sigjmp_bufDecl</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>sigjmp_bufDecl</name></name> <operator>=</operator> <name>sigjmp_bufDecl</name></expr>;</expr_stmt>
</block_content>}</block>


<expr_stmt><expr><name>QualType</name> <macro><name>getsigjmp_bufType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>sigjmp_bufDecl</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getTypeDeclType</name><argument_list>(<argument><expr><name>sigjmp_bufDecl</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return>
}


void <macro><name>setucontext_tDecl</name><argument_list>(<argument>TypeDecl *ucontext_tDecl</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>ucontext_tDecl</name></name> <operator>=</operator> <name>ucontext_tDecl</name></expr>;</expr_stmt>
</block_content>}</block>


<expr_stmt><expr><name>QualType</name> <macro><name>getucontext_tType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>ucontext_tDecl</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getTypeDeclType</name><argument_list>(<argument><expr><name>ucontext_tDecl</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return>
}


QualType <macro><name>getLogicalOperationType</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<return>return <expr><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>CPlusPlus</name> <operator>?</operator> <name>BoolTy</name> <operator>:</operator> <name>IntTy</name></expr>;</return>
}</block></expr></expr_stmt>





<decl_stmt><decl><type><name>void</name></type> <name>getObjCEncodingForType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>S</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><name>Field</name><operator>=</operator><name>nullptr</name></expr></argument>,
<argument><expr><name>QualType</name> <operator>*</operator><name>NotEncodedT</name><operator>=</operator><name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>getObjCEncodingForPropertyType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>S</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>getLegacyIntegralTypeEncoding</name><argument_list>(<argument><expr><name>QualType</name> <operator>&amp;</operator><name>t</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>getObjCEncodingForTypeQualifier</name><argument_list>(<argument><expr><name>Decl</name><operator>::</operator><name>ObjCDeclQualifier</name> <name>QT</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>S</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>







<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getObjCEncodingForFunctionDecl</name><argument_list>(<argument>const FunctionDecl *Decl</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getObjCEncodingForMethodDecl</name><argument_list>(<argument>const ObjCMethodDecl *Decl</argument>,
<argument>bool Extended = false</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getObjCEncodingForBlock</name><argument_list>(<argument>const BlockExpr *blockExpr</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>





<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getObjCEncodingForPropertyDecl</name><argument_list>(<argument>const ObjCPropertyDecl *PD</argument>,
<argument>const Decl *Container</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>ProtocolCompatibleWithProtocol</name><argument_list>(<argument><expr><name>ObjCProtocolDecl</name> <operator>*</operator><name>lProto</name></expr></argument>,
<argument><expr><name>ObjCProtocolDecl</name> <operator>*</operator><name>rProto</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>ObjCPropertyImplDecl</name> <modifier>*</modifier></type><name>getObjCPropertyImplDeclForPropertyDecl</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>ObjCPropertyDecl</name> <operator>*</operator><name>PD</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>Container</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>CharUnits</name></type> <name>getObjCEncodingTypeSize</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<expr_stmt><expr><name>TypedefDecl</name> <operator>*</operator><macro><name>getObjCIdDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>





<expr_stmt><expr><name>QualType</name> <macro><name>getObjCIdType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypeDeclType</name><argument_list>(<argument><expr><call><name>getObjCIdDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>TypedefDecl</name> <operator>*</operator><macro><name>getObjCSelDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>QualType</name> <macro><name>getObjCSelType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypeDeclType</name><argument_list>(<argument><expr><call><name>getObjCSelDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>TypedefDecl</name> <operator>*</operator><macro><name>getObjCClassDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>





<expr_stmt><expr><name>QualType</name> <macro><name>getObjCClassType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypeDeclType</name><argument_list>(<argument><expr><call><name>getObjCClassDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>ObjCInterfaceDecl</name> <operator>*</operator><macro><name>getObjCProtocolDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>TypedefDecl</name> <operator>*</operator><macro><name>getBOOLDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>BOOLDecl</name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setBOOLDecl</name><parameter_list>(<parameter><decl><type><name>TypedefDecl</name> <modifier>*</modifier></type><name>TD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>BOOLDecl</name> <operator>=</operator> <name>TD</name></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>QualType</name> <macro><name>getBOOLType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypeDeclType</name><argument_list>(<argument><expr><call><name>getBOOLDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>QualType</name> <macro><name>getObjCProtoType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getObjCInterfaceType</name><argument_list>(<argument><expr><call><name>getObjCProtocolDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>TypedefDecl</name> <operator>*</operator><macro><name>getBuiltinVaListDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>QualType</name> <macro><name>getBuiltinVaListType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypeDeclType</name><argument_list>(<argument><expr><call><name>getBuiltinVaListDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>Decl</name> <operator>*</operator><macro><name>getVaListTagDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>TypedefDecl</name> <operator>*</operator><macro><name>getBuiltinMSVaListDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>QualType</name> <macro><name>getBuiltinMSVaListType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypeDeclType</name><argument_list>(<argument><expr><call><name>getBuiltinMSVaListDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>TagDecl</name> <operator>*</operator><macro><name>getMSGuidTagDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MSGuidTagDecl</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>QualType</name> <macro><name>getMSGuidType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>MSGuidTagDecl</name> <operator>&amp;&amp;</operator> <literal type="string">"asked for GUID type but MS extensions disabled"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getTagDeclType</name><argument_list>(<argument><expr><name>MSGuidTagDecl</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>canBuiltinBeRedeclared</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getCVRQualifiedType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>, <argument><expr><name>unsigned</name> <name>CVR</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getQualifiedType</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>Qualifiers</name><operator>::</operator><call><name>fromCVRMask</name><argument_list>(<argument><expr><name>CVR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>getQualifiedType</name><argument_list>(<argument><expr><name>SplitQualType</name> <name>split</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getQualifiedType</name><argument_list>(<argument><expr><name><name>split</name><operator>.</operator><name>Ty</name></name></expr></argument>, <argument><expr><name><name>split</name><operator>.</operator><name>Quals</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>getQualifiedType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>, <argument><expr><name>Qualifiers</name> <name>Qs</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Qs</name><operator>.</operator><name>hasNonFastQualifiers</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>T</name><operator>.</operator><name>withFastQualifiers</name></name><argument_list>(<argument><expr><call><name><name>Qs</name><operator>.</operator><name>getFastQualifiers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<function_decl><type><name>QualifierCollector</name></type> <name>Qc</name><parameter_list>(<parameter><decl><type><name>Qs</name></type></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>const</specifier> <name>Type</name> <modifier>*</modifier></type><name>Ptr</name> <init>= <expr><call><name><name>Qc</name><operator>.</operator><name>strip</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>getExtQualType</name><argument_list>(<argument><expr><name>Ptr</name></expr></argument>, <argument><expr><name>Qc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>getQualifiedType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name></expr></argument>, <argument><expr><name>Qualifiers</name> <name>Qs</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Qs</name><operator>.</operator><name>hasNonFastQualifiers</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><call><name><name>Qs</name><operator>.</operator><name>getFastQualifiers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getExtQualType</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>Qs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name>QualType</name></type> <name>getLifetimeQualifiedType</name><argument_list>(<argument><expr><name>QualType</name> <name>type</name></expr></argument>,
<argument><expr><name>Qualifiers</name><operator>::</operator><name>ObjCLifetime</name> <name>lifetime</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>type</name><operator>.</operator><name>getObjCLifetime</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Qualifiers</name><operator>::</operator><name>OCL_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lifetime</name> <operator>!=</operator> <name>Qualifiers</name><operator>::</operator><name>OCL_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>Qualifiers</name></type> <name>qs</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>qs</name><operator>.</operator><name>addObjCLifetime</name></name><argument_list>(<argument><expr><name>lifetime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>getQualifiedType</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>qs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getUnqualifiedObjCPointerType</name><argument_list>(<argument><expr><name>QualType</name> <name>type</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>type</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isObjCObjectPointerType</name><argument_list>()</argument_list></call> <operator>||</operator>
<operator>!</operator><call><name><name>type</name><operator>.</operator><name>getQualifiers</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasObjCLifetime</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>type</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>Qualifiers</name></type> <name>Qs</name> <init>= <expr><call><name><name>type</name><operator>.</operator><name>getQualifiers</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Qs</name><operator>.</operator><name>removeObjCLifetime</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>getQualifiedType</name><argument_list>(<argument><expr><call><name><name>type</name><operator>.</operator><name>getUnqualifiedType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Qs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>getFixedPointScale</name><argument_list>(<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>getFixedPointIBits</name><argument_list>(<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FixedPointSemantics</name> <macro><name>getFixedPointSemantics</name><argument_list>(<argument>QualType Ty</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>APFixedPoint</name> <macro><name>getFixedPointMax</name><argument_list>(<argument>QualType Ty</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>APFixedPoint</name> <macro><name>getFixedPointMin</name><argument_list>(<argument>QualType Ty</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<decl_stmt><decl><type><name>DeclarationNameInfo</name></type> <name>getNameForTemplate</name><argument_list>(<argument><expr><name>TemplateName</name> <name>Name</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>NameLoc</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>TemplateName</name></type> <name>getOverloadedTemplateName</name><argument_list>(<argument><expr><name>UnresolvedSetIterator</name> <name>Begin</name></expr></argument>,
<argument><expr><name>UnresolvedSetIterator</name> <name>End</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>TemplateName</name></type> <name>getAssumedTemplateName</name><argument_list>(<argument><expr><name>DeclarationName</name> <name>Name</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>TemplateName</name></type> <name>getQualifiedTemplateName</name><argument_list>(<argument><expr><name>NestedNameSpecifier</name> <operator>*</operator><name>NNS</name></expr></argument>,
<argument><expr><name>bool</name> <name>TemplateKeyword</name></expr></argument>,
<argument><expr><name>TemplateDecl</name> <operator>*</operator><name>Template</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>TemplateName</name></type> <name>getDependentTemplateName</name><argument_list>(<argument><expr><name>NestedNameSpecifier</name> <operator>*</operator><name>NNS</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>Name</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>TemplateName</name></type> <name>getDependentTemplateName</name><argument_list>(<argument><expr><name>NestedNameSpecifier</name> <operator>*</operator><name>NNS</name></expr></argument>,
<argument><expr><name>OverloadedOperatorKind</name> <name>Operator</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>TemplateName</name></type> <name>getSubstTemplateTemplateParm</name><argument_list>(<argument><expr><name>TemplateTemplateParmDecl</name> <operator>*</operator><name>param</name></expr></argument>,
<argument><expr><name>TemplateName</name> <name>replacement</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>TemplateName</name></type> <name>getSubstTemplateTemplateParmPack</name><argument_list>(<argument><expr><name>TemplateTemplateParmDecl</name> <operator>*</operator><name>Param</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TemplateArgument</name> <operator>&amp;</operator><name>ArgPack</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<enum>enum <name>GetBuiltinTypeError</name> <block>{

<decl><name>GE_None</name></decl>,


<decl><name>GE_Missing_type</name></decl>,


<decl><name>GE_Missing_stdio</name></decl>,


<decl><name>GE_Missing_setjmp</name></decl>,


<decl><name>GE_Missing_ucontext</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><name>QualType</name></type> <name>DecodeTypeStr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>&amp;</operator><name>Str</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>,
<argument><expr><name>ASTContext</name><operator>::</operator><name>GetBuiltinTypeError</name> <operator>&amp;</operator><name>Error</name></expr></argument>,
<argument><expr><name>bool</name> <operator>&amp;</operator><name>RequireICE</name></expr></argument>, <argument><expr><name>bool</name> <name>AllowTypeModifiers</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<decl_stmt><decl><type><name>QualType</name></type> <name>GetBuiltinType</name><argument_list>(<argument><expr><name>unsigned</name> <name>ID</name></expr></argument>, <argument><expr><name>GetBuiltinTypeError</name> <operator>&amp;</operator><name>Error</name></expr></argument>,
<argument><expr><name>unsigned</name> <operator>*</operator><name>IntegerConstantArgs</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>ComparisonCategories</name></type> <name>CompCategories</name></decl>;</decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>getFromTargetType</name><argument_list>(<argument><expr><name>unsigned</name> <name>Type</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>TypeInfo</name></type> <name>getTypeInfoImpl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<label><name>public</name>:</label>


<expr_stmt><expr><name>Qualifiers</name><operator>::</operator><name>GC</name> <macro><name>getObjCGCAttrKind</name><argument_list>(<argument>QualType Ty</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>






<function_decl><type><name>bool</name></type> <name>areCompatibleVectorTypes</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>FirstVec</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>SecondVec</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>areCompatibleSveTypes</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>FirstType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>SecondType</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>areLaxCompatibleSveTypes</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>FirstType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>SecondType</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>bool</name></type> <name>hasDirectOwnershipQualifier</name><argument_list>(<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>isObjCNSObjectType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>Ty</name><operator>-&gt;</operator><name>isObjCNSObjectType</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>







<expr_stmt><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>fltSemantics</name> <operator>&amp;</operator><macro><name>getFloatTypeSemantics</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<decl_stmt><decl><type><name>TypeInfo</name></type> <name>getTypeInfo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>TypeInfo</name></type> <name>getTypeInfo</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><call><name>getTypeInfo</name><argument_list>(<argument><expr><call><name><name>T</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>getOpenMPDefaultSimdAlign</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>getTypeSize</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><call><name>getTypeInfo</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call><operator>.</operator><name>Width</name></expr>;</return> </block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>getTypeSize</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><call><name>getTypeInfo</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call><operator>.</operator><name>Width</name></expr>;</return> </block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name>uint64_t</name> <macro><name>getCharWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypeSize</name><argument_list>(<argument><expr><name>CharTy</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>CharUnits</name></type> <name>toCharUnitsFromBits</name><argument_list>(<argument><expr><name>int64_t</name> <name>BitSize</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>int64_t</name></type> <name>toBits</name><argument_list>(<argument><expr><name>CharUnits</name> <name>CharSize</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>CharUnits</name></type> <name>getTypeSizeInChars</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharUnits</name></type> <name>getTypeSizeInChars</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>CharUnits</name></expr></argument>&gt;</argument_list></name></type> <name>getTypeSizeInCharsIfKnown</name><argument_list>(<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Ty</name><operator>-&gt;</operator><name>isIncompleteType</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>Ty</name><operator>-&gt;</operator><name>isDependentType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>None</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getTypeSizeInChars</name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>CharUnits</name></expr></argument>&gt;</argument_list></name></type> <name>getTypeSizeInCharsIfKnown</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>Ty</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getTypeSizeInCharsIfKnown</name><argument_list>(<argument><expr><call><name>QualType</name><argument_list>(<argument><expr><name>Ty</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>getTypeAlign</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><call><name>getTypeInfo</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call><operator>.</operator><name>Align</name></expr>;</return> </block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>getTypeAlign</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><call><name>getTypeInfo</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call><operator>.</operator><name>Align</name></expr>;</return> </block_content>}</block></decl></decl_stmt>






<decl_stmt><decl><type><name>unsigned</name></type> <name>getTypeUnadjustedAlign</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getTypeUnadjustedAlign</name><argument_list>(<argument><expr><call><name><name>T</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>getTypeUnadjustedAlign</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<decl_stmt><decl><type><name>unsigned</name></type> <name>getTypeAlignIfKnown</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>,
<argument><expr><name>bool</name> <name>NeedsPreferredAlignment</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>CharUnits</name></type> <name>getTypeAlignInChars</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharUnits</name></type> <name>getTypeAlignInChars</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>CharUnits</name></type> <name>getPreferredTypeAlignInChars</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>toCharUnitsFromBits</name><argument_list>(<argument><expr><call><name>getPreferredTypeAlign</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name>CharUnits</name></type> <name>getTypeUnadjustedAlignInChars</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharUnits</name></type> <name>getTypeUnadjustedAlignInChars</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>TypeInfoChars</name></type> <name>getTypeInfoDataSizeInChars</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>TypeInfoChars</name></type> <name>getTypeInfoInChars</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>TypeInfoChars</name></type> <name>getTypeInfoInChars</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isAlignmentRequired</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isAlignmentRequired</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>








<decl_stmt><decl><type><name>unsigned</name></type> <name>getPreferredTypeAlign</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getPreferredTypeAlign</name><argument_list>(<argument><expr><call><name><name>T</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>getPreferredTypeAlign</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getTargetDefaultAlignForAttributeAligned</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>getAlignOfGlobalVar</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>CharUnits</name></type> <name>getAlignOfGlobalVarInChars</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>











<decl_stmt><decl><type><name>CharUnits</name></type> <name>getDeclAlign</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>bool</name> <name>ForAlignof</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<expr_stmt><expr><name>CharUnits</name> <macro><name>getExnObjectAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<decl_stmt><decl><type><specifier>const</specifier> <name>ASTRecordLayout</name> <modifier>&amp;</modifier></type><name>getASTRecordLayout</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RecordDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>ASTRecordLayout</name> <modifier>&amp;</modifier></type><name>getASTObjCInterfaceLayout</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list>
const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>DumpRecordLayout</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>, <argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>,
<argument><expr><name>bool</name> <name>Simple</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><specifier>const</specifier> <name>ASTRecordLayout</name> <modifier>&amp;</modifier></type>
<name>getASTObjCImplementationLayout</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCImplementationDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>











<function_decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>getCurrentKeyFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>void</name></type> <name>setNonKeyFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>method</name></decl></parameter>)</parameter_list>;</function_decl>










<decl_stmt><decl><type><name>CharUnits</name></type> <name>getOffsetOfBaseWithVBPtr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>getFieldOffset</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><name>FD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>lookupFieldBitOffset</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><name>OID</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ObjCImplementationDecl</name> <operator>*</operator><name>ID</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ObjCIvarDecl</name> <operator>*</operator><name>Ivar</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>CharUnits</name></type> <name>getMemberPointerPathAdjustment</name><argument_list>(<argument><expr><specifier>const</specifier> <name>APValue</name> <operator>&amp;</operator><name>MP</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isNearlyEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function_decl><type><name>VTableContextBase</name> <modifier>*</modifier></type><name>getVTableContext</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>MangleContext</name> <modifier>*</modifier></type><name>createMangleContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>*</modifier></type><name>T</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>MangleContext</name> <modifier>*</modifier></type><name>createDeviceMangleContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>&amp;</modifier></type><name>T</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>DeepCollectObjCIvars</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><name>OI</name></expr></argument>, <argument><expr><name>bool</name> <name>leafClass</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ObjCIvarDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Ivars</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>CountNonClassIvars</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><name>OI</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>CollectInheritedProtocols</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>CDecl</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Protocols</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>hasUniqueObjectRepresentations</name><argument_list>(<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>













<decl_stmt><decl><type><name>CanQualType</name></type> <name>getCanonicalType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>CanQualType</name><operator>::</operator><call><name>CreateUnsafe</name><argument_list>(<argument><expr><call><name><name>T</name><operator>.</operator><name>getCanonicalType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>Type</name> <modifier>*</modifier></type><name>getCanonicalType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getCanonicalTypeInternal</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>






<decl_stmt><decl><type><name>CanQualType</name></type> <name>getCanonicalParamType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>hasSameType</name><argument_list>(<argument><expr><name>QualType</name> <name>T1</name></expr></argument>, <argument><expr><name>QualType</name> <name>T2</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getCanonicalType</name><argument_list>(<argument><expr><name>T1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>getCanonicalType</name><argument_list>(<argument><expr><name>T2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>hasSameType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T1</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T2</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getCanonicalType</name><argument_list>(<argument><expr><name>T1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>getCanonicalType</name><argument_list>(<argument><expr><name>T2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>














<function_decl><type><name>QualType</name></type> <name>getUnqualifiedArrayType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>Qualifiers</name> <modifier>&amp;</modifier></type><name>Quals</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>bool</name></type> <name>hasSameUnqualifiedType</name><argument_list>(<argument><expr><name>QualType</name> <name>T1</name></expr></argument>, <argument><expr><name>QualType</name> <name>T2</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getCanonicalType</name><argument_list>(<argument><expr><name>T1</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call> <operator>==</operator>
<call><name>getCanonicalType</name><argument_list>(<argument><expr><name>T2</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>hasSameNullabilityTypeQualifier</name><argument_list>(<argument><expr><name>QualType</name> <name>SubT</name></expr></argument>, <argument><expr><name>QualType</name> <name>SuperT</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsParam</name></expr></argument>)</argument_list> const <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>SubTnullability</name> <init>= <expr><call><name><name>SubT</name><operator>-&gt;</operator><name>getNullability</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>auto</name></type> <name>SuperTnullability</name> <init>= <expr><call><name><name>SuperT</name><operator>-&gt;</operator><name>getNullability</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>SubTnullability</name><operator>.</operator><name>hasValue</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>SuperTnullability</name><operator>.</operator><name>hasValue</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>SubTnullability</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>SubTnullability</name> <operator>==</operator> <operator>*</operator><name>SuperTnullability</name> <operator>||</operator>
<operator>*</operator><name>SubTnullability</name> <operator>==</operator> <name>NullabilityKind</name><operator>::</operator><name>Unspecified</name> <operator>||</operator>
<operator>*</operator><name>SuperTnullability</name> <operator>==</operator> <name>NullabilityKind</name><operator>::</operator><name>Unspecified</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>IsParam</name></expr>)</condition> <block>{<block_content>


<return>return <expr><operator>(</operator><operator>*</operator><name>SuperTnullability</name> <operator>==</operator> <name>NullabilityKind</name><operator>::</operator><name>NonNull</name> <operator>&amp;&amp;</operator>
<operator>*</operator><name>SubTnullability</name> <operator>==</operator> <name>NullabilityKind</name><operator>::</operator><name>Nullable</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>


<return>return <expr><operator>(</operator><operator>*</operator><name>SuperTnullability</name> <operator>==</operator> <name>NullabilityKind</name><operator>::</operator><name>Nullable</name> <operator>&amp;&amp;</operator>
<operator>*</operator><name>SubTnullability</name> <operator>==</operator> <name>NullabilityKind</name><operator>::</operator><name>NonNull</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function_decl><type><name>bool</name></type> <name>ObjCMethodsAreEqual</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>MethodDecl</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>MethodImp</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>UnwrapSimilarTypes</name><parameter_list>(<parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>T1</name></decl></parameter>, <parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>T2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>UnwrapSimilarArrayTypes</name><parameter_list>(<parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>T1</name></decl></parameter>, <parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>T2</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>bool</name></type> <name>hasSimilarType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T1</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T2</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>hasCvrSimilarType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T1</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T2</name></decl></parameter>)</parameter_list>;</function_decl>
























<decl_stmt><decl><type><name>NestedNameSpecifier</name> <modifier>*</modifier></type>
<name>getCanonicalNestedNameSpecifier</name><argument_list>(<argument><expr><name>NestedNameSpecifier</name> <operator>*</operator><name>NNS</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>CallingConv</name></type> <name>getDefaultCallingConvention</name><argument_list>(<argument><expr><name>bool</name> <name>IsVariadic</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsCXXMethod</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsBuiltin</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



















<decl_stmt><decl><type><name>TemplateName</name></type> <name>getCanonicalTemplateName</name><argument_list>(<argument><expr><name>TemplateName</name> <name>Name</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<function_decl><type><name>bool</name></type> <name>hasSameTemplateName</name><parameter_list>(<parameter><decl><type><name>TemplateName</name></type> <name>X</name></decl></parameter>, <parameter><decl><type><name>TemplateName</name></type> <name>Y</name></decl></parameter>)</parameter_list>;</function_decl>






<decl_stmt><decl><type><name>TemplateArgument</name></type> <name>getCanonicalTemplateArgument</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TemplateArgument</name> <operator>&amp;</operator><name>Arg</name></expr></argument>)</argument_list>
const</decl>;</decl_stmt>





<decl_stmt><decl><type><specifier>const</specifier> <name>ArrayType</name> <modifier>*</modifier></type><name>getAsArrayType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ConstantArrayType</name> <modifier>*</modifier></type><name>getAsConstantArrayType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>ConstantArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getAsArrayType</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>VariableArrayType</name> <modifier>*</modifier></type><name>getAsVariableArrayType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>VariableArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getAsArrayType</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>IncompleteArrayType</name> <modifier>*</modifier></type><name>getAsIncompleteArrayType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>IncompleteArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getAsArrayType</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>DependentSizedArrayType</name> <modifier>*</modifier></type><name>getAsDependentSizedArrayType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list>
const <block>{<block_content>
<return>return <expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>DependentSizedArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getAsArrayType</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name>QualType</name></type> <name>getBaseElementType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ArrayType</name> <operator>*</operator><name>VAT</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getBaseElementType</name><argument_list>(<argument><expr><name>QualType</name> <name>QT</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>getConstantArrayElementCount</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ConstantArrayType</name> <operator>*</operator><name>CA</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<decl_stmt><decl><type><name>QualType</name></type> <name>getAdjustedParameterType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<decl_stmt><decl><type><name>QualType</name></type> <name>getSignatureParameterType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getExceptionObjectType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>









<decl_stmt><decl><type><name>QualType</name></type> <name>getArrayDecayedType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getPromotedIntegerType</name><argument_list>(<argument><expr><name>QualType</name> <name>PromotableType</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<expr_stmt><expr><name>Qualifiers</name><operator>::</operator><name>ObjCLifetime</name> <macro><name>getInnerObjCOwnership</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>






<decl_stmt><decl><type><name>QualType</name></type> <name>isPromotableBitField</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>int</name></type> <name>getIntegerTypeOrder</name><argument_list>(<argument><expr><name>QualType</name> <name>LHS</name></expr></argument>, <argument><expr><name>QualType</name> <name>RHS</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<decl_stmt><decl><type><name>int</name></type> <name>getFloatingTypeOrder</name><argument_list>(<argument><expr><name>QualType</name> <name>LHS</name></expr></argument>, <argument><expr><name>QualType</name> <name>RHS</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<decl_stmt><decl><type><name>int</name></type> <name>getFloatingTypeSemanticOrder</name><argument_list>(<argument><expr><name>QualType</name> <name>LHS</name></expr></argument>, <argument><expr><name>QualType</name> <name>RHS</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<decl_stmt><decl><type><name>QualType</name></type> <name>getFloatingTypeOfSizeWithinDomain</name><argument_list>(<argument><expr><name>QualType</name> <name>typeSize</name></expr></argument>,
<argument><expr><name>QualType</name> <name>typeDomain</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>getTargetAddressSpace</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getTargetAddressSpace</name><argument_list>(<argument><expr><call><name><name>T</name><operator>.</operator><name>getQualifiers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>getTargetAddressSpace</name><argument_list>(<argument><expr><name>Qualifiers</name> <name>Q</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getTargetAddressSpace</name><argument_list>(<argument><expr><call><name><name>Q</name><operator>.</operator><name>getAddressSpace</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>getTargetAddressSpace</name><argument_list>(<argument><expr><name>LangAS</name> <name>AS</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>LangAS</name></type> <name>getLangASForBuiltinAddressSpace</name><argument_list>(<argument><expr><name>unsigned</name> <name>AS</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>getTargetNullPointerValue</name><argument_list>(<argument><expr><name>QualType</name> <name>QT</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>addressSpaceMapManglingFor</name><argument_list>(<argument><expr><name>LangAS</name> <name>AS</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>AddrSpaceMapMangling</name> <operator>||</operator> <call><name>isTargetAddressSpace</name><argument_list>(<argument><expr><name>AS</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>unsigned</name></type> <name>getIntegerRank</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<label><name>public</name>:</label>





<function_decl><type><name>bool</name></type> <name>typesAreCompatible</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T1</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T2</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>CompareUnqualified</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>propertyTypesAreCompatible</name><parameter_list>(<parameter><decl><type><name>QualType</name></type></decl></parameter>, <parameter><decl><type><name>QualType</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>typesAreBlockPointerCompatible</name><parameter_list>(<parameter><decl><type><name>QualType</name></type></decl></parameter>, <parameter><decl><type><name>QualType</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>bool</name></type> <name>isObjCIdType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>T</name> <operator>==</operator> <call><name>getObjCIdType</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isObjCClassType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>T</name> <operator>==</operator> <call><name>getObjCClassType</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isObjCSelType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>T</name> <operator>==</operator> <call><name>getObjCSelType</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function_decl><type><name>bool</name></type> <name>ObjCQualifiedIdTypesAreCompatible</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCObjectPointerType</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCObjectPointerType</name> <modifier>*</modifier></type><name>RHS</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ForCompare</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>ObjCQualifiedClassTypesAreCompatible</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCObjectPointerType</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCObjectPointerType</name> <modifier>*</modifier></type><name>RHS</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>canAssignObjCInterfaces</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCObjectPointerType</name> <modifier>*</modifier></type><name>LHSOPT</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCObjectPointerType</name> <modifier>*</modifier></type><name>RHSOPT</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>canAssignObjCInterfaces</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCObjectType</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCObjectType</name> <modifier>*</modifier></type><name>RHS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>canAssignObjCInterfacesInBlockPointer</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>ObjCObjectPointerType</name> <modifier>*</modifier></type><name>LHSOPT</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCObjectPointerType</name> <modifier>*</modifier></type><name>RHSOPT</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>BlockReturnType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>areComparableObjCPointerTypes</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>LHS</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>RHS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>areCommonBaseCompatible</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCObjectPointerType</name> <modifier>*</modifier></type><name>LHSOPT</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCObjectPointerType</name> <modifier>*</modifier></type><name>RHSOPT</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>canBindObjCObjectType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>To</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>From</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>QualType</name></type> <name>mergeTypes</name><parameter_list>(<parameter><decl><type><name>QualType</name></type></decl></parameter>, <parameter><decl><type><name>QualType</name></type></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>OfBlockPointer</name><init>=<expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Unqualified</name> <init>= <expr><name>false</name></expr></init></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>BlockReturnType</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>mergeFunctionTypes</name><parameter_list>(<parameter><decl><type><name>QualType</name></type></decl></parameter>, <parameter><decl><type><name>QualType</name></type></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>OfBlockPointer</name><init>=<expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Unqualified</name> <init>= <expr><name>false</name></expr></init></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>AllowCXX</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>mergeFunctionParameterTypes</name><parameter_list>(<parameter><decl><type><name>QualType</name></type></decl></parameter>, <parameter><decl><type><name>QualType</name></type></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>OfBlockPointer</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Unqualified</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>mergeTransparentUnionType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type></decl></parameter>, <parameter><decl><type><name>QualType</name></type></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>OfBlockPointer</name><init>=<expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Unqualified</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type> <name>mergeObjCGCQualifiers</name><parameter_list>(<parameter><decl><type><name>QualType</name></type></decl></parameter>, <parameter><decl><type><name>QualType</name></type></decl></parameter>)</parameter_list>;</function_decl>




















<function_decl><type><name>bool</name></type> <name>mergeExtParameterInfo</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>FirstFnType</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>SecondFnType</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>CanUseFirst</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>CanUseSecond</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name><operator>::</operator><name>ExtParameterInfo</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>NewParamInfos</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ResetObjCLayout</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCContainerDecl</name> <modifier>*</modifier></type><name>CD</name></decl></parameter>)</parameter_list>;</function_decl>







<decl_stmt><decl><type><name>unsigned</name></type> <name>getIntWidth</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>







<decl_stmt><decl><type><name>QualType</name></type> <name>getCorrespondingUnsignedType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>







<decl_stmt><decl><type><name>QualType</name></type> <name>getCorrespondingSignedType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>getCorrespondingSaturatedType</name><argument_list>(<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>QualType</name></type> <name>getCorrespondingSignedFixedPointType</name><argument_list>(<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>







<expr_stmt><expr><name>llvm</name><operator>::</operator><name>APSInt</name> <macro><name>MakeIntValue</name><argument_list>(<argument>uint64_t Value</argument>, <argument>QualType Type</argument>)</argument_list></macro> <specifier>const</specifier> <block>{


<expr><name>llvm</name><operator>::</operator><name>APSInt</name> <call><name>Res</name><argument_list>(<argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><operator>!</operator><call><name><name>Type</name><operator>-&gt;</operator><name>isSignedIntegerOrEnumerationType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>Res</name> <operator>=</operator> <name>Value</name></expr>;
<expr><name>unsigned</name> <name>Width</name> <operator>=</operator> <call><name>getIntWidth</name><argument_list>(<argument><expr><name>Type</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>Width</name> <operator>!=</operator> <call><name><name>Res</name><operator>.</operator><name>getBitWidth</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Res</name><operator>.</operator><name>extOrTrunc</name></name><argument_list>(<argument><expr><name>Width</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>Res</name></expr>;</return>
}

bool <expr_stmt><expr><call><name>isSentinelNullExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<function_decl><type><name>ObjCImplementationDecl</name> <modifier>*</modifier></type><name>getObjCImplementation</name><parameter_list>(<parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ObjCCategoryImplDecl</name> <modifier>*</modifier></type><name>getObjCImplementation</name><parameter_list>(<parameter><decl><type><name>ObjCCategoryDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>bool</name></type> <name>AnyObjCImplementation</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><operator>!</operator><call><name><name>ObjCImpls</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>setObjCImplementation</name><parameter_list>(<parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>IFaceD</name></decl></parameter>,
<parameter><decl><type><name>ObjCImplementationDecl</name> <modifier>*</modifier></type><name>ImplD</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>setObjCImplementation</name><parameter_list>(<parameter><decl><type><name>ObjCCategoryDecl</name> <modifier>*</modifier></type><name>CatD</name></decl></parameter>,
<parameter><decl><type><name>ObjCCategoryImplDecl</name> <modifier>*</modifier></type><name>ImplD</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><specifier>const</specifier> <name>ObjCMethodDecl</name> <modifier>*</modifier></type>
<name>getObjCMethodRedeclaration</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCMethodDecl</name> <operator>*</operator><name>MD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>setObjCMethodRedeclaration</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Redecl</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>getObjContainingInterface</name><argument_list>(<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>ND</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>setBlockVarCopyInit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name><modifier>*</modifier></type> <name>VD</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>CopyExpr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>CanThrow</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>BlockVarCopyInit</name></type> <name>getBlockVarCopyInit</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name><operator>*</operator> <name>VD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>












<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>CreateTypeSourceInfo</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>, <argument><expr><name>unsigned</name> <name>Size</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type>
<name>getTrivialTypeSourceInfo</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list> const</decl>;</decl_stmt>








<decl_stmt><decl><type><name>void</name></type> <name>AddDeallocation</name><argument_list>(<argument><expr><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator><name>Callback</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>Data</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>void</name></type> <name>addDestruction</name><argument_list>(<argument><expr><name>T</name> <operator>*</operator><name>Ptr</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>std</name><operator>::</operator><name><name>is_trivially_destructible</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>DestroyPtr</name> <init>= <expr><index>[]</index><operator>(</operator><name>void</name> <operator>*</operator><name>V</name><operator>)</operator> <block>{ <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><operator>~</operator><call><name>T</name><argument_list>()</argument_list></call></expr>; }</block></expr></init></decl></decl_stmt><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>AddDeallocation</name><argument_list>(<argument><expr><name>DestroyPtr</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>GVALinkage</name></type> <name>GetGVALinkageForFunction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>FD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<function_decl><type><name>GVALinkage</name></type> <name>GetGVALinkageForVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>bool</name></type> <name>DeclMustBeEmitted</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>void</name></type> <name>forEachMultiversionedFunctionVersion</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>FD</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>FunctionDecl</name> <operator>*</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>Pred</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function_decl><type><specifier>const</specifier> <name>CXXConstructorDecl</name> <modifier>*</modifier></type>
<name>getCopyConstructorForExceptionObject</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>addCopyConstructorForExceptionObject</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>,
<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>CD</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>addTypedefNameForUnnamedTagDecl</name><parameter_list>(<parameter><decl><type><name>TagDecl</name> <modifier>*</modifier></type><name>TD</name></decl></parameter>, <parameter><decl><type><name>TypedefNameDecl</name> <modifier>*</modifier></type><name>TND</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TypedefNameDecl</name> <modifier>*</modifier></type><name>getTypedefNameForUnnamedTagDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TagDecl</name> <modifier>*</modifier></type><name>TD</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>addDeclaratorForUnnamedTagDecl</name><parameter_list>(<parameter><decl><type><name>TagDecl</name> <modifier>*</modifier></type><name>TD</name></decl></parameter>, <parameter><decl><type><name>DeclaratorDecl</name> <modifier>*</modifier></type><name>DD</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclaratorDecl</name> <modifier>*</modifier></type><name>getDeclaratorForUnnamedTagDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TagDecl</name> <modifier>*</modifier></type><name>TD</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>setManglingNumber</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>ND</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Number</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>unsigned</name></type> <name>getManglingNumber</name><argument_list>(<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>ND</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>setStaticLocalNumber</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Number</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>unsigned</name></type> <name>getStaticLocalNumber</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<function_decl><type><name>MangleNumberingContext</name> <modifier>&amp;</modifier></type><name>getManglingNumberContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>
<enum>enum <name>NeedExtraManglingDecl_t</name> <block>{ <decl><name>NeedExtraManglingDecl</name></decl> }</block>;</enum>
<function_decl><type><name>MangleNumberingContext</name> <modifier>&amp;</modifier></type><name>getManglingNumberContext</name><parameter_list>(<parameter><decl><type><name>NeedExtraManglingDecl_t</name></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MangleNumberingContext</name></expr></argument>&gt;</argument_list></name> <macro><name>createMangleNumberingContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<function_decl><type><name>void</name></type> <name>setParameterIndex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParmVarDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>index</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>unsigned</name></type> <name>getParameterIndex</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ParmVarDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<decl_stmt><decl><type><name>StringLiteral</name> <modifier>*</modifier></type><name>getPredefinedStringLiteralFromCache</name><argument_list>(<argument><expr><name>StringRef</name> <name>Key</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>MSGuidDecl</name> <modifier>*</modifier></type><name>getMSGuidDecl</name><argument_list>(<argument><expr><name>MSGuidDeclParts</name> <name>Parts</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>TemplateParamObjectDecl</name> <modifier>*</modifier></type><name>getTemplateParamObjectDecl</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>APValue</name> <operator>&amp;</operator><name>V</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>ParsedTargetAttr</name></type> <name>filterFunctionTargetAttrs</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TargetAttr</name> <operator>*</operator><name>TD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>getFunctionFeatureMap</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>FeatureMap</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>getFunctionFeatureMap</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>FeatureMap</name></expr></argument>,
<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<decl_stmt><decl><type><name>unsigned</name></type> <name>NumImplicitDefaultConstructors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumImplicitDefaultConstructorsDeclared</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumImplicitCopyConstructors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumImplicitCopyConstructorsDeclared</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumImplicitMoveConstructors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumImplicitMoveConstructorsDeclared</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumImplicitCopyAssignmentOperators</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumImplicitCopyAssignmentOperatorsDeclared</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumImplicitMoveAssignmentOperators</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumImplicitMoveAssignmentOperatorsDeclared</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumImplicitDestructors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumImplicitDestructorsDeclared</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>






<function_decl><type><name>void</name></type> <name>InitBuiltinTypes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>&amp;</modifier></type><name>Target</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>*</modifier></type><name>AuxTarget</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>void</name></type> <name>InitBuiltinType</name><argument_list>(<argument><expr><name>CanQualType</name> <operator>&amp;</operator><name>R</name></expr></argument>, <argument><expr><name>BuiltinType</name><operator>::</operator><name>Kind</name> <name>K</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>ObjCEncOptions</name> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>Bits</name></decl>;</decl_stmt>

<macro><name>ObjCEncOptions</name><argument_list>(<argument>unsigned Bits</argument>)</argument_list></macro> : <macro><name>Bits</name><argument_list>(<argument>Bits</argument>)</argument_list></macro> <block>{<block_content/>}</block>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>ObjCEncOptions</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Bits</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro> <block>{}</block>
<call><name>ObjCEncOptions</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCEncOptions</name> <operator>&amp;</operator><name>RHS</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>Bits</name><argument_list>(<argument>RHS.Bits</argument>)</argument_list></macro> <block>{}</block>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_LIST</name><parameter_list>(<parameter><type><name>V</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>V(ExpandPointedToStructures, 0) V(ExpandStructures, 1) V(IsOutermostType, 2) V(EncodingProperty, 3) V(IsStructField, 4) V(EncodeBlockParameters, 5) V(EncodeClassNames, 6)</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>V</name><parameter_list>(<parameter><type><name>N</name></type></parameter>,<parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ObjCEncOptions&amp; set##N() { Bits |= 1 &lt;&lt; I; return *this; }</cpp:value></cpp:define>
<macro><name>OPT_LIST</name><argument_list>(<argument>V</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>V</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>V</name><parameter_list>(<parameter><type><name>N</name></type></parameter>,<parameter><type><name>I</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>bool N() const { return Bits &amp; 1 &lt;&lt; I; }</cpp:value></cpp:define>
<macro><name>OPT_LIST</name><argument_list>(<argument>V</argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>V</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OPT_LIST</name></cpp:undef>

<name>LLVM_NODISCARD</name> <name>ObjCEncOptions</name> <macro><name>keepingOnly</name><argument_list>(<argument>ObjCEncOptions Mask</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Bits</name> <operator>&amp;</operator> <name><name>Mask</name><operator>.</operator><name>Bits</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>LLVM_NODISCARD</name> <name>ObjCEncOptions</name> <macro><name>forComponentType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>ObjCEncOptions</name> <name>Mask</name> <operator>=</operator> <call><name>ObjCEncOptions</name><argument_list>()</argument_list></call>
<operator>.</operator><call><name>setIsOutermostType</name><argument_list>()</argument_list></call>
<operator>.</operator><call><name>setIsStructField</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>Bits</name> <operator>&amp;</operator> <operator>~</operator><name><name>Mask</name><operator>.</operator><name>Bits</name></name></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>getObjCEncodingForTypeImpl</name><argument_list>(<argument><expr><name>QualType</name> <name>t</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>S</name></expr></argument>,
<argument><expr><name>ObjCEncOptions</name> <name>Options</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><name>Field</name></expr></argument>,
<argument><expr><name>QualType</name> <operator>*</operator><name>NotEncodedT</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>getObjCEncodingForStructureImpl</name><argument_list>(<argument><expr><name>RecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>S</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><name>Field</name></expr></argument>,
<argument><expr><name>bool</name> <name>includeVBases</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>QualType</name> <operator>*</operator><name>NotEncodedT</name><operator>=</operator><name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<label><name>public</name>:</label>

<decl_stmt><decl><type><name>void</name></type> <name>getObjCEncodingForMethodParameter</name><argument_list>(<argument><expr><name>Decl</name><operator>::</operator><name>ObjCDeclQualifier</name> <name>QT</name></expr></argument>,
<argument><expr><name>QualType</name> <name>T</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>S</name></expr></argument>,
<argument><expr><name>bool</name> <name>Extended</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isMSStaticDataMemberInlineDefinition</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>InlineVariableDefinitionKind</name> <block>{<block_content>

<expr_stmt><expr><name>None</name></expr><operator>,</operator>


<expr><name>Weak</name></expr><operator>,</operator>


<expr><name>WeakUnknown</name></expr><operator>,</operator>


<expr><name>Strong</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>






<decl_stmt><decl><type><name>InlineVariableDefinitionKind</name></type>
<name>getInlineVariableDefinitionKind</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>DeclarationNameTable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>DeclContext</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ASTRecordLayout</name> <modifier>&amp;</modifier></type>
<name>getObjCLayout</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><name>D</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ObjCImplementationDecl</name> <operator>*</operator><name>Impl</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>









<decl_stmt><decl><type><name>using</name></type> <name>DeallocationFunctionsAndArguments</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><operator>*</operator><operator>)</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator></expr></argument>, <argument><expr><name>void</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mutable</name> <name>DeallocationFunctionsAndArguments</name></type> <name>Deallocations</name></decl>;</decl_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>StoredDeclsMap</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <name>LastSDM</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>TraversalScope</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>VTableContextBase</name></expr></argument>&gt;</argument_list></name> <name>VTContext</name></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>ReleaseDeclContextMaps</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>public</name>:</label>
<enum>enum <name>PragmaSectionFlag</name> : <type><name>unsigned</name></type> <block>{
<decl><name>PSF_None</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>PSF_Read</name> <init>= <expr><literal type="number">0x1</literal></expr></init></decl>,
<decl><name>PSF_Write</name> <init>= <expr><literal type="number">0x2</literal></expr></init></decl>,
<decl><name>PSF_Execute</name> <init>= <expr><literal type="number">0x4</literal></expr></init></decl>,
<decl><name>PSF_Implicit</name> <init>= <expr><literal type="number">0x8</literal></expr></init></decl>,
<decl><name>PSF_ZeroInit</name> <init>= <expr><literal type="number">0x10</literal></expr></init></decl>,
<decl><name>PSF_Invalid</name> <init>= <expr><literal type="number">0x80000000U</literal></expr></init></decl>,
}</block>;</enum>

<struct>struct <name>SectionInfo</name> <block>{
<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Decl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>PragmaSectionLocation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>SectionFlags</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SectionInfo</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<macro><name>SectionInfo</name><argument_list>(<argument>NamedDecl *Decl</argument>, <argument>SourceLocation PragmaSectionLocation</argument>,
<argument>int SectionFlags</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Decl</name><argument_list>(<argument><expr><name>Decl</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>PragmaSectionLocation</name><argument_list>(<argument><expr><name>PragmaSectionLocation</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>SectionFlags</name><argument_list>(<argument>SectionFlags</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>SectionInfo</name></expr></argument>&gt;</argument_list></name> <name>SectionInfos</name></expr>;</expr_stmt>


<function_decl><type><name>OMPTraitInfo</name> <modifier>&amp;</modifier></type><name>getNewOMPTraitInfo</name><parameter_list>()</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>bool</name></type> <name>mayExternalizeStaticVar</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>shouldExternalizeStaticVar</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>StringRef</name> <macro><name>getCUIDHash</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>AddSYCLKernelNamingDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>bool</name></type> <name>IsSYCLKernelNamingDecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<function_decl><type><name>unsigned</name></type> <name>GetSYCLKernelNamingIndex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>SYCLUniqueStableNameExpr</name> <operator>*</operator></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name>
<name>SYCLUniqueStableNameEvaluatedValues</name></expr>;</expr_stmt>

<label><name>private</name>:</label>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>OMPTraitInfo</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>OMPTraitInfoVector</name></decl>;</decl_stmt>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>SYCLKernelNamingTypes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ItaniumMangleContext</name></expr></argument>&gt;</argument_list></name> <name>SYCLKernelFilterContext</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>FilterSYCLKernelNamingDecls</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Decls</name></expr></argument>)</argument_list></decl>;</decl_stmt>
};


<expr_stmt><expr><specifier>const</specifier> <name>StreamingDiagnostic</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><specifier>const</specifier> <name>StreamingDiagnostic</name> <operator>&amp;</operator><name>DB</name><operator>,</operator>
<specifier>const</specifier> <name>ASTContext</name><operator>::</operator><name>SectionInfo</name> <operator>&amp;</operator><name>Section</name><operator>)</operator></expr>;</expr_stmt>


<function><type><specifier>inline</specifier> <name>Selector</name></type> <name>GetNullarySelector</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>IdentifierInfo</name><modifier>*</modifier></type> <name>II</name> <init>= <expr><operator>&amp;</operator><call><name><name>Ctx</name><operator>.</operator><name>Idents</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>Ctx</name><operator>.</operator><name>Selectors</name><operator>.</operator><name>getSelector</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>II</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>inline</specifier> <name>Selector</name></type> <name>GetUnarySelector</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>IdentifierInfo</name><modifier>*</modifier></type> <name>II</name> <init>= <expr><operator>&amp;</operator><call><name><name>Ctx</name><operator>.</operator><name>Idents</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>Ctx</name><operator>.</operator><name>Selectors</name><operator>.</operator><name>getSelector</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>II</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

}































inline <decl_stmt><decl><type><name>void</name> <modifier>*</modifier><name>operator</name></type> <name>new</name><argument_list>(<argument><expr><name>size_t</name> <name>Bytes</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>clang</name><operator>::</operator><name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>,
<argument><expr><name>size_t</name> <name>Alignment</name></expr></argument> )</argument_list> <block>{<block_content>
<return>return <expr><call><name><name>C</name><operator>.</operator><name>Allocate</name></name><argument_list>(<argument><expr><name>Bytes</name></expr></argument>, <argument><expr><name>Alignment</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>







<decl_stmt><decl><type><specifier>inline</specifier> <name>void</name> <name>operator</name></type> <name>delete</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>Ptr</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>clang</name><operator>::</operator><name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>C</name><operator>.</operator><name>Deallocate</name></name><argument_list>(<argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>
























<decl_stmt><decl><type><specifier>inline</specifier> <name>void</name> <modifier>*</modifier><name>operator</name></type> <name><name>new</name><index>[]</index></name><argument_list>(<argument><expr><name>size_t</name> <name>Bytes</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>clang</name><operator>::</operator><name>ASTContext</name><operator>&amp;</operator> <name>C</name></expr></argument>,
<argument><expr><name>size_t</name> <name>Alignment</name></expr></argument> )</argument_list> <block>{<block_content>
<return>return <expr><call><name><name>C</name><operator>.</operator><name>Allocate</name></name><argument_list>(<argument><expr><name>Bytes</name></expr></argument>, <argument><expr><name>Alignment</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>







<decl_stmt><decl><type><specifier>inline</specifier> <name>void</name> <name>operator</name></type> <name><name>delete</name><index>[]</index></name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>Ptr</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>clang</name><operator>::</operator><name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>C</name><operator>.</operator><name>Deallocate</name></name><argument_list>(<argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Owner</name></expr></argument>, <argument><expr><name>typename</name> <name>T</name></expr></argument>,
<argument><expr><name>void</name> <operator>(</operator><name>clang</name><operator>::</operator><name>ExternalASTSource</name><operator>::</operator><operator>*</operator><name>Update</name><operator>)</operator><operator>(</operator><name>Owner</name><operator>)</operator></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>clang</name><operator>::</operator><name><name>LazyGenerationalUpdatePtr</name><argument_list type="generic">&lt;<argument><expr><name>Owner</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>Update</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ValueType</name>
<name>clang</name><operator>::</operator><name><name>LazyGenerationalUpdatePtr</name><argument_list type="generic">&lt;<argument><expr><name>Owner</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>Update</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>makeValue</name><argument_list>(
<argument>const clang::ASTContext &amp;Ctx</argument>, <argument>T Value</argument>)</argument_list></macro> <block>{



<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>Source</name> <operator>=</operator> <call><name><name>Ctx</name><operator>.</operator><name>getExternalSource</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <macro><name>new</name> <argument_list>(<argument>Ctx</argument>)</argument_list></macro> <expr><call><name>LazyData</name><argument_list>(<argument><expr><name>Source</name></expr></argument>, <argument><expr><name>Value</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>Value</name></expr>;</return>
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
