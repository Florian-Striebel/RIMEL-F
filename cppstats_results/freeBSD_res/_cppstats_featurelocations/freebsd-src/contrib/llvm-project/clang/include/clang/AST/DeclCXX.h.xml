<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/DeclCXX.h">













<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_DECLCXX_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_DECLCXX_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTUnresolvedSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclBase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclarationName.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExternalASTSource.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/LambdaCapture.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/NestedNameSpecifier.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Redeclarable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Stmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeLoc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/UnresolvedSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Lambda.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LangOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OperatorKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Specifiers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerIntPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerUnion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/STLExtras.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/TinyPtrVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/PointerLikeTypeTraits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/TrailingObjects.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iterator&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ClassTemplateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ConstructorUsingShadowDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXBasePath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXBasePaths</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXConstructorDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXDestructorDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXFinalOverriderMap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXIndirectPrimaryBaseSet</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXMethodDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DecompositionDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DiagnosticBuilder</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FriendDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionTemplateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>IdentifierInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MemberSpecializationInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BaseUsingDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateParameterList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UsingDecl</name></decl>;</decl_stmt>











<decl_stmt><decl><type><name>class</name></type> <name>AccessSpecDecl</name> <range>: <expr><name>public</name> <name>Decl</name> <block>{

<expr><name>SourceLocation</name> <name>ColonLoc</name></expr>;

<macro><name>AccessSpecDecl</name><argument_list>(<argument>AccessSpecifier AS</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation ASLoc</argument>, <argument>SourceLocation ColonLoc</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Decl</name><argument_list>(<argument><expr><name>AccessSpec</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>ASLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>ColonLoc</name><argument_list>(<argument>ColonLoc</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setAccess</name><argument_list>(<argument><expr><name>AS</name></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>AccessSpecDecl</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Decl</name><argument_list>(<argument>AccessSpec</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>

<name>SourceLocation</name> <macro><name>getAccessSpecifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>void</name> <macro><name>setAccessSpecifierLoc</name><argument_list>(<argument>SourceLocation ASLoc</argument>)</argument_list></macro> <block>{ <expr><call><name>setLocation</name><argument_list>(<argument><expr><name>ASLoc</name></expr></argument>)</argument_list></call></expr>; }</block>


<name>SourceLocation</name> <macro><name>getColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColonLoc</name></expr>;</return> }</block>


<name>void</name> <macro><name>setColonLoc</name><argument_list>(<argument>SourceLocation CLoc</argument>)</argument_list></macro> <block>{ <expr><name>ColonLoc</name> <operator>=</operator> <name>CLoc</name></expr>; }</block>

<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getAccessSpecifierLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getColonLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>AccessSpecDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>AccessSpecifier AS</argument>,
<argument>DeclContext *DC</argument>, <argument>SourceLocation ASLoc</argument>,
<argument>SourceLocation ColonLoc</argument>)</argument_list></macro> <block>{
<return>return <macro><name>new</name> <argument_list>(<argument>C</argument>, <argument>DC</argument>)</argument_list></macro> <expr><call><name>AccessSpecDecl</name><argument_list>(<argument><expr><name>AS</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>ASLoc</name></expr></argument>, <argument><expr><name>ColonLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>AccessSpecDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>AccessSpec</name></expr>;</return> }</block>
}</expr>;

















<expr><name>class</name> <name>CXXBaseSpecifier</name> <block>{



<expr><name>SourceRange</name> <name>Range</name></expr>;



<expr><name>SourceLocation</name> <name>EllipsisLoc</name></expr>;


<expr><name>unsigned</name> <name>Virtual</name> <operator>:</operator> <literal type="number">1</literal></expr>;





<expr><name>unsigned</name> <name>BaseOfClass</name> <operator>:</operator> <literal type="number">1</literal></expr>;





<expr><name>unsigned</name> <name>Access</name> <operator>:</operator> <literal type="number">2</literal></expr>;



<expr><name>unsigned</name> <name>InheritConstructors</name> <operator>:</operator> <literal type="number">1</literal></expr>;





<expr><name>TypeSourceInfo</name> <operator>*</operator><name>BaseTypeInfo</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>CXXBaseSpecifier</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<macro><name>CXXBaseSpecifier</name><argument_list>(<argument>SourceRange R</argument>, <argument>bool V</argument>, <argument>bool BC</argument>, <argument>AccessSpecifier A</argument>,
<argument>TypeSourceInfo *TInfo</argument>, <argument>SourceLocation EllipsisLoc</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Range</name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>EllipsisLoc</name><argument_list>(<argument><expr><name>EllipsisLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Virtual</name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>BaseOfClass</name><argument_list>(<argument><expr><name>BC</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Access</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>InheritConstructors</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>, <macro><name>BaseTypeInfo</name><argument_list>(<argument>TInfo</argument>)</argument_list></macro> <expr><block>{}</block>


<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Range</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getBaseTypeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>BaseTypeInfo</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>isVirtual</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Virtual</name></expr>;</return> }</block>



<name>bool</name> <macro><name>isBaseOfClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BaseOfClass</name></expr>;</return> }</block>


<name>bool</name> <macro><name>isPackExpansion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>EllipsisLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>bool</name> <macro><name>getInheritConstructors</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>InheritConstructors</name></expr>;</return> }</block>


<name>void</name> <macro><name>setInheritConstructors</name><argument_list>(<argument>bool Inherit = true</argument>)</argument_list></macro> <block>{
<expr><name>InheritConstructors</name> <operator>=</operator> <name>Inherit</name></expr>;
}</block>


<name>SourceLocation</name> <macro><name>getEllipsisLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>EllipsisLoc</name></expr>;</return>
}</block>






<name>AccessSpecifier</name> <macro><name>getAccessSpecifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>AccessSpecifier</name><operator>)</operator><name>Access</name> <operator>==</operator> <name>AS_none</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>BaseOfClass</name><operator>?</operator> <name>AS_private</name> <operator>:</operator> <name>AS_public</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>AccessSpecifier</name><operator>)</operator><name>Access</name></expr>;</return></block_content></block></else></if_stmt>
}</block>






<name>AccessSpecifier</name> <macro><name>getAccessSpecifierAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>AccessSpecifier</name><operator>)</operator><name>Access</name></expr>;</return>
}</block>




<name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>BaseTypeInfo</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getUnqualifiedType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BaseTypeInfo</name></expr>;</return> }</block>
}</expr>;


<expr><name>class</name> <name>CXXRecordDecl</name> <operator>:</operator> <name>public</name> <name>RecordDecl</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTNodeImporter</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTRecordWriter</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTWriter</name></expr>;
<expr><name>friend</name> <name>class</name> <name>DeclContext</name></expr>;
<expr><name>friend</name> <name>class</name> <name>LambdaExpr</name></expr>;

<expr><name>friend</name> <name>void</name> <name>FunctionDecl</name><operator>::</operator><call><name>setPure</name><argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></call></expr>;
<expr><name>friend</name> <name>void</name> <name>TagDecl</name><operator>::</operator><call><name>startDefinition</name><argument_list>()</argument_list></call></expr>;


enum <expr><name>SpecialMemberFlags</name> <block>{
<expr><name>SMF_DefaultConstructor</name> <operator>=</operator> <literal type="number">0x1</literal></expr>,
<expr><name>SMF_CopyConstructor</name> <operator>=</operator> <literal type="number">0x2</literal></expr>,
<expr><name>SMF_MoveConstructor</name> <operator>=</operator> <literal type="number">0x4</literal></expr>,
<expr><name>SMF_CopyAssignment</name> <operator>=</operator> <literal type="number">0x8</literal></expr>,
<expr><name>SMF_MoveAssignment</name> <operator>=</operator> <literal type="number">0x10</literal></expr>,
<expr><name>SMF_Destructor</name> <operator>=</operator> <literal type="number">0x20</literal></expr>,
<expr><name>SMF_All</name> <operator>=</operator> <literal type="number">0x3f</literal></expr>
}</block></expr>;

struct <expr><name>DefinitionData</name> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELD</name><parameter_list>(<parameter><type><name>Name</name></type></parameter>, <parameter><type><name>Width</name></type></parameter>, <parameter><type><name>Merge</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>unsigned Name : Width;</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"CXXRecordDeclDefinitionBits.def"</cpp:file></cpp:include>


<expr><name>unsigned</name> <name>IsLambda</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>unsigned</name> <name>IsParsingBaseSpecifiers</name> <operator>:</operator> <literal type="number">1</literal></expr>;



<expr><name>unsigned</name> <name>ComputedVisibleConversions</name> <operator>:</operator> <literal type="number">1</literal></expr>;

<expr><name>unsigned</name> <name>HasODRHash</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>unsigned</name> <name>ODRHash</name> <operator>=</operator> <literal type="number">0</literal></expr>;


<expr><name>unsigned</name> <name>NumBases</name> <operator>=</operator> <literal type="number">0</literal></expr>;


<expr><name>unsigned</name> <name>NumVBases</name> <operator>=</operator> <literal type="number">0</literal></expr>;




<expr><name>LazyCXXBaseSpecifiersPtr</name> <name>Bases</name></expr>;


<expr><name>LazyCXXBaseSpecifiersPtr</name> <name>VBases</name></expr>;





<expr><name>LazyASTUnresolvedSet</name> <name>Conversions</name></expr>;






<expr><name>LazyASTUnresolvedSet</name> <name>VisibleConversions</name></expr>;


<expr><name>CXXRecordDecl</name> <operator>*</operator><name>Definition</name></expr>;





<expr><name>LazyDeclPtr</name> <name>FirstFriend</name></expr>;

<expr><call><name>DefinitionData</name><argument_list>(<argument><expr><name>CXXRecordDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;


<expr><name>CXXBaseSpecifier</name> <operator>*</operator><macro><name>getBases</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Bases</name><operator>.</operator><name>isOffset</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Bases</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getBasesSlowCase</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>CXXBaseSpecifier</name> <operator>*</operator><macro><name>getVBases</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>VBases</name><operator>.</operator><name>isOffset</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>VBases</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getVBasesSlowCase</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>CXXBaseSpecifier</name></expr></argument>&gt;</argument_list></name> <macro><name>bases</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getBases</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NumBases</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>CXXBaseSpecifier</name></expr></argument>&gt;</argument_list></name> <macro><name>vbases</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getVBases</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NumVBases</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>CXXBaseSpecifier</name> <operator>*</operator><macro><name>getBasesSlowCase</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>CXXBaseSpecifier</name> <operator>*</operator><macro><name>getVBasesSlowCase</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr>;

struct <expr><name>DefinitionData</name> <operator>*</operator><name>DefinitionData</name></expr>;


struct <expr><name>LambdaDefinitionData</name> <operator>:</operator> <name>public</name> <name>DefinitionData</name> <block>{
<expr><name>using</name> <name>Capture</name> <operator>=</operator> <name>LambdaCapture</name></expr>;









<expr><name>unsigned</name> <name>Dependent</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>unsigned</name> <name>IsGenericLambda</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>unsigned</name> <name>CaptureDefault</name> <operator>:</operator> <literal type="number">2</literal></expr>;


<expr><name>unsigned</name> <name>NumCaptures</name> <operator>:</operator> <literal type="number">15</literal></expr>;


<expr><name>unsigned</name> <name>NumExplicitCaptures</name> <operator>:</operator> <literal type="number">13</literal></expr>;


<expr><name>unsigned</name> <name>HasKnownInternalLinkage</name> <operator>:</operator> <literal type="number">1</literal></expr>;



<expr><name>unsigned</name> <name>ManglingNumber</name> <operator>:</operator> <literal type="number">31</literal></expr>;





<expr><name>LazyDeclPtr</name> <name>ContextDecl</name></expr>;



<expr><name>Capture</name> <operator>*</operator><name>Captures</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>TypeSourceInfo</name> <operator>*</operator><name>MethodTyInfo</name></expr>;

<macro><name>LambdaDefinitionData</name><argument_list>(<argument>CXXRecordDecl *D</argument>, <argument>TypeSourceInfo *Info</argument>, <argument>bool Dependent</argument>,
<argument>bool IsGeneric</argument>, <argument>LambdaCaptureDefault CaptureDefault</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>DefinitionData</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Dependent</name><argument_list>(<argument><expr><name>Dependent</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>IsGenericLambda</name><argument_list>(<argument><expr><name>IsGeneric</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>CaptureDefault</name><argument_list>(<argument><expr><name>CaptureDefault</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NumCaptures</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>NumExplicitCaptures</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>HasKnownInternalLinkage</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>ManglingNumber</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<macro><name>MethodTyInfo</name><argument_list>(<argument>Info</argument>)</argument_list></macro> <expr><block>{
<expr><name>IsLambda</name> <operator>=</operator> <name>true</name></expr>;



<expr><name>Aggregate</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>PlainOldData</name> <operator>=</operator> <name>false</name></expr>;
}</block></expr>
}</block></expr>;

struct <expr><name>DefinitionData</name> <operator>*</operator><macro><name>dataPtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{

<expr><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>DefinitionData</name></expr>;</return>
}</block>

struct <name>DefinitionData</name> <operator>&amp;</operator><macro><name>data</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <operator>*</operator><name>DD</name> <operator>=</operator> <call><name>dataPtr</name><argument_list>()</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>DD</name> <operator>&amp;&amp;</operator> <literal type="string">"queried property of class with no definition"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>DD</name></expr>;</return>
}</block>

struct <name>LambdaDefinitionData</name> <operator>&amp;</operator><macro><name>getLambdaData</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{


<expr><name>auto</name> <operator>*</operator><name>DD</name> <operator>=</operator> <name>DefinitionData</name></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>DD</name> <operator>&amp;&amp;</operator> <name><name>DD</name><operator>-&gt;</operator><name>IsLambda</name></name> <operator>&amp;&amp;</operator> <literal type="string">"queried lambda property of non-lambda class"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>LambdaDefinitionData</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>DD</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>










<name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>MemberSpecializationInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>TemplateOrInstantiation</name></expr>;



<expr><name>void</name> <call><name>addedClassSubobject</name><argument_list>(<argument><expr><name>CXXRecordDecl</name> <operator>*</operator><name>Base</name></expr></argument>)</argument_list></call></expr>;






<expr><name>void</name> <call><name>addedMember</name><argument_list>(<argument><expr><name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;

<expr><name>void</name> <call><name>markedVirtualFunctionPure</name><argument_list>()</argument_list></call></expr>;



<expr><name>FriendDecl</name> <operator>*</operator><macro><name>getFirstFriend</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>bool</name> <call><name>hasSubobjectAtOffsetZeroOfEmptyBaseType</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>X</name></expr></argument>)</argument_list></call></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>CXXRecordDecl</name><argument_list>(<argument>Kind K</argument>, <argument>TagKind TK</argument>, <argument>const ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation IdLoc</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>CXXRecordDecl *PrevDecl</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>

<name>using</name> <name>base_class_iterator</name> <operator>=</operator> <name>CXXBaseSpecifier</name> <operator>*</operator></expr>;


<expr><name>using</name> <name>base_class_const_iterator</name> <operator>=</operator> <specifier>const</specifier> <name>CXXBaseSpecifier</name> <operator>*</operator></expr>;

<expr><name>CXXRecordDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RecordDecl</name><operator>::</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>CXXRecordDecl</name> <operator>*</operator><macro><name>getPreviousDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>RecordDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><macro><name>getPreviousDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>CXXRecordDecl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>RecordDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>CXXRecordDecl</name> <operator>*</operator><macro><name>getMostRecentNonInjectedDecl</name><argument_list>()</argument_list></macro> <block>{
<expr><name>CXXRecordDecl</name> <operator>*</operator><name>Recent</name> <operator>=</operator>
<call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;
<while>while <condition>(<expr><call><name><name>Recent</name><operator>-&gt;</operator><name>isInjectedClassName</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Recent</name><operator>-&gt;</operator><name>getPreviousDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Recent</name> <operator>=</operator> <call><name><name>Recent</name><operator>-&gt;</operator><name>getPreviousDecl</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
return Recent</block><empty_stmt>;</empty_stmt></while>
}</block>

<specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><macro><name>getMostRecentNonInjectedDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentNonInjectedDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>CXXRecordDecl</name> <operator>*</operator><macro><name>getDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{


<expr><name>auto</name> <operator>*</operator><name>DD</name> <operator>=</operator> <name>DefinitionData</name> <operator>?</operator> <name>DefinitionData</name> <operator>:</operator> <call><name>dataPtr</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><ternary><condition><expr><name>DD</name></expr> ?</condition><then> <expr><name><name>DD</name><operator>-&gt;</operator><name>Definition</name></name></expr> </then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DefinitionData</name> <operator>||</operator> <call><name>dataPtr</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>CXXRecordDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>TagKind TK</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation IdLoc</argument>,
<argument>IdentifierInfo *Id</argument>,
<argument>CXXRecordDecl *PrevDecl = nullptr</argument>,
<argument>bool DelayTypeCreation = false</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>CXXRecordDecl</name> <operator>*</operator><macro><name>CreateLambda</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>TypeSourceInfo *Info</argument>, <argument>SourceLocation Loc</argument>,
<argument>bool DependentLambda</argument>, <argument>bool IsGeneric</argument>,
<argument>LambdaCaptureDefault CaptureDefault</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>CXXRecordDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>bool</name> <macro><name>isDynamicClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>Polymorphic</name> <operator>||</operator> <call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>NumVBases</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
}</block>



<name>bool</name> <macro><name>mayBeDynamicClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name>hasDefinition</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isDynamicClass</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>hasAnyDependentBases</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>mayBeNonDynamicClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name>hasDefinition</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>isDynamicClass</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>hasAnyDependentBases</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setIsParsingBaseSpecifiers</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>IsParsingBaseSpecifiers</name> <operator>=</operator> <name>true</name></expr>; }</block>

<name>bool</name> <macro><name>isParsingBaseSpecifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>IsParsingBaseSpecifiers</name></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getODRHash</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>void</name> <macro><name>setBases</name><argument_list>(<argument>CXXBaseSpecifier const * const *Bases</argument>, <argument>unsigned NumBases</argument>)</argument_list></macro></expr>;


<expr><name>unsigned</name> <macro><name>getNumBases</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>NumBases</name></expr>;</return> }</block>

<name>using</name> <name>base_class_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>base_class_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>base_class_const_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>base_class_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>base_class_range</name> <macro><name>bases</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>base_class_range</name><argument_list>(<argument><expr><call><name>bases_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>bases_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>base_class_const_range</name> <macro><name>bases</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>base_class_const_range</name><argument_list>(<argument><expr><call><name>bases_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>bases_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>base_class_iterator</name> <macro><name>bases_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBases</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>base_class_const_iterator</name> <macro><name>bases_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBases</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>base_class_iterator</name> <macro><name>bases_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>bases_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>NumBases</name></expr>;</return> }</block>
<name>base_class_const_iterator</name> <macro><name>bases_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>bases_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>NumBases</name></expr>;</return>
}</block>


<name>unsigned</name> <macro><name>getNumVBases</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>NumVBases</name></expr>;</return> }</block>

<name>base_class_range</name> <macro><name>vbases</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>base_class_range</name><argument_list>(<argument><expr><call><name>vbases_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>vbases_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>base_class_const_range</name> <macro><name>vbases</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>base_class_const_range</name><argument_list>(<argument><expr><call><name>vbases_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>vbases_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>base_class_iterator</name> <macro><name>vbases_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getVBases</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>base_class_const_iterator</name> <macro><name>vbases_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getVBases</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>base_class_iterator</name> <macro><name>vbases_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>vbases_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>NumVBases</name></expr>;</return> }</block>
<name>base_class_const_iterator</name> <macro><name>vbases_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>vbases_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>NumVBases</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>hasAnyDependentBases</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>using</name> <name>method_iterator</name> <operator>=</operator> <name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>CXXMethodDecl</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>method_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>CXXMethodDecl</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>method_range</name> <macro><name>methods</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>method_range</name><argument_list>(<argument><expr><call><name>method_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>method_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>method_iterator</name> <macro><name>method_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>method_iterator</name><argument_list>(<argument><expr><call><name>decls_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>method_iterator</name> <macro><name>method_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>method_iterator</name><argument_list>(<argument><expr><call><name>decls_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>using</name> <name>ctor_iterator</name> <operator>=</operator> <name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructorDecl</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>ctor_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name><name>specific_decl_iterator</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructorDecl</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>ctor_range</name> <macro><name>ctors</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>ctor_range</name><argument_list>(<argument><expr><call><name>ctor_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>ctor_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>ctor_iterator</name> <macro><name>ctor_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>ctor_iterator</name><argument_list>(<argument><expr><call><name>decls_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>ctor_iterator</name> <macro><name>ctor_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>ctor_iterator</name><argument_list>(<argument><expr><call><name>decls_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>class</name> <name>friend_iterator</name></expr>;
<expr><name>using</name> <name>friend_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>friend_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>friend_range</name> <macro><name>friends</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>friend_iterator</name> <macro><name>friend_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>friend_iterator</name> <macro><name>friend_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <call><name>pushFriendDecl</name><argument_list>(<argument><expr><name>FriendDecl</name> <operator>*</operator><name>FD</name></expr></argument>)</argument_list></call></expr>;


<expr><name>bool</name> <macro><name>hasFriends</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>FirstFriend</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>defaultedCopyConstructorIsDeleted</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>!</operator><call><name>needsOverloadResolutionForCopyConstructor</name><argument_list>()</argument_list></call> <operator>||</operator>
<operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredSpecialMembers</name> <operator>&amp;</operator> <name>SMF_CopyConstructor</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"this property has not yet been computed by Sema"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedCopyConstructorIsDeleted</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>defaultedMoveConstructorIsDeleted</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>!</operator><call><name>needsOverloadResolutionForMoveConstructor</name><argument_list>()</argument_list></call> <operator>||</operator>
<operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredSpecialMembers</name> <operator>&amp;</operator> <name>SMF_MoveConstructor</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"this property has not yet been computed by Sema"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedMoveConstructorIsDeleted</name></expr>;</return>
}</block>


<name>bool</name> <macro><name>defaultedDestructorIsDeleted</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>!</operator><call><name>needsOverloadResolutionForDestructor</name><argument_list>()</argument_list></call> <operator>||</operator>
<operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredSpecialMembers</name> <operator>&amp;</operator> <name>SMF_Destructor</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"this property has not yet been computed by Sema"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedDestructorIsDeleted</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>hasSimpleCopyConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name>hasUserDeclaredCopyConstructor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedCopyConstructorIsDeleted</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>hasSimpleMoveConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name>hasUserDeclaredMoveConstructor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>hasMoveConstructor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedMoveConstructorIsDeleted</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>hasSimpleCopyAssignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name>hasUserDeclaredCopyAssignment</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedCopyAssignmentIsDeleted</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>hasSimpleMoveAssignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name>hasUserDeclaredMoveAssignment</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>hasMoveAssignment</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedMoveAssignmentIsDeleted</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>hasSimpleDestructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name>hasUserDeclaredDestructor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedDestructorIsDeleted</name></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasDefaultConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredSpecialMembers</name> <operator>&amp;</operator> <name>SMF_DefaultConstructor</name><operator>)</operator> <operator>||</operator>
<call><name>needsImplicitDefaultConstructor</name><argument_list>()</argument_list></call></expr>;</return>
}</block>





<name>bool</name> <macro><name>needsImplicitDefaultConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><operator>!</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>UserDeclaredConstructor</name> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredSpecialMembers</name> <operator>&amp;</operator> <name>SMF_DefaultConstructor</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><call><name>isLambda</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>lambdaIsDefaultConstructibleAndAssignable</name><argument_list>()</argument_list></call><operator>)</operator><operator>)</operator> <operator>||</operator>



<operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasInheritedDefaultConstructor</name> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredSpecialMembers</name> <operator>&amp;</operator> <name>SMF_DefaultConstructor</name><operator>)</operator><operator>)</operator></expr>;</return>
}</block>




<name>bool</name> <macro><name>hasUserDeclaredConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>UserDeclaredConstructor</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>hasUserProvidedDefaultConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>UserProvidedDefaultConstructor</name></expr>;</return>
}</block>




<name>bool</name> <macro><name>hasUserDeclaredCopyConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>UserDeclaredSpecialMembers</name> <operator>&amp;</operator> <name>SMF_CopyConstructor</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>needsImplicitCopyConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredSpecialMembers</name> <operator>&amp;</operator> <name>SMF_CopyConstructor</name><operator>)</operator></expr>;</return>
}</block>



<name>bool</name> <macro><name>needsOverloadResolutionForCopyConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{






<if_stmt><if>if <condition>(<expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>UserDeclaredSpecialMembers</name> <operator>&amp;</operator>
<operator>(</operator><name>SMF_MoveConstructor</name> <operator>|</operator> <name>SMF_MoveAssignment</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>NeedOverloadResolutionForCopyConstructor</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>implicitCopyConstructorHasConstParam</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>ImplicitCopyConstructorCanHaveConstParamForNonVBase</name> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>isAbstract</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>ImplicitCopyConstructorCanHaveConstParamForVBase</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasCopyConstructorWithConstParam</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasDeclaredCopyConstructorWithConstParam</name> <operator>||</operator>
<operator>(</operator><call><name>needsImplicitCopyConstructor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>implicitCopyConstructorHasConstParam</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>






<expr_stmt><expr><name>bool</name> <macro><name>hasUserDeclaredMoveOperation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>UserDeclaredSpecialMembers</name> <operator>&amp;</operator>
<operator>(</operator><name>SMF_MoveConstructor</name> <operator>|</operator> <name>SMF_MoveAssignment</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasUserDeclaredMoveConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>UserDeclaredSpecialMembers</name> <operator>&amp;</operator> <name>SMF_MoveConstructor</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasMoveConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredSpecialMembers</name> <operator>&amp;</operator> <name>SMF_MoveConstructor</name><operator>)</operator> <operator>||</operator>
<call><name>needsImplicitMoveConstructor</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>void</name></type> <name>setImplicitCopyConstructorIsDeleted</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedCopyConstructorIsDeleted</name> <operator>||</operator>
<call><name>needsOverloadResolutionForCopyConstructor</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Copy constructor should not be deleted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedCopyConstructorIsDeleted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>setImplicitMoveConstructorIsDeleted</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedMoveConstructorIsDeleted</name> <operator>||</operator>
<call><name>needsOverloadResolutionForMoveConstructor</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"move constructor should not be deleted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedMoveConstructorIsDeleted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>setImplicitDestructorIsDeleted</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedDestructorIsDeleted</name> <operator>||</operator>
<call><name>needsOverloadResolutionForDestructor</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"destructor should not be deleted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedDestructorIsDeleted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>needsImplicitMoveConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredSpecialMembers</name> <operator>&amp;</operator> <name>SMF_MoveConstructor</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>hasUserDeclaredCopyConstructor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>hasUserDeclaredCopyAssignment</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>hasUserDeclaredMoveAssignment</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>hasUserDeclaredDestructor</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>needsOverloadResolutionForMoveConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>NeedOverloadResolutionForMoveConstructor</name></expr>;</return>
}</block></expr></expr_stmt>





<expr_stmt><expr><name>bool</name> <macro><name>hasUserDeclaredCopyAssignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>UserDeclaredSpecialMembers</name> <operator>&amp;</operator> <name>SMF_CopyAssignment</name></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>void</name></type> <name>setImplicitCopyAssignmentIsDeleted</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedCopyAssignmentIsDeleted</name> <operator>||</operator>
<call><name>needsOverloadResolutionForCopyAssignment</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"copy assignment should not be deleted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedCopyAssignmentIsDeleted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>needsImplicitCopyAssignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredSpecialMembers</name> <operator>&amp;</operator> <name>SMF_CopyAssignment</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>needsOverloadResolutionForCopyAssignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{






<if_stmt><if>if <condition>(<expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>UserDeclaredSpecialMembers</name> <operator>&amp;</operator>
<operator>(</operator><name>SMF_MoveConstructor</name> <operator>|</operator> <name>SMF_MoveAssignment</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>NeedOverloadResolutionForCopyAssignment</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>implicitCopyAssignmentHasConstParam</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>ImplicitCopyAssignmentHasConstParam</name></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>hasCopyAssignmentWithConstParam</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasDeclaredCopyAssignmentWithConstParam</name> <operator>||</operator>
<operator>(</operator><call><name>needsImplicitCopyAssignment</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>implicitCopyAssignmentHasConstParam</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasUserDeclaredMoveAssignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>UserDeclaredSpecialMembers</name> <operator>&amp;</operator> <name>SMF_MoveAssignment</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasMoveAssignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredSpecialMembers</name> <operator>&amp;</operator> <name>SMF_MoveAssignment</name><operator>)</operator> <operator>||</operator>
<call><name>needsImplicitMoveAssignment</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>void</name></type> <name>setImplicitMoveAssignmentIsDeleted</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedMoveAssignmentIsDeleted</name> <operator>||</operator>
<call><name>needsOverloadResolutionForMoveAssignment</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"move assignment should not be deleted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedMoveAssignmentIsDeleted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>




<expr_stmt><expr><name>bool</name> <macro><name>needsImplicitMoveAssignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredSpecialMembers</name> <operator>&amp;</operator> <name>SMF_MoveAssignment</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>hasUserDeclaredCopyConstructor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>hasUserDeclaredCopyAssignment</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>hasUserDeclaredMoveConstructor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>hasUserDeclaredDestructor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><call><name>isLambda</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>lambdaIsDefaultConstructibleAndAssignable</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>needsOverloadResolutionForMoveAssignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>NeedOverloadResolutionForMoveAssignment</name></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>hasUserDeclaredDestructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>UserDeclaredSpecialMembers</name> <operator>&amp;</operator> <name>SMF_Destructor</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>needsImplicitDestructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredSpecialMembers</name> <operator>&amp;</operator> <name>SMF_Destructor</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>needsOverloadResolutionForDestructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>NeedOverloadResolutionForDestructor</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isLambda</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{

<expr><name>auto</name> <operator>*</operator><name>DD</name> <operator>=</operator> <name>DefinitionData</name></expr>;
<return>return <expr><name>DD</name> <operator>&amp;&amp;</operator> <name><name>DD</name><operator>-&gt;</operator><name>IsLambda</name></name></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>isGenericLambda</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>lambdaIsDefaultConstructibleAndAssignable</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>CXXMethodDecl</name> <operator>*</operator><macro><name>getLambdaCallOperator</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>FunctionTemplateDecl</name> <operator>*</operator><macro><name>getDependentLambdaCallOperator</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>








<expr_stmt><expr><name>CXXMethodDecl</name> <operator>*</operator><macro><name>getLambdaStaticInvoker</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<decl_stmt><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>getLambdaStaticInvoker</name><argument_list>(<argument><expr><name>CallingConv</name> <name>CC</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<expr_stmt><expr><name>TemplateParameterList</name> <operator>*</operator><macro><name>getGenericLambdaTemplateParameterList</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getLambdaExplicitTemplateParameters</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>LambdaCaptureDefault</name> <macro><name>getLambdaCaptureDefault</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isLambda</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>LambdaCaptureDefault</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getLambdaData</name><argument_list>()</argument_list></call><operator>.</operator><name>CaptureDefault</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function_decl><type><name>void</name></type> <name>setCaptures</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>LambdaCapture</name></expr></argument>&gt;</argument_list></name></type> <name>Captures</name></decl></parameter>)</parameter_list>;</function_decl>













<decl_stmt><decl><type><name>void</name></type> <name>getCaptureFields</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>FieldDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Captures</name></expr></argument>,
<argument><expr><name>FieldDecl</name> <operator>*</operator><operator>&amp;</operator><name>ThisCapture</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>capture_const_iterator</name> <init>= <expr><specifier>const</specifier> <name>LambdaCapture</name> <operator>*</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>capture_const_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>capture_const_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>capture_const_range</name> <macro><name>captures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>capture_const_range</name><argument_list>(<argument><expr><call><name>captures_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>captures_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>capture_const_iterator</name> <macro><name>captures_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isLambda</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name>getLambdaData</name><argument_list>()</argument_list></call><operator>.</operator><name>Captures</name> <operator>:</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>capture_const_iterator</name> <macro><name>captures_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isLambda</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name>captures_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getLambdaData</name><argument_list>()</argument_list></call><operator>.</operator><name>NumCaptures</name>
<operator>:</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>capture_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLambdaData</name><argument_list>()</argument_list></call><operator>.</operator><name>NumCaptures</name></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>conversion_iterator</name> <init>= <expr><name>UnresolvedSetIterator</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>conversion_iterator</name> <macro><name>conversion_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>Conversions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>conversion_iterator</name> <macro><name>conversion_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>Conversions</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<function_decl><type><name>void</name></type> <name>removeConversion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>conversion_iterator</name></expr></argument>&gt;</argument_list></name>
<macro><name>getVisibleConversionFunctions</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>





<expr_stmt><expr><name>bool</name> <macro><name>isAggregate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>Aggregate</name></expr>;</return> }</block></expr></expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>hasInClassInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasInClassInitializer</name></expr>;</return> }</block></expr></expr_stmt>









<expr_stmt><expr><name>bool</name> <macro><name>hasUninitializedReferenceMember</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name>isUnion</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>hasUserDeclaredConstructor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasUninitializedReferenceMember</name></expr>;</return>
}</block></expr></expr_stmt>









<expr_stmt><expr><name>bool</name> <macro><name>isPOD</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>PlainOldData</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isCLike</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>










<expr_stmt><expr><name>bool</name> <macro><name>isEmpty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>Empty</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasPrivateFields</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasPrivateFields</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasProtectedFields</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasProtectedFields</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasDirectFields</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <operator>&amp;</operator><name>D</name> <operator>=</operator> <call><name>data</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name><name>D</name><operator>.</operator><name>HasPublicFields</name></name> <operator>||</operator> <name><name>D</name><operator>.</operator><name>HasProtectedFields</name></name> <operator>||</operator> <name><name>D</name><operator>.</operator><name>HasPrivateFields</name></name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isPolymorphic</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>Polymorphic</name></expr>;</return> }</block></expr></expr_stmt>






<expr_stmt><expr><name>bool</name> <macro><name>isAbstract</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>Abstract</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isStandardLayout</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>IsStandardLayout</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isCXX11StandardLayout</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>IsCXX11StandardLayout</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasMutableFields</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasMutableFields</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasVariantMembers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasVariantMembers</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasTrivialDefaultConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasDefaultConstructor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasTrivialSpecialMembers</name> <operator>&amp;</operator> <name>SMF_DefaultConstructor</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasNonTrivialDefaultConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredNonTrivialSpecialMembers</name> <operator>&amp;</operator> <name>SMF_DefaultConstructor</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>needsImplicitDefaultConstructor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasTrivialSpecialMembers</name> <operator>&amp;</operator> <name>SMF_DefaultConstructor</name><operator>)</operator><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasConstexprNonCopyMoveConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasConstexprNonCopyMoveConstructor</name> <operator>||</operator>
<operator>(</operator><call><name>needsImplicitDefaultConstructor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>defaultedDefaultConstructorIsConstexpr</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>defaultedDefaultConstructorIsConstexpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedDefaultConstructorIsConstexpr</name> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><call><name>isUnion</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>hasInClassInitializer</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>hasVariantMembers</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>CPlusPlus20</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasConstexprDefaultConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasConstexprDefaultConstructor</name> <operator>||</operator>
<operator>(</operator><call><name>needsImplicitDefaultConstructor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>defaultedDefaultConstructorIsConstexpr</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasTrivialCopyConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasTrivialSpecialMembers</name> <operator>&amp;</operator> <name>SMF_CopyConstructor</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasTrivialCopyConstructorForCall</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasTrivialSpecialMembersForCall</name> <operator>&amp;</operator> <name>SMF_CopyConstructor</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasNonTrivialCopyConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredNonTrivialSpecialMembers</name> <operator>&amp;</operator> <name>SMF_CopyConstructor</name> <operator>||</operator>
<operator>!</operator><call><name>hasTrivialCopyConstructor</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasNonTrivialCopyConstructorForCall</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredNonTrivialSpecialMembersForCall</name> <operator>&amp;</operator>
<name>SMF_CopyConstructor</name><operator>)</operator> <operator>||</operator>
<operator>!</operator><call><name>hasTrivialCopyConstructorForCall</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasTrivialMoveConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasMoveConstructor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasTrivialSpecialMembers</name> <operator>&amp;</operator> <name>SMF_MoveConstructor</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasTrivialMoveConstructorForCall</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasMoveConstructor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasTrivialSpecialMembersForCall</name> <operator>&amp;</operator> <name>SMF_MoveConstructor</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasNonTrivialMoveConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredNonTrivialSpecialMembers</name> <operator>&amp;</operator> <name>SMF_MoveConstructor</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>needsImplicitMoveConstructor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasTrivialSpecialMembers</name> <operator>&amp;</operator> <name>SMF_MoveConstructor</name><operator>)</operator><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasNonTrivialMoveConstructorForCall</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredNonTrivialSpecialMembersForCall</name> <operator>&amp;</operator>
<name>SMF_MoveConstructor</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>needsImplicitMoveConstructor</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasTrivialSpecialMembersForCall</name> <operator>&amp;</operator> <name>SMF_MoveConstructor</name><operator>)</operator><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasTrivialCopyAssignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasTrivialSpecialMembers</name> <operator>&amp;</operator> <name>SMF_CopyAssignment</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasNonTrivialCopyAssignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredNonTrivialSpecialMembers</name> <operator>&amp;</operator> <name>SMF_CopyAssignment</name> <operator>||</operator>
<operator>!</operator><call><name>hasTrivialCopyAssignment</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasTrivialMoveAssignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasMoveAssignment</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasTrivialSpecialMembers</name> <operator>&amp;</operator> <name>SMF_MoveAssignment</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasNonTrivialMoveAssignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DeclaredNonTrivialSpecialMembers</name> <operator>&amp;</operator> <name>SMF_MoveAssignment</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>needsImplicitMoveAssignment</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasTrivialSpecialMembers</name> <operator>&amp;</operator> <name>SMF_MoveAssignment</name><operator>)</operator><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>defaultedDestructorIsConstexpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>DefaultedDestructorIsConstexpr</name> <operator>&amp;&amp;</operator>
<call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>CPlusPlus20</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasConstexprDestructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasTrivialDestructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasTrivialSpecialMembers</name> <operator>&amp;</operator> <name>SMF_Destructor</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasTrivialDestructorForCall</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasTrivialSpecialMembersForCall</name> <operator>&amp;</operator> <name>SMF_Destructor</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasNonTrivialDestructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasTrivialSpecialMembers</name> <operator>&amp;</operator> <name>SMF_Destructor</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasNonTrivialDestructorForCall</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasTrivialSpecialMembersForCall</name> <operator>&amp;</operator> <name>SMF_Destructor</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setHasTrivialSpecialMemberForCall</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasTrivialSpecialMembersForCall</name> <operator>=</operator>
<operator>(</operator><name>SMF_CopyConstructor</name> <operator>|</operator> <name>SMF_MoveConstructor</name> <operator>|</operator> <name>SMF_Destructor</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>allowConstDefaultInit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasUninitializedFields</name> <operator>||</operator>
<operator>!</operator><operator>(</operator><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasDefaultedDefaultConstructor</name> <operator>||</operator>
<call><name>needsImplicitDefaultConstructor</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>






<expr_stmt><expr><name>bool</name> <macro><name>hasIrrelevantDestructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasIrrelevantDestructor</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasNonLiteralTypeFieldsOrBases</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasNonLiteralTypeFieldsOrBases</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasInheritedConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasInheritedConstructor</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasInheritedAssignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>HasInheritedAssignment</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isTriviallyCopyable</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>






<expr_stmt><expr><name>bool</name> <macro><name>isTrivial</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isTriviallyCopyable</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>hasTrivialDefaultConstructor</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


















<expr_stmt><expr><name>bool</name> <macro><name>isLiteral</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><name>LangOpts</name> <operator>=</operator> <call><name>getLangOpts</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>LangOpts</name><operator>.</operator><name>CPlusPlus20</name></name></expr> ?</condition><then> <expr><call><name>hasConstexprDestructor</name><argument_list>()</argument_list></call></expr>
</then><else>: <expr><call><name>hasTrivialDestructor</name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><call><name>isLambda</name><argument_list>()</argument_list></call> <operator>||</operator> <name><name>LangOpts</name><operator>.</operator><name>CPlusPlus17</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>hasNonLiteralTypeFieldsOrBases</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>isAggregate</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isLambda</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name>hasConstexprNonCopyMoveConstructor</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name>hasTrivialDefaultConstructor</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isStructural</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isLiteral</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>StructuralIfLiteral</name></expr>;</return>
}</block></expr></expr_stmt>




















<expr_stmt><expr><name>CXXRecordDecl</name> <operator>*</operator><macro><name>getInstantiatedFromMemberClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>MemberSpecializationInfo</name> <operator>*</operator><macro><name>getMemberSpecializationInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<function_decl><type><name>void</name></type> <name>setInstantiationOfMemberClass</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>,
<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name></decl></parameter>)</parameter_list>;</function_decl>












<expr_stmt><expr><name>ClassTemplateDecl</name> <operator>*</operator><macro><name>getDescribedClassTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>setDescribedClassTemplate</name><parameter_list>(<parameter><decl><type><name>ClassTemplateDecl</name> <modifier>*</modifier></type><name>Template</name></decl></parameter>)</parameter_list>;</function_decl>




<expr_stmt><expr><name>TemplateSpecializationKind</name> <macro><name>getTemplateSpecializationKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<function_decl><type><name>void</name></type> <name>setTemplateSpecializationKind</name><parameter_list>(<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><macro><name>getTemplateInstantiationPattern</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>getTemplateInstantiationPattern</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>getTemplateInstantiationPattern</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<expr_stmt><expr><name>CXXDestructorDecl</name> <operator>*</operator><macro><name>getDestructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isAnyDestructorNoReturn</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>IsAnyDestructorNoReturn</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><macro><name>isLocalClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>RD</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDeclContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>RD</name><operator>-&gt;</operator><name>isLocalClass</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDeclContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

FunctionDecl <expr_stmt><expr><operator>*</operator><macro><name>isLocalClass</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>isLocalClass</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isCurrentInstantiation</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><name>CurContext</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>











<decl_stmt><decl><type><name>bool</name></type> <name>isDerivedFrom</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>Base</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

















<decl_stmt><decl><type><name>bool</name></type> <name>isDerivedFrom</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>Base</name></expr></argument>, <argument><expr><name>CXXBasePaths</name> <operator>&amp;</operator><name>Paths</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>














<decl_stmt><decl><type><name>bool</name></type> <name>isVirtuallyDerivedFrom</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>Base</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isProvablyNotDerivedFrom</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>Base</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<decl_stmt><decl><type><name>using</name></type> <name>ForallBasesCallback</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>bool</name><operator>(</operator><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>BaseDefinition</name><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>









<decl_stmt><decl><type><name>bool</name></type> <name>forallBases</name><argument_list>(<argument><expr><name>ForallBasesCallback</name> <name>BaseMatches</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>











<decl_stmt><decl><type><name>using</name></type> <name>BaseMatchesCallback</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>bool</name><operator>(</operator><specifier>const</specifier> <name>CXXBaseSpecifier</name> <operator>*</operator><name>Specifier</name>,
<name>CXXBasePath</name> <operator>&amp;</operator><name>Path</name><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>






















<decl_stmt><decl><type><name>bool</name></type> <name>lookupInBases</name><argument_list>(<argument><expr><name>BaseMatchesCallback</name> <name>BaseMatches</name></expr></argument>, <argument><expr><name>CXXBasePaths</name> <operator>&amp;</operator><name>Paths</name></expr></argument>,
<argument><expr><name>bool</name> <name>LookupInDependent</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>








<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FindBaseClass</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXBaseSpecifier</name> <modifier>*</modifier></type><name>Specifier</name></decl></parameter>,
<parameter><decl><type><name>CXXBasePath</name> <modifier>&amp;</modifier></type><name>Path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>BaseRecord</name></decl></parameter>)</parameter_list>;</function_decl>










<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FindVirtualBaseClass</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXBaseSpecifier</name> <modifier>*</modifier></type><name>Specifier</name></decl></parameter>,
<parameter><decl><type><name>CXXBasePath</name> <modifier>&amp;</modifier></type><name>Path</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>BaseRecord</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>void</name></type> <name>getFinalOverriders</name><argument_list>(<argument><expr><name>CXXFinalOverriderMap</name> <operator>&amp;</operator><name>FinaOverriders</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>getIndirectPrimaryBases</name><argument_list>(<argument><expr><name>CXXIndirectPrimaryBaseSet</name><operator>&amp;</operator> <name>Bases</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>







<decl_stmt><decl><type><name>bool</name></type> <name>hasMemberName</name><argument_list>(<argument><expr><name>DeclarationName</name> <name>N</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<macro><name>lookupDependentName</name><argument_list>(<argument>DeclarationName Name</argument>,
<argument>llvm::function_ref&lt;bool(const NamedDecl *ND)&gt; Filter</argument>)</argument_list></macro></expr>;</expr_stmt>




<decl_stmt><decl><type><name>void</name></type> <name>viewInheritance</name><argument_list>(<argument><expr><name>ASTContext</name><operator>&amp;</operator> <name>Context</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<function><type><specifier>static</specifier> <name>AccessSpecifier</name></type> <name>MergeAccess</name><parameter_list>(<parameter><decl><type><name>AccessSpecifier</name></type> <name>PathAccess</name></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>DeclAccess</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>DeclAccess</name> <operator>!=</operator> <name>AS_none</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>DeclAccess</name> <operator>==</operator> <name>AS_private</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>AS_none</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><name>PathAccess</name> <operator>&gt;</operator> <name>DeclAccess</name></expr> ?</condition><then> <expr><name>PathAccess</name></expr> </then><else>: <expr><name>DeclAccess</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<function_decl><type><name>void</name></type> <name>finishedDefaultedOrDeletedMember</name><parameter_list>(<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>setTrivialForCallFlags</name><parameter_list>(<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>void</name> <macro><name>completeDefinition</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>








<function_decl><type><name>void</name></type> <name>completeDefinition</name><parameter_list>(<parameter><decl><type><name>CXXFinalOverriderMap</name> <modifier>*</modifier></type><name>FinalOverriders</name></decl></parameter>)</parameter_list>;</function_decl>








<expr_stmt><expr><name>bool</name> <macro><name>mayBeAbstract</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isEffectivelyFinal</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>







<expr_stmt><expr><name>unsigned</name> <macro><name>getLambdaManglingNumber</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isLambda</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Not a lambda closure type!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getLambdaData</name><argument_list>()</argument_list></call><operator>.</operator><name>ManglingNumber</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasKnownLambdaInternalLinkage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isLambda</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Not a lambda closure type!"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>getLambdaData</name><argument_list>()</argument_list></call><operator>.</operator><name>HasKnownInternalLinkage</name></expr>;</return>
}</block></expr></expr_stmt>










<expr_stmt><expr><name>Decl</name> <operator>*</operator><macro><name>getLambdaContextDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<function><type><name>void</name></type> <name>setLambdaMangling</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>ManglingNumber</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ContextDecl</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>HasKnownInternalLinkage</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isLambda</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Not a lambda closure type!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>getLambdaData</name><argument_list>()</argument_list></call><operator>.</operator><name>ManglingNumber</name> <operator>=</operator> <name>ManglingNumber</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>getLambdaData</name><argument_list>()</argument_list></call><operator>.</operator><name>ContextDecl</name> <operator>=</operator> <name>ContextDecl</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>getLambdaData</name><argument_list>()</argument_list></call><operator>.</operator><name>HasKnownInternalLinkage</name> <operator>=</operator> <name>HasKnownInternalLinkage</name></expr>;</expr_stmt>
</block_content>}</block></function>


<decl_stmt><decl><type><name>void</name></type> <name>setDeviceLambdaManglingNumber</name><argument_list>(<argument><expr><name>unsigned</name> <name>Num</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getDeviceLambdaManglingNumber</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>MSInheritanceModel</name> <macro><name>getMSInheritanceModel</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>MSInheritanceModel</name> <macro><name>calculateInheritanceModel</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>







<expr_stmt><expr><name>bool</name> <macro><name>nullFieldOffsetIsZero</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>MSVtorDispMode</name> <macro><name>getMSVtorDispMode</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>












<expr_stmt><expr><name>bool</name> <macro><name>isDependentLambda</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isLambda</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>getLambdaData</name><argument_list>()</argument_list></call><operator>.</operator><name>Dependent</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>TypeSourceInfo</name> <operator>*</operator><macro><name>getLambdaTypeInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLambdaData</name><argument_list>()</argument_list></call><operator>.</operator><name>MethodTyInfo</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isInterfaceLike</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>K</name> <operator>&gt;=</operator> <name>firstCXXRecord</name> <operator>&amp;&amp;</operator> <name>K</name> <operator>&lt;=</operator> <name>lastCXXRecord</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>markAbstract</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>data</name><argument_list>()</argument_list></call><operator>.</operator><name>Abstract</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> </block_content>}</block></function>
};



<decl_stmt><decl><type><name>class</name></type> <name>ExplicitSpecifier</name> <block>{<block_content>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ExplicitSpecKind</name></expr></argument>&gt;</argument_list></name> <name>ExplicitSpec</name><block>{
<expr><name>nullptr</name></expr>, <expr><name>ExplicitSpecKind</name><operator>::</operator><name>ResolvedFalse</name></expr>}</block></expr>;</expr_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>ExplicitSpecifier</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<macro><name>ExplicitSpecifier</name><argument_list>(<argument>Expr *Expression</argument>, <argument>ExplicitSpecKind Kind</argument>)</argument_list></macro>
: <macro><name>ExplicitSpec</name><argument_list>(<argument>Expression</argument>, <argument>Kind</argument>)</argument_list></macro> <block>{<block_content/>}</block>
<expr_stmt><expr><name>ExplicitSpecKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>ExplicitSpec</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>ExplicitSpec</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>Expr</name> <modifier>*</modifier></type><name>getExpr</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>ExplicitSpec</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>isSpecified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>ExplicitSpec</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>ExplicitSpecKind</name><operator>::</operator><name>ResolvedFalse</name> <operator>||</operator>
<call><name><name>ExplicitSpec</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isEquivalent</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ExplicitSpecifier</name> <name>Other</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isExplicit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>ExplicitSpec</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ExplicitSpecKind</name><operator>::</operator><name>ResolvedTrue</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isInvalid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>ExplicitSpec</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ExplicitSpecKind</name><operator>::</operator><name>Unresolved</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name><name>ExplicitSpec</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setKind</name><parameter_list>(<parameter><decl><type><name>ExplicitSpecKind</name></type> <name>Kind</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>ExplicitSpec</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>ExplicitSpec</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>ExplicitSpecifier</name></type> <name>getFromDecl</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Function</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>ExplicitSpecifier</name></type> <name>getFromDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>Function</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getFromDecl</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Function</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>ExplicitSpecifier</name></type> <name>Invalid</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>ExplicitSpecifier</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>ExplicitSpecKind</name><operator>::</operator><name>Unresolved</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>











<decl_stmt><decl><type><name>class</name></type> <name>CXXDeductionGuideDecl</name> <range>: <expr><name>public</name> <name>FunctionDecl</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>private</name><operator>:</operator>
<macro><name>CXXDeductionGuideDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>ExplicitSpecifier ES</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>, <argument>QualType T</argument>,
<argument>TypeSourceInfo *TInfo</argument>, <argument>SourceLocation EndLocation</argument>,
<argument>CXXConstructorDecl *Ctor</argument>)</argument_list></macro>
<operator>:</operator> <call><name>FunctionDecl</name><argument_list>(<argument><expr><name>CXXDeductionGuide</name></expr></argument>, <argument><expr><name>C</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>NameInfo</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>TInfo</name></expr></argument>,
<argument><expr><name>SC_None</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ConstexprSpecKind</name><operator>::</operator><name>Unspecified</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Ctor</name><argument_list>(<argument><expr><name>Ctor</name></expr></argument>)</argument_list></call></expr>, <macro><name>ExplicitSpec</name><argument_list>(<argument>ES</argument>)</argument_list></macro> <expr><block>{
<if_stmt><if>if <condition>(<expr><call><name><name>EndLocation</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setRangeEnd</name><argument_list>(<argument><expr><name>EndLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<call><name>setIsCopyDeductionCandidate</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></block></expr>;
}</block>

<name>CXXConstructorDecl</name> <operator>*</operator><name>Ctor</name></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExplicitSpecifier</name></type> <name>ExplicitSpec</name></decl>;</decl_stmt>
<function><type><name>void</name></type> <name>setExplicitSpecifier</name><parameter_list>(<parameter><decl><type><name>ExplicitSpecifier</name></type> <name>ES</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>ExplicitSpec</name> <operator>=</operator> <name>ES</name></expr>;</expr_stmt> </block_content>}</block></function>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclWriter</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>CXXDeductionGuideDecl</name> <modifier>*</modifier></type>
<name>Create</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>ExplicitSpecifier</name></type> <name>ES</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLocation</name></decl></parameter>,
<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Ctor</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>CXXDeductionGuideDecl</name> <modifier>*</modifier></type><name>CreateDeserialized</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>ExplicitSpecifier</name></type> <name>getExplicitSpecifier</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>ExplicitSpec</name></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>ExplicitSpecifier</name> <macro><name>getExplicitSpecifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ExplicitSpec</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isExplicit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>ExplicitSpec</name><operator>.</operator><name>isExplicit</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>TemplateDecl</name> <operator>*</operator><macro><name>getDeducedTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getDeclName</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCXXDeductionGuideTemplate</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>CXXConstructorDecl</name> <operator>*</operator><macro><name>getCorrespondingConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Ctor</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setIsCopyDeductionCandidate</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCDC</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsCopyDeductionCandidate</name></name> <operator>=</operator> <name>isCDC</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>isCopyDeductionCandidate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>FunctionDeclBits</name><operator>.</operator><name>IsCopyDeductionCandidate</name></name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>K</name> <operator>==</operator> <name>CXXDeductionGuide</name></expr>;</return> </block_content>}</block></function>
};














<decl_stmt><decl><type><name>class</name></type> <name>RequiresExprBodyDecl</name> <range>: <expr><name>public</name> <name>Decl</name></expr></range></decl>, <decl><type ref="prev"/><name>public</name> <name>DeclContext</name> <block>{<block_content>
<macro><name>RequiresExprBodyDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Decl</name><argument_list>(<argument><expr><name>RequiresExprBody</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>DeclContext</name><argument_list>(<argument>RequiresExprBody</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclWriter</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>RequiresExprBodyDecl</name> <modifier>*</modifier></type><name>Create</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>RequiresExprBodyDecl</name> <modifier>*</modifier></type><name>CreateDeserialized</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>K</name> <operator>==</operator> <name>RequiresExprBody</name></expr>;</return> </block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>





<decl_stmt><decl><type><name>class</name></type> <name>CXXMethodDecl</name> <range>: <expr><name>public</name> <name>FunctionDecl</name> <block>{
<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>CXXMethodDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>ASTContext &amp;C</argument>, <argument>CXXRecordDecl *RD</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>const DeclarationNameInfo &amp;NameInfo</argument>,
<argument>QualType T</argument>, <argument>TypeSourceInfo *TInfo</argument>, <argument>StorageClass SC</argument>,
<argument>bool isInline</argument>, <argument>ConstexprSpecKind ConstexprKind</argument>,
<argument>SourceLocation EndLocation</argument>,
<argument>Expr *TrailingRequiresClause = nullptr</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>FunctionDecl</name><argument_list>(<argument>DK</argument>, <argument>C</argument>, <argument>RD</argument>, <argument>StartLoc</argument>, <argument>NameInfo</argument>, <argument>T</argument>, <argument>TInfo</argument>, <argument>SC</argument>, <argument>isInline</argument>,
<argument>ConstexprKind</argument>, <argument>TrailingRequiresClause</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>EndLocation</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setRangeEnd</name><argument_list>(<argument><expr><name>EndLocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>CXXMethodDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>CXXRecordDecl *RD</argument>,
<argument>SourceLocation StartLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>, <argument>QualType T</argument>,
<argument>TypeSourceInfo *TInfo</argument>, <argument>StorageClass SC</argument>,
<argument>bool isInline</argument>, <argument>ConstexprSpecKind ConstexprKind</argument>,
<argument>SourceLocation EndLocation</argument>,
<argument>Expr *TrailingRequiresClause = nullptr</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>CXXMethodDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>bool</name> <macro><name>isStatic</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isInstance</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>isStatic</name><argument_list>()</argument_list></call></expr>;</return> }</block>



<specifier>static</specifier> <name>bool</name> <macro><name>isStaticOverloadedOperator</name><argument_list>(<argument>OverloadedOperatorKind OOK</argument>)</argument_list></macro> <block>{





<return>return <expr><name>OOK</name> <operator>==</operator> <name>OO_New</name> <operator>||</operator> <name>OOK</name> <operator>==</operator> <name>OO_Array_New</name> <operator>||</operator> <name>OOK</name> <operator>==</operator> <name>OO_Delete</name> <operator>||</operator>
<name>OOK</name> <operator>==</operator> <name>OO_Array_Delete</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isConst</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>castAs</name><argument_list type="generic">&lt;<argument><expr><name>FunctionType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isConst</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>isVolatile</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>castAs</name><argument_list type="generic">&lt;<argument><expr><name>FunctionType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isVolatile</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>isVirtual</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>CXXMethodDecl</name> <operator>*</operator><name>CD</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXMethodDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr>;



<if_stmt><if>if <condition>(<expr><call><name><name>CD</name><operator>-&gt;</operator><name>isVirtualAsWritten</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>CD</name><operator>-&gt;</operator><name>isPure</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name><name>CD</name><operator>-&gt;</operator><name>size_overridden_methods</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
}</block></expr></range></decl></decl_stmt>






<function_decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>getDevirtualizedMethod</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsAppleKext</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>getDevirtualizedMethod</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>Base</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsAppleKext</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXMethodDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getDevirtualizedMethod</name><argument_list>(
<argument><expr><name>Base</name></expr></argument>, <argument><expr><name>IsAppleKext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>








<decl_stmt><decl><type><name>bool</name></type> <name>isUsualDeallocationFunction</name><argument_list>(
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>PreventedBy</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isCopyAssignmentOperator</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isMoveAssignmentOperator</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>getCanonicalDecl</name><parameter_list>()</parameter_list> override <block>{<block_content>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXMethodDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>FunctionDecl</name><operator>::</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>CXXMethodDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXMethodDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>getMostRecentDecl</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXMethodDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>CXXMethodDecl</name> <operator>*</operator><macro><name>getMostRecentDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXMethodDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function_decl><type><name>void</name></type> <name>addOverriddenMethod</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>using</name></type> <name>method_iterator</name> <init>= <expr><specifier>const</specifier> <name>CXXMethodDecl</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>method_iterator</name> <macro><name>begin_overridden_methods</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>method_iterator</name> <macro><name>end_overridden_methods</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>size_overridden_methods</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>overridden_method_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;
<argument><expr><name>llvm</name><operator>::</operator><name><name>TinyPtrVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXMethodDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>overridden_method_range</name> <macro><name>overridden_methods</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><macro><name>getParent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>FunctionDecl</name><operator>::</operator><call><name>getParent</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>getParent</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>FunctionDecl</name><operator>::</operator><call><name>getParent</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>







<expr_stmt><expr><name>QualType</name> <macro><name>getThisType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>QualType</name> <macro><name>getThisObjectType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function_decl><type><specifier>static</specifier> <name>QualType</name></type> <name>getThisType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>FPT</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>QualType</name></type> <name>getThisObjectType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>FPT</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>Qualifiers</name> <macro><name>getMethodQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>castAs</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getMethodQuals</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>












<expr_stmt><expr><name>RefQualifierKind</name> <macro><name>getRefQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>castAs</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getRefQualifier</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasInlineBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>








<expr_stmt><expr><name>bool</name> <macro><name>isLambdaStaticInvoker</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>






<function_decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type>
<name>getCorrespondingMethodInClass</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>MayBeBase</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type>
<name>getCorrespondingMethodInClass</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>,
<argument><expr><name>bool</name> <name>MayBeBase</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXMethodDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>getCorrespondingMethodInClass</name><argument_list>(<argument><expr><name>RD</name></expr></argument>, <argument><expr><name>MayBeBase</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<function_decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>getCorrespondingMethodDeclaredInClass</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>MayBeBase</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type>
<name>getCorrespondingMethodDeclaredInClass</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>,
<argument><expr><name>bool</name> <name>MayBeBase</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXMethodDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>getCorrespondingMethodDeclaredInClass</name><argument_list>(<argument><expr><name>RD</name></expr></argument>, <argument><expr><name>MayBeBase</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>K</name> <operator>&gt;=</operator> <name>firstCXXMethod</name> <operator>&amp;&amp;</operator> <name>K</name> <operator>&lt;=</operator> <name>lastCXXMethod</name></expr>;</return>
</block_content>}</block></function>
};
















<decl_stmt><decl><type><name>class</name> <name>CXXCtorInitializer</name></type> <name>final</name> <block>{<block_content>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>FieldDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>IndirectFieldDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>Initializee</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Init</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>SourceLocation</name></type> <name>MemberOrEllipsisLocation</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>IsDelegating</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>IsVirtual</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>IsWritten</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>SourceOrder</name> <range>: <expr><literal type="number">13</literal></expr></range></decl>;</decl_stmt>

<label><name>public</name>:</label>

<function_decl><type><name>explicit</name></type>
<name>CXXCtorInitializer</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsVirtual</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>L</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>R</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>explicit</name></type>
<name>CXXCtorInitializer</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>Member</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>MemberLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>L</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>R</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>explicit</name></type>
<name>CXXCtorInitializer</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name>IndirectFieldDecl</name> <modifier>*</modifier></type><name>Member</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>MemberLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>L</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>R</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>explicit</name></type>
<name>CXXCtorInitializer</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>L</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>R</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>int64_t</name></type> <name>getID</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isBaseInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Initializee</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>TypeSourceInfo</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>IsDelegating</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isMemberInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Initializee</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>FieldDecl</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isAnyMemberInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isMemberInitializer</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isIndirectMemberInitializer</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isIndirectMemberInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Initializee</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>IndirectFieldDecl</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>







<expr_stmt><expr><name>bool</name> <macro><name>isInClassMemberInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Init</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Stmt</name><operator>::</operator><name>CXXDefaultInitExprClass</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isDelegatingInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Initializee</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>TypeSourceInfo</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>&amp;&amp;</operator> <name>IsDelegating</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isPackExpansion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isBaseInitializer</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>MemberOrEllipsisLocation</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEllipsisLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isPackExpansion</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><block>{}</block></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>MemberOrEllipsisLocation</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<expr_stmt><expr><name>TypeLoc</name> <macro><name>getBaseClassLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><macro><name>getBaseClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isBaseVirtual</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isBaseInitializer</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Must call this on base initializer!"</literal></expr></argument>)</argument_list></call></expr>;

<return>return <expr><name>IsVirtual</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>TypeSourceInfo</name> <operator>*</operator><macro><name>getTypeSourceInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Initializee</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>TypeSourceInfo</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>FieldDecl</name> <operator>*</operator><macro><name>getMember</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isMemberInitializer</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>Initializee</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>FieldDecl</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>nullptr</name></expr>;</return>
}

FieldDecl <expr_stmt><expr><operator>*</operator><macro><name>getAnyMember</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isMemberInitializer</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>Initializee</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>FieldDecl</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isIndirectMemberInitializer</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>Initializee</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>IndirectFieldDecl</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>-&gt;</operator><call><name>getAnonField</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>nullptr</name></expr>;</return>
}

IndirectFieldDecl <expr_stmt><expr><operator>*</operator><macro><name>getIndirectMember</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isIndirectMemberInitializer</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>Initializee</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>IndirectFieldDecl</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>nullptr</name></expr>;</return>
}

SourceLocation <macro><name>getMemberLocation</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<return>return <expr><name>MemberOrEllipsisLocation</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getSourceLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsWritten</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>int</name> <macro><name>getSourceOrder</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>IsWritten</name> <operator>?</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>SourceOrder</name></expr></argument>)</argument_list></call> <operator>:</operator> <operator>-</operator><literal type="number">1</literal></expr>;</return>
}</block></expr></expr_stmt>








<function><type><name>void</name></type> <name>setSourceOrder</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>Pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>IsWritten</name> <operator>&amp;&amp;</operator>
<literal type="string">"setSourceOrder() used on implicit initializer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>SourceOrder</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<literal type="string">"calling twice setSourceOrder() on the same initializer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>Pos</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<literal type="string">"setSourceOrder() used to make an initializer implicit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>IsWritten</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>SourceOrder</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getInit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
};


<decl_stmt><decl><type><name>class</name></type> <name>InheritedConstructor</name> <block>{<block_content>
<decl_stmt><decl><type><name>ConstructorUsingShadowDecl</name> <modifier>*</modifier></type><name>Shadow</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>BaseCtor</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>InheritedConstructor</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<expr_stmt><expr><call><name>InheritedConstructor</name><argument_list>(<argument><expr><name>ConstructorUsingShadowDecl</name> <operator>*</operator><name>Shadow</name></expr></argument>,
<argument><expr><name>CXXConstructorDecl</name> <operator>*</operator><name>BaseCtor</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Shadow</name><argument_list>(<argument><expr><name>Shadow</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>BaseCtor</name><argument_list>(<argument>BaseCtor</argument>)</argument_list></macro> <expr><block>{}</block>

<name>explicit</name> <name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Shadow</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>ConstructorUsingShadowDecl</name> <operator>*</operator><macro><name>getShadowDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Shadow</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>CXXConstructorDecl</name> <operator>*</operator><macro><name>getConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BaseCtor</name></expr>;</return> }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>











<decl_stmt><decl><type><name>class</name> <name>CXXConstructorDecl</name></type> <name>final</name>
<range>: <expr><name>public</name> <name>CXXMethodDecl</name></expr></range></decl>,
<decl><type ref="prev"/><name>private</name> <name>llvm</name>::<name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructorDecl</name></expr></argument>, <argument><expr><name>InheritedConstructor</name></expr></argument>,
<argument><expr><name>ExplicitSpecifier</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>






<decl_stmt><decl><type><name>LazyCXXCtorInitializersPtr</name></type> <name>CtorInitializers</name></decl>;</decl_stmt>

<macro><name>CXXConstructorDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>CXXRecordDecl *RD</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>, <argument>QualType T</argument>,
<argument>TypeSourceInfo *TInfo</argument>, <argument>ExplicitSpecifier ES</argument>, <argument>bool isInline</argument>,
<argument>bool isImplicitlyDeclared</argument>, <argument>ConstexprSpecKind ConstexprKind</argument>,
<argument>InheritedConstructor Inherited</argument>,
<argument>Expr *TrailingRequiresClause</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>numTrailingObjects</name><argument_list>(<argument><expr><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>InheritedConstructor</name></expr></argument>&gt;</argument_list></name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name><name>CXXConstructorDeclBits</name><operator>.</operator><name>IsInheritingConstructor</name></name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>numTrailingObjects</name><argument_list>(<argument><expr><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>ExplicitSpecifier</name></expr></argument>&gt;</argument_list></name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name><name>CXXConstructorDeclBits</name><operator>.</operator><name>HasTrailingExplicitSpecifier</name></name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>ExplicitSpecifier</name> <macro><name>getExplicitSpecifierInternal</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name><name>CXXConstructorDeclBits</name><operator>.</operator><name>HasTrailingExplicitSpecifier</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ExplicitSpecifier</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>ExplicitSpecifier</name><argument_list>(
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>CXXConstructorDeclBits</name><operator>.</operator><name>IsSimpleExplicit</name></name></expr>
?</condition><then> <expr><name>ExplicitSpecKind</name><operator>::</operator><name>ResolvedTrue</name></expr>
</then><else>: <expr><name>ExplicitSpecKind</name><operator>::</operator><name>ResolvedFalse</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<enum>enum <name>TrailingAllocKind</name> <block>{
<decl><name>TAKInheritsConstructor</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>TAKHasTailExplicit</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>,
}</block>;</enum>

<expr_stmt><expr><name>uint64_t</name> <macro><name>getTrailingAllocKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>numTrailingObjects</name><argument_list>(<argument><expr><call><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>InheritedConstructor</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>|</operator>
<operator>(</operator><call><name>numTrailingObjects</name><argument_list>(<argument><expr><call><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>ExplicitSpecifier</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclWriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name></type> <name>TrailingObjects</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>CreateDeserialized</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name></type> <name>AllocKind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CXXConstructorDecl</name> <modifier>*</modifier></type>
<name>Create</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>, <parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>ExplicitSpecifier</name></type> <name>ES</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isInline</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isImplicitlyDeclared</name></decl></parameter>,
<parameter><decl><type><name>ConstexprSpecKind</name></type> <name>ConstexprKind</name></decl></parameter>,
<parameter><decl><type><name>InheritedConstructor</name></type> <name>Inherited</name> <init>= <expr><call><name>InheritedConstructor</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>TrailingRequiresClause</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type> <name>setExplicitSpecifier</name><parameter_list>(<parameter><decl><type><name>ExplicitSpecifier</name></type> <name>ES</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>!</operator><call><name><name>ES</name><operator>.</operator><name>getExpr</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<name><name>CXXConstructorDeclBits</name><operator>.</operator><name>HasTrailingExplicitSpecifier</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"cannot set this explicit specifier. no trail-allocated space for "</literal>
<literal type="string">"explicit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>ES</name><operator>.</operator><name>getExpr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ExplicitSpecifier</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>=</operator> <name>ES</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>CXXConstructorDeclBits</name><operator>.</operator><name>IsSimpleExplicit</name></name> <operator>=</operator> <call><name><name>ES</name><operator>.</operator><name>isExplicit</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>ExplicitSpecifier</name></type> <name>getExplicitSpecifier</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getExplicitSpecifierInternal</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>ExplicitSpecifier</name> <macro><name>getExplicitSpecifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getExplicitSpecifierInternal</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isExplicit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getExplicitSpecifier</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isExplicit</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>init_iterator</name> <init>= <expr><name>CXXCtorInitializer</name> <operator>*</operator><operator>*</operator></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>init_const_iterator</name> <init>= <expr><name>CXXCtorInitializer</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>init_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>init_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>init_const_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>init_const_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<function><type><name>init_range</name></type> <name>inits</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>init_range</name><argument_list>(<argument><expr><call><name>init_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>init_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><name>init_const_range</name> <macro><name>inits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>init_const_range</name><argument_list>(<argument><expr><call><name>init_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>init_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>init_iterator</name></type> <name>init_begin</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>ConstThis</name> <init>= <expr><name>this</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>init_iterator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>ConstThis</name><operator>-&gt;</operator><name>init_begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<expr_stmt><expr><name>init_const_iterator</name> <macro><name>init_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<function><type><name>init_iterator</name></type> <name>init_end</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>init_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumCtorInitializers</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


<expr_stmt><expr><name>init_const_iterator</name> <macro><name>init_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>init_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getNumCtorInitializers</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>init_reverse_iterator</name> <init>= <expr><name>std</name><operator>::</operator><name><name>reverse_iterator</name><argument_list type="generic">&lt;<argument><expr><name>init_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>init_const_reverse_iterator</name> <init>=
<expr><name>std</name><operator>::</operator><name><name>reverse_iterator</name><argument_list type="generic">&lt;<argument><expr><name>init_const_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<function><type><name>init_reverse_iterator</name></type> <name>init_rbegin</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>init_reverse_iterator</name><argument_list>(<argument><expr><call><name>init_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><name>init_const_reverse_iterator</name> <macro><name>init_rbegin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>init_const_reverse_iterator</name><argument_list>(<argument><expr><call><name>init_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>init_reverse_iterator</name></type> <name>init_rend</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>init_reverse_iterator</name><argument_list>(<argument><expr><call><name>init_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><name>init_const_reverse_iterator</name> <macro><name>init_rend</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>init_const_reverse_iterator</name><argument_list>(<argument><expr><call><name>init_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getNumCtorInitializers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CXXConstructorDeclBits</name><operator>.</operator><name>NumCtorInitializers</name></name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setNumCtorInitializers</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>numCtorInitializers</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>CXXConstructorDeclBits</name><operator>.</operator><name>NumCtorInitializers</name></name> <operator>=</operator> <name>numCtorInitializers</name></expr>;</expr_stmt>



<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>CXXConstructorDeclBits</name><operator>.</operator><name>NumCtorInitializers</name></name> <operator>==</operator>
<name>numCtorInitializers</name> <operator>&amp;&amp;</operator> <literal type="string">"NumCtorInitializers overflow!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setCtorInitializers</name><parameter_list>(<parameter><decl><type><name>CXXCtorInitializer</name> <modifier>*</modifier><modifier>*</modifier></type><name>Initializers</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>CtorInitializers</name> <operator>=</operator> <name>Initializers</name></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>isDelegatingConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>getNumCtorInitializers</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>init_begin</name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index><operator>-&gt;</operator><call><name>isDelegatingInitializer</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>CXXConstructorDecl</name> <operator>*</operator><macro><name>getTargetConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>isDefaultConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>














<decl_stmt><decl><type><name>bool</name></type> <name>isCopyConstructor</name><argument_list>(<argument><expr><name>unsigned</name> <operator>&amp;</operator><name>TypeQuals</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>isCopyConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>unsigned</name> <name>TypeQuals</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<return>return <expr><call><name>isCopyConstructor</name><argument_list>(<argument><expr><name>TypeQuals</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>






<decl_stmt><decl><type><name>bool</name></type> <name>isMoveConstructor</name><argument_list>(<argument><expr><name>unsigned</name> <operator>&amp;</operator><name>TypeQuals</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isMoveConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>unsigned</name> <name>TypeQuals</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<return>return <expr><call><name>isMoveConstructor</name><argument_list>(<argument><expr><name>TypeQuals</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>isCopyOrMoveConstructor</name><argument_list>(<argument><expr><name>unsigned</name> <operator>&amp;</operator><name>TypeQuals</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isCopyOrMoveConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>unsigned</name> <name>Quals</name></expr>;
<return>return <expr><call><name>isCopyOrMoveConstructor</name><argument_list>(<argument><expr><name>Quals</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>isConvertingConstructor</name><argument_list>(<argument><expr><name>bool</name> <name>AllowExplicit</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>isSpecializationCopyingObject</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isInheritingConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CXXConstructorDeclBits</name><operator>.</operator><name>IsInheritingConstructor</name></name></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>void</name></type> <name>setInheritingConstructor</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isIC</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>CXXConstructorDeclBits</name><operator>.</operator><name>IsInheritingConstructor</name></name> <operator>=</operator> <name>isIC</name></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>InheritedConstructor</name> <macro><name>getInheritedConstructor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isInheritingConstructor</name><argument_list>()</argument_list></call> <operator>?</operator>
<operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>InheritedConstructor</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>InheritedConstructor</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>getCanonicalDecl</name><parameter_list>()</parameter_list> override <block>{<block_content>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructorDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>FunctionDecl</name><operator>::</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>CXXConstructorDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructorDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classofKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>K</name> <operator>==</operator> <name>CXXConstructor</name></expr>;</return> </block_content>}</block></function>
};











<decl_stmt><decl><type><name>class</name></type> <name>CXXDestructorDecl</name> <range>: <expr><name>public</name> <name>CXXMethodDecl</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;



<expr><name>FunctionDecl</name> <operator>*</operator><name>OperatorDelete</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>Expr</name> <operator>*</operator><name>OperatorDeleteThisArg</name> <operator>=</operator> <name>nullptr</name></expr>;

<macro><name>CXXDestructorDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>CXXRecordDecl *RD</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>, <argument>QualType T</argument>,
<argument>TypeSourceInfo *TInfo</argument>, <argument>bool isInline</argument>,
<argument>bool isImplicitlyDeclared</argument>, <argument>ConstexprSpecKind ConstexprKind</argument>,
<argument>Expr *TrailingRequiresClause = nullptr</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CXXMethodDecl</name><argument_list>(<argument>CXXDestructor</argument>, <argument>C</argument>, <argument>RD</argument>, <argument>StartLoc</argument>, <argument>NameInfo</argument>, <argument>T</argument>, <argument>TInfo</argument>,
<argument>SC_None</argument>, <argument>isInline</argument>, <argument>ConstexprKind</argument>, <argument>SourceLocation()</argument>,
<argument>TrailingRequiresClause</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setImplicit</name><argument_list>(<argument><expr><name>isImplicitlyDeclared</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>CXXDestructorDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>CXXRecordDecl *RD</argument>,
<argument>SourceLocation StartLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>,
<argument>QualType T</argument>, <argument>TypeSourceInfo *TInfo</argument>,
<argument>bool isInline</argument>, <argument>bool isImplicitlyDeclared</argument>,
<argument>ConstexprSpecKind ConstexprKind</argument>,
<argument>Expr *TrailingRequiresClause = nullptr</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>CXXDestructorDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp; C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <call><name>setOperatorDelete</name><argument_list>(<argument><expr><name>FunctionDecl</name> <operator>*</operator><name>OD</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>ThisArg</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><macro><name>getOperatorDelete</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>OperatorDelete</name></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getOperatorDeleteThisArg</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>OperatorDeleteThisArg</name></expr>;</return>
}</block>

<name>CXXDestructorDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXDestructorDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>FunctionDecl</name><operator>::</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>CXXDestructorDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXDestructorDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>CXXDestructor</name></expr>;</return> }</block>
}</expr>;











<expr><name>class</name> <name>CXXConversionDecl</name> <operator>:</operator> <name>public</name> <name>CXXMethodDecl</name> <block>{
<macro><name>CXXConversionDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>CXXRecordDecl *RD</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>, <argument>QualType T</argument>,
<argument>TypeSourceInfo *TInfo</argument>, <argument>bool isInline</argument>, <argument>ExplicitSpecifier ES</argument>,
<argument>ConstexprSpecKind ConstexprKind</argument>, <argument>SourceLocation EndLocation</argument>,
<argument>Expr *TrailingRequiresClause = nullptr</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>CXXMethodDecl</name><argument_list>(<argument><expr><name>CXXConversion</name></expr></argument>, <argument><expr><name>C</name></expr></argument>, <argument><expr><name>RD</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>NameInfo</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>TInfo</name></expr></argument>,
<argument><expr><name>SC_None</name></expr></argument>, <argument><expr><name>isInline</name></expr></argument>, <argument><expr><name>ConstexprKind</name></expr></argument>, <argument><expr><name>EndLocation</name></expr></argument>,
<argument><expr><name>TrailingRequiresClause</name></expr></argument>)</argument_list></call></expr>,
<macro><name>ExplicitSpec</name><argument_list>(<argument>ES</argument>)</argument_list></macro> <expr><block>{}</block>
<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>ExplicitSpecifier</name> <name>ExplicitSpec</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;

<expr><specifier>static</specifier> <name>CXXConversionDecl</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>CXXRecordDecl *RD</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>, <argument>QualType T</argument>, <argument>TypeSourceInfo *TInfo</argument>,
<argument>bool isInline</argument>, <argument>ExplicitSpecifier ES</argument>, <argument>ConstexprSpecKind ConstexprKind</argument>,
<argument>SourceLocation EndLocation</argument>, <argument>Expr *TrailingRequiresClause = nullptr</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>CXXConversionDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>ExplicitSpecifier</name> <macro><name>getExplicitSpecifier</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ExplicitSpec</name></expr>;</return>
}</block>

<specifier>const</specifier> <name>ExplicitSpecifier</name> <macro><name>getExplicitSpecifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>ExplicitSpec</name></expr>;</return>
}</block>


<name>bool</name> <macro><name>isExplicit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getExplicitSpecifier</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isExplicit</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setExplicitSpecifier</name><argument_list>(<argument>ExplicitSpecifier ES</argument>)</argument_list></macro> <block>{ <expr><name>ExplicitSpec</name> <operator>=</operator> <name>ES</name></expr>; }</block>


<name>QualType</name> <macro><name>getConversionType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getType</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>castAs</name><argument_list type="generic">&lt;<argument><expr><name>FunctionType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getReturnType</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isLambdaToBlockPointerConversion</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>CXXConversionDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXConversionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>FunctionDecl</name><operator>::</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>CXXConversionDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXConversionDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>CXXConversion</name></expr>;</return> }</block>
}</expr>;







<expr><name>class</name> <name>LinkageSpecDecl</name> <operator>:</operator> <name>public</name> <name>Decl</name></expr>, <expr><name>public</name> <name>DeclContext</name> <block>{
<expr><name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;


<expr><name>public</name><operator>:</operator>




enum <name>LanguageIDs</name> <block>{ <expr><name>lang_c</name> <operator>=</operator> <literal type="number">1</literal></expr>, <expr><name>lang_cxx</name> <operator>=</operator> <literal type="number">2</literal></expr> }</block></expr>;

<expr><name>private</name><operator>:</operator>

<name>SourceLocation</name> <name>ExternLoc</name></expr>;


<expr><name>SourceLocation</name> <name>RBraceLoc</name></expr>;

<macro><name>LinkageSpecDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation ExternLoc</argument>,
<argument>SourceLocation LangLoc</argument>, <argument>LanguageIDs lang</argument>, <argument>bool HasBraces</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>LinkageSpecDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation ExternLoc</argument>,
<argument>SourceLocation LangLoc</argument>, <argument>LanguageIDs Lang</argument>,
<argument>bool HasBraces</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>LinkageSpecDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;


<expr><name>LanguageIDs</name> <macro><name>getLanguage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>LanguageIDs</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>LinkageSpecDeclBits</name><operator>.</operator><name>Language</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>void</name> <macro><name>setLanguage</name><argument_list>(<argument>LanguageIDs L</argument>)</argument_list></macro> <block>{ <expr><name><name>LinkageSpecDeclBits</name><operator>.</operator><name>Language</name></name> <operator>=</operator> <name>L</name></expr>; }</block>



<name>bool</name> <macro><name>hasBraces</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>RBraceLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call> <operator>||</operator> <name><name>LinkageSpecDeclBits</name><operator>.</operator><name>HasBraces</name></name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>LinkageSpecDeclBits</name><operator>.</operator><name>HasBraces</name></name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getExternLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ExternLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getRBraceLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RBraceLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setExternLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>ExternLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>void</name> <macro><name>setRBraceLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{
<expr><name>RBraceLoc</name> <operator>=</operator> <name>L</name></expr>;
<expr><name><name>LinkageSpecDeclBits</name><operator>.</operator><name>HasBraces</name></name> <operator>=</operator> <call><name><name>RBraceLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasBraces</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getRBraceLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>


<return>return <expr><ternary><condition><expr><call><name>decls_empty</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>decls_begin</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>ExternLoc</name></expr></argument>, <argument><expr><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>LinkageSpec</name></expr>;</return> }</block>

<specifier>static</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>castToDeclContext</name><argument_list>(<argument>const LinkageSpecDecl *D</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>LinkageSpecDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>LinkageSpecDecl</name> <operator>*</operator><macro><name>castFromDeclContext</name><argument_list>(<argument>const DeclContext *DC</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>LinkageSpecDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;











<expr><name>class</name> <name>UsingDirectiveDecl</name> <operator>:</operator> <name>public</name> <name>NamedDecl</name> <block>{

<expr><name>SourceLocation</name> <name>UsingLoc</name></expr>;


<expr><name>SourceLocation</name> <name>NamespaceLoc</name></expr>;


<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;


<expr><name>NamedDecl</name> <operator>*</operator><name>NominatedNamespace</name></expr>;



<expr><name>DeclContext</name> <operator>*</operator><name>CommonAncestor</name></expr>;

<macro><name>UsingDirectiveDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation UsingLoc</argument>,
<argument>SourceLocation NamespcLoc</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>SourceLocation IdentLoc</argument>,
<argument>NamedDecl *Nominated</argument>,
<argument>DeclContext *CommonAncestor</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>NamedDecl</name><argument_list>(<argument><expr><name>UsingDirective</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>IdentLoc</name></expr></argument>, <argument><expr><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>, <expr><call><name>UsingLoc</name><argument_list>(<argument><expr><name>UsingLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>NamespaceLoc</name><argument_list>(<argument><expr><name>NamespcLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>QualifierLoc</name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>NominatedNamespace</name><argument_list>(<argument><expr><name>Nominated</name></expr></argument>)</argument_list></call></expr>, <macro><name>CommonAncestor</name><argument_list>(<argument>CommonAncestor</argument>)</argument_list></macro> <expr><block>{}</block>





<specifier>static</specifier> <name>DeclarationName</name> <macro><name>getName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>DeclarationName</name><operator>::</operator><call><name>getUsingDirectiveName</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;


<expr><name>friend</name> <name>class</name> <name>DeclContext</name></expr>;



<expr><name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QualifierLoc</name></expr>;</return> }</block>



<name>NestedNameSpecifier</name> <operator>*</operator><macro><name>getQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>NamedDecl</name> <operator>*</operator><macro><name>getNominatedNamespaceAsWritten</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>NominatedNamespace</name></expr>;</return> }</block>
<specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><macro><name>getNominatedNamespaceAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NominatedNamespace</name></expr>;</return>
}</block>


<name>NamespaceDecl</name> <operator>*</operator><call><name>getNominatedNamespace</name><argument_list>()</argument_list></call></expr>;

<expr><specifier>const</specifier> <name>NamespaceDecl</name> <operator>*</operator><macro><name>getNominatedNamespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>UsingDirectiveDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getNominatedNamespace</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>DeclContext</name> <operator>*</operator><macro><name>getCommonAncestor</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>CommonAncestor</name></expr>;</return> }</block>
<specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>getCommonAncestor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CommonAncestor</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getUsingLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>UsingLoc</name></expr>;</return> }</block>



<name>SourceLocation</name> <macro><name>getNamespaceKeyLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NamespaceLoc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getIdentLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>UsingDirectiveDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation UsingLoc</argument>,
<argument>SourceLocation NamespaceLoc</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>SourceLocation IdentLoc</argument>,
<argument>NamedDecl *Nominated</argument>,
<argument>DeclContext *CommonAncestor</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>UsingDirectiveDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>UsingLoc</name></expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>UsingDirective</name></expr>;</return> }</block>
}</expr>;








<expr><name>class</name> <name>NamespaceAliasDecl</name> <operator>:</operator> <name>public</name> <name>NamedDecl</name></expr>,
<expr><name>public</name> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>NamespaceAliasDecl</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;


<expr><name>SourceLocation</name> <name>NamespaceLoc</name></expr>;




<expr><name>SourceLocation</name> <name>IdentLoc</name></expr>;


<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;



<expr><name>NamedDecl</name> <operator>*</operator><name>Namespace</name></expr>;

<macro><name>NamespaceAliasDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation NamespaceLoc</argument>, <argument>SourceLocation AliasLoc</argument>,
<argument>IdentifierInfo *Alias</argument>, <argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>SourceLocation IdentLoc</argument>, <argument>NamedDecl *Namespace</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>NamedDecl</name><argument_list>(<argument><expr><name>NamespaceAlias</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>AliasLoc</name></expr></argument>, <argument><expr><name>Alias</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>redeclarable_base</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>NamespaceLoc</name><argument_list>(<argument><expr><name>NamespaceLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>IdentLoc</name><argument_list>(<argument><expr><name>IdentLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>QualifierLoc</name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>Namespace</name><argument_list>(<argument>Namespace</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>using</name> <name>redeclarable_base</name> <operator>=</operator> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>NamespaceAliasDecl</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>NamespaceAliasDecl</name> <operator>*</operator><macro><name>getNextRedeclarationImpl</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>NamespaceAliasDecl</name> <operator>*</operator><macro><name>getPreviousDeclImpl</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>NamespaceAliasDecl</name> <operator>*</operator><macro><name>getMostRecentDeclImpl</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>NamespaceAliasDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation NamespaceLoc</argument>,
<argument>SourceLocation AliasLoc</argument>,
<argument>IdentifierInfo *Alias</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>SourceLocation IdentLoc</argument>,
<argument>NamedDecl *Namespace</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>NamespaceAliasDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>using</name> <name>redecl_range</name> <operator>=</operator> <name>redeclarable_base</name><operator>::</operator><name>redecl_range</name></expr>;
<expr><name>using</name> <name>redecl_iterator</name> <operator>=</operator> <name>redeclarable_base</name><operator>::</operator><name>redecl_iterator</name></expr>;

<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_begin</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_end</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getPreviousDecl</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getMostRecentDecl</name></expr>;

<expr><name>NamespaceAliasDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>NamespaceAliasDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QualifierLoc</name></expr>;</return> }</block>



<name>NestedNameSpecifier</name> <operator>*</operator><macro><name>getQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>NamespaceDecl</name> <operator>*</operator><macro><name>getNamespace</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>AD</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>NamespaceAliasDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Namespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>AD</name><operator>-&gt;</operator><name>getNamespace</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>NamespaceDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Namespace</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>NamespaceDecl</name> <operator>*</operator><macro><name>getNamespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>NamespaceAliasDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getNamespace</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>SourceLocation</name> <macro><name>getAliasLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getNamespaceLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NamespaceLoc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getTargetNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IdentLoc</name></expr>;</return> }</block>



<name>NamedDecl</name> <operator>*</operator><macro><name>getAliasedNamespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Namespace</name></expr>;</return> }</block>

<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>NamespaceLoc</name></expr></argument>, <argument><expr><name>IdentLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>NamespaceAlias</name></expr>;</return> }</block>
}</expr>;



<expr><name>class</name> <name>LifetimeExtendedTemporaryDecl</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Decl</name></expr>,
<expr><name>public</name> <name><name>Mergeable</name><argument_list type="generic">&lt;<argument><expr><name>LifetimeExtendedTemporaryDecl</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>MaterializeTemporaryExpr</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;

<expr><name>Stmt</name> <operator>*</operator><name>ExprWithTemporary</name> <operator>=</operator> <name>nullptr</name></expr>;



<expr><name>ValueDecl</name> <operator>*</operator><name>ExtendingDecl</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>unsigned</name> <name>ManglingNumber</name></expr>;

<expr><name>mutable</name> <name>APValue</name> <operator>*</operator><name>Value</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;

<macro><name>LifetimeExtendedTemporaryDecl</name><argument_list>(<argument>Expr *Temp</argument>, <argument>ValueDecl *EDecl</argument>, <argument>unsigned Mangling</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Decl</name><argument_list>(<argument><expr><name>Decl</name><operator>::</operator><name>LifetimeExtendedTemporary</name></expr></argument>, <argument><expr><call><name><name>EDecl</name><operator>-&gt;</operator><name>getDeclContext</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>EDecl</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ExprWithTemporary</name><argument_list>(<argument><expr><name>Temp</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ExtendingDecl</name><argument_list>(<argument><expr><name>EDecl</name></expr></argument>)</argument_list></call></expr>,
<macro><name>ManglingNumber</name><argument_list>(<argument>Mangling</argument>)</argument_list></macro> <expr><block>{}</block>

<call><name>LifetimeExtendedTemporaryDecl</name><argument_list>(<argument><expr><name>EmptyShell</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>Decl</name><argument_list>(<argument>Decl::LifetimeExtendedTemporary</argument>, <argument>EmptyShell{}</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>LifetimeExtendedTemporaryDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>Expr *Temp</argument>, <argument>ValueDecl *EDec</argument>,
<argument>unsigned Mangling</argument>)</argument_list></macro> <block>{
<return>return <macro><name>new</name> <argument_list>(<argument>EDec-&gt;getASTContext()</argument>, <argument>EDec-&gt;getDeclContext()</argument>)</argument_list></macro>
<expr><call><name>LifetimeExtendedTemporaryDecl</name><argument_list>(<argument><expr><name>Temp</name></expr></argument>, <argument><expr><name>EDec</name></expr></argument>, <argument><expr><name>Mangling</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>LifetimeExtendedTemporaryDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>,
<argument>unsigned ID</argument>)</argument_list></macro> <block>{
<return>return <macro><name>new</name> <argument_list>(<argument>C</argument>, <argument>ID</argument>)</argument_list></macro> <macro><name>LifetimeExtendedTemporaryDecl</name><argument_list>(<argument>EmptyShell{}</argument>)</argument_list></macro>;</return>
}</block>

<name>ValueDecl</name> <operator>*</operator><macro><name>getExtendingDecl</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>ExtendingDecl</name></expr>;</return> }</block>
<specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><macro><name>getExtendingDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ExtendingDecl</name></expr>;</return> }</block>


<name>StorageDuration</name> <macro><name>getStorageDuration</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;






<expr><name>Expr</name> <operator>*</operator><macro><name>getTemporaryExpr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ExprWithTemporary</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getTemporaryExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ExprWithTemporary</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>unsigned</name> <macro><name>getManglingNumber</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ManglingNumber</name></expr>;</return> }</block>



<name>APValue</name> <operator>*</operator><macro><name>getOrCreateValue</name><argument_list>(<argument>bool MayCreate</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>APValue</name> <operator>*</operator><macro><name>getValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Value</name></expr>;</return> }</block>


<name>Stmt</name><operator>::</operator><name>child_range</name> <macro><name>childrenExpr</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>Stmt</name><operator>::</operator><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ExprWithTemporary</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ExprWithTemporary</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Stmt</name><operator>::</operator><name>const_child_range</name> <macro><name>childrenExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Stmt</name><operator>::</operator><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ExprWithTemporary</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ExprWithTemporary</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{
<return>return <expr><name>K</name> <operator>==</operator> <name>Decl</name><operator>::</operator><name>LifetimeExtendedTemporary</name></expr>;</return>
}</block>
}</expr>;




















<expr><name>class</name> <name>UsingShadowDecl</name> <operator>:</operator> <name>public</name> <name>NamedDecl</name></expr>, <expr><name>public</name> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>UsingShadowDecl</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>BaseUsingDecl</name></expr>;


<expr><name>NamedDecl</name> <operator>*</operator><name>Underlying</name> <operator>=</operator> <name>nullptr</name></expr>;



<expr><name>NamedDecl</name> <operator>*</operator><name>UsingOrNextShadow</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>using</name> <name>redeclarable_base</name> <operator>=</operator> <name><name>Redeclarable</name><argument_list type="generic">&lt;<argument><expr><name>UsingShadowDecl</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>UsingShadowDecl</name> <operator>*</operator><macro><name>getNextRedeclarationImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getNextRedeclaration</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>UsingShadowDecl</name> <operator>*</operator><macro><name>getPreviousDeclImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getPreviousDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>UsingShadowDecl</name> <operator>*</operator><macro><name>getMostRecentDeclImpl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getMostRecentDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>protected</name><operator>:</operator>
<macro><name>UsingShadowDecl</name><argument_list>(<argument>Kind K</argument>, <argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation Loc</argument>,
<argument>DeclarationName Name</argument>, <argument>BaseUsingDecl *Introducer</argument>,
<argument>NamedDecl *Target</argument>)</argument_list></macro></expr>;
<macro><name>UsingShadowDecl</name><argument_list>(<argument>Kind K</argument>, <argument>ASTContext &amp;C</argument>, <argument>EmptyShell</argument>)</argument_list></macro>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;

<expr><specifier>static</specifier> <name>UsingShadowDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation Loc</argument>, <argument>DeclarationName Name</argument>,
<argument>BaseUsingDecl *Introducer</argument>, <argument>NamedDecl *Target</argument>)</argument_list></macro> <block>{
<return>return <macro><name>new</name> <argument_list>(<argument>C</argument>, <argument>DC</argument>)</argument_list></macro>
<expr><call><name>UsingShadowDecl</name><argument_list>(<argument><expr><name>UsingShadow</name></expr></argument>, <argument><expr><name>C</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Name</name></expr></argument>, <argument><expr><name>Introducer</name></expr></argument>, <argument><expr><name>Target</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>UsingShadowDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>using</name> <name>redecl_range</name> <operator>=</operator> <name>redeclarable_base</name><operator>::</operator><name>redecl_range</name></expr>;
<expr><name>using</name> <name>redecl_iterator</name> <operator>=</operator> <name>redeclarable_base</name><operator>::</operator><name>redecl_iterator</name></expr>;

<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_begin</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls_end</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>redecls</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getPreviousDecl</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>getMostRecentDecl</name></expr>;
<expr><name>using</name> <name>redeclarable_base</name><operator>::</operator><name>isFirstDecl</name></expr>;

<expr><name>UsingShadowDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>UsingShadowDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>NamedDecl</name> <operator>*</operator><macro><name>getTargetDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Underlying</name></expr>;</return> }</block>



<name>void</name> <macro><name>setTargetDecl</name><argument_list>(<argument>NamedDecl *ND</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>ND</name> <operator>&amp;&amp;</operator> <literal type="string">"Target decl is null!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>Underlying</name> <operator>=</operator> <name>ND</name></expr>;


<expr><name>IdentifierNamespace</name> <operator>=</operator>
<call><name><name>ND</name><operator>-&gt;</operator><name>getIdentifierNamespace</name></name><argument_list>()</argument_list></call> <operator>&amp;</operator>
<operator>~</operator><operator>(</operator><name>IDNS_OrdinaryFriend</name> <operator>|</operator> <name>IDNS_TagFriend</name> <operator>|</operator> <name>IDNS_LocalExtern</name><operator>)</operator></expr>;
}</block>



<name>BaseUsingDecl</name> <operator>*</operator><macro><name>getIntroducer</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>UsingShadowDecl</name> <operator>*</operator><macro><name>getNextUsingShadowDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>UsingShadowDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>UsingOrNextShadow</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{
<return>return <expr><name>K</name> <operator>==</operator> <name>Decl</name><operator>::</operator><name>UsingShadow</name> <operator>||</operator> <name>K</name> <operator>==</operator> <name>Decl</name><operator>::</operator><name>ConstructorUsingShadow</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>BaseUsingDecl</name> <operator>:</operator> <name>public</name> <name>NamedDecl</name> <block>{





<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>UsingShadowDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>FirstUsingShadow</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>BaseUsingDecl</name><argument_list>(<argument>Kind DK</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>, <argument>DeclarationName N</argument>)</argument_list></macro>
<operator>:</operator> <call><name>NamedDecl</name><argument_list>(<argument><expr><name>DK</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>L</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>, <macro><name>FirstUsingShadow</name><argument_list>(<argument>nullptr</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro> <expr><block>{}</block>

<name>private</name><operator>:</operator>
<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>protected</name><operator>:</operator>

<name>bool</name> <macro><name>getShadowFlag</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>FirstUsingShadow</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>void</name> <macro><name>setShadowFlag</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{ <expr><call><name><name>FirstUsingShadow</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;



<expr><name>class</name> <name>shadow_iterator</name> <block>{

<expr><name>UsingShadowDecl</name> <operator>*</operator><name>Current</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>using</name> <name>value_type</name> <operator>=</operator> <name>UsingShadowDecl</name> <operator>*</operator></expr>;
<expr><name>using</name> <name>reference</name> <operator>=</operator> <name>UsingShadowDecl</name> <operator>*</operator></expr>;
<expr><name>using</name> <name>pointer</name> <operator>=</operator> <name>UsingShadowDecl</name> <operator>*</operator></expr>;
<expr><name>using</name> <name>iterator_category</name> <operator>=</operator> <name>std</name><operator>::</operator><name>forward_iterator_tag</name></expr>;
<expr><name>using</name> <name>difference_type</name> <operator>=</operator> <name>std</name><operator>::</operator><name>ptrdiff_t</name></expr>;

<expr><call><name>shadow_iterator</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><name>explicit</name> <call><name>shadow_iterator</name><argument_list>(<argument><expr><name>UsingShadowDecl</name> <operator>*</operator><name>C</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>Current</name><argument_list>(<argument>C</argument>)</argument_list></macro> <block>{}</block>

<name>reference</name> <name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>Current</name></expr>;</return> }</block>
<name>pointer</name> <name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr>) <specifier>const</specifier> <block>{ <return>return <expr><name>Current</name></expr>;</return> }</block></block>

<name>shadow_iterator</name> <operator>&amp;</operator><name>operator</name><operator>++</operator><operator>(</operator><operator>)</operator> <block>{
<expr><name>Current</name> <operator>=</operator> <call><name><name>Current</name><operator>-&gt;</operator><name>getNextUsingShadowDecl</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block>

<name>shadow_iterator</name> <name>operator</name><operator>++</operator><operator>(</operator><name>int</name><operator>)</operator> <block>{
<expr><name>shadow_iterator</name> <call><name>tmp</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>++</operator><operator>(</operator><operator>*</operator><name>this</name><operator>)</operator></expr>;
<return>return <expr><name>tmp</name></expr>;</return>
}</block>

<name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><name>shadow_iterator</name> <name>x</name>, <name>shadow_iterator</name> <name>y</name><operator>)</operator> <block>{
<return>return <expr><name><name>x</name><operator>.</operator><name>Current</name></name> <operator>==</operator> <name><name>y</name><operator>.</operator><name>Current</name></name></expr>;</return>
}</block>
<name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><name>shadow_iterator</name> <name>x</name>, <name>shadow_iterator</name> <name>y</name><operator>)</operator> <block>{
<return>return <expr><name><name>x</name><operator>.</operator><name>Current</name></name> <operator>!=</operator> <name><name>y</name><operator>.</operator><name>Current</name></name></expr>;</return>
}</block>
}</expr>;

<expr><name>using</name> <name>shadow_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>shadow_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>shadow_range</name> <macro><name>shadows</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>shadow_range</name><argument_list>(<argument><expr><call><name>shadow_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>shadow_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>shadow_iterator</name> <macro><name>shadow_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>shadow_iterator</name><argument_list>(<argument><expr><call><name><name>FirstUsingShadow</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>shadow_iterator</name> <macro><name>shadow_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>shadow_iterator</name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>unsigned</name> <macro><name>shadow_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>std</name><operator>::</operator><call><name>distance</name><argument_list>(<argument><expr><call><name>shadow_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>shadow_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <call><name>addShadowDecl</name><argument_list>(<argument><expr><name>UsingShadowDecl</name> <operator>*</operator><name>S</name></expr></argument>)</argument_list></call></expr>;
<expr><name>void</name> <call><name>removeShadowDecl</name><argument_list>(<argument><expr><name>UsingShadowDecl</name> <operator>*</operator><name>S</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>Using</name> <operator>||</operator> <name>K</name> <operator>==</operator> <name>UsingEnum</name></expr>;</return> }</block>
}</expr>;







<expr><name>class</name> <name>UsingDecl</name> <operator>:</operator> <name>public</name> <name>BaseUsingDecl</name></expr>, <expr><name>public</name> <name><name>Mergeable</name><argument_list type="generic">&lt;<argument><expr><name>UsingDecl</name></expr></argument>&gt;</argument_list></name> <block>{

<expr><name>SourceLocation</name> <name>UsingLocation</name></expr>;


<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;



<expr><name>DeclarationNameLoc</name> <name>DNLoc</name></expr>;

<macro><name>UsingDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation UL</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>, <argument>bool HasTypenameKeyword</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>BaseUsingDecl</name><argument_list>(<argument><expr><name>Using</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><call><name><name>NameInfo</name><operator>.</operator><name>getLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>UsingLocation</name><argument_list>(<argument><expr><name>UL</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>QualifierLoc</name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>,
<macro><name>DNLoc</name><argument_list>(<argument>NameInfo.getInfo()</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setShadowFlag</name><argument_list>(<argument><expr><name>HasTypenameKeyword</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;


<expr><name>SourceLocation</name> <macro><name>getUsingLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>UsingLocation</name></expr>;</return> }</block>


<name>void</name> <macro><name>setUsingLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>UsingLocation</name> <operator>=</operator> <name>L</name></expr>; }</block>



<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QualifierLoc</name></expr>;</return> }</block>


<name>NestedNameSpecifier</name> <operator>*</operator><macro><name>getQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>DeclarationNameInfo</name> <macro><name>getNameInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>DeclarationNameInfo</name><argument_list>(<argument><expr><call><name>getDeclName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DNLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>isAccessDeclaration</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>UsingLocation</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>bool</name> <macro><name>hasTypename</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getShadowFlag</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>void</name> <macro><name>setTypename</name><argument_list>(<argument>bool TN</argument>)</argument_list></macro> <block>{ <expr><call><name>setShadowFlag</name><argument_list>(<argument><expr><name>TN</name></expr></argument>)</argument_list></call></expr>; }</block>

<specifier>static</specifier> <name>UsingDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation UsingL</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>,
<argument>bool HasTypenameKeyword</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>UsingDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;


<expr><name>UsingDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UsingDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>UsingDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UsingDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>Using</name></expr>;</return> }</block>
}</expr>;











<expr><name>class</name> <name>ConstructorUsingShadowDecl</name> <name>final</name> <operator>:</operator> <name>public</name> <name>UsingShadowDecl</name> <block>{



<expr><name>ConstructorUsingShadowDecl</name> <operator>*</operator><name>NominatedBaseClassShadowDecl</name> <operator>=</operator> <name>nullptr</name></expr>;





<expr><name>ConstructorUsingShadowDecl</name> <operator>*</operator><name>ConstructedBaseClassShadowDecl</name> <operator>=</operator> <name>nullptr</name></expr>;




<expr><name>unsigned</name> <name>IsVirtual</name> <operator>:</operator> <literal type="number">1</literal></expr>;

<macro><name>ConstructorUsingShadowDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation Loc</argument>,
<argument>UsingDecl *Using</argument>, <argument>NamedDecl *Target</argument>,
<argument>bool TargetInVirtualBase</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>UsingShadowDecl</name><argument_list>(<argument><expr><name>ConstructorUsingShadow</name></expr></argument>, <argument><expr><name>C</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>,
<argument><expr><call><name><name>Using</name><operator>-&gt;</operator><name>getDeclName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Using</name></expr></argument>,
<argument><expr><call><name><name>Target</name><operator>-&gt;</operator><name>getUnderlyingDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>NominatedBaseClassShadowDecl</name><argument_list>(
<argument><expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ConstructorUsingShadowDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ConstructedBaseClassShadowDecl</name><argument_list>(<argument><expr><name>NominatedBaseClassShadowDecl</name></expr></argument>)</argument_list></call></expr>,
<macro><name>IsVirtual</name><argument_list>(<argument>TargetInVirtualBase</argument>)</argument_list></macro> <expr><block>{



<if_stmt><if>if <condition>(<expr><name>NominatedBaseClassShadowDecl</name> <operator>&amp;&amp;</operator>
<call><name><name>NominatedBaseClassShadowDecl</name><operator>-&gt;</operator><name>constructsVirtualBase</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ConstructedBaseClassShadowDecl</name> <operator>=</operator>
<name><name>NominatedBaseClassShadowDecl</name><operator>-&gt;</operator><name>ConstructedBaseClassShadowDecl</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>IsVirtual</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}

ConstructorUsingShadowDecl(ASTContext &amp;C</block><operator>,</operator> <expr_stmt><expr><name>EmptyShell</name> <name>Empty</name></expr></expr_stmt></if></if_stmt>)
<operator>:</operator> <call><name>UsingShadowDecl</name><argument_list>(<argument><expr><name>ConstructorUsingShadow</name></expr></argument>, <argument><expr><name>C</name></expr></argument>, <argument><expr><name>Empty</name></expr></argument>)</argument_list></call>, <macro><name>IsVirtual</name><argument_list>(<argument>false</argument>)</argument_list></macro> <block>{}</block></block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;

<expr><specifier>static</specifier> <name>ConstructorUsingShadowDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation Loc</argument>,
<argument>UsingDecl *Using</argument>, <argument>NamedDecl *Target</argument>,
<argument>bool IsVirtual</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>ConstructorUsingShadowDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>,
<argument>unsigned ID</argument>)</argument_list></macro></expr>;



<expr><name>UsingDecl</name> <operator>*</operator><macro><name>getIntroducer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UsingDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>UsingShadowDecl</name><operator>::</operator><call><name>getIntroducer</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><macro><name>getParent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDeclContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>CXXRecordDecl</name> <operator>*</operator><macro><name>getParent</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDeclContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name>ConstructorUsingShadowDecl</name> <operator>*</operator><macro><name>getNominatedBaseClassShadowDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NominatedBaseClassShadowDecl</name></expr>;</return>
}</block>



<name>ConstructorUsingShadowDecl</name> <operator>*</operator><macro><name>getConstructedBaseClassShadowDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ConstructedBaseClassShadowDecl</name></expr>;</return>
}</block>



<name>CXXRecordDecl</name> <operator>*</operator><macro><name>getNominatedBaseClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>CXXRecordDecl</name> <operator>*</operator><macro><name>getConstructedBaseClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>(</operator><name>ConstructedBaseClassShadowDecl</name>
<operator>?</operator> <name>ConstructedBaseClassShadowDecl</name>
<operator>:</operator> <call><name>getTargetDecl</name><argument_list>()</argument_list></call><operator>)</operator>
<operator>-&gt;</operator><call><name>getDeclContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>constructsVirtualBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>IsVirtual</name></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>ConstructorUsingShadow</name></expr>;</return> }</block>
}</expr>;








<expr><name>class</name> <name>UsingEnumDecl</name> <operator>:</operator> <name>public</name> <name>BaseUsingDecl</name></expr>, <expr><name>public</name> <name><name>Mergeable</name><argument_list type="generic">&lt;<argument><expr><name>UsingEnumDecl</name></expr></argument>&gt;</argument_list></name> <block>{

<expr><name>SourceLocation</name> <name>UsingLocation</name></expr>;


<expr><name>SourceLocation</name> <name>EnumLocation</name></expr>;


<expr><name>EnumDecl</name> <operator>*</operator><name>Enum</name></expr>;

<macro><name>UsingEnumDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>DeclarationName DN</argument>, <argument>SourceLocation UL</argument>,
<argument>SourceLocation EL</argument>, <argument>SourceLocation NL</argument>, <argument>EnumDecl *ED</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>BaseUsingDecl</name><argument_list>(<argument><expr><name>UsingEnum</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>NL</name></expr></argument>, <argument><expr><name>DN</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>UsingLocation</name><argument_list>(<argument><expr><name>UL</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>EnumLocation</name><argument_list>(<argument><expr><name>EL</name></expr></argument>)</argument_list></call></expr>, <macro><name>Enum</name><argument_list>(<argument>ED</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;


<expr><name>SourceLocation</name> <macro><name>getUsingLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>UsingLocation</name></expr>;</return> }</block>
<name>void</name> <macro><name>setUsingLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>UsingLocation</name> <operator>=</operator> <name>L</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getEnumLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>EnumLocation</name></expr>;</return> }</block>
<name>void</name> <macro><name>setEnumLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>EnumLocation</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>public</name><operator>:</operator>
<name>EnumDecl</name> <operator>*</operator><macro><name>getEnumDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Enum</name></expr>;</return> }</block>

<specifier>static</specifier> <name>UsingEnumDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation UsingL</argument>, <argument>SourceLocation EnumL</argument>,
<argument>SourceLocation NameL</argument>, <argument>EnumDecl *ED</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>UsingEnumDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;


<expr><name>UsingEnumDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UsingEnumDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>UsingEnumDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UsingEnumDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>UsingEnum</name></expr>;</return> }</block>
}</expr>;














<expr><name>class</name> <name>UsingPackDecl</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>NamedDecl</name></expr>, <expr><name>public</name> <name><name>Mergeable</name><argument_list type="generic">&lt;<argument><expr><name>UsingPackDecl</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>UsingPackDecl</name></expr></argument>, <argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{


<expr><name>NamedDecl</name> <operator>*</operator><name>InstantiatedFrom</name></expr>;


<expr><name>unsigned</name> <name>NumExpansions</name></expr>;

<expr><call><name>UsingPackDecl</name><argument_list>(<argument><expr><name>DeclContext</name> <operator>*</operator><name>DC</name></expr></argument>, <argument><expr><name>NamedDecl</name> <operator>*</operator><name>InstantiatedFrom</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>UsingDecls</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>NamedDecl</name><argument_list>(<argument><expr><name>UsingPack</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>InstantiatedFrom</name></expr> ?</condition><then> <expr><call><name><name>InstantiatedFrom</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr>
</then><else>: <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name>InstantiatedFrom</name></expr> ?</condition><then> <expr><call><name><name>InstantiatedFrom</name><operator>-&gt;</operator><name>getDeclName</name></name><argument_list>()</argument_list></call></expr>
</then><else>: <expr><call><name>DeclarationName</name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>,
<expr><call><name>InstantiatedFrom</name><argument_list>(<argument><expr><name>InstantiatedFrom</name></expr></argument>)</argument_list></call></expr>, <macro><name>NumExpansions</name><argument_list>(<argument>UsingDecls.size()</argument>)</argument_list></macro> <expr><block>{
<expr><name>std</name><operator>::</operator><call><name>uninitialized_copy</name><argument_list>(<argument><expr><call><name><name>UsingDecls</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>UsingDecls</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;




<expr><name>NamedDecl</name> <operator>*</operator><macro><name>getInstantiatedFromUsingDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>InstantiatedFrom</name></expr>;</return> }</block>



<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>expansions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>UsingPackDecl</name> <operator>*</operator><call><name>Create</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>DeclContext</name> <operator>*</operator><name>DC</name></expr></argument>,
<argument><expr><name>NamedDecl</name> <operator>*</operator><name>InstantiatedFrom</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>UsingDecls</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>UsingPackDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>,
<argument>unsigned NumExpansions</argument>)</argument_list></macro></expr>;

<expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>InstantiatedFrom</name><operator>-&gt;</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>UsingPackDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{ <return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>UsingPackDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>UsingPack</name></expr>;</return> }</block>
}</expr>;












<expr><name>class</name> <name>UnresolvedUsingValueDecl</name> <operator>:</operator> <name>public</name> <name>ValueDecl</name></expr>,
<expr><name>public</name> <name><name>Mergeable</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedUsingValueDecl</name></expr></argument>&gt;</argument_list></name> <block>{

<expr><name>SourceLocation</name> <name>UsingLocation</name></expr>;


<expr><name>SourceLocation</name> <name>EllipsisLoc</name></expr>;


<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;



<expr><name>DeclarationNameLoc</name> <name>DNLoc</name></expr>;

<macro><name>UnresolvedUsingValueDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>QualType Ty</argument>,
<argument>SourceLocation UsingLoc</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>,
<argument>SourceLocation EllipsisLoc</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>ValueDecl</name><argument_list>(<argument><expr><name>UnresolvedUsingValue</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>,
<argument><expr><call><name><name>NameInfo</name><operator>.</operator><name>getLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>UsingLocation</name><argument_list>(<argument><expr><name>UsingLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>EllipsisLoc</name><argument_list>(<argument><expr><name>EllipsisLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>QualifierLoc</name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>DNLoc</name><argument_list>(<argument>NameInfo.getInfo()</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclWriter</name></expr>;


<expr><name>SourceLocation</name> <macro><name>getUsingLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>UsingLocation</name></expr>;</return> }</block>


<name>void</name> <macro><name>setUsingLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>UsingLocation</name> <operator>=</operator> <name>L</name></expr>; }</block>


<name>bool</name> <macro><name>isAccessDeclaration</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>UsingLocation</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QualifierLoc</name></expr>;</return> }</block>


<name>NestedNameSpecifier</name> <operator>*</operator><macro><name>getQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>DeclarationNameInfo</name> <macro><name>getNameInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>DeclarationNameInfo</name><argument_list>(<argument><expr><call><name>getDeclName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DNLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>isPackExpansion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>EllipsisLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getEllipsisLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>EllipsisLoc</name></expr>;</return>
}</block>

<specifier>static</specifier> <name>UnresolvedUsingValueDecl</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation UsingLoc</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>, <argument>SourceLocation EllipsisLoc</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>UnresolvedUsingValueDecl</name> <operator>*</operator>
<macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name></expr>;


<expr><name>UnresolvedUsingValueDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>UnresolvedUsingValueDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>UnresolvedUsingValue</name></expr>;</return> }</block>
}</expr>;












<expr><name>class</name> <name>UnresolvedUsingTypenameDecl</name>
<operator>:</operator> <name>public</name> <name>TypeDecl</name></expr>,
<expr><name>public</name> <name><name>Mergeable</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedUsingTypenameDecl</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;


<expr><name>SourceLocation</name> <name>TypenameLocation</name></expr>;


<expr><name>SourceLocation</name> <name>EllipsisLoc</name></expr>;


<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;

<macro><name>UnresolvedUsingTypenameDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation UsingLoc</argument>,
<argument>SourceLocation TypenameLoc</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>SourceLocation TargetNameLoc</argument>,
<argument>IdentifierInfo *TargetName</argument>,
<argument>SourceLocation EllipsisLoc</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>TypeDecl</name><argument_list>(<argument><expr><name>UnresolvedUsingTypename</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>TargetNameLoc</name></expr></argument>, <argument><expr><name>TargetName</name></expr></argument>,
<argument><expr><name>UsingLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TypenameLocation</name><argument_list>(<argument><expr><name>TypenameLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>EllipsisLoc</name><argument_list>(<argument><expr><name>EllipsisLoc</name></expr></argument>)</argument_list></call></expr>,
<macro><name>QualifierLoc</name><argument_list>(<argument>QualifierLoc</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>

<name>SourceLocation</name> <macro><name>getUsingLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getTypenameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TypenameLocation</name></expr>;</return> }</block>



<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QualifierLoc</name></expr>;</return> }</block>


<name>NestedNameSpecifier</name> <operator>*</operator><macro><name>getQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>DeclarationNameInfo</name> <macro><name>getNameInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>DeclarationNameInfo</name><argument_list>(<argument><expr><call><name>getDeclName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>isPackExpansion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>EllipsisLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getEllipsisLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>EllipsisLoc</name></expr>;</return>
}</block>

<specifier>static</specifier> <name>UnresolvedUsingTypenameDecl</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation UsingLoc</argument>,
<argument>SourceLocation TypenameLoc</argument>, <argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>SourceLocation TargetNameLoc</argument>, <argument>DeclarationName TargetName</argument>,
<argument>SourceLocation EllipsisLoc</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>UnresolvedUsingTypenameDecl</name> <operator>*</operator>
<macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;


<expr><name>UnresolvedUsingTypenameDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>UnresolvedUsingTypenameDecl</name> <operator>*</operator><macro><name>getCanonicalDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getFirstDecl</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>UnresolvedUsingTypename</name></expr>;</return> }</block>
}</expr>;






<expr><name>class</name> <name>UnresolvedUsingIfExistsDecl</name> <name>final</name> <operator>:</operator> <name>public</name> <name>NamedDecl</name> <block>{
<macro><name>UnresolvedUsingIfExistsDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation Loc</argument>,
<argument>DeclarationName Name</argument>)</argument_list></macro>;

<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>UnresolvedUsingIfExistsDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;Ctx</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation Loc</argument>,
<argument>DeclarationName Name</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>UnresolvedUsingIfExistsDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;Ctx</argument>,
<argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>Decl</name><operator>::</operator><name>UnresolvedUsingIfExists</name></expr>;</return> }</block>
}</expr>;


<expr><name>class</name> <name>StaticAssertDecl</name> <operator>:</operator> <name>public</name> <name>Decl</name> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>AssertExprAndFailed</name></expr>;
<expr><name>StringLiteral</name> <operator>*</operator><name>Message</name></expr>;
<expr><name>SourceLocation</name> <name>RParenLoc</name></expr>;

<macro><name>StaticAssertDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation StaticAssertLoc</argument>,
<argument>Expr *AssertExpr</argument>, <argument>StringLiteral *Message</argument>,
<argument>SourceLocation RParenLoc</argument>, <argument>bool Failed</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Decl</name><argument_list>(<argument><expr><name>StaticAssert</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>StaticAssertLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>AssertExprAndFailed</name><argument_list>(<argument><expr><name>AssertExpr</name></expr></argument>, <argument><expr><name>Failed</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Message</name><argument_list>(<argument><expr><name>Message</name></expr></argument>)</argument_list></call></expr>,
<macro><name>RParenLoc</name><argument_list>(<argument>RParenLoc</argument>)</argument_list></macro> <expr><block>{}</block>

<name>virtual</name> <name>void</name> <call><name>anchor</name><argument_list>()</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;

<expr><specifier>static</specifier> <name>StaticAssertDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StaticAssertLoc</argument>,
<argument>Expr *AssertExpr</argument>, <argument>StringLiteral *Message</argument>,
<argument>SourceLocation RParenLoc</argument>, <argument>bool Failed</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>StaticAssertDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><name>Expr</name> <operator>*</operator><macro><name>getAssertExpr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>AssertExprAndFailed</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getAssertExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>AssertExprAndFailed</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>StringLiteral</name> <operator>*</operator><macro><name>getMessage</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Message</name></expr>;</return> }</block>
<specifier>const</specifier> <name>StringLiteral</name> <operator>*</operator><macro><name>getMessage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Message</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isFailed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>AssertExprAndFailed</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>

<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRParenLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>StaticAssert</name></expr>;</return> }</block>
}</expr>;









<expr><name>class</name> <name>BindingDecl</name> <operator>:</operator> <name>public</name> <name>ValueDecl</name> <block>{

<expr><name>ValueDecl</name> <operator>*</operator><name>Decomp</name></expr>;




<expr><name>Expr</name> <operator>*</operator><name>Binding</name> <operator>=</operator> <name>nullptr</name></expr>;

<macro><name>BindingDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation IdLoc</argument>, <argument>IdentifierInfo *Id</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>ValueDecl</name><argument_list>(<argument>Decl::Binding</argument>, <argument>DC</argument>, <argument>IdLoc</argument>, <argument>Id</argument>, <argument>QualType()</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;

<expr><specifier>static</specifier> <name>BindingDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation IdLoc</argument>, <argument>IdentifierInfo *Id</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>BindingDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;




<expr><name>Expr</name> <operator>*</operator><macro><name>getBinding</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Binding</name></expr>;</return> }</block>



<name>ValueDecl</name> <operator>*</operator><macro><name>getDecomposedDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Decomp</name></expr>;</return> }</block>



<name>VarDecl</name> <operator>*</operator><macro><name>getHoldingVar</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>void</name> <macro><name>setBinding</name><argument_list>(<argument>QualType DeclaredType</argument>, <argument>Expr *Binding</argument>)</argument_list></macro> <block>{
<expr><call><name>setType</name><argument_list>(<argument><expr><name>DeclaredType</name></expr></argument>)</argument_list></call></expr>;
<expr><name><name>this</name><operator>-&gt;</operator><name>Binding</name></name> <operator>=</operator> <name>Binding</name></expr>;
}</block>


<name>void</name> <macro><name>setDecomposedDecl</name><argument_list>(<argument>ValueDecl *Decomposed</argument>)</argument_list></macro> <block>{ <expr><name>Decomp</name> <operator>=</operator> <name>Decomposed</name></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>Decl</name><operator>::</operator><name>Binding</name></expr>;</return> }</block>
}</expr>;









<expr><name>class</name> <name>DecompositionDecl</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>VarDecl</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>DecompositionDecl</name></expr></argument>, <argument><expr><name>BindingDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{

<expr><name>unsigned</name> <name>NumBindings</name></expr>;

<macro><name>DecompositionDecl</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LSquareLoc</argument>, <argument>QualType T</argument>,
<argument>TypeSourceInfo *TInfo</argument>, <argument>StorageClass SC</argument>,
<argument>ArrayRef&lt;BindingDecl *&gt; Bindings</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>VarDecl</name><argument_list>(<argument><expr><name>Decomposition</name></expr></argument>, <argument><expr><name>C</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LSquareLoc</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>TInfo</name></expr></argument>,
<argument><expr><name>SC</name></expr></argument>)</argument_list></call></expr>,
<macro><name>NumBindings</name><argument_list>(<argument>Bindings.size()</argument>)</argument_list></macro> <expr><block>{
<expr><name>std</name><operator>::</operator><call><name>uninitialized_copy</name><argument_list>(<argument><expr><call><name><name>Bindings</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Bindings</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>BindingDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>B</name> <operator>:</operator> <name>Bindings</name></expr></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>B</name><operator>-&gt;</operator><name>setDecomposedDecl</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;

<expr><specifier>static</specifier> <name>DecompositionDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LSquareLoc</argument>,
<argument>QualType T</argument>, <argument>TypeSourceInfo *TInfo</argument>,
<argument>StorageClass S</argument>,
<argument>ArrayRef&lt;BindingDecl *&gt; Bindings</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>DecompositionDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>,
<argument>unsigned NumBindings</argument>)</argument_list></macro></expr>;

<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>BindingDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>bindings</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>BindingDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NumBindings</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>printName</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>Decomposition</name></expr>;</return> }</block>
}</expr>;




























<expr><name>class</name> <name>MSPropertyDecl</name> <operator>:</operator> <name>public</name> <name>DeclaratorDecl</name> <block>{
<expr><name>IdentifierInfo</name> <operator>*</operator><name>GetterId</name></expr>, <expr><operator>*</operator><name>SetterId</name></expr>;

<macro><name>MSPropertyDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>SourceLocation L</argument>, <argument>DeclarationName N</argument>,
<argument>QualType T</argument>, <argument>TypeSourceInfo *TInfo</argument>, <argument>SourceLocation StartL</argument>,
<argument>IdentifierInfo *Getter</argument>, <argument>IdentifierInfo *Setter</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>DeclaratorDecl</name><argument_list>(<argument><expr><name>MSProperty</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>, <argument><expr><name>L</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>TInfo</name></expr></argument>, <argument><expr><name>StartL</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>GetterId</name><argument_list>(<argument><expr><name>Getter</name></expr></argument>)</argument_list></call></expr>, <macro><name>SetterId</name><argument_list>(<argument>Setter</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;

<expr><specifier>static</specifier> <name>MSPropertyDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>DeclContext *DC</argument>,
<argument>SourceLocation L</argument>, <argument>DeclarationName N</argument>, <argument>QualType T</argument>,
<argument>TypeSourceInfo *TInfo</argument>, <argument>SourceLocation StartL</argument>,
<argument>IdentifierInfo *Getter</argument>, <argument>IdentifierInfo *Setter</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>MSPropertyDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>MSProperty</name></expr>;</return> }</block>

<name>bool</name> <macro><name>hasGetter</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>GetterId</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block>
<name>IdentifierInfo</name><operator>*</operator> <macro><name>getGetterId</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>GetterId</name></expr>;</return> }</block>
<name>bool</name> <macro><name>hasSetter</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SetterId</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block>
<name>IdentifierInfo</name><operator>*</operator> <macro><name>getSetterId</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SetterId</name></expr>;</return> }</block>
}</expr>;



struct <expr><name>MSGuidDeclParts</name> <block>{

<expr><name>uint32_t</name> <name>Part1</name></expr>;

<expr><name>uint16_t</name> <name>Part2</name></expr>;

<expr><name>uint16_t</name> <name>Part3</name></expr>;

<expr><name>uint8_t</name> <name><name>Part4And5</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;

<expr><name>uint64_t</name> <macro><name>getPart4And5AsUint64</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>uint64_t</name> <name>Val</name></expr>;
<expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Part4And5</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Part4And5</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Val</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>MSGuidDecl</name> <operator>:</operator> <name>public</name> <name>ValueDecl</name></expr>,
<expr><name>public</name> <name><name>Mergeable</name><argument_list type="generic">&lt;<argument><expr><name>MSGuidDecl</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>using</name> <name>Parts</name> <operator>=</operator> <name>MSGuidDeclParts</name></expr>;

<expr><name>private</name><operator>:</operator>

<name>Parts</name> <name>PartVal</name></expr>;



<expr><name>mutable</name> <name>APValue</name> <name>APVal</name></expr>;

<expr><name>void</name> <macro><name>anchor</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<macro><name>MSGuidDecl</name><argument_list>(<argument>DeclContext *DC</argument>, <argument>QualType T</argument>, <argument>Parts P</argument>)</argument_list></macro>;

<expr><specifier>static</specifier> <name>MSGuidDecl</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>QualType T</argument>, <argument>Parts P</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>MSGuidDecl</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>ASTContext &amp;C</argument>, <argument>unsigned ID</argument>)</argument_list></macro></expr>;


<expr><name>friend</name> <name>class</name> <name>ASTContext</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTDeclReader</name></expr>;

<expr><name>public</name><operator>:</operator>

<name>void</name> <macro><name>printName</name><argument_list>(<argument>llvm::raw_ostream &amp;OS</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;


<expr><name>Parts</name> <macro><name>getParts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PartVal</name></expr>;</return> }</block>




<name>APValue</name> <operator>&amp;</operator><macro><name>getAsAPValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>Parts P</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name><name>P</name><operator>.</operator><name>Part1</name></name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name><name>P</name><operator>.</operator><name>Part2</name></name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name><name>P</name><operator>.</operator><name>Part3</name></name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><call><name><name>P</name><operator>.</operator><name>getPart4And5AsUint64</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>
<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <block>{ <expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>PartVal</name></expr></argument>)</argument_list></call></expr>; }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Decl *D</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>classofKind</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classofKind</name><argument_list>(<argument>Kind K</argument>)</argument_list></macro> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>Decl</name><operator>::</operator><name>MSGuid</name></expr>;</return> }</block>
}</expr>;



<expr><specifier>const</specifier> <name>StreamingDiagnostic</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><specifier>const</specifier> <name>StreamingDiagnostic</name> <operator>&amp;</operator><name>DB</name>,
<name>AccessSpecifier</name> <name>AS</name><operator>)</operator></expr>;

}</block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></range></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
