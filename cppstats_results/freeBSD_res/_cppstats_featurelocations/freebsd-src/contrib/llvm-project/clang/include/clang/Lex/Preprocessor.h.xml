<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Lex/Preprocessor.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_LEX_PREPROCESSOR_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_LEX_PREPROCESSOR_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Diagnostic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/IdentifierTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LangOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Module.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TokenKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/Lexer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/MacroInfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/ModuleLoader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/ModuleMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/PPCallbacks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/PreprocessorExcludedConditionalDirectiveSkipMapping.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/Token.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/TokenLexer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/FoldingSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/FunctionExtras.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/None.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerUnion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/STLExtras.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallPtrSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/TinyPtrVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Allocator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Registry.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;map&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>

<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>InternalLen</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>SmallString</name></decl>;</decl_stmt>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>CodeCompletionHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CommentHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DirectoryEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DirectoryLookup</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>EmptylineHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ExternalPreprocessorSource</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FileEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FileManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>HeaderSearch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MacroArgs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>PragmaHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>PragmaNamespace</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>PreprocessingRecord</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>PreprocessorLexer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>PreprocessorOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ScratchBuffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TargetInfo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>Builtin</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>Context</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>TokenValue</name> <block>{<block_content>
<expr_stmt><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Kind</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>TokenValue</name><argument_list>(<argument>tok::TokenKind Kind</argument>)</argument_list></macro> : <expr_stmt><expr><call><name>Kind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>II</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Kind</name> <operator>!=</operator> <name>tok</name><operator>::</operator><name>raw_identifier</name> <operator>&amp;&amp;</operator> <literal type="string">"Raw identifiers are not supported."</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Kind</name> <operator>!=</operator> <name>tok</name><operator>::</operator><name>identifier</name> <operator>&amp;&amp;</operator>
<literal type="string">"Identifiers should be created by TokenValue(IdentifierInfo *)"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>tok</name><operator>::</operator><call><name>isLiteral</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Literals are not supported."</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>tok</name><operator>::</operator><call><name>isAnnotation</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Annotations are not supported."</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>TokenValue</name><argument_list>(<argument><expr><name>IdentifierInfo</name> <operator>*</operator><name>II</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>identifier</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>II</name><argument_list>(<argument>II</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>Token</name> <operator>&amp;</operator><name>Tok</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Tok</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Kind</name> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><name>II</name> <operator>||</operator> <name>II</name> <operator>==</operator> <call><name><name>Tok</name><operator>.</operator><name>getIdentifierInfo</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<enum>enum <name>MacroUse</name> <block>{

<decl><name>MU_Other</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,


<decl><name>MU_Define</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,


<decl><name>MU_Undef</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>
}</block>;</enum>







<decl_stmt><decl><type><name>class</name></type> <name>Preprocessor</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>VAOptDefinitionContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>VariadicMacroScopeGuard</name></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>unique_function</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><specifier>const</specifier> <name>clang</name><operator>::</operator><name>Token</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>OnToken</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PreprocessorOptions</name></expr></argument>&gt;</argument_list></name> <name>PPOpts</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>DiagnosticsEngine</name> <modifier>*</modifier></type><name>Diags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LangOptions</name> <modifier>&amp;</modifier></type><name>LangOpts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>*</modifier></type><name>Target</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>*</modifier></type><name>AuxTarget</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FileManager</name> <modifier>&amp;</modifier></type><name>FileMgr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceManager</name> <modifier>&amp;</modifier></type><name>SourceMgr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ScratchBuffer</name></expr></argument>&gt;</argument_list></name> <name>ScratchBuf</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>HeaderSearch</name> <modifier>&amp;</modifier></type><name>HeaderInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ModuleLoader</name> <modifier>&amp;</modifier></type><name>TheModuleLoader</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ExternalPreprocessorSource</name> <modifier>*</modifier></type><name>ExternalSource</name></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name> <name>BP</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__LINE__</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>Ident__FILE__</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__DATE__</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>Ident__TIME__</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__INCLUDE_LEVEL__</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__BASE_FILE__</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__FILE_NAME__</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__TIMESTAMP__</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__COUNTER__</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident_Pragma</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>Ident__pragma</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__identifier</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__VA_ARGS__</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__VA_OPT__</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__has_feature</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__has_extension</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__has_builtin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__has_attribute</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__has_include</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__has_include_next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__has_warning</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__is_identifier</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__building_module</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__MODULE__</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__has_cpp_attribute</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__has_c_attribute</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__has_declspec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__is_target_arch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__is_target_vendor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__is_target_os</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__is_target_environment</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Token</name><modifier>*</modifier></type> <name>ArgMacro</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>DATELoc</name></decl>, <decl><type ref="prev"/><name>TIMELoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>CounterValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<enum>enum <block>{

<decl><name>MaxAllowedIncludeStackDepth</name> <init>= <expr><literal type="number">200</literal></expr></init></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>bool</name></type> <name>KeepComments</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>KeepMacroComments</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>SuppressIncludeNotFoundError</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>InMacroArgs</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>OwnsHeaderSearch</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>DisableMacroExpansion</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>MacroExpansionInDirectivesOverride</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>ResetMacroExpansionHelper</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>mutable</name> <name>bool</name></type> <name>ReadMacrosFromExternalSource</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>PragmasEnabled</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>PreprocessedOutput</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>ParsingIfOrElifDirective</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>InMacroArgPreExpansion</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>mutable</name> <name>IdentifierTable</name></type> <name>Identifiers</name></decl>;</decl_stmt>










<decl_stmt><decl><type><name>SelectorTable</name></type> <name>Selectors</name></decl>;</decl_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Builtin</name><operator>::</operator><name>Context</name></expr></argument>&gt;</argument_list></name> <name>BuiltinInfo</name></expr>;</expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaNamespace</name></expr></argument>&gt;</argument_list></name> <name>PragmaHandlers</name></expr>;</expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PragmaNamespace</name></expr></argument>&gt;</argument_list></name> <name>PragmaHandlersBackup</name></expr>;</expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CommentHandler</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CommentHandlers</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>EmptylineHandler</name> <modifier>*</modifier></type><name>Emptyline</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>IncrementalProcessing</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>

<decl_stmt><decl><type><specifier>const</specifier> <name>TranslationUnitKind</name></type> <name>TUKind</name></decl>;</decl_stmt>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>CodeCompletionHandler</name> <modifier>*</modifier></type><name>CodeComplete</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>CodeCompletionFile</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>CodeCompletionOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>SourceLocation</name></type> <name>CodeCompletionLoc</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>SourceLocation</name></type> <name>CodeCompletionFileLoc</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ModuleImportLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <modifier>*</modifier></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>ModuleImportPath</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>LastTokenWasAt</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>ImportSeq</name> <block>{<block_content>
<label><name>public</name>:</label>
<enum>enum <name>State</name> : <type><name>int</name></type> <block>{

<decl><name>AtTopLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>AfterTopLevelTokenSeq</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
<decl><name>AfterExport</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>,
<decl><name>AfterImportSeq</name> <init>= <expr><operator>-</operator><literal type="number">3</literal></expr></init></decl>,
}</block>;</enum>

<macro><name>ImportSeq</name><argument_list>(<argument>State S</argument>)</argument_list></macro> : <macro><name>S</name><argument_list>(<argument>S</argument>)</argument_list></macro> <block>{<block_content/>}</block>


<function><type><name>void</name></type> <name>handleOpenBracket</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>S</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>State</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>max</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>handleCloseBracket</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>S</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>State</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>max</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>handleCloseBrace</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>handleCloseBracket</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>S</name> <operator>==</operator> <name>AtTopLevel</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>AfterHeaderName</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>S</name> <operator>=</operator> <name>AfterTopLevelTokenSeq</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>handleSemi</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>atTopLevel</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>S</name> <operator>=</operator> <name>AfterTopLevelTokenSeq</name></expr>;</expr_stmt>
<expr_stmt><expr><name>AfterHeaderName</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>handleExport</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>S</name> <operator>==</operator> <name>AfterTopLevelTokenSeq</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>S</name> <operator>=</operator> <name>AfterExport</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>S</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>S</name> <operator>=</operator> <name>AtTopLevel</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>handleImport</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>S</name> <operator>==</operator> <name>AfterTopLevelTokenSeq</name> <operator>||</operator> <name>S</name> <operator>==</operator> <name>AfterExport</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>S</name> <operator>=</operator> <name>AfterImportSeq</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>S</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>S</name> <operator>=</operator> <name>AtTopLevel</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>handleHeaderName</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>S</name> <operator>==</operator> <name>AfterImportSeq</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>AfterHeaderName</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>handleMisc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>handleMisc</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>S</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>S</name> <operator>=</operator> <name>AtTopLevel</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>atTopLevel</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>S</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</return> </block_content>}</block></function>
<function><type><name>bool</name></type> <name>afterImportSeq</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>S</name> <operator>==</operator> <name>AfterImportSeq</name></expr>;</return> </block_content>}</block></function>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>State</name></type> <name>S</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>AfterHeaderName</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>ImportSeq</name></type> <name>ImportSeqState</name> <init>= <expr><name>ImportSeq</name><operator>::</operator><name>AfterTopLevelTokenSeq</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>ModuleImportExpectsIdentifier</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <name>PragmaARCCFCodeAuditedInfo</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>SourceLocation</name></type> <name>PragmaAssumeNonNullLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>CodeCompletionReached</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>CodeCompletionII</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceRange</name></type> <name>CodeCompletionTokenRange</name></decl>;</decl_stmt>




<decl_stmt><decl><type><specifier>const</specifier> <name>DirectoryEntry</name> <modifier>*</modifier></type><name>MainFileDir</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>






<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>SkipMainFilePreamble</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>HasReachedMaxIncludeDepth</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>







<decl_stmt><decl><type><name>unsigned</name></type> <name>LexLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>TokenCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>PreprocessToken</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>MaxTokens</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>MaxTokensOverrideLoc</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<struct>struct <name>PreambleSkipInfo</name> <block>{
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>HashTokenLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>IfTokenLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>FoundNonSkipPortion</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>FoundElse</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ElseLoc</name></decl>;</decl_stmt>

<macro><name>PreambleSkipInfo</name><argument_list>(<argument>SourceLocation HashTokenLoc</argument>, <argument>SourceLocation IfTokenLoc</argument>,
<argument>bool FoundNonSkipPortion</argument>, <argument>bool FoundElse</argument>,
<argument>SourceLocation ElseLoc</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>HashTokenLoc</name><argument_list>(<argument><expr><name>HashTokenLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IfTokenLoc</name><argument_list>(<argument><expr><name>IfTokenLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>FoundNonSkipPortion</name><argument_list>(<argument><expr><name>FoundNonSkipPortion</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>FoundElse</name><argument_list>(<argument><expr><name>FoundElse</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>ElseLoc</name><argument_list>(<argument>ElseLoc</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>MacroArgs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>PreambleConditionalStackStore</name> <block>{<block_content>
<enum>enum <name>State</name> <block>{
<decl><name>Off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>Recording</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>Replaying</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
}</block>;</enum>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>PreambleConditionalStackStore</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>

<function><type><name>void</name></type> <name>startRecording</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>ConditionalStackState</name> <operator>=</operator> <name>Recording</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>startReplaying</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>ConditionalStackState</name> <operator>=</operator> <name>Replaying</name></expr>;</expr_stmt> </block_content>}</block></function>
<expr_stmt><expr><name>bool</name> <macro><name>isRecording</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ConditionalStackState</name> <operator>==</operator> <name>Recording</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isReplaying</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ConditionalStackState</name> <operator>==</operator> <name>Replaying</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>PPConditionalInfo</name></expr></argument>&gt;</argument_list></name> <macro><name>getStack</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ConditionalStack</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>doneReplaying</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>ConditionalStack</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ConditionalStackState</name> <operator>=</operator> <name>Off</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setStack</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>PPConditionalInfo</name></expr></argument>&gt;</argument_list></name></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isRecording</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isReplaying</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>ConditionalStack</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ConditionalStack</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>s</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>s</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>hasRecordedPreamble</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name><name>ConditionalStack</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>reachedEOFWhileSkipping</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>SkipInfo</name><operator>.</operator><name>hasValue</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>clearSkipInfo</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>SkipInfo</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>PreambleSkipInfo</name></expr></argument>&gt;</argument_list></name> <name>SkipInfo</name></expr>;</expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>PPConditionalInfo</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>ConditionalStack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>State</name></type> <name>ConditionalStackState</name> <init>= <expr><name>Off</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt> <expr_stmt><expr><name>PreambleConditionalStack</name></expr>;</expr_stmt>





<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Lexer</name></expr></argument>&gt;</argument_list></name> <name>CurLexer</name></expr>;</expr_stmt>





<decl_stmt><decl><type><name>PreprocessorLexer</name> <modifier>*</modifier></type><name>CurPPLexer</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>






<decl_stmt><decl><type><specifier>const</specifier> <name>DirectoryLookup</name> <modifier>*</modifier></type><name>CurDirLookup</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>




<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>TokenLexer</name></expr></argument>&gt;</argument_list></name> <name>CurTokenLexer</name></expr>;</expr_stmt>


<enum>enum <name>CurLexerKind</name> <block>{
<decl><name>CLK_Lexer</name></decl>,
<decl><name>CLK_TokenLexer</name></decl>,
<decl><name>CLK_CachingLexer</name></decl>,
<decl><name>CLK_LexAfterModuleImport</name></decl>
}</block> <decl><name>CurLexerKind</name> <init>= <expr><name>CLK_Lexer</name></expr></init></decl>;</enum>



<decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>CurLexerSubmodule</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>




<struct>struct <name>IncludeStackInfo</name> <block>{
<decl_stmt><decl><type><name><name>enum</name> <name>CurLexerKind</name></name></type> <name>CurLexerKind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>TheSubmodule</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Lexer</name></expr></argument>&gt;</argument_list></name> <name>TheLexer</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PreprocessorLexer</name> <modifier>*</modifier></type><name>ThePPLexer</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>TokenLexer</name></expr></argument>&gt;</argument_list></name> <name>TheTokenLexer</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>DirectoryLookup</name> <modifier>*</modifier></type><name>TheDirLookup</name></decl>;</decl_stmt>



<macro><name>IncludeStackInfo</name><argument_list>(<argument>enum CurLexerKind CurLexerKind</argument>, <argument>Module *TheSubmodule</argument>,
<argument>std::unique_ptr&lt;Lexer&gt; &amp;&amp;TheLexer</argument>,
<argument>PreprocessorLexer *ThePPLexer</argument>,
<argument>std::unique_ptr&lt;TokenLexer&gt; &amp;&amp;TheTokenLexer</argument>,
<argument>const DirectoryLookup *TheDirLookup</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>CurLexerKind</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>CurLexerKind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>TheSubmodule</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>TheSubmodule</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>TheLexer</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>TheLexer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>ThePPLexer</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>ThePPLexer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>TheTokenLexer</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>TheTokenLexer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>TheDirLookup</name><argument_list>(<argument>std::move(TheDirLookup)</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>IncludeStackInfo</name></expr></argument>&gt;</argument_list></name> <name>IncludeMacroStack</name></expr>;</expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PPCallbacks</name></expr></argument>&gt;</argument_list></name> <name>Callbacks</name></expr>;</expr_stmt>

<struct>struct <name>MacroExpandsInfo</name> <block>{
<decl_stmt><decl><type><name>Token</name></type> <name>Tok</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MacroDefinition</name></type> <name>MD</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceRange</name></type> <name>Range</name></decl>;</decl_stmt>

<macro><name>MacroExpandsInfo</name><argument_list>(<argument>Token Tok</argument>, <argument>MacroDefinition MD</argument>, <argument>SourceRange Range</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Tok</name><argument_list>(<argument><expr><name>Tok</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>MD</name><argument_list>(<argument><expr><name>MD</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Range</name><argument_list>(<argument>Range</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>MacroExpandsInfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>DelayedMacroExpandsCallbacks</name></decl>;</decl_stmt>


<struct>struct <name>ModuleMacroInfo</name> <block>{

<decl_stmt><decl><type><name>MacroDirective</name> <modifier>*</modifier></type><name>MD</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>TinyPtrVector</name><argument_list type="generic">&lt;<argument><expr><name>ModuleMacro</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ActiveModuleMacros</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>ActiveModuleMacrosGeneration</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>IsAmbiguous</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>TinyPtrVector</name><argument_list type="generic">&lt;<argument><expr><name>ModuleMacro</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>OverriddenMacros</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ModuleMacroInfo</name><argument_list>(<argument><expr><name>MacroDirective</name> <operator>*</operator><name>MD</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>MD</name><argument_list>(<argument>MD</argument>)</argument_list></macro> <block>{}</block></expr></expr_stmt>
}</block>;</struct>


<decl_stmt><decl><type><name>class</name></type> <name>MacroState</name> <block>{<block_content>
<expr_stmt><expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>MacroDirective</name> <operator>*</operator></expr></argument>, <argument><expr><name>ModuleMacroInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>State</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ModuleMacroInfo</name> <modifier>*</modifier></type><name>getModuleInfo</name><argument_list>(<argument><expr><name>Preprocessor</name> <operator>&amp;</operator><name>PP</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>II</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>II</name><operator>-&gt;</operator><name>isOutOfDate</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>PP</name><operator>.</operator><name>updateOutOfDateIdentifier</name></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>II</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>II</name><operator>-&gt;</operator><name>hasMacroDefinition</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<operator>(</operator><operator>!</operator><call><name><name>PP</name><operator>.</operator><name>getLangOpts</name></name><argument_list>()</argument_list></call><operator>.</operator><name>Modules</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name><name>PP</name><operator>.</operator><name>getLangOpts</name></name><argument_list>()</argument_list></call><operator>.</operator><name>ModulesLocalVisibility</name><operator>)</operator> <operator>||</operator>
<operator>!</operator><call><name><name>PP</name><operator>.</operator><name>CurSubmoduleState</name><operator>-&gt;</operator><name>VisibleModules</name><operator>.</operator><name>getGeneration</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>auto</name> <operator>*</operator><name>Info</name> <operator>=</operator> <name><name>State</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>ModuleMacroInfo</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Info</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Info</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>PP.getPreprocessorAllocator()</argument>)</argument_list></macro>
<call><name>ModuleMacroInfo</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>MacroDirective</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>State</name> <operator>=</operator> <name>Info</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>PP</name><operator>.</operator><name>CurSubmoduleState</name><operator>-&gt;</operator><name>VisibleModules</name><operator>.</operator><name>getGeneration</name></name><argument_list>()</argument_list></call> <operator>!=</operator>
<name><name>Info</name><operator>-&gt;</operator><name>ActiveModuleMacrosGeneration</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>PP</name><operator>.</operator><name>updateModuleMacroInfo</name></name><argument_list>(<argument><expr><name>II</name></expr></argument>, <argument><expr><operator>*</operator><name>Info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>Info</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>MacroState</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>MacroState</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <block>{}</block>
<call><name>MacroState</name><argument_list>(<argument><expr><name>MacroDirective</name> <operator>*</operator><name>MD</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>State</name><argument_list>(<argument>MD</argument>)</argument_list></macro> <block>{}</block>

<macro><name>MacroState</name><argument_list>(<argument>MacroState &amp;&amp;O</argument>)</argument_list></macro> <name>noexcept</name> <operator>:</operator> <macro><name>State</name><argument_list>(<argument>O.State</argument>)</argument_list></macro> <block>{
<expr><name><name>O</name><operator>.</operator><name>State</name></name> <operator>=</operator> <operator>(</operator><name>MacroDirective</name> <operator>*</operator><operator>)</operator><name>nullptr</name></expr>;
}</block>

<name>MacroState</name> <operator>&amp;</operator><name>operator</name><operator>=</operator><operator>(</operator><name>MacroState</name> <operator>&amp;&amp;</operator><name>O</name><operator>)</operator> <name>noexcept</name> <block>{
<expr><name>auto</name> <name>S</name> <operator>=</operator> <name><name>O</name><operator>.</operator><name>State</name></name></expr>;
<expr><name><name>O</name><operator>.</operator><name>State</name></name> <operator>=</operator> <operator>(</operator><name>MacroDirective</name> <operator>*</operator><operator>)</operator><name>nullptr</name></expr>;
<expr><name>State</name> <operator>=</operator> <name>S</name></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><operator>~</operator><macro><name>MacroState</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>Info</name> <operator>=</operator> <name><name>State</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>ModuleMacroInfo</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>Info</name><operator>-&gt;</operator><name/></name>~<call><name>ModuleMacroInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>MacroDirective</name> <operator>*</operator><macro><name>getLatest</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>Info</name> <operator>=</operator> <name><name>State</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>ModuleMacroInfo</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>Info</name><operator>-&gt;</operator><name>MD</name></name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name><name>State</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>MacroDirective</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type> <name>setLatest</name><parameter_list>(<parameter><decl><type><name>MacroDirective</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>Info</name> <operator>=</operator> <name><name>State</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>ModuleMacroInfo</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>Info</name><operator>-&gt;</operator><name>MD</name></name> <operator>=</operator> <name>MD</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>State</name> <operator>=</operator> <name>MD</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name>bool</name></type> <name>isAmbiguous</name><argument_list>(<argument><expr><name>Preprocessor</name> <operator>&amp;</operator><name>PP</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>II</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>Info</name> <operator>=</operator> <call><name>getModuleInfo</name><argument_list>(<argument><expr><name>PP</name></expr></argument>, <argument><expr><name>II</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><name>Info</name></expr> ?</condition><then> <expr><name><name>Info</name><operator>-&gt;</operator><name>IsAmbiguous</name></name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ModuleMacro</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type>
<name>getActiveModuleMacros</name><argument_list>(<argument><expr><name>Preprocessor</name> <operator>&amp;</operator><name>PP</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>II</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>Info</name> <operator>=</operator> <call><name>getModuleInfo</name><argument_list>(<argument><expr><name>PP</name></expr></argument>, <argument><expr><name>II</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>Info</name><operator>-&gt;</operator><name>ActiveModuleMacros</name></name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>None</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>MacroDirective</name><operator>::</operator><name>DefInfo</name> <macro><name>findDirectiveAtLoc</name><argument_list>(<argument>SourceLocation Loc</argument>,
<argument>SourceManager &amp;SourceMgr</argument>)</argument_list></macro> <specifier>const</specifier> <block>{

<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>Latest</name> <operator>=</operator> <call><name>getLatest</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Latest</name><operator>-&gt;</operator><name>findDirectiveAtLoc</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>SourceMgr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><block>{}</block></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type> <name>overrideActiveModuleMacros</name><parameter_list>(<parameter><decl><type><name>Preprocessor</name> <modifier>&amp;</modifier></type><name>PP</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>Info</name> <operator>=</operator> <call><name>getModuleInfo</name><argument_list>(<argument><expr><name>PP</name></expr></argument>, <argument><expr><name>II</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Info</name><operator>-&gt;</operator><name>OverriddenMacros</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>Info</name><operator>-&gt;</operator><name>OverriddenMacros</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Info</name><operator>-&gt;</operator><name>ActiveModuleMacros</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Info</name><operator>-&gt;</operator><name>ActiveModuleMacros</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Info</name><operator>-&gt;</operator><name>ActiveModuleMacros</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Info</name><operator>-&gt;</operator><name>IsAmbiguous</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ModuleMacro</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getOverriddenMacros</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>Info</name> <operator>=</operator> <name><name>State</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>ModuleMacroInfo</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>Info</name><operator>-&gt;</operator><name>OverriddenMacros</name></name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>None</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type> <name>setOverriddenMacros</name><parameter_list>(<parameter><decl><type><name>Preprocessor</name> <modifier>&amp;</modifier></type><name>PP</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ModuleMacro</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Overrides</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>Info</name> <operator>=</operator> <name><name>State</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>ModuleMacroInfo</name><operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Info</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Overrides</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>Info</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>PP.getPreprocessorAllocator()</argument>)</argument_list></macro>
<call><name>ModuleMacroInfo</name><argument_list>(<argument><expr><name><name>State</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>MacroDirective</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>State</name> <operator>=</operator> <name>Info</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name><name>Info</name><operator>-&gt;</operator><name>OverriddenMacros</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Info</name><operator>-&gt;</operator><name>OverriddenMacros</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>Info</name><operator>-&gt;</operator><name>OverriddenMacros</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Overrides</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Overrides</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Info</name><operator>-&gt;</operator><name>ActiveModuleMacrosGeneration</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
};






<decl_stmt><decl><type><name>using</name></type> <name>MacroMap</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>MacroState</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<struct_decl>struct <name>SubmoduleState</name>;</struct_decl>


<struct>struct <name>BuildingSubmoduleInfo</name> <block>{

<decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>M</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ImportLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>IsPragma</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SubmoduleState</name> <modifier>*</modifier></type><name>OuterSubmoduleState</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>OuterPendingModuleMacroNames</name></decl>;</decl_stmt>

<macro><name>BuildingSubmoduleInfo</name><argument_list>(<argument>Module *M</argument>, <argument>SourceLocation ImportLoc</argument>, <argument>bool IsPragma</argument>,
<argument>SubmoduleState *OuterSubmoduleState</argument>,
<argument>unsigned OuterPendingModuleMacroNames</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ImportLoc</name><argument_list>(<argument><expr><name>ImportLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IsPragma</name><argument_list>(<argument><expr><name>IsPragma</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>OuterSubmoduleState</name><argument_list>(<argument><expr><name>OuterSubmoduleState</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>OuterPendingModuleMacroNames</name><argument_list>(<argument>OuterPendingModuleMacroNames</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>BuildingSubmoduleInfo</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>BuildingSubmoduleStack</name></decl>;</decl_stmt>


<struct>struct <name>SubmoduleState</name> <block>{

<decl_stmt><decl><type><name>MacroMap</name></type> <name>Macros</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>VisibleModuleSet</name></type> <name>VisibleModules</name></decl>;</decl_stmt>



}</block>;</struct>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>Module</name> <operator>*</operator></expr></argument>, <argument><expr><name>SubmoduleState</name></expr></argument>&gt;</argument_list></name> <name>Submodules</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>SubmoduleState</name></type> <name>NullSubmoduleState</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>SubmoduleState</name> <modifier>*</modifier></type><name>CurSubmoduleState</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>ModuleMacro</name></expr></argument>&gt;</argument_list></name> <name>ModuleMacros</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>&gt;</argument_list></name> <name>PendingModuleMacroNames</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name><name>TinyPtrVector</name><argument_list type="generic">&lt;<argument><expr><name>ModuleMacro</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>LeafModuleMacros</name></expr>;</expr_stmt>









<decl_stmt><decl><type><name>using</name></type> <name>WarnUnusedMacroLocsTy</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>SmallDenseSet</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WarnUnusedMacroLocsTy</name></type> <name>WarnUnusedMacroLocs</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>MacroArgs</name> <modifier>*</modifier></type><name>MacroArgCache</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>MacroInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>PragmaPushMacroInfo</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumDirectives</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumDefined</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumUndefined</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumPragma</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumIf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumElse</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumEndif</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumEnteredSourceFiles</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>MaxIncludeStackDepth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumMacroExpanded</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumFnMacroExpanded</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumBuiltinMacroExpanded</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumFastMacroExpanded</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumTokenPaste</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumFastTokenPaste</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumSkipped</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>Predefines</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>FileID</name></type> <name>PredefinesFileID</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>FileID</name></type> <name>PCHThroughHeaderFileID</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>SkippingUntilPragmaHdrStop</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>SkippingUntilPCHThroughHeader</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<enum>enum <block>{ <decl><name>TokenLexerCacheSize</name> <init>= <expr><literal type="number">8</literal></expr></init></decl> }</block>;</enum>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumCachedTokenLexers</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>TokenLexer</name></expr></argument>&gt;</argument_list></name> <name><name>TokenLexerCache</name><index>[<expr><name>TokenLexerCacheSize</name></expr>]</index></name></expr>;</expr_stmt>







<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Token</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>MacroExpandedTokens</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>TokenLexer</name> <operator>*</operator></expr></argument>, <argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>MacroExpandingLexersStack</name></expr>;</expr_stmt>






<decl_stmt><decl><type><name>PreprocessingRecord</name> <modifier>*</modifier></type><name>Record</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>CachedTokensTy</name> <init>= <expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Token</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>CachedTokensTy</name></type> <name>CachedTokens</name></decl>;</decl_stmt>






<expr_stmt><expr><name>CachedTokensTy</name><operator>::</operator><name>size_type</name> <name>CachedLexPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>






<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CachedTokensTy</name><operator>::</operator><name>size_type</name></expr></argument>&gt;</argument_list></name> <name>BacktrackPositions</name></expr>;</expr_stmt>

<struct>struct <name>MacroInfoChain</name> <block>{
<decl_stmt><decl><type><name>MacroInfo</name></type> <name>MI</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MacroInfoChain</name> <modifier>*</modifier></type><name>Next</name></decl>;</decl_stmt>
}</block>;</struct>



<decl_stmt><decl><type><name>MacroInfoChain</name> <modifier>*</modifier></type><name>MIChainHead</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>updateOutOfDateIdentifier</name><argument_list>(<argument><expr><name>IdentifierInfo</name> <operator>&amp;</operator><name>II</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>Preprocessor</name><argument_list>(<argument>std::shared_ptr&lt;PreprocessorOptions&gt; PPOpts</argument>,
<argument>DiagnosticsEngine &amp;diags</argument>, <argument>LangOptions &amp;opts</argument>, <argument>SourceManager &amp;SM</argument>,
<argument>HeaderSearch &amp;Headers</argument>, <argument>ModuleLoader &amp;TheModuleLoader</argument>,
<argument>IdentifierInfoLookup *IILookup = nullptr</argument>,
<argument>bool OwnsHeaderSearch = false</argument>,
<argument>TranslationUnitKind TUKind = TU_Complete</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><operator>~</operator><call><name>Preprocessor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>







<function_decl><type><name>void</name></type> <name>Initialize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>&amp;</modifier></type><name>Target</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>*</modifier></type><name>AuxTarget</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>void</name></type> <name>InitializeForModelFile</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>FinalizeForModelFile</name><parameter_list>()</parameter_list>;</function_decl>



<expr_stmt><expr><name>PreprocessorOptions</name> <operator>&amp;</operator><macro><name>getPreprocessorOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>PPOpts</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><macro><name>getDiagnostics</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>Diags</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setDiagnostics</name><parameter_list>(<parameter><decl><type><name>DiagnosticsEngine</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Diags</name> <operator>=</operator> <operator>&amp;</operator><name>D</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><macro><name>getLangOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LangOpts</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>TargetInfo</name> <operator>&amp;</operator><macro><name>getTargetInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>Target</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>TargetInfo</name> <operator>*</operator><macro><name>getAuxTargetInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AuxTarget</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>FileManager</name> <operator>&amp;</operator><macro><name>getFileManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FileMgr</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceManager</name> <operator>&amp;</operator><macro><name>getSourceManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SourceMgr</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>HeaderSearch</name> <operator>&amp;</operator><macro><name>getHeaderSearchInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HeaderInfo</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>IdentifierTable</name> <modifier>&amp;</modifier></type><name>getIdentifierTable</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>Identifiers</name></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>IdentifierTable</name> <operator>&amp;</operator><macro><name>getIdentifierTable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Identifiers</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>SelectorTable</name> <modifier>&amp;</modifier></type><name>getSelectorTable</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>Selectors</name></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><name>Builtin</name><operator>::</operator><name>Context</name> <operator>&amp;</operator><macro><name>getBuiltinInfo</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><operator>*</operator><name>BuiltinInfo</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name> <operator>&amp;</operator><macro><name>getPreprocessorAllocator</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>BP</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setExternalSource</name><parameter_list>(<parameter><decl><type><name>ExternalPreprocessorSource</name> <modifier>*</modifier></type><name>Source</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>ExternalSource</name> <operator>=</operator> <name>Source</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>ExternalPreprocessorSource</name> <operator>*</operator><macro><name>getExternalSource</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ExternalSource</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>ModuleLoader</name> <operator>&amp;</operator><macro><name>getModuleLoader</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TheModuleLoader</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hadModuleLoaderFatalFailure</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>TheModuleLoader</name><operator>.</operator><name>HadFatalFailure</name></name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getNumDirectives</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumDirectives</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isParsingIfOrElifDirective</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ParsingIfOrElifDirective</name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>SetCommentRetentionState</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>KeepComments</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>KeepMacroComments</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>KeepComments</name></name> <operator>=</operator> <name>KeepComments</name> <operator>|</operator> <name>KeepMacroComments</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>KeepMacroComments</name></name> <operator>=</operator> <name>KeepMacroComments</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>getCommentRetentionState</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>KeepComments</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setPragmasEnabled</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Enabled</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>PragmasEnabled</name> <operator>=</operator> <name>Enabled</name></expr>;</expr_stmt> </block_content>}</block></function>
<expr_stmt><expr><name>bool</name> <macro><name>getPragmasEnabled</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PragmasEnabled</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>SetSuppressIncludeNotFoundError</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Suppress</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SuppressIncludeNotFoundError</name> <operator>=</operator> <name>Suppress</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>GetSuppressIncludeNotFoundError</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><name>SuppressIncludeNotFoundError</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>setPreprocessedOutput</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IsPreprocessedOutput</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>PreprocessedOutput</name> <operator>=</operator> <name>IsPreprocessedOutput</name></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>isPreprocessedOutput</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PreprocessedOutput</name></expr>;</return> }</block></expr></expr_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>isCurrentLexer</name><argument_list>(<argument><expr><specifier>const</specifier> <name>PreprocessorLexer</name> <operator>*</operator><name>L</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>CurPPLexer</name> <operator>==</operator> <name>L</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<expr_stmt><expr><name>PreprocessorLexer</name> <operator>*</operator><macro><name>getCurrentLexer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CurPPLexer</name></expr>;</return> }</block></expr></expr_stmt>





<expr_stmt><expr><name>PreprocessorLexer</name> <operator>*</operator><macro><name>getCurrentFileLexer</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>Module</name> <operator>*</operator><macro><name>getCurrentLexerSubmodule</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CurLexerSubmodule</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>FileID</name> <macro><name>getPredefinesFileID</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PredefinesFileID</name></expr>;</return> }</block></expr></expr_stmt>






<expr_stmt><expr><name>PPCallbacks</name> <operator>*</operator><macro><name>getPPCallbacks</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Callbacks</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>addPPCallbacks</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PPCallbacks</name></expr></argument>&gt;</argument_list></name> <name>C</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>Callbacks</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>C</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name><name>make_unique</name><argument_list type="generic">&lt;<argument><expr><name>PPChainedCallbacks</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Callbacks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>Callbacks</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getTokenCount</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TokenCount</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getMaxTokens</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MaxTokens</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>overrideMaxTokens</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Value</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>MaxTokens</name> <operator>=</operator> <name>Value</name></expr>;</expr_stmt>
<expr_stmt><expr><name>MaxTokensOverrideLoc</name> <operator>=</operator> <name>Loc</name></expr>;</expr_stmt>
</block_content>}</block></function><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getMaxTokensOverrideLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MaxTokensOverrideLoc</name></expr>;</return> }</block></expr></expr_stmt>




<decl_stmt><decl><type><name>void</name></type> <name>setTokenWatcher</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>unique_function</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><specifier>const</specifier> <name>clang</name><operator>::</operator><name>Token</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>F</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name>OnToken</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>F</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type> <name>setPreprocessToken</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Preprocess</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>PreprocessToken</name> <operator>=</operator> <name>Preprocess</name></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>bool</name></type> <name>isMacroDefined</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Id</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>isMacroDefined</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name><name>Identifiers</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>Id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>isMacroDefined</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>II</name><operator>-&gt;</operator><name>hasMacroDefinition</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>Modules</name> <operator>||</operator> <operator>(</operator><name>bool</name><operator>)</operator><call><name>getMacroDefinition</name><argument_list>(<argument><expr><name>II</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>bool</name></type> <name>isMacroDefinedInLocalModule</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>M</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>II</name><operator>-&gt;</operator><name>hasMacroDefinition</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>auto</name></type> <name>I</name> <init>= <expr><call><name><name>Submodules</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>I</name> <operator>==</operator> <call><name><name>Submodules</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>auto</name></type> <name>J</name> <init>= <expr><call><name><name>I</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>Macros</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>II</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>J</name> <operator>==</operator> <call><name><name>I</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>Macros</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>MD</name> <operator>=</operator> <call><name><name>J</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>getLatest</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>MD</name> <operator>&amp;&amp;</operator> <call><name><name>MD</name><operator>-&gt;</operator><name>isDefined</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>MacroDefinition</name></type> <name>getMacroDefinition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>II</name><operator>-&gt;</operator><name>hasMacroDefinition</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><block>{}</block></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>MacroState</name> <modifier>&amp;</modifier></type><name>S</name> <init>= <expr><name><name>CurSubmoduleState</name><operator>-&gt;</operator><name>Macros</name><index>[<expr><name>II</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>MD</name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>getLatest</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>MD</name> <operator>&amp;&amp;</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>VisibilityMacroDirective</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>MD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>MD</name> <operator>=</operator> <call><name><name>MD</name><operator>-&gt;</operator><name>getPrevious</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><call><name>MacroDefinition</name><argument_list>(<argument><expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>DefMacroDirective</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>MD</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>.</operator><name>getActiveModuleMacros</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>II</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>.</operator><name>isAmbiguous</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>II</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>MacroDefinition</name></type> <name>getMacroDefinitionAtLoc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>II</name><operator>-&gt;</operator><name>hadMacroDefinition</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><block>{}</block></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>MacroState</name> <modifier>&amp;</modifier></type><name>S</name> <init>= <expr><name><name>CurSubmoduleState</name><operator>-&gt;</operator><name>Macros</name><index>[<expr><name>II</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>MacroDirective</name><operator>::</operator><name>DefInfo</name> <name>DI</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>MD</name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>getLatest</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>DI</name> <operator>=</operator> <call><name><name>MD</name><operator>-&gt;</operator><name>findDirectiveAtLoc</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><call><name>getSourceManager</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>MacroDefinition</name><argument_list>(<argument><expr><call><name><name>DI</name><operator>.</operator><name>getDirective</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>.</operator><name>getActiveModuleMacros</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>II</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>.</operator><name>isAmbiguous</name></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>II</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<decl_stmt><decl><type><name>MacroDirective</name> <modifier>*</modifier></type><name>getLocalMacroDirective</name><argument_list>(<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>II</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>II</name><operator>-&gt;</operator><name>hasMacroDefinition</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>auto</name> <operator>*</operator><name>MD</name> <operator>=</operator> <call><name>getLocalMacroDirectiveHistory</name><argument_list>(<argument><expr><name>II</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>MD</name> <operator>||</operator> <call><name><name>MD</name><operator>-&gt;</operator><name>getDefinition</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isUndefined</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>MD</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>MacroInfo</name> <modifier>*</modifier></type><name>getMacroInfo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>II</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Preprocessor</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getMacroInfo</name><argument_list>(<argument><expr><name>II</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>MacroInfo</name> <modifier>*</modifier></type><name>getMacroInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>II</name><operator>-&gt;</operator><name>hasMacroDefinition</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<decl><type><name>auto</name></type> <name>MD</name> <init>= <expr><call><name>getMacroDefinition</name><argument_list>(<argument><expr><name>II</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>MD</name><operator>.</operator><name>getMacroInfo</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>nullptr</name></expr>;</return>
</block_content>}</block></function>






<decl_stmt><decl><type><name>MacroDirective</name> <modifier>*</modifier></type><name>getLocalMacroDirectiveHistory</name><argument_list>(<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>II</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>appendMacroDirective</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>MacroDirective</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>DefMacroDirective</name> <modifier>*</modifier></type><name>appendDefMacroDirective</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>MacroInfo</name> <modifier>*</modifier></type><name>MI</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DefMacroDirective</name> <modifier>*</modifier></type><name>MD</name> <init>= <expr><call><name>AllocateDefMacroDirective</name><argument_list>(<argument><expr><name>MI</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>appendMacroDirective</name><argument_list>(<argument><expr><name>II</name></expr></argument>, <argument><expr><name>MD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>MD</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>DefMacroDirective</name> <modifier>*</modifier></type><name>appendDefMacroDirective</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>,
<parameter><decl><type><name>MacroInfo</name> <modifier>*</modifier></type><name>MI</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>appendDefMacroDirective</name><argument_list>(<argument><expr><name>II</name></expr></argument>, <argument><expr><name>MI</name></expr></argument>, <argument><expr><call><name><name>MI</name><operator>-&gt;</operator><name>getDefinitionLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>setLoadedMacroDirective</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>MacroDirective</name> <modifier>*</modifier></type><name>ED</name></decl></parameter>,
<parameter><decl><type><name>MacroDirective</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ModuleMacro</name> <modifier>*</modifier></type><name>addModuleMacro</name><parameter_list>(<parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>Mod</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>MacroInfo</name> <modifier>*</modifier></type><name>Macro</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ModuleMacro</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Overrides</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>IsNew</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ModuleMacro</name> <modifier>*</modifier></type><name>getModuleMacro</name><parameter_list>(<parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>Mod</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ModuleMacro</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>getLeafModuleMacros</name><argument_list>(<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>II</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>II</name><operator>-&gt;</operator><name>isOutOfDate</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>updateOutOfDateIdentifier</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>II</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>auto</name></type> <name>I</name> <init>= <expr><call><name><name>LeafModuleMacros</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>II</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>I</name> <operator>!=</operator> <call><name><name>LeafModuleMacros</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>I</name><operator>-&gt;</operator><name>second</name></name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>None</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>BuildingSubmoduleInfo</name></expr></argument>&gt;</argument_list></name> <macro><name>getBuildingSubmodules</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>BuildingSubmoduleStack</name></expr>;</return>
}</block></expr></expr_stmt>





<decl_stmt><decl><type><name>using</name></type> <name>macro_iterator</name> <init>= <expr><name>MacroMap</name><operator>::</operator><name>const_iterator</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>macro_iterator</name></type> <name>macro_begin</name><argument_list>(<argument><expr><name>bool</name> <name>IncludeExternalMacros</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>macro_iterator</name></type> <name>macro_end</name><argument_list>(<argument><expr><name>bool</name> <name>IncludeExternalMacros</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>macro_iterator</name></expr></argument>&gt;</argument_list></name>
<macro><name>macros</name><argument_list>(<argument>bool IncludeExternalMacros = true</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>macro_iterator</name> <name>begin</name> <operator>=</operator> <call><name>macro_begin</name><argument_list>(<argument><expr><name>IncludeExternalMacros</name></expr></argument>)</argument_list></call></expr>;
<expr><name>macro_iterator</name> <name>end</name> <operator>=</operator> <call><name>macro_end</name><argument_list>(<argument><expr><name>IncludeExternalMacros</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>llvm</name><operator>::</operator><call><name>make_range</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>






<decl_stmt><decl><type><name>StringRef</name></type> <name>getLastMacroWithSpelling</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TokenValue</name></expr></argument>&gt;</argument_list></name> <name>Tokens</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><macro><name>getPredefines</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Predefines</name></expr>;</return> }</block></expr></expr_stmt>




<function><type><name>void</name></type> <name>setPredefines</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>P</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Predefines</name> <operator>=</operator> <name>P</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setPredefines</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>P</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Predefines</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>



<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>getIdentifierInfo</name><argument_list>(<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><operator>&amp;</operator><call><name><name>Identifiers</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>Name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<function_decl><type><name>void</name></type> <name>AddPragmaHandler</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Namespace</name></decl></parameter>, <parameter><decl><type><name>PragmaHandler</name> <modifier>*</modifier></type><name>Handler</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>void</name></type> <name>AddPragmaHandler</name><parameter_list>(<parameter><decl><type><name>PragmaHandler</name> <modifier>*</modifier></type><name>Handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>AddPragmaHandler</name><argument_list>(<argument><expr><call><name>StringRef</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function_decl><type><name>void</name></type> <name>RemovePragmaHandler</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Namespace</name></decl></parameter>, <parameter><decl><type><name>PragmaHandler</name> <modifier>*</modifier></type><name>Handler</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>void</name></type> <name>RemovePragmaHandler</name><parameter_list>(<parameter><decl><type><name>PragmaHandler</name> <modifier>*</modifier></type><name>Handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>RemovePragmaHandler</name><argument_list>(<argument><expr><call><name>StringRef</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>IgnorePragmas</name><parameter_list>()</parameter_list>;</function_decl>


<function><type><name>void</name></type> <name>setEmptylineHandler</name><parameter_list>(<parameter><decl><type><name>EmptylineHandler</name> <modifier>*</modifier></type><name>Handler</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Emptyline</name> <operator>=</operator> <name>Handler</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>EmptylineHandler</name> <operator>*</operator><macro><name>getEmptylineHandler</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Emptyline</name></expr>;</return> }</block></expr></expr_stmt>


<function_decl><type><name>void</name></type> <name>addCommentHandler</name><parameter_list>(<parameter><decl><type><name>CommentHandler</name> <modifier>*</modifier></type><name>Handler</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>removeCommentHandler</name><parameter_list>(<parameter><decl><type><name>CommentHandler</name> <modifier>*</modifier></type><name>Handler</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>void</name></type> <name>setCodeCompletionHandler</name><parameter_list>(<parameter><decl><type><name>CodeCompletionHandler</name> <modifier>&amp;</modifier></type><name>Handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>CodeComplete</name> <operator>=</operator> <operator>&amp;</operator><name>Handler</name></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>CodeCompletionHandler</name> <operator>*</operator><macro><name>getCodeCompletionHandler</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>CodeComplete</name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>clearCodeCompletionHandler</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>CodeComplete</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
</block_content>}</block></function>



<decl_stmt><decl><type><name>void</name></type> <name>CodeCompleteIncludedFile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>Dir</name></expr></argument>, <argument><expr><name>bool</name> <name>IsAngled</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>CodeCompleteNaturalLanguage</name><parameter_list>()</parameter_list>;</function_decl>


<function><type><name>void</name></type> <name>setCodeCompletionIdentifierInfo</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Filter</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>CodeCompletionII</name> <operator>=</operator> <name>Filter</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>setCodeCompletionTokenRange</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SourceLocation</name></type> <name>Start</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>SourceLocation</name></type> <name>End</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>CodeCompletionTokenRange</name> <operator>=</operator> <block>{<expr><name>Start</name></expr>, <expr><name>End</name></expr>}</block></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><name>SourceRange</name> <macro><name>getCodeCompletionTokenRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>CodeCompletionTokenRange</name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>StringRef</name></type> <name>getCodeCompletionFilter</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>CodeCompletionII</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>CodeCompletionII</name><operator>-&gt;</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><block>{}</block></expr>;</return>
</block_content>}</block></function>



<expr_stmt><expr><name>PreprocessingRecord</name> <operator>*</operator><macro><name>getPreprocessingRecord</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Record</name></expr>;</return> }</block></expr></expr_stmt>



<function_decl><type><name>void</name></type> <name>createPreprocessingRecord</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>isPCHThroughHeader</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>FE</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>creatingPCHWithThroughHeader</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>usingPCHWithThroughHeader</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>creatingPCHWithPragmaHdrStop</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>usingPCHWithPragmaHdrStop</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>SkipTokensWhileUsingPCH</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>HandleSkippedDirectiveWhileUsingPCH</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>HashLoc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>EnterMainSourceFile</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EndSourceFile</name><parameter_list>()</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>EnterSourceFile</name><parameter_list>(<parameter><decl><type><name>FileID</name></type> <name>FID</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DirectoryLookup</name> <modifier>*</modifier></type><name>Dir</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>void</name></type> <name>EnterMacro</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ILEnd</name></decl></parameter>, <parameter><decl><type><name>MacroInfo</name> <modifier>*</modifier></type><name>Macro</name></decl></parameter>,
<parameter><decl><type><name>MacroArgs</name> <modifier>*</modifier></type><name>Args</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>














<function_decl><type><name>void</name></type> <name>EnterTokenStream</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>*</modifier></type><name>Toks</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumToks</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DisableMacroExpansion</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>OwnsTokens</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsReinject</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>void</name></type> <name>EnterTokenStream</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name><name>Token</name><index>[]</index></name></expr></argument>&gt;</argument_list></name> <name>Toks</name></expr></argument>, <argument><expr><name>unsigned</name> <name>NumToks</name></expr></argument>,
<argument><expr><name>bool</name> <name>DisableMacroExpansion</name></expr></argument>, <argument><expr><name>bool</name> <name>IsReinject</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>EnterTokenStream</name><argument_list>(<argument><expr><call><name><name>Toks</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NumToks</name></expr></argument>, <argument><expr><name>DisableMacroExpansion</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><name>IsReinject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type> <name>EnterTokenStream</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Token</name></expr></argument>&gt;</argument_list></name></type> <name>Toks</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>DisableMacroExpansion</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsReinject</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>EnterTokenStream</name><argument_list>(<argument><expr><call><name><name>Toks</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Toks</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DisableMacroExpansion</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
<argument><expr><name>IsReinject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function_decl><type><name>void</name></type> <name>RemoveTopOfLexerStack</name><parameter_list>()</parameter_list>;</function_decl>














<function_decl><type><name>void</name></type> <name>EnableBacktrackAtThisPos</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>CommitBacktrackedTokens</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>Backtrack</name><parameter_list>()</parameter_list>;</function_decl>



<expr_stmt><expr><name>bool</name> <macro><name>isBacktrackEnabled</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name><name>BacktrackPositions</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<function_decl><type><name>void</name></type> <name>Lex</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>LexHeaderName</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>AllowMacroExpansion</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>LexAfterModuleImport</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CollectPpImportSuffix</name><parameter_list>(<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Token</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Toks</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>makeModuleVisible</name><parameter_list>(<parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>M</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>getModuleImportLoc</name><argument_list>(<argument><expr><name>Module</name> <operator>*</operator><name>M</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>CurSubmoduleState</name><operator>-&gt;</operator><name>VisibleModules</name><operator>.</operator><name>getImportLoc</name></name><argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>LexStringLiteral</name><argument_list>(<argument><expr><name>Token</name> <operator>&amp;</operator><name>Result</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>String</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>DiagnosticTag</name></expr></argument>, <argument><expr><name>bool</name> <name>AllowMacroExpansion</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>AllowMacroExpansion</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Lex</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LexUnexpandedToken</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><call><name>FinishLexStringLiteral</name><argument_list>(<argument><expr><name>Result</name></expr></argument>, <argument><expr><name>String</name></expr></argument>, <argument><expr><name>DiagnosticTag</name></expr></argument>,
<argument><expr><name>AllowMacroExpansion</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>FinishLexStringLiteral</name><argument_list>(<argument><expr><name>Token</name> <operator>&amp;</operator><name>Result</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>String</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>DiagnosticTag</name></expr></argument>,
<argument><expr><name>bool</name> <name>AllowMacroExpansion</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<function><type><name>void</name></type> <name>LexNonComment</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>)</parameter_list> <block>{<block_content>
<do>do<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Lex</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block>
while <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>tok</name><operator>::</operator><name>comment</name></expr>)</condition>;</do>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>LexUnexpandedToken</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>OldVal</name> <init>= <expr><name>DisableMacroExpansion</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>DisableMacroExpansion</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Lex</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>DisableMacroExpansion</name> <operator>=</operator> <name>OldVal</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>LexUnexpandedNonComment</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>)</parameter_list> <block>{<block_content>
<do>do<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LexUnexpandedToken</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block>
while <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>tok</name><operator>::</operator><name>comment</name></expr>)</condition>;</do>
</block_content>}</block></function>




<function_decl><type><name>bool</name></type> <name>parseSimpleIntegerLiteral</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>&amp;</modifier></type><name>Value</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>void</name></type> <name>SetMacroExpansionOnlyInDirectives</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>DisableMacroExpansion</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>MacroExpansionInDirectivesOverride</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>LookAhead</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>N</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>LexLevel</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="string">"cannot use lookahead while lexing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>CachedLexPos</name> <operator>+</operator> <name>N</name> <operator>&lt;</operator> <call><name><name>CachedTokens</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>CachedTokens</name><index>[<expr><name>CachedLexPos</name><operator>+</operator><name>N</name></expr>]</index></name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>PeekAhead</name><argument_list>(<argument><expr><name>N</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>RevertCachedTokens</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>N</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isBacktrackEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Should only be called when tokens are cached for backtracking"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>signed</name><argument_list>(<argument><expr><name>CachedLexPos</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>signed</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>signed</name><argument_list>(<argument><expr><call><name><name>BacktrackPositions</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <literal type="string">"Should revert tokens up to the last backtrack position, not more"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>signed</name><argument_list>(<argument><expr><name>CachedLexPos</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>signed</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<literal type="string">"Corrupted backtrack positions ?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>CachedLexPos</name> <operator>-=</operator> <name>N</name></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type> <name>EnterToken</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsReinject</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>LexLevel</name></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>auto</name></type> <name>TokCopy</name> <init>= <expr><name>std</name><operator>::</operator><call><name><name>make_unique</name><argument_list type="generic">&lt;<argument><expr><name><name>Token</name><index>[]</index></name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>TokCopy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>Tok</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EnterTokenStream</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>TokCopy</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>IsReinject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>EnterCachingLexMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>IsReinject</name> <operator>&amp;&amp;</operator> <literal type="string">"new tokens in the middle of cached stream"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>CachedTokens</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>CachedTokens</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call><operator>+</operator><name>CachedLexPos</name></expr></argument>, <argument><expr><name>Tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>









<function><type><name>void</name></type> <name>AnnotateCachedTokens</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Tok</name><operator>.</operator><name>isAnnotation</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Expected annotation token"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>CachedLexPos</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isBacktrackEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>AnnotatePreviousCachedTokens</name><argument_list>(<argument><expr><name>Tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>SourceLocation</name> <macro><name>getLastCachedTokenLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>CachedLexPos</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>CachedTokens</name><index>[<expr><name>CachedLexPos</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>getLastLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>IsPreviousCachedToken</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Token</name> <operator>&amp;</operator><name>Tok</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<function_decl><type><name>void</name></type> <name>ReplacePreviousCachedToken</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Token</name></expr></argument>&gt;</argument_list></name></type> <name>NewToks</name></decl></parameter>)</parameter_list>;</function_decl>









<function><type><name>void</name></type> <name>ReplaceLastTokenWithAnnotation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Tok</name><operator>.</operator><name>isAnnotation</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Expected annotation token"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>CachedLexPos</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isBacktrackEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>CachedTokens</name><index>[<expr><name>CachedLexPos</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>Tok</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<decl_stmt><decl><type><name>void</name></type> <name>EnterAnnotationToken</name><argument_list>(<argument><expr><name>SourceRange</name> <name>Range</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Kind</name></expr></argument>,
<argument><expr><name>void</name> <operator>*</operator><name>AnnotationVal</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function><type><name>bool</name></type> <name>mightHavePendingAnnotationTokens</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><name>CurLexerKind</name> <operator>!=</operator> <name>CLK_Lexer</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>TypoCorrectToken</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Tok</name><operator>.</operator><name>getIdentifierInfo</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Expected identifier token"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>CachedLexPos</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isBacktrackEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>CachedTokens</name><index>[<expr><name>CachedLexPos</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>Tok</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>



<function_decl><type><name>void</name></type> <name>recomputeCurLexerKind</name><parameter_list>()</parameter_list>;</function_decl>


<expr_stmt><expr><name>bool</name> <macro><name>isIncrementalProcessingEnabled</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IncrementalProcessing</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>enableIncrementalProcessing</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>value</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>IncrementalProcessing</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></function>















<function_decl><type><name>bool</name></type> <name>SetCodeCompletionPoint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>File</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Line</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Column</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>bool</name> <macro><name>isCodeCompletionEnabled</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CodeCompletionFile</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block></expr></expr_stmt>





<expr_stmt><expr><name>SourceLocation</name> <macro><name>getCodeCompletionLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CodeCompletionLoc</name></expr>;</return> }</block></expr></expr_stmt>





<expr_stmt><expr><name>SourceLocation</name> <macro><name>getCodeCompletionFileLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>CodeCompletionFileLoc</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isCodeCompletionReached</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CodeCompletionReached</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setCodeCompletionReached</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isCodeCompletionEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Code-completion not enabled!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>CodeCompletionReached</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>getDiagnostics</name><argument_list>()</argument_list></call><operator>.</operator><call><name>setSuppressAllDiagnostics</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name>
<macro><name>getPragmaARCCFCodeAuditedInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PragmaARCCFCodeAuditedInfo</name></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>void</name></type> <name>setPragmaARCCFCodeAuditedInfo</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>PragmaARCCFCodeAuditedInfo</name> <operator>=</operator> <block>{<expr><name>Ident</name></expr>, <expr><name>Loc</name></expr>}</block></expr>;</expr_stmt>
</block_content>}</block></function>





<expr_stmt><expr><name>SourceLocation</name> <macro><name>getPragmaAssumeNonNullLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>PragmaAssumeNonNullLoc</name></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name>void</name></type> <name>setPragmaAssumeNonNullLoc</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>PragmaAssumeNonNullLoc</name> <operator>=</operator> <name>Loc</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>setMainFileDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DirectoryEntry</name> <modifier>*</modifier></type><name>Dir</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>MainFileDir</name> <operator>=</operator> <name>Dir</name></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type> <name>setSkipMainFilePreamble</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Bytes</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>StartOfLine</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>SkipMainFilePreamble</name><operator>.</operator><name>first</name></name> <operator>=</operator> <name>Bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>SkipMainFilePreamble</name><operator>.</operator><name>second</name></name> <operator>=</operator> <name>StartOfLine</name></expr>;</expr_stmt>
</block_content>}</block></function>




<decl_stmt><decl><type><name>DiagnosticBuilder</name></type> <name>Diag</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>unsigned</name> <name>DiagID</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>Diags</name><operator>-&gt;</operator><name>Report</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>DiagID</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>DiagnosticBuilder</name></type> <name>Diag</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Token</name> <operator>&amp;</operator><name>Tok</name></expr></argument>, <argument><expr><name>unsigned</name> <name>DiagID</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>Diags</name><operator>-&gt;</operator><name>Report</name></name><argument_list>(<argument><expr><call><name><name>Tok</name><operator>.</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DiagID</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>








<decl_stmt><decl><type><name>StringRef</name></type> <name>getSpelling</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>loc</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>buffer</name></expr></argument>,
<argument><expr><name>bool</name> <operator>*</operator><name>invalid</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>Lexer</name><operator>::</operator><call><name>getSpelling</name><argument_list>(<argument><expr><name>loc</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>SourceMgr</name></expr></argument>, <argument><expr><name>LangOpts</name></expr></argument>, <argument><expr><name>invalid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>









<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getSpelling</name><argument_list>(<argument>const Token &amp;Tok</argument>, <argument>bool *Invalid = nullptr</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Lexer</name><operator>::</operator><call><name>getSpelling</name><argument_list>(<argument><expr><name>Tok</name></expr></argument>, <argument><expr><name>SourceMgr</name></expr></argument>, <argument><expr><name>LangOpts</name></expr></argument>, <argument><expr><name>Invalid</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>













<decl_stmt><decl><type><name>unsigned</name></type> <name>getSpelling</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Token</name> <operator>&amp;</operator><name>Tok</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>&amp;</operator><name>Buffer</name></expr></argument>,
<argument><expr><name>bool</name> <operator>*</operator><name>Invalid</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>Lexer</name><operator>::</operator><call><name>getSpelling</name><argument_list>(<argument><expr><name>Tok</name></expr></argument>, <argument><expr><name>Buffer</name></expr></argument>, <argument><expr><name>SourceMgr</name></expr></argument>, <argument><expr><name>LangOpts</name></expr></argument>, <argument><expr><name>Invalid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<decl_stmt><decl><type><name>StringRef</name></type> <name>getSpelling</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Token</name> <operator>&amp;</operator><name>Tok</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Buffer</name></expr></argument>,
<argument><expr><name>bool</name> <operator>*</operator><name>Invalid</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<function><type><name>bool</name></type> <name>getRawToken</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IgnoreWhiteSpace</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>Lexer</name><operator>::</operator><call><name>getRawToken</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>, <argument><expr><name>SourceMgr</name></expr></argument>, <argument><expr><name>LangOpts</name></expr></argument>, <argument><expr><name>IgnoreWhiteSpace</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<decl_stmt><decl><type><name>char</name></type>
<name>getSpellingOfSingleCharacterNumericConstant</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Token</name> <operator>&amp;</operator><name>Tok</name></expr></argument>,
<argument><expr><name>bool</name> <operator>*</operator><name>Invalid</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>numeric_constant</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Tok</name><operator>.</operator><name>getLength</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <literal type="string">"Called on unsupported token"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>Tok</name><operator>.</operator><name>needsCleaning</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Token can't need cleaning with length 1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>D</name> <init>= <expr><call><name><name>Tok</name><operator>.</operator><name>getLiteralData</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>*</operator><name>D</name></expr>;</return></block_content></block></if></if_stmt>



<return>return <expr><operator>*</operator><call><name><name>SourceMgr</name><operator>.</operator><name>getCharacterData</name></name><argument_list>(<argument><expr><call><name><name>Tok</name><operator>.</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Invalid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>









<function><type><name>StringRef</name></type> <name>getImmediateMacroName</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>Lexer</name><operator>::</operator><call><name>getImmediateMacroName</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>SourceMgr</name></expr></argument>, <argument><expr><call><name>getLangOpts</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function_decl><type><name>void</name></type> <name>CreateString</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Str</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ExpansionLocStart</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ExpansionLocEnd</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>SourceLocation</name></type> <name>SplitToken</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>TokLoc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Length</name></decl></parameter>)</parameter_list>;</function_decl>
















<function><type><name>SourceLocation</name></type> <name>getLocForEndOfToken</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>Lexer</name><operator>::</operator><call><name>getLocForEndOfToken</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Offset</name></expr></argument>, <argument><expr><name>SourceMgr</name></expr></argument>, <argument><expr><name>LangOpts</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<decl_stmt><decl><type><name>bool</name></type> <name>isAtStartOfMacroExpansion</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>loc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <operator>*</operator><name>MacroBegin</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>Lexer</name><operator>::</operator><call><name>isAtStartOfMacroExpansion</name><argument_list>(<argument><expr><name>loc</name></expr></argument>, <argument><expr><name>SourceMgr</name></expr></argument>, <argument><expr><name>LangOpts</name></expr></argument>,
<argument><expr><name>MacroBegin</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>






<decl_stmt><decl><type><name>bool</name></type> <name>isAtEndOfMacroExpansion</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>loc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <operator>*</operator><name>MacroEnd</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>Lexer</name><operator>::</operator><call><name>isAtEndOfMacroExpansion</name><argument_list>(<argument><expr><name>loc</name></expr></argument>, <argument><expr><name>SourceMgr</name></expr></argument>, <argument><expr><name>LangOpts</name></expr></argument>, <argument><expr><name>MacroEnd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>DumpToken</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Token</name> <operator>&amp;</operator><name>Tok</name></expr></argument>, <argument><expr><name>bool</name> <name>DumpFlags</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>DumpLocation</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>DumpMacro</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MacroInfo</name> <operator>&amp;</operator><name>MI</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>dumpMacroInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>SourceLocation</name></type> <name>AdvanceToTokenCharacter</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>TokStart</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>Char</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>Lexer</name><operator>::</operator><call><name>AdvanceToTokenCharacter</name><argument_list>(<argument><expr><name>TokStart</name></expr></argument>, <argument><expr><name>Char</name></expr></argument>, <argument><expr><name>SourceMgr</name></expr></argument>, <argument><expr><name>LangOpts</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<function><type><name>void</name></type> <name>IncrementPasteCounter</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isFast</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>isFast</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>NumFastTokenPaste</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>NumTokenPaste</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>PrintStats</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>size_t</name> <macro><name>getTotalMemory</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<function_decl><type><name>void</name></type> <name>HandleMicrosoftCommentPaste</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>








<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>LookUpIdentifierInfo</name><argument_list>(<argument><expr><name>Token</name> <operator>&amp;</operator><name>Identifier</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name><operator>*</operator></expr></argument>,<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>PoisonReasons</name></expr>;</expr_stmt>

<label><name>public</name>:</label>




<function_decl><type><name>void</name></type> <name>SetPoisonReason</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>HandlePoisonedIdentifier</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type> <name>Identifier</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type> <name>MaybeHandlePoisonedIdentifier</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type> <name>Identifier</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if<condition>(<decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type> <name>II</name> <init>= <expr><call><name><name>Identifier</name><operator>.</operator><name>getIdentifierInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name><name>II</name><operator>-&gt;</operator><name>isPoisoned</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>HandlePoisonedIdentifier</name><argument_list>(<argument><expr><name>Identifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<label><name>private</name>:</label>



<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__exception_code</name></decl>,
<decl><type ref="prev"><modifier>*</modifier></type><name>Ident___exception_code</name></decl>,
<decl><type ref="prev"><modifier>*</modifier></type><name>Ident_GetExceptionCode</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__exception_info</name></decl>,
<decl><type ref="prev"><modifier>*</modifier></type><name>Ident___exception_info</name></decl>,
<decl><type ref="prev"><modifier>*</modifier></type><name>Ident_GetExceptionInfo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__abnormal_termination</name></decl>,
<decl><type ref="prev"><modifier>*</modifier></type><name>Ident___abnormal_termination</name></decl>,
<decl><type ref="prev"><modifier>*</modifier></type><name>Ident_AbnormalTermination</name></decl>;</decl_stmt>

<function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getCurLexerEndPos</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>diagnoseMissingHeaderInUmbrellaDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Module</name> <modifier>&amp;</modifier></type><name>Mod</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>
<function_decl><type><name>void</name></type> <name>PoisonSEHIdentifiers</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Poison</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>bool</name></type> <name>HandleIdentifier</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Identifier</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>bool</name></type> <name>HandleEndOfFile</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isEndOfMacro</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>HandleEndOfTokenLexer</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>void</name></type> <name>HandleDirective</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>SourceLocation</name></type> <name>CheckEndOfDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>DirType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>EnableMacros</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>SourceRange</name></type> <name>DiscardUntilEndOfDirective</name><parameter_list>()</parameter_list>;</function_decl>



<expr_stmt><expr><name>bool</name> <macro><name>SawDateOrTime</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>DATELoc</name> <operator>!=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call> <operator>||</operator> <name>TIMELoc</name> <operator>!=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getCounterValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CounterValue</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setCounterValue</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>V</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>CounterValue</name> <operator>=</operator> <name>V</name></expr>;</expr_stmt> </block_content>}</block></function>


<function_decl><type><name>Module</name> <modifier>*</modifier></type><name>getCurrentModule</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>MacroInfo</name> <modifier>*</modifier></type><name>AllocateMacroInfo</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>L</name></decl></parameter>)</parameter_list>;</function_decl>










<function_decl><type><name>bool</name></type> <name>GetIncludeFilenameSpelling</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,<parameter><decl><type><name>StringRef</name> <modifier>&amp;</modifier></type><name>Buffer</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>FileEntryRef</name></expr></argument>&gt;</argument_list></name></type>
<name>LookupFile</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>FilenameLoc</name></expr></argument>, <argument><expr><name>StringRef</name> <name>Filename</name></expr></argument>, <argument><expr><name>bool</name> <name>isAngled</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>DirectoryLookup</name> <operator>*</operator><name>FromDir</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator><name>FromFile</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>DirectoryLookup</name> <operator>*</operator><operator>&amp;</operator><name>CurDir</name></expr></argument>, <argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>SearchPath</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>RelativePath</name></expr></argument>,
<argument><expr><name>ModuleMap</name><operator>::</operator><name>KnownHeader</name> <operator>*</operator><name>SuggestedModule</name></expr></argument>, <argument><expr><name>bool</name> <operator>*</operator><name>IsMapped</name></expr></argument>,
<argument><expr><name>bool</name> <operator>*</operator><name>IsFrameworkFound</name></expr></argument>, <argument><expr><name>bool</name> <name>SkipCache</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<function><type><specifier>const</specifier> <name>DirectoryLookup</name> <modifier>*</modifier></type><name>GetCurDirLookup</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>CurDirLookup</name></expr>;</return> </block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>isInPrimaryFile</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>LexOnOffSwitch</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>OnOffSwitch</name> <operator>&amp;</operator><name>Result</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>bool</name></type> <name>CheckMacroName</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>MacroNameTok</name></decl></parameter>, <parameter><decl><type><name>MacroUse</name></type> <name>isDefineUndef</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>ShadowFlag</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EnterSubmodule</name><parameter_list>(<parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>M</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ImportLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ForPragma</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Module</name> <modifier>*</modifier></type><name>LeaveSubmodule</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>ForPragma</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
<expr_stmt><expr><name>friend</name> <name>void</name> <name>TokenLexer</name><operator>::</operator><call><name>ExpandFunctionArguments</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<function><type><name>void</name></type> <name>PushIncludeMacroStack</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>CurLexerKind</name> <operator>!=</operator> <name>CLK_CachingLexer</name> <operator>&amp;&amp;</operator> <literal type="string">"cannot push a caching lexer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>IncludeMacroStack</name><operator>.</operator><name>emplace_back</name></name><argument_list>(<argument><expr><name>CurLexerKind</name></expr></argument>, <argument><expr><name>CurLexerSubmodule</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>CurLexer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CurPPLexer</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>CurTokenLexer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CurDirLookup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>CurPPLexer</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>PopIncludeMacroStack</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>CurLexer</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><call><name><name>IncludeMacroStack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>TheLexer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>CurPPLexer</name> <operator>=</operator> <call><name><name>IncludeMacroStack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>ThePPLexer</name></expr>;</expr_stmt>
<expr_stmt><expr><name>CurTokenLexer</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><call><name><name>IncludeMacroStack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>TheTokenLexer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>CurDirLookup</name> <operator>=</operator> <call><name><name>IncludeMacroStack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>TheDirLookup</name></expr>;</expr_stmt>
<expr_stmt><expr><name>CurLexerSubmodule</name> <operator>=</operator> <call><name><name>IncludeMacroStack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>TheSubmodule</name></expr>;</expr_stmt>
<expr_stmt><expr><name>CurLexerKind</name> <operator>=</operator> <call><name><name>IncludeMacroStack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>CurLexerKind</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>IncludeMacroStack</name><operator>.</operator><name>pop_back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>PropagateLineStartLeadingSpaceInfo</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>)</parameter_list>;</function_decl>



<macro><name>bool</name></macro> <macro><name>needModuleMacros</name><argument_list>()</argument_list></macro> <decl_stmt><decl><type><specifier>const</specifier></type></decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>updateModuleMacroInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>ModuleMacroInfo</name> <modifier>&amp;</modifier></type><name>Info</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DefMacroDirective</name> <modifier>*</modifier></type><name>AllocateDefMacroDirective</name><parameter_list>(<parameter><decl><type><name>MacroInfo</name> <modifier>*</modifier></type><name>MI</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>UndefMacroDirective</name> <modifier>*</modifier></type><name>AllocateUndefMacroDirective</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>UndefLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>VisibilityMacroDirective</name> <modifier>*</modifier></type><name>AllocateVisibilityMacroDirective</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isPublic</name></decl></parameter>)</parameter_list>;</function_decl>











<function_decl><type><name>void</name></type> <name>ReadMacroName</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>MacroNameTok</name></decl></parameter>, <parameter><decl><type><name>MacroUse</name></type> <name>IsDefineUndef</name> <init>= <expr><name>MU_Other</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>ShadowFlag</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>










<function_decl><type><name>MacroInfo</name> <modifier>*</modifier></type><name>ReadOptionalMacroParameterListAndBody</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>MacroNameTok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ImmediatelyAfterHeaderGuard</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>ReadMacroParameterList</name><parameter_list>(<parameter><decl><type><name>MacroInfo</name> <modifier>*</modifier></type><name>MI</name></decl></parameter>, <parameter><decl><type><name>Token</name><modifier>&amp;</modifier></type> <name>LastTok</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>void</name></type> <name>SkipExcludedConditionalBlock</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>HashTokenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IfTokenLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>FoundNonSkipPortion</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>FoundElse</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ElseLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<struct>struct <name>DirectiveEvalResult</name> <block>{

<decl_stmt><decl><type><name>bool</name></type> <name>Conditional</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>IncludedUndefinedIds</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceRange</name></type> <name>ExprRange</name></decl>;</decl_stmt>
}</block>;</struct>





<function_decl><type><name>DirectiveEvalResult</name></type> <name>EvaluateDirectiveExpression</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>IfNDefMacro</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>RegisterBuiltinPragmas</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>RegisterBuiltinMacros</name><parameter_list>()</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>HandleMacroExpandedIdentifier</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Identifier</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MacroDefinition</name> <modifier>&amp;</modifier></type><name>MD</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>Token</name> <modifier>*</modifier></type><name>cacheMacroExpandedTokens</name><parameter_list>(<parameter><decl><type><name>TokenLexer</name> <modifier>*</modifier></type><name>tokLexer</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Token</name></expr></argument>&gt;</argument_list></name></type> <name>tokens</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>removeCachedMacroExpandedTokensOfLastLexer</name><parameter_list>()</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>isNextPPTokenLParen</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>MacroArgs</name> <modifier>*</modifier></type><name>ReadMacroCallArgumentList</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>MacroName</name></decl></parameter>, <parameter><decl><type><name>MacroInfo</name> <modifier>*</modifier></type><name>MI</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>MacroEnd</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ExpandBuiltinMacro</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>Handle_Pragma</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>HandleMicrosoft__pragma</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>EnterSourceFileWithLexer</name><parameter_list>(<parameter><decl><type><name>Lexer</name> <modifier>*</modifier></type><name>TheLexer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DirectoryLookup</name> <modifier>*</modifier></type><name>Dir</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>void</name></type> <name>setPredefinesFileID</name><parameter_list>(<parameter><decl><type><name>FileID</name></type> <name>FID</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>PredefinesFileID</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"PredefinesFileID already set!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>PredefinesFileID</name> <operator>=</operator> <name>FID</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>setPCHThroughHeaderFileID</name><parameter_list>(<parameter><decl><type><name>FileID</name></type> <name>FID</name></decl></parameter>)</parameter_list>;</function_decl>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>IsFileLexer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Lexer</name><modifier>*</modifier></type> <name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PreprocessorLexer</name><modifier>*</modifier></type> <name>P</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><name>L</name></expr> ?</condition><then> <expr><operator>!</operator><call><name><name>L</name><operator>-&gt;</operator><name>isPragmaLexer</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>P</name> <operator>!=</operator> <name>nullptr</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>IsFileLexer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IncludeStackInfo</name><modifier>&amp;</modifier></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>IsFileLexer</name><argument_list>(<argument><expr><call><name><name>I</name><operator>.</operator><name>TheLexer</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>I</name><operator>.</operator><name>ThePPLexer</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>IsFileLexer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>IsFileLexer</name><argument_list>(<argument><expr><call><name><name>CurLexer</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>CurPPLexer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<function_decl><type><name>void</name></type> <name>CachingLex</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>bool</name> <macro><name>InCachingLexMode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{


<return>return <expr><operator>!</operator><name>CurPPLexer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>CurTokenLexer</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>IncludeMacroStack</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function_decl><type><name>void</name></type> <name>EnterCachingLexMode</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EnterCachingLexModeUnchecked</name><parameter_list>()</parameter_list>;</function_decl>

<function><type><name>void</name></type> <name>ExitCachingLexMode</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>InCachingLexMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>RemoveTopOfLexerStack</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>PeekAhead</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>N</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>AnnotatePreviousCachedTokens</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type> <name>HandleLineDirective</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandleDigitDirective</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandleUserDiagnosticDirective</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isWarning</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandleIdentSCCSDirective</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandleMacroPublicDirective</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandleMacroPrivateDirective</name><parameter_list>()</parameter_list>;</function_decl>



<struct>struct <name>ImportAction</name> <block>{
<enum>enum <name>ActionKind</name> <block>{
<decl><name>None</name></decl>,
<decl><name>ModuleBegin</name></decl>,
<decl><name>ModuleImport</name></decl>,
<decl><name>SkippedModuleImport</name></decl>,
<decl><name>Failure</name></decl>,
}</block> <decl><name>Kind</name></decl>;</enum>
<decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>ModuleForHeader</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<macro><name>ImportAction</name><argument_list>(<argument>ActionKind AK</argument>, <argument>Module *Mod = nullptr</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Kind</name><argument_list>(<argument><expr><name>AK</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>ModuleForHeader</name><argument_list>(<argument>Mod</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>AK</name> <operator>==</operator> <name>None</name> <operator>||</operator> <name>Mod</name> <operator>||</operator> <name>AK</name> <operator>==</operator> <name>Failure</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"no module for module action"</literal></expr></argument>)</argument_list></call></expr>;
}</block></expr></expr_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>FileEntryRef</name></expr></argument>&gt;</argument_list></name></type> <name>LookupHeaderIncludeOrImport</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>DirectoryLookup</name> <operator>*</operator><operator>&amp;</operator><name>CurDir</name></expr></argument>, <argument><expr><name>StringRef</name> <operator>&amp;</operator><name>Filename</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>FilenameLoc</name></expr></argument>, <argument><expr><name>CharSourceRange</name> <name>FilenameRange</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Token</name> <operator>&amp;</operator><name>FilenameTok</name></expr></argument>, <argument><expr><name>bool</name> <operator>&amp;</operator><name>IsFrameworkFound</name></expr></argument>, <argument><expr><name>bool</name> <name>IsImportDecl</name></expr></argument>,
<argument><expr><name>bool</name> <operator>&amp;</operator><name>IsMapped</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>DirectoryLookup</name> <operator>*</operator><name>LookupFrom</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator><name>LookupFromFile</name></expr></argument>, <argument><expr><name>StringRef</name> <operator>&amp;</operator><name>LookupFilename</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>RelativePath</name></expr></argument>, <argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>SearchPath</name></expr></argument>,
<argument><expr><name>ModuleMap</name><operator>::</operator><name>KnownHeader</name> <operator>&amp;</operator><name>SuggestedModule</name></expr></argument>, <argument><expr><name>bool</name> <name>isAngled</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>HandleIncludeDirective</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>HashLoc</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DirectoryLookup</name> <modifier>*</modifier></type><name>LookupFrom</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>LookupFromFile</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ImportAction</name></type>
<name>HandleHeaderIncludeOrImport</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>HashLoc</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>IncludeTok</name></decl></parameter>,
<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>FilenameTok</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DirectoryLookup</name> <modifier>*</modifier></type><name>LookupFrom</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>LookupFromFile</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandleIncludeNextDirective</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>HashLoc</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandleIncludeMacrosDirective</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>HashLoc</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandleImportDirective</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>HashLoc</name></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandleMicrosoftImportDirective</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>



<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>checkModuleIsAvailable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LangOptions</name> <modifier>&amp;</modifier></type><name>LangOpts</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>&amp;</modifier></type><name>TargetInfo</name></decl></parameter>,
<parameter><decl><type><name>DiagnosticsEngine</name> <modifier>&amp;</modifier></type><name>Diags</name></decl></parameter>, <parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>M</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>Module</name> <modifier>*</modifier></type><name>getModuleForLocation</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>















<function_decl><type><specifier>const</specifier> <name>FileEntry</name> <modifier>*</modifier></type><name>getHeaderToIncludeForDiagnostics</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>IncLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>MLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>bool</name> <macro><name>isRecordingPreamble</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>PreambleConditionalStack</name><operator>.</operator><name>isRecording</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasRecordedPreamble</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>PreambleConditionalStack</name><operator>.</operator><name>hasRecordedPreamble</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>PPConditionalInfo</name></expr></argument>&gt;</argument_list></name> <macro><name>getPreambleConditionalStack</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>PreambleConditionalStack</name><operator>.</operator><name>getStack</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setRecordedPreambleConditionalStack</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>PPConditionalInfo</name></expr></argument>&gt;</argument_list></name></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>PreambleConditionalStack</name><operator>.</operator><name>setStack</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name>void</name></type> <name>setReplayablePreambleConditionalStack</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>PPConditionalInfo</name></expr></argument>&gt;</argument_list></name> <name>s</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>PreambleSkipInfo</name></expr></argument>&gt;</argument_list></name> <name>SkipInfo</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>PreambleConditionalStack</name><operator>.</operator><name>startReplaying</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>PreambleConditionalStack</name><operator>.</operator><name>setStack</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>PreambleConditionalStack</name><operator>.</operator><name>SkipInfo</name></name> <operator>=</operator> <name>SkipInfo</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>PreambleSkipInfo</name></expr></argument>&gt;</argument_list></name> <macro><name>getPreambleSkipInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>PreambleConditionalStack</name><operator>.</operator><name>SkipInfo</name></name></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>


<function_decl><type><name>void</name></type> <name>replayPreambleConditionalStack</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>HandleDefineDirective</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ImmediatelyAfterHeaderGuard</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandleUndefDirective</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>HandleIfdefDirective</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>HashToken</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isIfndef</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ReadAnyTokensBeforeDirective</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandleIfDirective</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>IfToken</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>HashToken</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ReadAnyTokensBeforeDirective</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandleEndifDirective</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>EndifToken</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandleElseDirective</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>HashToken</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>HandleElifFamilyDirective</name><argument_list>(<argument><expr><name>Token</name> <operator>&amp;</operator><name>ElifToken</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Token</name> <operator>&amp;</operator><name>HashToken</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>PPKeywordKind</name> <name>Kind</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>HandlePragmaDirective</name><parameter_list>(<parameter><decl><type><name>PragmaIntroducer</name></type> <name>Introducer</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>ResolvePragmaIncludeInstead</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Location</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<label><name>public</name>:</label>
<function_decl><type><name>void</name></type> <name>HandlePragmaOnce</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>OnceTok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandlePragmaMark</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>MarkTok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandlePragmaPoison</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandlePragmaSystemHeader</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>SysHeaderTok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandlePragmaIncludeInstead</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandlePragmaDependency</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>DependencyTok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandlePragmaPushMacro</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandlePragmaPopMacro</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandlePragmaIncludeAlias</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandlePragmaModuleBuild</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandlePragmaHdrstop</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ParsePragmaPushOrPopMacro</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>HandleComment</name><parameter_list>(<parameter><decl><type><name>Token</name> <modifier>&amp;</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>Comment</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>markMacroAsUsed</name><parameter_list>(<parameter><decl><type><name>MacroInfo</name> <modifier>*</modifier></type><name>MI</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
<function_decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type>
<name>getSkippedRangeForExcludedConditionalBlock</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>HashLoc</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>ExcludedPreprocessorDirectiveSkipMapping</name>
<modifier>*</modifier></type><name>ExcludedConditionalDirectiveSkipMappings</name></decl>;</decl_stmt>
};



<decl_stmt><decl><type><name>class</name></type> <name>CommentHandler</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>CommentHandler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>



<function_decl><type><name>virtual</name> <name>bool</name></type> <name>HandleComment</name><parameter_list>(<parameter><decl><type><name>Preprocessor</name> <modifier>&amp;</modifier></type><name>PP</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>Comment</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>EmptylineHandler</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>EmptylineHandler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>HandleEmptyline</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>PragmaHandlerRegistry</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>Registry</name><argument_list type="generic">&lt;<argument><expr><name>PragmaHandler</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
