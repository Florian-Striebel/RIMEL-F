<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/lib/CodeGen/CodeGenModule.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_LIB_CODEGEN_CODEGENMODULE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_LIB_CODEGEN_CODEGENMODULE_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"CGVTables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"CodeGenTypeCache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"CodeGenTypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"SanitizerMetadata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclOpenMP.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/GlobalDecl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Mangle.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/ABI.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LangOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Module.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/NoSanitizeList.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TargetInfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/XRayLists.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/PreprocessorOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SetVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallPtrSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/IR/Module.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/IR/ValueHandle.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Transforms/Utils/SanitizerStats.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>Module</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Constant</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ConstantInt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Function</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>GlobalValue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DataLayout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LLVMContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>OpenMPIRBuilder</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>IndexedInstrProfReader</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>AtomicType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>IdentifierInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCMethodDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCImplementationDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCCategoryImplDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCProtocolDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCEncodeExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BlockExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CharUnits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Decl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Stmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>InitListExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>StringLiteral</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>NamedDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ValueDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VarDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LangOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CodeGenOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>HeaderSearchOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DiagnosticsEngine</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>AnnotateAttr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXDestructorDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Module</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CoverageSourceInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TargetAttr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>InitSegAttr</name></decl>;</decl_stmt>
<struct_decl>struct <name>ParsedTargetAttr</name>;</struct_decl>

<decl_stmt><decl><type><name>namespace</name></type> <name>CodeGen</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>CallArgList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CodeGenFunction</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CodeGenTBAA</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CGCXXABI</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CGDebugInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CGObjCRuntime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CGOpenCLRuntime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CGOpenMPRuntime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CGCUDARuntime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BlockFieldFlags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionArgList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CoverageMappingModuleGen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TargetCodeGenInfo</name></decl>;</decl_stmt>

<enum>enum <name>ForDefinition_t</name> : <type><name>bool</name></type> <block>{
<decl><name>NotForDefinition</name> <init>= <expr><name>false</name></expr></init></decl>,
<decl><name>ForDefinition</name> <init>= <expr><name>true</name></expr></init></decl>
}</block>;</enum>

<struct>struct <name>OrderGlobalInitsOrStermFinalizers</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>priority</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>lex_order</name></decl>;</decl_stmt>
<macro><name>OrderGlobalInitsOrStermFinalizers</name><argument_list>(<argument>unsigned int p</argument>, <argument>unsigned int l</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>priority</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>lex_order</name><argument_list>(<argument>l</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>OrderGlobalInitsOrStermFinalizers</name> <operator>&amp;</operator><name>RHS</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>priority</name> <operator>==</operator> <name><name>RHS</name><operator>.</operator><name>priority</name></name> <operator>&amp;&amp;</operator> <name>lex_order</name> <operator>==</operator> <name><name>RHS</name><operator>.</operator><name>lex_order</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <name>operator</name><operator>&lt;</operator><operator>(</operator><specifier>const</specifier> <name>OrderGlobalInitsOrStermFinalizers</name> <operator>&amp;</operator><name>RHS</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>std</name><operator>::</operator><call><name>tie</name><argument_list>(<argument><expr><name>priority</name></expr></argument>, <argument><expr><name>lex_order</name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
<name>std</name><operator>::</operator><call><name>tie</name><argument_list>(<argument><expr><name><name>RHS</name><operator>.</operator><name>priority</name></name></expr></argument>, <argument><expr><name><name>RHS</name><operator>.</operator><name>lex_order</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
}</block>;</struct>

<struct>struct <name>ObjCEntrypoints</name> <block>{
<macro><name>ObjCEntrypoints</name><argument_list>()</argument_list></macro> <block>{<block_content> <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>objc_alloc</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>objc_allocWithZone</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>objc_alloc_init</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>objc_autoreleasePoolPop</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>objc_autoreleasePoolPopInvoke</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>objc_autoreleasePoolPush</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>objc_autorelease</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>objc_autoreleaseRuntimeFunction</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>objc_autoreleaseReturnValue</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>objc_copyWeak</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>objc_destroyWeak</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>objc_initWeak</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>objc_loadWeak</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>objc_loadWeakRetained</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>objc_moveWeak</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>objc_retain</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>objc_retainRuntimeFunction</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>objc_retainAutorelease</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>objc_retainAutoreleaseReturnValue</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>objc_retainAutoreleasedReturnValue</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>objc_retainBlock</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>objc_release</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>objc_releaseRuntimeFunction</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>objc_storeStrong</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>objc_storeWeak</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>objc_unsafeClaimAutoreleasedReturnValue</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>InlineAsm</name> <operator>*</operator><name>retainAutoreleasedReturnValueMarker</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>clang_arc_use</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>clang_arc_noop_use</name></expr>;</expr_stmt>
}</block>;</struct>


<decl_stmt><decl><type><name>class</name></type> <name>InstrProfStats</name> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>VisitedInMainFile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>MissingInMainFile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>Visited</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>Missing</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>Mismatched</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>InstrProfStats</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>VisitedInMainFile</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>MissingInMainFile</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Visited</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Missing</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>Mismatched</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro> <expr><block>{}</block>


<name>void</name> <macro><name>addVisited</name><argument_list>(<argument>bool MainFile</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>MainFile</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>VisitedInMainFile</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<operator>++</operator><name>Visited</name></block></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type> <name>addMissing</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>MainFile</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>MainFile</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>MissingInMainFile</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>Missing</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>addMismatched</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>MainFile</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><operator>++</operator><name>Mismatched</name></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>bool</name></type> <name>hasDiagnostics</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>Missing</name> <operator>||</operator> <name>Mismatched</name></expr>;</return> </block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>reportDiagnostics</name><parameter_list>(<parameter><decl><type><name>DiagnosticsEngine</name> <modifier>&amp;</modifier></type><name>Diags</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>MainFile</name></decl></parameter>)</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>BlockByrefHelpers</name> <range>: <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{


<expr><name>public</name><operator>:</operator>
<name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>CopyHelper</name></expr>;
<expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>DisposeHelper</name></expr>;




<expr><name>CharUnits</name> <name>Alignment</name></expr>;

<macro><name>BlockByrefHelpers</name><argument_list>(<argument>CharUnits alignment</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>CopyHelper</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>DisposeHelper</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>, <macro><name>Alignment</name><argument_list>(<argument>alignment</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>BlockByrefHelpers</name><argument_list>(<argument><expr><specifier>const</specifier> <name>BlockByrefHelpers</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;
<expr><name>virtual</name> <operator>~</operator><call><name>BlockByrefHelpers</name><argument_list>()</argument_list></call></expr>;

<expr><name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;id</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name><name>id</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><call><name><name>Alignment</name><operator>.</operator><name>getQuantity</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>profileImpl</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>virtual</name> <name>void</name> <macro><name>profileImpl</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;id</argument>)</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>needsCopy</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<name>virtual</name> <name>void</name> <macro><name>emitCopy</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>Address dest</argument>, <argument>Address src</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>needsDispose</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<name>virtual</name> <name>void</name> <macro><name>emitDispose</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>Address field</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>CodeGenModule</name> <range>: <expr><name>public</name> <name>CodeGenTypeCache</name> <block>{
<expr><call><name>CodeGenModule</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CodeGenModule</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><name>void</name> <name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>CodeGenModule</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr>;

<expr><name>public</name><operator>:</operator>
struct <name>Structor</name> <block>{
<expr><call><name>Structor</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>Priority</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>Initializer</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>, <macro><name>AssociatedData</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{}</block>
<macro><name>Structor</name><argument_list>(<argument>int Priority</argument>, <argument>llvm::Constant *Initializer</argument>,
<argument>llvm::Constant *AssociatedData</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Priority</name><argument_list>(<argument><expr><name>Priority</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Initializer</name><argument_list>(<argument><expr><name>Initializer</name></expr></argument>)</argument_list></call></expr>,
<macro><name>AssociatedData</name><argument_list>(<argument>AssociatedData</argument>)</argument_list></macro> <expr><block>{}</block>
<name>int</name> <name>Priority</name></expr>;
<expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>Initializer</name></expr>;
<expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>AssociatedData</name></expr>;
}</block></expr>;

<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Structor</name></expr></argument>&gt;</argument_list></name> <name>CtorList</name></expr>;</expr_stmt></typedef>

<name>private</name><operator>:</operator>
<name>ASTContext</name> <operator>&amp;</operator><name>Context</name></block></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>LangOptions</name> <modifier>&amp;</modifier></type><name>LangOpts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>HeaderSearchOptions</name> <modifier>&amp;</modifier></type><name>HeaderSearchOpts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PreprocessorOptions</name> <modifier>&amp;</modifier></type><name>PreprocessorOpts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>CodeGenOptions</name> <modifier>&amp;</modifier></type><name>CodeGenOpts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumAutoVarInit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Module</name> <operator>&amp;</operator><name>TheModule</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>DiagnosticsEngine</name> <modifier>&amp;</modifier></type><name>Diags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>&amp;</modifier></type><name>Target</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CGCXXABI</name></expr></argument>&gt;</argument_list></name> <name>ABI</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>LLVMContext</name> <operator>&amp;</operator><name>VMContext</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>ModuleNameHash</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CodeGenTBAA</name></expr></argument>&gt;</argument_list></name> <name>TBAA</name></expr>;</expr_stmt>

<expr_stmt><expr><name>mutable</name> <name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>TargetCodeGenInfo</name></expr></argument>&gt;</argument_list></name> <name>TheTargetCodeGenInfo</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name>CodeGenTypes</name></type> <name>Types</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>CodeGenVTables</name></type> <name>VTables</name></decl>;</decl_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CGObjCRuntime</name></expr></argument>&gt;</argument_list></name> <name>ObjCRuntime</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CGOpenCLRuntime</name></expr></argument>&gt;</argument_list></name> <name>OpenCLRuntime</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CGOpenMPRuntime</name></expr></argument>&gt;</argument_list></name> <name>OpenMPRuntime</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CGCUDARuntime</name></expr></argument>&gt;</argument_list></name> <name>CUDARuntime</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CGDebugInfo</name></expr></argument>&gt;</argument_list></name> <name>DebugInfo</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ObjCEntrypoints</name></expr></argument>&gt;</argument_list></name> <name>ObjCData</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>MDNode</name> <operator>*</operator><name>NoObjCARCExceptionsMetadata</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>IndexedInstrProfReader</name></expr></argument>&gt;</argument_list></name> <name>PGOReader</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>InstrProfStats</name></type> <name>PGOStats</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>SanitizerStatReport</name></expr></argument>&gt;</argument_list></name> <name>SanStats</name></expr>;</expr_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>&gt;</argument_list></name> <name>WeakRefReferences</name></expr>;</expr_stmt>





<expr_stmt><expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>, <argument><expr><name>GlobalDecl</name></expr></argument>&gt;</argument_list></name> <name>DeferredDecls</name></expr>;</expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>GlobalDecl</name></expr></argument>&gt;</argument_list></name> <name>DeferredDeclsToEmit</name></expr>;</expr_stmt>
<function><type><name>void</name></type> <name>addDeferredDeclToEmit</name><parameter_list>(<parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>DeferredDeclsToEmit</name><operator>.</operator><name>emplace_back</name></name><argument_list>(<argument><expr><name>GD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>GlobalDecl</name></expr></argument>&gt;</argument_list></name> <name>Aliases</name></expr>;</expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>GlobalDecl</name></expr></argument>&gt;</argument_list></name> <name>MultiVersionFuncs</name></expr>;</expr_stmt>

<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name><name>TrackingVH</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <name>ReplacementsTy</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>ReplacementsTy</name></type> <name>Replacements</name></decl>;</decl_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name>
<name>GlobalValReplacements</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name><operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>InitializerConstants</name></expr>;</expr_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseSet</name><argument_list type="generic">&lt;<argument><expr><name>GlobalDecl</name></expr></argument>&gt;</argument_list></name> <name>DiagnosedConflictingDefinitions</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>DeferredVTables</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>OpportunisticVTables</name></expr>;</expr_stmt>




<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>WeakTrackingVH</name></expr></argument>&gt;</argument_list></name> <name>LLVMUsed</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>WeakTrackingVH</name></expr></argument>&gt;</argument_list></name> <name>LLVMCompilerUsed</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>CtorList</name></type> <name>GlobalCtors</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>CtorList</name></type> <name>GlobalDtors</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>GlobalDecl</name></expr></argument>, <argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <name>MangledDeclNames</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>GlobalDecl</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name></expr></argument>&gt;</argument_list></name> <name>Manglings</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>GlobalDecl</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name>
<name>CPUSpecificMangledDeclNames</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>GlobalDecl</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name></expr></argument>&gt;</argument_list></name>
<name>CPUSpecificManglings</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Annotations</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>AnnotationStrings</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>AnnotationArgs</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CFConstantStringMap</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ConstantStringMap</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name><operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>StaticLocalDeclMap</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name><operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>StaticLocalDeclGuardMap</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name><operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>MaterializedGlobalTemporaryMap</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>AtomicSetterHelperFnMap</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>AtomicGetterHelperFnMap</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>TypeDescriptorMap</name></expr>;</expr_stmt>



<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>StaticExternCMap</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>StaticExternCMap</name></type> <name>StaticExternCValues</name></decl>;</decl_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CXXThreadLocals</name></expr>;</expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CXXThreadLocalInits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CXXThreadLocalInitVars</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CXXGlobalInits</name></expr>;</expr_stmt>






<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name><operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>DelayedCXXInitPosition</name></expr>;</expr_stmt>

<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>OrderGlobalInitsOrStermFinalizers</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>GlobalInitData</name></expr>;</expr_stmt></typedef>

<struct>struct <name>GlobalInitPriorityCmp</name> <block>{
<expr_stmt><expr><name>bool</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>GlobalInitData</name> <operator>&amp;</operator><name>LHS</name><operator>,</operator>
<specifier>const</specifier> <name>GlobalInitData</name> <operator>&amp;</operator><name>RHS</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name><name>LHS</name><operator>.</operator><name>first</name><operator>.</operator><name>priority</name></name> <operator>&lt;</operator> <name><name>RHS</name><operator>.</operator><name>first</name><operator>.</operator><name>priority</name></name></expr>;</return>
}</block></expr></expr_stmt>
}</block>;</struct>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>GlobalInitData</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>PrioritizedCXXGlobalInits</name></decl>;</decl_stmt>




<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>FunctionType</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>WeakTrackingVH</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>CXXGlobalDtorsOrStermFinalizer_t</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>CXXGlobalDtorsOrStermFinalizer_t</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type>
<name>CXXGlobalDtorsOrStermFinalizers</name></decl>;</decl_stmt>

<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>OrderGlobalInitsOrStermFinalizers</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>StermFinalizerData</name></expr>;</expr_stmt></typedef>

<struct>struct <name>StermFinalizerPriorityCmp</name> <block>{
<expr_stmt><expr><name>bool</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>StermFinalizerData</name> <operator>&amp;</operator><name>LHS</name><operator>,</operator>
<specifier>const</specifier> <name>StermFinalizerData</name> <operator>&amp;</operator><name>RHS</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name><name>LHS</name><operator>.</operator><name>first</name><operator>.</operator><name>priority</name></name> <operator>&lt;</operator> <name><name>RHS</name><operator>.</operator><name>first</name><operator>.</operator><name>priority</name></name></expr>;</return>
}</block></expr></expr_stmt>
}</block>;</struct>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>StermFinalizerData</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>PrioritizedCXXStermFinalizers</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SetVector</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>Module</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ImportedModules</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>Module</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>EmittedModuleInitializers</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>MDNode</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>LinkerOptionsMetadata</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>MDNode</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>ELFDependentLibraries</name></decl>;</decl_stmt>






<expr_stmt><expr><name>llvm</name><operator>::</operator><name>WeakTrackingVH</name> <name>CFConstantStringClassRef</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>ObjCFastEnumerationStateType</name></decl>;</decl_stmt>




<function_decl><type><name>void</name></type> <name>createObjCRuntime</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>createOpenCLRuntime</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>createOpenMPRuntime</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>createCUDARuntime</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>isTriviallyRecursive</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>F</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>shouldEmitFunction</name><parameter_list>(<parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>shouldOpportunisticallyEmitVTables</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CompoundLiteralExpr</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>EmittedCompoundLiterals</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>BlockExpr</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>EmittedGlobalBlocks</name></expr>;</expr_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>NSConcreteGlobalBlock</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>NSConcreteStackBlock</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>BlockObjectAssign</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>BlockObjectDispose</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>BlockDescriptorType</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>GenericBlockLiteralType</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>GlobalUniqueCount</name></decl>;</decl_stmt>
}</block> <decl><name>Block</name></decl>;</struct>

<decl_stmt><decl><type><name>GlobalDecl</name></type> <name>initializedGlobalDecl</name></decl>;</decl_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>LifetimeStartFn</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>LifetimeEndFn</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>SanitizerMetadata</name></expr></argument>&gt;</argument_list></name> <name>SanitizerMD</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>DeferredEmptyCoverageMappingDecls</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CoverageMappingModuleGen</name></expr></argument>&gt;</argument_list></name> <name>CoverageMapping</name></expr>;</expr_stmt>




<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Metadata</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>MetadataTypeMap</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>MetadataTypeMap</name></type> <name>MetadataIdMap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MetadataTypeMap</name></type> <name>VirtualMetadataIdMap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MetadataTypeMap</name></type> <name>GeneralizedMetadataIdMap</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>CodeGenModule</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>HeaderSearchOptions</name> <operator>&amp;</operator><name>headersearchopts</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PreprocessorOptions</name> <operator>&amp;</operator><name>ppopts</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CodeGenOptions</name> <operator>&amp;</operator><name>CodeGenOpts</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Module</name> <operator>&amp;</operator><name>M</name></expr></argument>,
<argument><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diags</name></expr></argument>,
<argument><expr><name>CoverageSourceInfo</name> <operator>*</operator><name>CoverageInfo</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>~</operator><call><name>CodeGenModule</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>clear</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>Release</name><parameter_list>()</parameter_list>;</function_decl>


<expr_stmt><expr><name>bool</name> <macro><name>getExpressionLocationsEnabled</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<function><type><name>CGObjCRuntime</name> <modifier>&amp;</modifier></type><name>getObjCRuntime</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ObjCRuntime</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>createObjCRuntime</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>*</operator><name>ObjCRuntime</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>bool</name></type> <name>hasObjCRuntime</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>!</operator><operator>!</operator><name>ObjCRuntime</name></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><macro><name>getModuleNameHash</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ModuleNameHash</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>CGOpenCLRuntime</name> <modifier>&amp;</modifier></type><name>getOpenCLRuntime</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>OpenCLRuntime</name> <operator>!=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>OpenCLRuntime</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>CGOpenMPRuntime</name> <modifier>&amp;</modifier></type><name>getOpenMPRuntime</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>OpenMPRuntime</name> <operator>!=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>OpenMPRuntime</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>CGCUDARuntime</name> <modifier>&amp;</modifier></type><name>getCUDARuntime</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>CUDARuntime</name> <operator>!=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>CUDARuntime</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>ObjCEntrypoints</name> <operator>&amp;</operator><macro><name>getObjCEntrypoints</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>ObjCData</name> <operator>!=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>ObjCData</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>IsOSVersionAtLeastFn</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>IsPlatformVersionAtLeastFn</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<function><type><name>InstrProfStats</name> <modifier>&amp;</modifier></type><name>getPGOStats</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>PGOStats</name></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>IndexedInstrProfReader</name> <operator>*</operator><macro><name>getPGOReader</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>PGOReader</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>CoverageMappingModuleGen</name> <operator>*</operator><macro><name>getCoverageMapping</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>CoverageMapping</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>getStaticLocalDeclAddress</name><argument_list>(<argument>const VarDecl *D</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>StaticLocalDeclMap</name><index>[<expr><name>D</name></expr>]</index></name></expr>;</return>
}</block></expr></expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>setStaticLocalDeclAddress</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>D</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>C</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name><name>StaticLocalDeclMap</name><index>[<expr><name>D</name></expr>]</index></name> <operator>=</operator> <name>C</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator>
<macro><name>getOrCreateStaticVarDecl</name><argument_list>(<argument>const VarDecl &amp;D</argument>,
<argument>llvm::GlobalValue::LinkageTypes Linkage</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator><macro><name>getStaticLocalDeclGuardAddress</name><argument_list>(<argument>const VarDecl *D</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>StaticLocalDeclGuardMap</name><index>[<expr><name>D</name></expr>]</index></name></expr>;</return>
}</block></expr></expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>setStaticLocalDeclGuardAddress</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>D</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator><name>C</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name><name>StaticLocalDeclGuardMap</name><index>[<expr><name>D</name></expr>]</index></name> <operator>=</operator> <name>C</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>Address</name></type> <name>createUnnamedGlobalFrom</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>&amp;</operator><name>D</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>Constant</name></expr></argument>,
<argument><expr><name>CharUnits</name> <name>Align</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>lookupRepresentativeDecl</name><argument_list>(<argument><expr><name>StringRef</name> <name>MangledName</name></expr></argument>,
<argument><expr><name>GlobalDecl</name> <operator>&amp;</operator><name>Result</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>getAtomicSetterHelperFnMap</name><argument_list>(<argument>QualType Ty</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>AtomicSetterHelperFnMap</name><index>[<expr><name>Ty</name></expr>]</index></name></expr>;</return>
}</block></expr></expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>setAtomicSetterHelperFnMap</name><argument_list>(<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>Fn</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name><name>AtomicSetterHelperFnMap</name><index>[<expr><name>Ty</name></expr>]</index></name> <operator>=</operator> <name>Fn</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>getAtomicGetterHelperFnMap</name><argument_list>(<argument>QualType Ty</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>AtomicGetterHelperFnMap</name><index>[<expr><name>Ty</name></expr>]</index></name></expr>;</return>
}</block></expr></expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>setAtomicGetterHelperFnMap</name><argument_list>(<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>Fn</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name><name>AtomicGetterHelperFnMap</name><index>[<expr><name>Ty</name></expr>]</index></name> <operator>=</operator> <name>Fn</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>getTypeDescriptorFromMap</name><argument_list>(<argument>QualType Ty</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>TypeDescriptorMap</name><index>[<expr><name>Ty</name></expr>]</index></name></expr>;</return>
}</block></expr></expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>setTypeDescriptorInMap</name><argument_list>(<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>C</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name><name>TypeDescriptorMap</name><index>[<expr><name>Ty</name></expr>]</index></name> <operator>=</operator> <name>C</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><name>CGDebugInfo</name> <modifier>*</modifier></type><name>getModuleDebugInfo</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>DebugInfo</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>MDNode</name> <operator>*</operator><macro><name>getNoObjCARCExceptionsMetadata</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NoObjCARCExceptionsMetadata</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>NoObjCARCExceptionsMetadata</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name>MDNode</name><operator>::</operator><call><name>get</name><argument_list>(<argument><expr><call><name>getLLVMContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>NoObjCARCExceptionsMetadata</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>ASTContext</name> <operator>&amp;</operator><macro><name>getContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Context</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><macro><name>getLangOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LangOpts</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>HeaderSearchOptions</name> <operator>&amp;</operator><macro><name>getHeaderSearchOpts</name><argument_list>()</argument_list></macro>
<specifier>const</specifier> <block>{ <return>return <expr><name>HeaderSearchOpts</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>PreprocessorOptions</name> <operator>&amp;</operator><macro><name>getPreprocessorOpts</name><argument_list>()</argument_list></macro>
<specifier>const</specifier> <block>{ <return>return <expr><name>PreprocessorOpts</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>CodeGenOptions</name> <operator>&amp;</operator><macro><name>getCodeGenOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CodeGenOpts</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Module</name> <operator>&amp;</operator><macro><name>getModule</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TheModule</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><macro><name>getDiags</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Diags</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>DataLayout</name> <operator>&amp;</operator><macro><name>getDataLayout</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>TheModule</name><operator>.</operator><name>getDataLayout</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>TargetInfo</name> <operator>&amp;</operator><macro><name>getTarget</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Target</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>Triple</name> <operator>&amp;</operator><macro><name>getTriple</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Target</name><operator>.</operator><name>getTriple</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>supportsCOMDAT</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>maybeSetTrivialComdat</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>&amp;</operator><name>D</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>GlobalObject</name> <operator>&amp;</operator><name>GO</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>CGCXXABI</name> <operator>&amp;</operator><macro><name>getCXXABI</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>ABI</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>LLVMContext</name> <operator>&amp;</operator><macro><name>getLLVMContext</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>VMContext</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>shouldUseTBAA</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TBAA</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block></expr></expr_stmt>

<function_decl><type><specifier>const</specifier> <name>TargetCodeGenInfo</name> <modifier>&amp;</modifier></type><name>getTargetCodeGenInfo</name><parameter_list>()</parameter_list>;</function_decl>

<function><type><name>CodeGenTypes</name> <modifier>&amp;</modifier></type><name>getTypes</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>Types</name></expr>;</return> </block_content>}</block></function>

<function><type><name>CodeGenVTables</name> <modifier>&amp;</modifier></type><name>getVTables</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>VTables</name></expr>;</return> </block_content>}</block></function>

<function><type><name>ItaniumVTableContext</name> <modifier>&amp;</modifier></type><name>getItaniumVTableContext</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>VTables</name><operator>.</operator><name>getItaniumVTableContext</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>MicrosoftVTableContext</name> <modifier>&amp;</modifier></type><name>getMicrosoftVTableContext</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>VTables</name><operator>.</operator><name>getMicrosoftVTableContext</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>CtorList</name> <modifier>&amp;</modifier></type><name>getGlobalCtors</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>GlobalCtors</name></expr>;</return> </block_content>}</block></function>
<function><type><name>CtorList</name> <modifier>&amp;</modifier></type><name>getGlobalDtors</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>GlobalDtors</name></expr>;</return> </block_content>}</block></function>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>MDNode</name> <operator>*</operator><macro><name>getTBAATypeInfo</name><argument_list>(<argument>QualType QTy</argument>)</argument_list></macro></expr>;</expr_stmt>



<function_decl><type><name>TBAAAccessInfo</name></type> <name>getTBAAAccessInfo</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>AccessType</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>TBAAAccessInfo</name></type> <name>getTBAAVTablePtrAccessInfo</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>VTablePtrType</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>MDNode</name> <operator>*</operator><macro><name>getTBAAStructInfo</name><argument_list>(<argument>QualType QTy</argument>)</argument_list></macro></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>MDNode</name> <operator>*</operator><macro><name>getTBAABaseTypeInfo</name><argument_list>(<argument>QualType QTy</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>MDNode</name> <operator>*</operator><macro><name>getTBAAAccessTagInfo</name><argument_list>(<argument>TBAAAccessInfo Info</argument>)</argument_list></macro></expr>;</expr_stmt>



<function_decl><type><name>TBAAAccessInfo</name></type> <name>mergeTBAAInfoForCast</name><parameter_list>(<parameter><decl><type><name>TBAAAccessInfo</name></type> <name>SourceInfo</name></decl></parameter>,
<parameter><decl><type><name>TBAAAccessInfo</name></type> <name>TargetInfo</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>TBAAAccessInfo</name></type> <name>mergeTBAAInfoForConditionalOperator</name><parameter_list>(<parameter><decl><type><name>TBAAAccessInfo</name></type> <name>InfoA</name></decl></parameter>,
<parameter><decl><type><name>TBAAAccessInfo</name></type> <name>InfoB</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>TBAAAccessInfo</name></type> <name>mergeTBAAInfoForMemoryTransfer</name><parameter_list>(<parameter><decl><type><name>TBAAAccessInfo</name></type> <name>DestInfo</name></decl></parameter>,
<parameter><decl><type><name>TBAAAccessInfo</name></type> <name>SrcInfo</name></decl></parameter>)</parameter_list>;</function_decl>



<function><type><name>TBAAAccessInfo</name></type> <name>getTBAAInfoForSubobject</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>Base</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>AccessType</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Base</name><operator>.</operator><name>getTBAAInfo</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isMayAlias</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>TBAAAccessInfo</name><operator>::</operator><call><name>getMayAliasInfo</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getTBAAAccessInfo</name><argument_list>(<argument><expr><name>AccessType</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>bool</name></type> <name>isTypeConstant</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>QTy</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ExcludeCtorDtor</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>isPaddedAtomicType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isPaddedAtomicType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AtomicType</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>void</name></type> <name>DecorateInstructionWithTBAA</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Instruction</name> <operator>*</operator><name>Inst</name></expr></argument>,
<argument><expr><name>TBAAAccessInfo</name> <name>TBAAInfo</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>DecorateInstructionWithInvariantGroup</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Instruction</name> <operator>*</operator><name>I</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>ConstantInt</name> <operator>*</operator><macro><name>getSize</name><argument_list>(<argument>CharUnits numChars</argument>)</argument_list></macro></expr>;</expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>setGlobalVisibility</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>setDSOLocal</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>setDLLImportDLLExport</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name></expr></argument>, <argument><expr><name>GlobalDecl</name> <name>D</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>setDLLImportDLLExport</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>setGVProperties</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name></expr></argument>, <argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>setGVProperties</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>setGVPropertiesAux</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>setTLSMode</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>&amp;</operator><name>D</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name><operator>::</operator><name>ThreadLocalMode</name> <macro><name>GetDefaultLLVMTLSModel</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><specifier>static</specifier> <name>llvm</name><operator>::</operator><name>GlobalValue</name><operator>::</operator><name>VisibilityTypes</name> <macro><name>GetLLVMVisibility</name><argument_list>(<argument>Visibility V</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><name>V</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DefaultVisibility</name></expr>:</case> <return>return <expr><name>llvm</name><operator>::</operator><name>GlobalValue</name><operator>::</operator><name>DefaultVisibility</name></expr>;</return>
<case>case <expr><name>HiddenVisibility</name></expr>:</case> <return>return <expr><name>llvm</name><operator>::</operator><name>GlobalValue</name><operator>::</operator><name>HiddenVisibility</name></expr>;</return>
<case>case <expr><name>ProtectedVisibility</name></expr>:</case> <return>return <expr><name>llvm</name><operator>::</operator><name>GlobalValue</name><operator>::</operator><name>ProtectedVisibility</name></expr>;</return>
<expr_stmt/></block_content></block></switch>}</block>
<call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"unknown visibility!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

llvm<expr_stmt><expr><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>GetAddrOfGlobal</name><argument_list>(<argument>GlobalDecl GD</argument>,
<argument>ForDefinition_t IsForDefinition
= NotForDefinition</argument>)</argument_list></macro></expr>;</expr_stmt>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator>
<macro><name>CreateOrReplaceCXXRuntimeVariable</name><argument_list>(<argument>StringRef Name</argument>, <argument>llvm::Type *Ty</argument>,
<argument>llvm::GlobalValue::LinkageTypes Linkage</argument>,
<argument>unsigned Alignment</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><macro><name>CreateGlobalInitOrCleanUpFunction</name><argument_list>(
<argument>llvm::FunctionType *ty</argument>, <argument>const Twine &amp;name</argument>, <argument>const CGFunctionInfo &amp;FI</argument>,
<argument>SourceLocation Loc = SourceLocation()</argument>, <argument>bool TLS = false</argument>)</argument_list></macro></expr>;</expr_stmt>









<function_decl><type><name>LangAS</name></type> <name>GetGlobalVarAddressSpace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>






<expr_stmt><expr><name>LangAS</name> <macro><name>GetGlobalConstantAddressSpace</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>







<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>GetAddrOfGlobalVar</name><argument_list>(<argument>const VarDecl *D</argument>,
<argument>llvm::Type *Ty = nullptr</argument>,
<argument>ForDefinition_t IsForDefinition
= NotForDefinition</argument>)</argument_list></macro></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>GetAddrOfFunction</name><argument_list>(<argument>GlobalDecl GD</argument>, <argument>llvm::Type *Ty = nullptr</argument>,
<argument>bool ForVTable = false</argument>,
<argument>bool DontDefer = false</argument>,
<argument>ForDefinition_t IsForDefinition
= NotForDefinition</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>GetAddrOfRTTIDescriptor</name><argument_list>(<argument>QualType Ty</argument>, <argument>bool ForEH = false</argument>)</argument_list></macro></expr>;</expr_stmt>


<function_decl><type><name>ConstantAddress</name></type> <name>GetAddrOfMSGuidDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MSGuidDecl</name> <modifier>*</modifier></type><name>GD</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ConstantAddress</name></type>
<name>GetAddrOfTemplateParamObject</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateParamObjectDecl</name> <modifier>*</modifier></type><name>TPO</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>GetAddrOfThunk</name><argument_list>(<argument>StringRef Name</argument>, <argument>llvm::Type *FnTy</argument>,
<argument>GlobalDecl GD</argument>)</argument_list></macro></expr>;</expr_stmt>


<function_decl><type><name>ConstantAddress</name></type> <name>GetWeakRefReference</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ValueDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>CharUnits</name></type> <name>getClassPointerAlignment</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>CD</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>CharUnits</name></type> <name>getMinimumClassObjectSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>CD</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>CharUnits</name></type> <name>getMinimumObjectSize</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name> <init>= <expr><call><name><name>Ty</name><operator>-&gt;</operator><name>getAsCXXRecordDecl</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getMinimumClassObjectSize</name><argument_list>(<argument><expr><name>RD</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getContext</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTypeSizeInChars</name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name>CharUnits</name></type> <name>getVBaseAlignment</name><parameter_list>(<parameter><decl><type><name>CharUnits</name></type> <name>DerivedAlign</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Derived</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>VBase</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>CharUnits</name></type> <name>getDynamicOffsetAlignment</name><parameter_list>(<parameter><decl><type><name>CharUnits</name></type> <name>ActualAlign</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>,
<parameter><decl><type><name>CharUnits</name></type> <name>ExpectedTargetAlign</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>CharUnits</name></type>
<name>computeNonVirtualBaseClassOffset</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>DerivedClass</name></expr></argument>,
<argument><expr><name>CastExpr</name><operator>::</operator><name>path_const_iterator</name> <name>Start</name></expr></argument>,
<argument><expr><name>CastExpr</name><operator>::</operator><name>path_const_iterator</name> <name>End</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator>
<macro><name>GetNonVirtualBaseClassOffset</name><argument_list>(<argument>const CXXRecordDecl *ClassDecl</argument>,
<argument>CastExpr::path_const_iterator PathBegin</argument>,
<argument>CastExpr::path_const_iterator PathEnd</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>BlockByrefHelpers</name></expr></argument>&gt;</argument_list></name> <name>ByrefHelpersCache</name></expr>;</expr_stmt>


<function><type><name>int</name></type> <name>getUniqueBlockCount</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>++</operator><name><name>Block</name><operator>.</operator><name>GlobalUniqueCount</name></name></expr>;</return> </block_content>}</block></function>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><call><name>getBlockDescriptorType</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><call><name>getGenericBlockLiteralType</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>GetAddrOfGlobalBlock</name><argument_list>(<argument>const BlockExpr *BE</argument>, <argument>StringRef Name</argument>)</argument_list></macro></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>getAddrOfGlobalBlockIfEmitted</name><argument_list>(<argument>const BlockExpr *BE</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>EmittedGlobalBlocks</name><operator>.</operator><name>lookup</name></name><argument_list>(<argument><expr><name>BE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>setAddrOfGlobalBlock</name><argument_list>(<argument><expr><specifier>const</specifier> <name>BlockExpr</name> <operator>*</operator><name>BE</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>Addr</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>ConstantAddress</name></type> <name>GetAddrOfConstantCFString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>StringLiteral</name> <modifier>*</modifier></type><name>Literal</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>ConstantAddress</name></type> <name>GetAddrOfConstantString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>StringLiteral</name> <modifier>*</modifier></type><name>Literal</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><call><name>GetConstantArrayFromStringLiteral</name><argument_list>(<argument><expr><specifier>const</specifier> <name>StringLiteral</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function_decl><type><name>ConstantAddress</name></type>
<name>GetAddrOfConstantStringFromLiteral</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>StringLiteral</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Name</name> <init>= <expr><literal type="string">".str"</literal></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ConstantAddress</name></type>
<name>GetAddrOfConstantStringFromObjCEncode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCEncodeExpr</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>






<decl_stmt><decl><type><name>ConstantAddress</name></type>
<name>GetAddrOfConstantCString</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>Str</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>GlobalName</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>ConstantAddress</name></type> <name>GetAddrOfConstantCompoundLiteral</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CompoundLiteralExpr</name><modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator>
<call><name>getAddrOfConstantCompoundLiteralIfEmitted</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CompoundLiteralExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>setAddrOfConstantCompoundLiteral</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CompoundLiteralExpr</name> <operator>*</operator><name>CLE</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator><name>GV</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>ConstantAddress</name></type> <name>GetAddrOfGlobalTemporary</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MaterializeTemporaryExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Inner</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>QualType</name></type> <name>getObjCFastEnumerationStateType</name><parameter_list>()</parameter_list>;</function_decl>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><macro><name>codegenCXXStructor</name><argument_list>(<argument>GlobalDecl GD</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator>
<macro><name>getAddrOfCXXStructor</name><argument_list>(<argument>GlobalDecl GD</argument>, <argument>const CGFunctionInfo *FnInfo = nullptr</argument>,
<argument>llvm::FunctionType *FnType = nullptr</argument>,
<argument>bool DontDefer = false</argument>,
<argument>ForDefinition_t IsForDefinition = NotForDefinition</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getAddrAndTypeOfCXXStructor</name><argument_list>(<argument><expr><name>GD</name></expr></argument>, <argument><expr><name>FnInfo</name></expr></argument>, <argument><expr><name>FnType</name></expr></argument>,
<argument><expr><name>DontDefer</name></expr></argument>,
<argument><expr><name>IsForDefinition</name></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>getCallee</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <macro><name>getAddrAndTypeOfCXXStructor</name><argument_list>(
<argument>GlobalDecl GD</argument>, <argument>const CGFunctionInfo *FnInfo = nullptr</argument>,
<argument>llvm::FunctionType *FnType = nullptr</argument>, <argument>bool DontDefer = false</argument>,
<argument>ForDefinition_t IsForDefinition = NotForDefinition</argument>)</argument_list></macro></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>getBuiltinLibFunction</name><argument_list>(<argument>const FunctionDecl *FD</argument>,
<argument>unsigned BuiltinID</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><macro><name>getIntrinsic</name><argument_list>(<argument>unsigned IID</argument>, <argument>ArrayRef&lt;llvm::Type*&gt; Tys = None</argument>)</argument_list></macro></expr>;</expr_stmt>


<function_decl><type><name>void</name></type> <name>EmitTopLevelDecl</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>AddDeferredUnusedCoverageMapping</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ClearUnusedCoverageMapping</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>EmitDeferredUnusedCoverageMappings</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitMainVoidAlias</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>HandleCXXStaticMemberVarInstantiation</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>SomeDecl</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>MaybeHandleStaticInExternC</name><argument_list>(<argument><expr><specifier>const</specifier> <name>SomeDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>addUsedGlobal</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>addCompilerUsedGlobal</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>addUsedOrCompilerUsedGlobal</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>AddCXXDtorEntry</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>DtorFn</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>Object</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>CXXGlobalDtorsOrStermFinalizers</name><operator>.</operator><name>emplace_back</name></name><argument_list>(<argument><expr><call><name><name>DtorFn</name><operator>.</operator><name>getFunctionType</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>DtorFn</name><operator>.</operator><name>getCallee</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>AddCXXStermFinalizerEntry</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>DtorFn</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>CXXGlobalDtorsOrStermFinalizers</name><operator>.</operator><name>emplace_back</name></name><argument_list>(<argument><expr><call><name><name>DtorFn</name><operator>.</operator><name>getFunctionType</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>DtorFn</name><operator>.</operator><name>getCallee</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>AddCXXStermFinalizerToGlobalDtor</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>StermFinalizer</name></expr></argument>,
<argument><expr><name>int</name> <name>Priority</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>AddGlobalDtor</name><argument_list>(<argument><expr><name>StermFinalizer</name></expr></argument>, <argument><expr><name>Priority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>AddCXXPrioritizedStermFinalizerEntry</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>StermFinalizer</name></expr></argument>,
<argument><expr><name>int</name> <name>Priority</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>OrderGlobalInitsOrStermFinalizers</name></type> <name>Key</name><argument_list>(<argument><expr><name>Priority</name></expr></argument>,
<argument><expr><call><name><name>PrioritizedCXXStermFinalizers</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>PrioritizedCXXStermFinalizers</name><operator>.</operator><name>push_back</name></name><argument_list>(
<argument><expr><name>std</name><operator>::</operator><call><name>make_pair</name><argument_list>(<argument><expr><name>Key</name></expr></argument>, <argument><expr><name>StermFinalizer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name>
<macro><name>CreateRuntimeFunction</name><argument_list>(<argument>llvm::FunctionType *Ty</argument>, <argument>StringRef Name</argument>,
<argument>llvm::AttributeList ExtraAttrs = llvm::AttributeList()</argument>,
<argument>bool Local = false</argument>, <argument>bool AssumeConvergent = false</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>CreateRuntimeVariable</name><argument_list>(<argument>llvm::Type *Ty</argument>,
<argument>StringRef Name</argument>)</argument_list></macro></expr>;</expr_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><call><name>getNSConcreteGlobalBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><call><name>getNSConcreteStackBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <call><name>getBlockObjectAssign</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <call><name>getBlockObjectDispose</name><argument_list>()</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><call><name>getLLVMLifetimeStartFn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><call><name>getLLVMLifetimeEndFn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<function_decl><type><name>void</name></type> <name>UpdateCompletedType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TagDecl</name> <modifier>*</modifier></type><name>TD</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><call><name>getMemberPointerConstant</name><argument_list>(<argument><expr><specifier>const</specifier> <name>UnaryOperator</name> <operator>*</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<function_decl><type><name>void</name></type> <name>EmitExplicitCastExprType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExplicitCastExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>CodeGenFunction</name> <modifier>*</modifier></type><name>CGF</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>EmitNullConstant</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><call><name>EmitNullConstantForBase</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>Record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function_decl><type><name>void</name></type> <name>Error</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>loc</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>error</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ErrorUnsupported</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Type</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ErrorUnsupported</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Type</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>void</name></type> <name>SetInternalFunctionAttributes</name><argument_list>(<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>F</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CGFunctionInfo</name> <operator>&amp;</operator><name>FI</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>SetLLVMFunctionAttributes</name><argument_list>(<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CGFunctionInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>F</name></expr></argument>, <argument><expr><name>bool</name> <name>IsThunk</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>SetLLVMFunctionAttributesForDefinition</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>setLLVMFunctionFEnvAttributes</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>bool</name></type> <name>ReturnTypeUsesSRet</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CGFunctionInfo</name> <modifier>&amp;</modifier></type><name>FI</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>ReturnSlotInterferesWithArgs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CGFunctionInfo</name> <modifier>&amp;</modifier></type><name>FI</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>ReturnTypeUsesFPRet</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>ResultType</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>ReturnTypeUsesFP2Ret</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>ResultType</name></decl></parameter>)</parameter_list>;</function_decl>











<decl_stmt><decl><type><name>void</name></type> <name>ConstructAttributeList</name><argument_list>(<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CGFunctionInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>,
<argument><expr><name>CGCalleeInfo</name> <name>CalleeInfo</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>AttributeList</name> <operator>&amp;</operator><name>Attrs</name></expr></argument>, <argument><expr><name>unsigned</name> <operator>&amp;</operator><name>CallingConv</name></expr></argument>,
<argument><expr><name>bool</name> <name>AttrOnCallSite</name></expr></argument>, <argument><expr><name>bool</name> <name>IsThunk</name></expr></argument>)</argument_list></decl>;</decl_stmt>


















<decl_stmt><decl><type><name>void</name></type> <name>addDefaultFunctionDefinitionAttributes</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>&amp;</operator><name>F</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>addDefaultFunctionDefinitionAttributes</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>AttrBuilder</name> <operator>&amp;</operator><name>attrs</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>StringRef</name></type> <name>getMangledName</name><parameter_list>(<parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StringRef</name></type> <name>getBlockMangledName</name><parameter_list>(<parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BlockDecl</name> <modifier>*</modifier></type><name>BD</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitTentativeDefinition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitExternalDeclaration</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitVTable</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>RefreshTypeCacheForClass</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AppendLinkerOptions</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Opts</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddDetectMismatch</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Name</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Value</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddDependentLib</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Lib</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name><operator>::</operator><name>LinkageTypes</name> <macro><name>getFunctionLinkage</name><argument_list>(<argument>GlobalDecl GD</argument>)</argument_list></macro></expr>;</expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>setFunctionLinkage</name><argument_list>(<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>F</name><operator>-&gt;</operator><name>setLinkage</name></name><argument_list>(<argument><expr><call><name>getFunctionLinkage</name><argument_list>(<argument><expr><name>GD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name><operator>::</operator><name>LinkageTypes</name> <call><name>getVTableLinkage</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>CharUnits</name></type> <name>GetTargetTypeStoreSize</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>Ty</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name><operator>::</operator><name>LinkageTypes</name>
<macro><name>getLLVMLinkageForDeclarator</name><argument_list>(<argument>const DeclaratorDecl *D</argument>, <argument>GVALinkage Linkage</argument>,
<argument>bool IsConstantVariable</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name><operator>::</operator><name>LinkageTypes</name>
<macro><name>getLLVMLinkageVarDefinition</name><argument_list>(<argument>const VarDecl *VD</argument>, <argument>bool IsConstant</argument>)</argument_list></macro></expr>;</expr_stmt>


<function_decl><type><name>void</name></type> <name>EmitGlobalAnnotations</name><parameter_list>()</parameter_list>;</function_decl>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>EmitAnnotationString</name><argument_list>(<argument>StringRef Str</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>EmitAnnotationUnit</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>EmitAnnotationLineNo</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><call><name>EmitAnnotationArgs</name><argument_list>(<argument><expr><specifier>const</specifier> <name>AnnotateAttr</name> <operator>*</operator><name>Attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>








<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>EmitAnnotateAttr</name><argument_list>(<argument>llvm::GlobalValue *GV</argument>,
<argument>const AnnotateAttr *AA</argument>,
<argument>SourceLocation L</argument>)</argument_list></macro></expr>;</expr_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>AddGlobalAnnotations</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isInNoSanitizeList</name><argument_list>(<argument><expr><name>SanitizerMask</name> <name>Kind</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Fn</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isInNoSanitizeList</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator><name>GV</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>, <argument><expr><name>StringRef</name> <name>Category</name> <operator>=</operator> <call><name>StringRef</name><argument_list>()</argument_list></call></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>imbueXRayAttrs</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Fn</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name>StringRef</name> <name>Category</name> <operator>=</operator> <call><name>StringRef</name><argument_list>()</argument_list></call></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isProfileInstrExcluded</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Fn</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function><type><name>SanitizerMetadata</name> <modifier>*</modifier></type><name>getSanitizerMetadata</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SanitizerMD</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>addDeferredVTable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>DeferredVTables</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>RD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function_decl><type><name>void</name></type> <name>EmitGlobal</name><parameter_list>(<parameter><decl><type><name>GlobalDecl</name></type> <name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>TryEmitBaseDestructorAsAlias</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><macro><name>GetGlobalValue</name><argument_list>(<argument>StringRef Ref</argument>)</argument_list></macro></expr>;</expr_stmt>





<decl_stmt><decl><type><name>void</name></type> <name>SetCommonAttributes</name><argument_list>(<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>addReplacement</name><argument_list>(<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>C</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>addGlobalValReplacement</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>C</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>EmitOMPThreadPrivateDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPThreadPrivateDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitOMPDeclareReduction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPDeclareReductionDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>CodeGenFunction</name> <modifier>*</modifier></type><name>CGF</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitOMPDeclareMapper</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPDeclareMapperDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>CodeGenFunction</name> <modifier>*</modifier></type><name>CGF</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>EmitOMPRequiresDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPRequiresDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>EmitOMPAllocateDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPAllocateDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>HasHiddenLTOVisibility</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>HasLTOVisibilityPublicStd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list>;</function_decl>







<expr_stmt><expr><name>llvm</name><operator>::</operator><name>GlobalObject</name><operator>::</operator><name>VCallVisibility</name>
<call><name>GetVCallVisibilityLevel</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>DenseSet</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Visited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>EmitVTableTypeMetadata</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator><name>VTable</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>VTableLayout</name> <operator>&amp;</operator><name>VTLayout</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>ConstantInt</name> <operator>*</operator><call><name>CreateCrossDsoCfiTypeId</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Metadata</name> <operator>*</operator><name>MD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Metadata</name> <operator>*</operator><macro><name>CreateMetadataIdentifierForType</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Metadata</name> <operator>*</operator><macro><name>CreateMetadataIdentifierForVirtualMemPtrType</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro></expr>;</expr_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Metadata</name> <operator>*</operator><macro><name>CreateMetadataIdentifierGeneralized</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro></expr>;</expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>CreateFunctionTypeMetadataForIcall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>FD</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>bool</name></type> <name>MayDropFunctionReturn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ReturnType</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>bool</name> <macro><name>NeedAllVtablesTypeId</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>AddVTableTypeMetadata</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator><name>VTable</name></expr></argument>, <argument><expr><name>CharUnits</name> <name>Offset</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<call><name>getMostBaseClasses</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <call><name>getTerminateFn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>SanitizerStatReport</name> <operator>&amp;</operator><call><name>getSanStats</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator>
<call><name>createOpenCLIntToSamplerConversion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>E</name></expr></argument>, <argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>











<decl_stmt><decl><type><name>void</name></type> <name>GenOpenCLArgMetadata</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>FN</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>FD</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>CodeGenFunction</name> <operator>*</operator><name>CGF</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>getNullPointer</name><argument_list>(<argument>llvm::PointerType *T</argument>, <argument>QualType QT</argument>)</argument_list></macro></expr>;</expr_stmt>

<function_decl><type><name>CharUnits</name></type> <name>getNaturalTypeAlignment</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>LValueBaseInfo</name> <modifier>*</modifier></type><name>BaseInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>TBAAAccessInfo</name> <modifier>*</modifier></type><name>TBAAInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>forPointeeType</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>CharUnits</name></type> <name>getNaturalPointeeTypeAlignment</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>LValueBaseInfo</name> <modifier>*</modifier></type><name>BaseInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>TBAAAccessInfo</name> <modifier>*</modifier></type><name>TBAAInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>stopAutoInit</name><parameter_list>()</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>void</name></type> <name>printPostfixForExternalizedStaticVar</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>GetOrCreateLLVMFunction</name><argument_list>(
<argument>StringRef MangledName</argument>, <argument>llvm::Type *Ty</argument>, <argument>GlobalDecl D</argument>, <argument>bool ForVTable</argument>,
<argument>bool DontDefer = false</argument>, <argument>bool IsThunk = false</argument>,
<argument>llvm::AttributeList ExtraAttrs = llvm::AttributeList()</argument>,
<argument>ForDefinition_t IsForDefinition = NotForDefinition</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>GetOrCreateMultiVersionResolver</name><argument_list>(<argument>GlobalDecl GD</argument>,
<argument>llvm::Type *DeclTy</argument>,
<argument>const FunctionDecl *FD</argument>)</argument_list></macro></expr>;</expr_stmt>
<function_decl><type><name>void</name></type> <name>UpdateMultiVersionNames</name><parameter_list>(<parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator>
<macro><name>GetOrCreateLLVMGlobal</name><argument_list>(<argument>StringRef MangledName</argument>, <argument>llvm::Type *Ty</argument>,
<argument>unsigned AddrSpace</argument>, <argument>const VarDecl *D</argument>,
<argument>ForDefinition_t IsForDefinition = NotForDefinition</argument>)</argument_list></macro></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>GetCPUAndFeaturesAttributes</name><argument_list>(<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>AttrBuilder</name> <operator>&amp;</operator><name>AttrBuilder</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>setNonAliasAttributes</name><argument_list>(<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>GlobalObject</name> <operator>*</operator><name>GO</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>SetFunctionAttributes</name><argument_list>(<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>F</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsIncompleteFunction</name></expr></argument>, <argument><expr><name>bool</name> <name>IsThunk</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>EmitGlobalDefinition</name><argument_list>(<argument><expr><name>GlobalDecl</name> <name>D</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>EmitGlobalFunctionDefinition</name><argument_list>(<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>EmitMultiVersionFunctionDefinition</name><argument_list>(<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>EmitGlobalVarDefinition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsTentative</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitExternalVarDeclaration</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitAliasDefinition</name><parameter_list>(<parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>emitIFuncDefinition</name><parameter_list>(<parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>emitCPUDispatchDefinition</name><parameter_list>(<parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitObjCPropertyImplementations</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCImplementationDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitObjCIvarInitializations</name><parameter_list>(<parameter><decl><type><name>ObjCImplementationDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>EmitDeclContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitLinkageSpec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LinkageSpecDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitCXXThreadLocalInitFunc</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitCXXGlobalInitFunc</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitCXXGlobalCleanUpFunc</name><parameter_list>()</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>void</name></type> <name>EmitCXXGlobalVarDeclInitFunc</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>D</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator><name>Addr</name></expr></argument>,
<argument><expr><name>bool</name> <name>PerformInit</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>EmitPointerToInitFunc</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator><name>Addr</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>InitFunc</name></expr></argument>, <argument><expr><name>InitSegAttr</name> <operator>*</operator><name>ISA</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>AddGlobalCtor</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Ctor</name></expr></argument>, <argument><expr><name>int</name> <name>Priority</name> <operator>=</operator> <literal type="number">65535</literal></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>AssociatedData</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>AddGlobalDtor</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Dtor</name></expr></argument>, <argument><expr><name>int</name> <name>Priority</name> <operator>=</operator> <literal type="number">65535</literal></expr></argument>,
<argument><expr><name>bool</name> <name>IsDtorAttrFunc</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<function_decl><type><name>void</name></type> <name>EmitCtorList</name><parameter_list>(<parameter><decl><type><name>CtorList</name> <modifier>&amp;</modifier></type><name>Fns</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>GlobalName</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitDeferred</name><parameter_list>()</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type> <name>EmitVTablesOpportunistically</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>applyReplacements</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>applyGlobalValReplacements</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>checkAliases</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name><name>TinyPtrVector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>DtorsUsingAtExit</name></expr>;</expr_stmt>



<function_decl><type><name>void</name></type> <name>registerGlobalDtorsWithAtExit</name><parameter_list>()</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>unregisterGlobalDtorsWithUnAtExit</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>emitMultiVersionFunctions</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitDeferredVTables</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>emitAtAvailableLinkGuard</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>emitLLVMUsed</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitModuleLinkOptions</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>EmitStaticExternCAliases</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitDeclMetadata</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitVersionIdentMetadata</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitCommandLineMetadata</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>EmitBackendOptionsMetadata</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CodeGenOptions</name></type> <name>CodeGenOpts</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitOpenCLMetadata</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>EmitCoverageFile</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>MustBeEmitted</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ValueDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>MayBeEmittedEagerly</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ValueDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>SimplifyPersonality</name><parameter_list>()</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>void</name></type> <name>getDefaultFunctionAttributes</name><argument_list>(<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>, <argument><expr><name>bool</name> <name>HasOptnone</name></expr></argument>,
<argument><expr><name>bool</name> <name>AttrOnCallSite</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>AttrBuilder</name> <operator>&amp;</operator><name>FuncAttrs</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Metadata</name> <operator>*</operator><macro><name>CreateMetadataIdentifierImpl</name><argument_list>(<argument>QualType T</argument>, <argument>MetadataTypeMap &amp;Map</argument>,
<argument>StringRef Suffix</argument>)</argument_list></macro></expr>;</expr_stmt>
};

}
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
