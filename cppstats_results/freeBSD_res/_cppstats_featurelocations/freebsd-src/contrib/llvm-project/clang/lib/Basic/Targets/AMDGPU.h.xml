<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/lib/Basic/Targets/AMDGPU.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_LIB_BASIC_TARGETS_AMDGPU_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_LIB_BASIC_TARGETS_AMDGPU_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TargetID.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TargetInfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TargetOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Triple.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/TargetParser.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>targets</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name> <name>LLVM_LIBRARY_VISIBILITY</name> <name>AMDGPUTargetInfo</name></type> <name>final</name> <range>: <expr><name>public</name> <name>TargetInfo</name> <block>{

<expr><specifier>static</specifier> <specifier>const</specifier> <name>Builtin</name><operator>::</operator><name>Info</name> <name><name>BuiltinInfo</name><index>[]</index></name></expr>;
<expr><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <operator>*</operator><specifier>const</specifier> <name><name>GCCRegNames</name><index>[]</index></name></expr>;

enum <expr><name>AddrSpace</name> <block>{
<expr><name>Generic</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><name>Global</name> <operator>=</operator> <literal type="number">1</literal></expr>,
<expr><name>Local</name> <operator>=</operator> <literal type="number">3</literal></expr>,
<expr><name>Constant</name> <operator>=</operator> <literal type="number">4</literal></expr>,
<expr><name>Private</name> <operator>=</operator> <literal type="number">5</literal></expr>
}</block></expr>;
<expr><specifier>static</specifier> <specifier>const</specifier> <name>LangASMap</name> <name>AMDGPUDefIsGenMap</name></expr>;
<expr><specifier>static</specifier> <specifier>const</specifier> <name>LangASMap</name> <name>AMDGPUDefIsPrivMap</name></expr>;

<expr><name>llvm</name><operator>::</operator><name>AMDGPU</name><operator>::</operator><name>GPUKind</name> <name>GPUKind</name></expr>;
<expr><name>unsigned</name> <name>GPUFeatures</name></expr>;
<expr><name>unsigned</name> <name>WavefrontSize</name></expr>;






<expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>OffloadArchFeatures</name></expr>;
<expr><name>std</name><operator>::</operator><name>string</name> <name>TargetID</name></expr>;

<expr><name>bool</name> <macro><name>hasFP64</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTriple</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getArch</name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator><name>Triple</name><operator>::</operator><name>amdgcn</name> <operator>||</operator>
<operator>!</operator><operator>!</operator><operator>(</operator><name>GPUFeatures</name> <operator>&amp;</operator> <name>llvm</name><operator>::</operator><name>AMDGPU</name><operator>::</operator><name>FEATURE_FP64</name><operator>)</operator></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasFastFMAF</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><operator>!</operator><operator>(</operator><name>GPUFeatures</name> <operator>&amp;</operator> <name>llvm</name><operator>::</operator><name>AMDGPU</name><operator>::</operator><name>FEATURE_FAST_FMA_F32</name><operator>)</operator></expr>;</return>
}</block>


<name>bool</name> <macro><name>hasFastFMA</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTriple</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getArch</name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator><name>Triple</name><operator>::</operator><name>amdgcn</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasFMAF</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTriple</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getArch</name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator><name>Triple</name><operator>::</operator><name>amdgcn</name> <operator>||</operator>
<operator>!</operator><operator>!</operator><operator>(</operator><name>GPUFeatures</name> <operator>&amp;</operator> <name>llvm</name><operator>::</operator><name>AMDGPU</name><operator>::</operator><name>FEATURE_FMA</name><operator>)</operator></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasFullRateDenormalsF32</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><operator>!</operator><operator>(</operator><name>GPUFeatures</name> <operator>&amp;</operator> <name>llvm</name><operator>::</operator><name>AMDGPU</name><operator>::</operator><name>FEATURE_FAST_DENORMAL_F32</name><operator>)</operator></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasLDEXPF</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTriple</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getArch</name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator><name>Triple</name><operator>::</operator><name>amdgcn</name> <operator>||</operator>
<operator>!</operator><operator>!</operator><operator>(</operator><name>GPUFeatures</name> <operator>&amp;</operator> <name>llvm</name><operator>::</operator><name>AMDGPU</name><operator>::</operator><name>FEATURE_LDEXP</name><operator>)</operator></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isAMDGCN</name><argument_list>(<argument>const llvm::Triple &amp;TT</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>TT</name><operator>.</operator><name>getArch</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator><name>Triple</name><operator>::</operator><name>amdgcn</name></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isR600</name><argument_list>(<argument>const llvm::Triple &amp;TT</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>TT</name><operator>.</operator><name>getArch</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator><name>Triple</name><operator>::</operator><name>r600</name></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<call><name>AMDGPUTargetInfo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>Triple</name> <operator>&amp;</operator><name>Triple</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>TargetOptions</name> <operator>&amp;</operator><name>Opts</name></expr></argument>)</argument_list></call></expr>;

<expr><name>void</name> <macro><name>setAddressSpaceMap</name><argument_list>(<argument>bool DefaultIsPrivate</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <macro><name>adjust</name><argument_list>(<argument>DiagnosticsEngine &amp;Diags</argument>, <argument>LangOptions &amp;Opts</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>uint64_t</name> <macro><name>getPointerWidthV</name><argument_list>(<argument>unsigned AddrSpace</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isR600</name><argument_list>(<argument><expr><call><name>getTriple</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">32</literal></expr>;</return></block_content></block></if></if_stmt></block></expr>

<if_stmt><if>if <condition>(<expr><name>AddrSpace</name> <operator>==</operator> <name>Private</name> <operator>||</operator> <name>AddrSpace</name> <operator>==</operator> <name>Local</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">32</literal></expr>;</return></block_content></block></if></if_stmt></block></expr></range></decl></decl_stmt>

<return>return <expr><literal type="number">64</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>getPointerAlignV</name><argument_list>(<argument><expr><name>unsigned</name> <name>AddrSpace</name></expr></argument>)</argument_list> const <name>override</name> <block>{<block_content>
<return>return <expr><call><name>getPointerWidthV</name><argument_list>(<argument><expr><name>AddrSpace</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>uint64_t</name> <macro><name>getMaxPointerWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getTriple</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getArch</name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator><name>Triple</name><operator>::</operator><name>amdgcn</name> <operator>?</operator> <literal type="number">64</literal> <operator>:</operator> <literal type="number">32</literal></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getClobbers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><literal type="string">""</literal></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getGCCRegNames</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TargetInfo</name><operator>::</operator><name>GCCRegAlias</name></expr></argument>&gt;</argument_list></name> <macro><name>getGCCRegAliases</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><name>None</name></expr>;</return>
}</block></expr></expr_stmt>












<decl_stmt><decl><type><name>bool</name></type> <name>validateAsmConstraint</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>&amp;</operator><name>Name</name></expr></argument>,
<argument><expr><name>TargetInfo</name><operator>::</operator><name>ConstraintInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>)</argument_list> const <name>override</name> <block>{<block_content>
<expr_stmt><expr><specifier>static</specifier> <specifier>const</specifier> <operator>::</operator><name>llvm</name><operator>::</operator><name><name>StringSet</name><argument_list type="generic">&lt;&gt;</argument_list></name> <macro><name>SpecialRegs</name><argument_list>(<argument>{
<literal type="string">"exec"</literal></argument>, <argument><literal type="string">"vcc"</literal></argument>, <argument><literal type="string">"flat_scratch"</literal></argument>, <argument><literal type="string">"m0"</literal></argument>, <argument><literal type="string">"scc"</literal></argument>, <argument><literal type="string">"tba"</literal></argument>, <argument><literal type="string">"tma"</literal></argument>,
<argument><literal type="string">"flat_scratch_lo"</literal></argument>, <argument><literal type="string">"flat_scratch_hi"</literal></argument>, <argument><literal type="string">"vcc_lo"</literal></argument>, <argument><literal type="string">"vcc_hi"</literal></argument>, <argument><literal type="string">"exec_lo"</literal></argument>,
<argument><literal type="string">"exec_hi"</literal></argument>, <argument><literal type="string">"tma_lo"</literal></argument>, <argument><literal type="string">"tma_hi"</literal></argument>, <argument><literal type="string">"tba_lo"</literal></argument>, <argument><literal type="string">"tba_hi"</literal></argument>,
<argument>}</argument>)</argument_list></macro></expr>;</expr_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>Name</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'I'</literal></expr>:</case>
<expr_stmt><expr><call><name><name>Info</name><operator>.</operator><name>setRequiresImmediate</name></name><argument_list>(<argument><expr><operator>-</operator><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
<case>case <expr><literal type="char">'J'</literal></expr>:</case>
<expr_stmt><expr><call><name><name>Info</name><operator>.</operator><name>setRequiresImmediate</name></name><argument_list>(<argument><expr><operator>-</operator><literal type="number">32768</literal></expr></argument>, <argument><expr><literal type="number">32767</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
<case>case <expr><literal type="char">'A'</literal></expr>:</case>
<case>case <expr><literal type="char">'B'</literal></expr>:</case>
<case>case <expr><literal type="char">'C'</literal></expr>:</case>
<expr_stmt><expr><call><name><name>Info</name><operator>.</operator><name>setRequiresImmediate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<function_decl><type><name>StringRef</name></type> <name>S</name><parameter_list>(<parameter><decl><type><name>Name</name></type></decl></parameter>)</parameter_list>;</function_decl>

<if_stmt><if>if <condition>(<expr><name>S</name> <operator>==</operator> <literal type="string">"DA"</literal> <operator>||</operator> <name>S</name> <operator>==</operator> <literal type="string">"DB"</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Name</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Info</name><operator>.</operator><name>setRequiresImmediate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>HasLeftParen</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>HasLeftParen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>S</name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>drop_front</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="char">'v'</literal> <operator>&amp;&amp;</operator> <call><name><name>S</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <call><name><name>S</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="char">'a'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HasLeftParen</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>auto</name></type> <name>E</name> <init>= <expr><call><name><name>S</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>SpecialRegs</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><call><name><name>S</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>S</name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>drop_front</name></name><argument_list>(<argument><expr><name>E</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>S</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>Info</name><operator>.</operator><name>setAllowsRegister</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Name</name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>S</name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>drop_front</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HasLeftParen</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>S</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>Info</name><operator>.</operator><name>setAllowsRegister</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Name</name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>HasLeftBracket</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>S</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>S</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>HasLeftBracket</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>S</name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>drop_front</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>N</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>consumeUnsignedInteger</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>S</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>S</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HasLeftBracket</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>S</name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>drop_front</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>M</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>consumeUnsignedInteger</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name>M</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>N</name> <operator>&gt;=</operator> <name>M</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>HasLeftBracket</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>S</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>S</name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>drop_front</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>S</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>S</name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>drop_front</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>S</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name><name>Info</name><operator>.</operator><name>setAllowsRegister</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Name</name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>convertConstraint</name><argument_list>(<argument>const char *&amp;Constraint</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{

<expr><name>StringRef</name> <call><name>S</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>S</name> <operator>==</operator> <literal type="string">"DA"</literal> <operator>||</operator> <name>S</name> <operator>==</operator> <literal type="string">"DB"</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><literal type="string">"^"</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><name>Constraint</name><operator>++</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>

const char *Begin = Constraint</block><empty_stmt>;</empty_stmt></if></if_stmt>
<name>TargetInfo</name><operator>::</operator><name>ConstraintInfo</name> <call><name>Info</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>validateAsmConstraint</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>, <argument><expr><name>Info</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><name>Begin</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>substr</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Constraint</name> <operator>-</operator> <name>Begin</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>Constraint</name> <operator>=</operator> <name>Begin</name></expr>;</expr_stmt>
<return>return <expr><name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>*</operator><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>
<name>initFeatureMap</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Features</name></expr></argument>, <argument><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diags</name></expr></argument>,
<argument><expr><name>StringRef</name> <name>CPU</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>FeatureVec</name></expr></argument>)</argument_list> const <name>override</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Builtin</name><operator>::</operator><name>Info</name></expr></argument>&gt;</argument_list></name> <macro><name>getTargetBuiltins</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;</expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>useFP16ConversionIntrinsics</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>getTargetDefines</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><name>Opts</name></expr></argument>,
<argument><expr><name>MacroBuilder</name> <operator>&amp;</operator><name>Builder</name></expr></argument>)</argument_list> const <name>override</name></decl>;</decl_stmt>

<expr_stmt><expr><name>BuiltinVaListKind</name> <macro><name>getBuiltinVaListKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><name>TargetInfo</name><operator>::</operator><name>CharPtrBuiltinVaList</name></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isValidCPUName</name><argument_list>(<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>)</argument_list> const <name>override</name> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getTriple</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getArch</name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator><name>Triple</name><operator>::</operator><name>amdgcn</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>llvm</name><operator>::</operator><name>AMDGPU</name><operator>::</operator><call><name>parseArchAMDGCN</name><argument_list>(<argument><expr><name>Name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>llvm</name><operator>::</operator><name>AMDGPU</name><operator>::</operator><name>GK_NONE</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>llvm</name><operator>::</operator><name>AMDGPU</name><operator>::</operator><call><name>parseArchR600</name><argument_list>(<argument><expr><name>Name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>llvm</name><operator>::</operator><name>AMDGPU</name><operator>::</operator><name>GK_NONE</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>fillValidCPUList</name><argument_list>(<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Values</name></expr></argument>)</argument_list> const <name>override</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>setCPU</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>Name</name></expr></argument>)</argument_list> <name>override</name> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getTriple</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getArch</name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator><name>Triple</name><operator>::</operator><name>amdgcn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>GPUKind</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name>AMDGPU</name><operator>::</operator><call><name>parseArchAMDGCN</name><argument_list>(<argument><expr><name>Name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>GPUFeatures</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name>AMDGPU</name><operator>::</operator><call><name>getArchAttrAMDGCN</name><argument_list>(<argument><expr><name>GPUKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>GPUKind</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name>AMDGPU</name><operator>::</operator><call><name>parseArchR600</name><argument_list>(<argument><expr><name>Name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>GPUFeatures</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name>AMDGPU</name><operator>::</operator><call><name>getArchAttrR600</name><argument_list>(<argument><expr><name>GPUKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>GPUKind</name> <operator>!=</operator> <name>llvm</name><operator>::</operator><name>AMDGPU</name><operator>::</operator><name>GK_NONE</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type> <name>setSupportedOpenCLOpts</name><parameter_list>()</parameter_list> override <block>{<block_content>
<expr_stmt><expr><name>auto</name> <operator>&amp;</operator><name>Opts</name> <operator>=</operator> <call><name>getSupportedOpenCLOpts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"cl_clang_storage_class_specifiers"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"__cl_clang_variadic_functions"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"__cl_clang_function_pointers"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"__cl_clang_non_portable_kernel_param_types"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"__cl_clang_bitfields"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>IsAMDGCN</name> <init>= <expr><call><name>isAMDGCN</name><argument_list>(<argument><expr><call><name>getTriple</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"cl_khr_fp64"</literal></expr>]</index></name> <operator>=</operator> <call><name>hasFP64</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"__opencl_c_fp64"</literal></expr>]</index></name> <operator>=</operator> <call><name>hasFP64</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>IsAMDGCN</name> <operator>||</operator> <name>GPUKind</name> <operator>&gt;=</operator> <name>llvm</name><operator>::</operator><name>AMDGPU</name><operator>::</operator><name>GK_CEDAR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"cl_khr_byte_addressable_store"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"cl_khr_global_int32_base_atomics"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"cl_khr_global_int32_extended_atomics"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"cl_khr_local_int32_base_atomics"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"cl_khr_local_int32_extended_atomics"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>IsAMDGCN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"cl_khr_fp16"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"cl_khr_int64_base_atomics"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"cl_khr_int64_extended_atomics"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"cl_khr_mipmap_image"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"cl_khr_mipmap_image_writes"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"cl_khr_subgroups"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"cl_amd_media_ops"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"cl_amd_media_ops2"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"__opencl_c_images"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"__opencl_c_3d_image_writes"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Opts</name><index>[<expr><literal type="string">"cl_khr_3d_image_writes"</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name>LangAS</name></type> <name>getOpenCLTypeAddrSpace</name><argument_list>(<argument><expr><name>OpenCLTypeKind</name> <name>TK</name></expr></argument>)</argument_list> const <name>override</name> <block>{<block_content>
<switch>switch <condition>(<expr><name>TK</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OCLTK_Image</name></expr>:</case>
<return>return <expr><name>LangAS</name><operator>::</operator><name>opencl_constant</name></expr>;</return>

<case>case <expr><name>OCLTK_ClkEvent</name></expr>:</case>
<case>case <expr><name>OCLTK_Queue</name></expr>:</case>
<case>case <expr><name>OCLTK_ReserveID</name></expr>:</case>
<return>return <expr><name>LangAS</name><operator>::</operator><name>opencl_global</name></expr>;</return>

<default>default:</default>
<return>return <expr><name>TargetInfo</name><operator>::</operator><call><name>getOpenCLTypeAddrSpace</name><argument_list>(<argument><expr><name>TK</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>LangAS</name></type> <name>getOpenCLBuiltinAddressSpace</name><argument_list>(<argument><expr><name>unsigned</name> <name>AS</name></expr></argument>)</argument_list> const <name>override</name> <block>{<block_content>
<switch>switch <condition>(<expr><name>AS</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<return>return <expr><name>LangAS</name><operator>::</operator><name>opencl_generic</name></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<return>return <expr><name>LangAS</name><operator>::</operator><name>opencl_global</name></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<return>return <expr><name>LangAS</name><operator>::</operator><name>opencl_local</name></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case>
<return>return <expr><name>LangAS</name><operator>::</operator><name>opencl_constant</name></expr>;</return>
<case>case <expr><literal type="number">5</literal></expr>:</case>
<return>return <expr><name>LangAS</name><operator>::</operator><name>opencl_private</name></expr>;</return>
<default>default:</default>
<return>return <expr><call><name>getLangASFromTargetAS</name><argument_list>(<argument><expr><name>AS</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>LangAS</name></type> <name>getCUDABuiltinAddressSpace</name><argument_list>(<argument><expr><name>unsigned</name> <name>AS</name></expr></argument>)</argument_list> const <name>override</name> <block>{<block_content>
<return>return <expr><name>LangAS</name><operator>::</operator><name>Default</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>LangAS</name></expr></argument>&gt;</argument_list></name> <macro><name>getConstantAddressSpace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>getLangASFromTargetAS</name><argument_list>(<argument><expr><name>Constant</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getVtblPtrAddressSpace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Constant</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>







<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type>
<name>getDWARFAddressSpace</name><argument_list>(<argument><expr><name>unsigned</name> <name>AddressSpace</name></expr></argument>)</argument_list> const <name>override</name> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>DWARF_Private</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>DWARF_Local</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>AddressSpace</name> <operator>==</operator> <name>Private</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>DWARF_Private</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>AddressSpace</name> <operator>==</operator> <name>Local</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>DWARF_Local</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><name>None</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>CallingConvCheckResult</name></type> <name>checkCallingConvention</name><argument_list>(<argument><expr><name>CallingConv</name> <name>CC</name></expr></argument>)</argument_list> const <name>override</name> <block>{<block_content>
<switch>switch <condition>(<expr><name>CC</name></expr>)</condition> <block>{<block_content>
<default>default:</default>
<return>return <expr><name>CCCR_Warning</name></expr>;</return>
<case>case <expr><name>CC_C</name></expr>:</case>
<case>case <expr><name>CC_OpenCLKernel</name></expr>:</case>
<return>return <expr><name>CCCR_OK</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name>uint64_t</name></type> <name>getNullPointerValue</name><argument_list>(<argument><expr><name>LangAS</name> <name>AS</name></expr></argument>)</argument_list> const <name>override</name> <block>{<block_content>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>AS</name> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>opencl_local</name> <operator>||</operator> <name>AS</name> <operator>==</operator> <name>LangAS</name><operator>::</operator><name>opencl_private</name><operator>)</operator></expr>
?</condition><then> <expr><operator>~</operator><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>setAuxTarget</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TargetInfo</name> <operator>*</operator><name>Aux</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasExtIntType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block></expr></expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>handleTargetFeatures</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Features</name></expr></argument>,
<argument><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diags</name></expr></argument>)</argument_list> <name>override</name> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>TargetIDFeatures</name> <init>=
<expr><call><name>getAllPossibleTargetIDFeatures</name><argument_list>(<argument><expr><call><name>getTriple</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getArchNameAMDGCN</name><argument_list>(<argument><expr><name>GPUKind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><call><name>for_each</name><argument_list>(<argument><expr><name>Features</name></expr></argument>, <argument><expr><index>[<expr><operator>&amp;</operator></expr>]</index><operator>(</operator><specifier>const</specifier> <name>auto</name> <operator>&amp;</operator><name>F</name><operator>)</operator> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>F</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <call><name><name>F</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>F</name> <operator>==</operator> <literal type="string">"+wavefrontsize64"</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>WavefrontSize</name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<name>bool</name> <name>IsOn</name> <operator>=</operator> <call><name><name>F</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">'+'</literal></block></expr></argument>;
<argument><expr><name>StringRef</name> <name>Name</name> <operator>=</operator> <call><name>StringRef</name><argument_list>(<argument><expr><name>F</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>drop_front</name><argument_list>()</argument_list></call></expr></argument>;
if <argument><expr><operator>(</operator><name>llvm</name><operator>::</operator><call><name>find</name><argument_list>(<argument><expr><name>TargetIDFeatures</name></expr></argument>, <argument><expr><name>Name</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name><name>TargetIDFeatures</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>
<return>return;</return></argument_list></call></expr></expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>OffloadArchFeatures</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>Name</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name><name>OffloadArchFeatures</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>OffloadArchFeatures</name><index>[<expr><name>Name</name></expr>]</index></name> <operator>=</operator> <name>IsOn</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>)<empty_stmt>;</empty_stmt>
<return>return <expr><name>true</name></expr>;</return>
}

Optional<expr_stmt><expr><operator>&lt;</operator><name>std</name><operator>::</operator><name>string</name><operator>&gt;</operator> <macro><name>getTargetID</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isAMDGCN</name><argument_list>(<argument><expr><call><name>getTriple</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>llvm</name><operator>::</operator><name>None</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>


<if_stmt><if>if <condition>(<expr><name>GPUKind</name> <operator>==</operator> <name>llvm</name><operator>::</operator><name>AMDGPU</name><operator>::</operator><name>GK_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getCanonicalTargetID</name><argument_list>(<argument><expr><call><name>getArchNameAMDGCN</name><argument_list>(<argument><expr><name>GPUKind</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>OffloadArchFeatures</name></expr></argument>)</argument_list></call></expr>;</return>
}
}<empty_stmt>;</empty_stmt>

}
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
