<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/lib/CodeGen/CodeGenFunction.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_LIB_CODEGEN_CODEGENFUNCTION_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_LIB_CODEGEN_CODEGENFUNCTION_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"CGBuilder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"CGDebugInfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"CGLoopInfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"CGValue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"CodeGenModule.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"CodeGenPGO.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"EHScopeStack.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"VarBypassDetector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/CharUnits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/CurrentSourceLocExprScope.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprOpenMP.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtOpenMP.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/ABI.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/CapturedStmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/CodeGenOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenMPKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TargetInfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/MapVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Frontend/OpenMP/OMPIRBuilder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/IR/ValueHandle.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Debug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Transforms/Utils/SanitizerStats.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>BasicBlock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LLVMContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MDNode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Module</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SwitchInst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Twine</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CanonicalLoopInfo</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BlockDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXDestructorDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXForRangeStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXTryStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Decl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LabelDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>EnumConstantDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionProtoType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LabelStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCContainerDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCInterfaceDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCIvarDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCMethodDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCImplementationDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCPropertyImplDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TargetInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VarDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCForCollectionStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCAtTryStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCAtThrowStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCAtSynchronizedStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCAutoreleasePoolStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>OMPUseDevicePtrClause</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>OMPUseDeviceAddrClause</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ReturnsNonNullAttr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SVETypeFlags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>OMPExecutableDirective</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>analyze_os_log</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>OSLogBufferLayout</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>CodeGen</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>CodeGenTypes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CGCallee</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CGFunctionInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CGRecordLayout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CGBlockInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CGCXXABI</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BlockByrefHelpers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BlockByrefInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BlockFlags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BlockFieldFlags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>RegionCodeGenTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TargetCodeGenInfo</name></decl>;</decl_stmt>
<struct_decl>struct <name>OMPTaskDataTy</name>;</struct_decl>
<struct_decl>struct <name>CGCoroData</name>;</struct_decl>






<enum>enum <name>TypeEvaluationKind</name> <block>{
<decl><name>TEK_Scalar</name></decl>,
<decl><name>TEK_Complex</name></decl>,
<decl><name>TEK_Aggregate</name></decl>
}</block>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIST_SANITIZER_CHECKS</name></cpp:macro> <cpp:value>SANITIZER_CHECK(AddOverflow, add_overflow, 0) SANITIZER_CHECK(BuiltinUnreachable, builtin_unreachable, 0) SANITIZER_CHECK(CFICheckFail, cfi_check_fail, 0) SANITIZER_CHECK(DivremOverflow, divrem_overflow, 0) SANITIZER_CHECK(DynamicTypeCacheMiss, dynamic_type_cache_miss, 0) SANITIZER_CHECK(FloatCastOverflow, float_cast_overflow, 0) SANITIZER_CHECK(FunctionTypeMismatch, function_type_mismatch, 1) SANITIZER_CHECK(ImplicitConversion, implicit_conversion, 0) SANITIZER_CHECK(InvalidBuiltin, invalid_builtin, 0) SANITIZER_CHECK(InvalidObjCCast, invalid_objc_cast, 0) SANITIZER_CHECK(LoadInvalidValue, load_invalid_value, 0) SANITIZER_CHECK(MissingReturn, missing_return, 0) SANITIZER_CHECK(MulOverflow, mul_overflow, 0) SANITIZER_CHECK(NegateOverflow, negate_overflow, 0) SANITIZER_CHECK(NullabilityArg, nullability_arg, 0) SANITIZER_CHECK(NullabilityReturn, nullability_return, 1) SANITIZER_CHECK(NonnullArg, nonnull_arg, 0) SANITIZER_CHECK(NonnullReturn, nonnull_return, 1) SANITIZER_CHECK(OutOfBounds, out_of_bounds, 0) SANITIZER_CHECK(PointerOverflow, pointer_overflow, 0) SANITIZER_CHECK(ShiftOutOfBounds, shift_out_of_bounds, 0) SANITIZER_CHECK(SubOverflow, sub_overflow, 0) SANITIZER_CHECK(TypeMismatch, type_mismatch, 1) SANITIZER_CHECK(AlignmentAssumption, alignment_assumption, 0) SANITIZER_CHECK(VLABoundNotPositive, vla_bound_not_positive, 0)</cpp:value></cpp:define>


























<enum>enum <name>SanitizerHandler</name> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SANITIZER_CHECK</name><parameter_list>(<parameter><type><name>Enum</name></type></parameter>, <parameter><type><name>Name</name></type></parameter>, <parameter><type><name>Version</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Enum,</cpp:value></cpp:define>
<decl><name>LIST_SANITIZER_CHECKS</name></decl>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SANITIZER_CHECK</name></cpp:undef>
}</block>;</enum>



<struct>struct <name>DominatingLLVMValue</name> <block>{
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>saved_type</name></expr>;</expr_stmt></typedef>


<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>needsSaving</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>)</argument_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Instruction</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>block</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Instruction</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getParent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>block</name> <operator>!=</operator> <operator>&amp;</operator><call><name><name>block</name><operator>-&gt;</operator><name>getParent</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEntryBlock</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>saved_type</name></type> <name>save</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><specifier>static</specifier> <name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>restore</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>saved_type value</argument>)</argument_list></macro></expr>;</expr_stmt>
}</block>;</struct>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> struct</type> <name><name>DominatingPointer</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>,<argument><expr><name>true</name></expr></argument>&gt;</argument_list></name> <range>: <expr><name>DominatingLLVMValue</name> <block>{
<typedef>typedef <type><name>T</name> <modifier>*</modifier></type><name>type</name>;</typedef>
<specifier>static</specifier> <name>type</name> <macro><name>restore</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>saved_type value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DominatingLLVMValue</name><operator>::</operator><call><name>restore</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</block></expr></range></decl></decl_stmt><empty_stmt>;</empty_stmt>


<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>DominatingValue</name><argument_list type="generic">&lt;<argument><expr><name>Address</name></expr></argument>&gt;</argument_list></name> <block>{
<typedef>typedef <type><name>Address</name></type> <name>type</name>;</typedef>

struct <name>saved_type</name> <block>{
<expr><name>DominatingLLVMValue</name><operator>::</operator><name>saved_type</name> <name>SavedValue</name></expr>;
<expr><name>CharUnits</name> <name>Alignment</name></expr>;
}</block></block></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>needsSaving</name><parameter_list>(<parameter><decl><type><name>type</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>DominatingLLVMValue</name><operator>::</operator><call><name>needsSaving</name><argument_list>(<argument><expr><call><name><name>value</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>saved_type</name></type> <name>save</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>type</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><block>{ <expr><name>DominatingLLVMValue</name><operator>::</operator><call><name>save</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>, <argument><expr><call><name><name>value</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>value</name></macro><expr><operator>.</operator><macro><name>getAlignment</name><argument_list>()</argument_list></macro></expr> }</block></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>type</name></type> <name>restore</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>saved_type</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>Address</name><argument_list>(<argument><expr><name>DominatingLLVMValue</name><operator>::</operator><call><name>restore</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>, <argument><expr><name><name>value</name><operator>.</operator><name>SavedValue</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>value</name><operator>.</operator><name>Alignment</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>DominatingValue</name><argument_list type="generic">&lt;<argument><expr><name>RValue</name></expr></argument>&gt;</argument_list></name> <block>{
<typedef>typedef <type><name>RValue</name></type> <name>type</name>;</typedef>
<name>class</name> <name>saved_type</name> <block>{
enum <expr><name>Kind</name> <block>{ <expr><name>ScalarLiteral</name></expr>, <expr><name>ScalarAddress</name></expr>, <expr><name>AggregateLiteral</name></expr>,
<expr><name>AggregateAddress</name></expr>, <expr><name>ComplexAddress</name></expr> }</block></expr>;

<expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Value</name></expr>;
<expr><name>unsigned</name> <name>K</name> <operator>:</operator> <literal type="number">3</literal></expr>;
<expr><name>unsigned</name> <name>Align</name> <operator>:</operator> <literal type="number">29</literal></expr>;
<macro><name>saved_type</name><argument_list>(<argument>llvm::Value *v</argument>, <argument>Kind k</argument>, <argument>unsigned a = <literal type="number">0</literal></argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Value</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>K</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>, <macro><name>Align</name><argument_list>(<argument>a</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>bool</name> <macro><name>needsSaving</name><argument_list>(<argument>RValue value</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>saved_type</name> <macro><name>save</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>RValue value</argument>)</argument_list></macro></expr>;
<expr><name>RValue</name> <call><name>restore</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>)</argument_list></call></expr>;


}</block></block></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>needsSaving</name><parameter_list>(<parameter><decl><type><name>type</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>saved_type</name><operator>::</operator><call><name>needsSaving</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>saved_type</name></type> <name>save</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>type</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>saved_type</name><operator>::</operator><call><name>save</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>type</name></type> <name>restore</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>saved_type</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>value</name><operator>.</operator><name>restore</name></name><argument_list>(<argument><expr><name>CGF</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>CodeGenFunction</name> <range>: <expr><name>public</name> <name>CodeGenTypeCache</name> <block>{
<expr><call><name>CodeGenFunction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CodeGenFunction</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><name>void</name> <name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>CodeGenFunction</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr>;

<expr><name>friend</name> <name>class</name> <name>CGCXXABI</name></expr>;
<expr><name>public</name><operator>:</operator>


struct <name>JumpDest</name> <block>{
<expr><call><name>JumpDest</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>Block</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ScopeDepth</name><argument_list>()</argument_list></call></expr>, <macro><name>Index</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro> <expr><block>{}</block>
<macro><name>JumpDest</name><argument_list>(<argument>llvm::BasicBlock *Block</argument>,
<argument>EHScopeStack::stable_iterator Depth</argument>,
<argument>unsigned Index</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Block</name><argument_list>(<argument><expr><name>Block</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ScopeDepth</name><argument_list>(<argument><expr><name>Depth</name></expr></argument>)</argument_list></call></expr>, <macro><name>Index</name><argument_list>(<argument>Index</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>isValid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Block</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block>
<name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><macro><name>getBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Block</name></expr>;</return> }</block>
<name>EHScopeStack</name><operator>::</operator><name>stable_iterator</name> <macro><name>getScopeDepth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ScopeDepth</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>getDestIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Index</name></expr>;</return> }</block>


<name>void</name> <macro><name>setScopeDepth</name><argument_list>(<argument>EHScopeStack::stable_iterator depth</argument>)</argument_list></macro> <block>{
<expr><name>ScopeDepth</name> <operator>=</operator> <name>depth</name></expr>;
}</block>

<name>private</name><operator>:</operator>
<name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>Block</name></expr>;
<expr><name>EHScopeStack</name><operator>::</operator><name>stable_iterator</name> <name>ScopeDepth</name></expr>;
<expr><name>unsigned</name> <name>Index</name></expr>;
}</block></expr>;

<expr><name>CodeGenModule</name> <operator>&amp;</operator><name>CGM</name></expr>;
<expr><specifier>const</specifier> <name>TargetInfo</name> <operator>&amp;</operator><name>Target</name></expr>;


<expr><name>CodeGenFunction</name> <operator>*</operator><name>ParentCGF</name> <operator>=</operator> <name>nullptr</name></expr>;

<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ComplexPairTy</name></expr>;</expr_stmt></typedef>
<name>LoopInfoStack</name> <name>LoopStack</name></block></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CGBuilderTy</name></type> <name>Builder</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>VarBypassDetector</name></type> <name>Bypasses</name></decl>;</decl_stmt>













<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>CanonicalLoopInfo</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>OMPLoopNestStack</name></decl>;</decl_stmt>


<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>CodeGenFunction</name> <operator>&amp;</operator>, <specifier>const</specifier> <name>OMPLoopDirective</name> <operator>&amp;</operator>,
<name>JumpDest</name><operator>)</operator></expr></argument>&gt;</argument_list></name>
<name>CodeGenLoopTy</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>CodeGenFunction</name> <operator>&amp;</operator>, <name>SourceLocation</name>,
<specifier>const</specifier> <name>unsigned</name>, <specifier>const</specifier> <name>bool</name><operator>)</operator></expr></argument>&gt;</argument_list></name>
<name>CodeGenOrderedTy</name></expr>;</expr_stmt></typedef>


<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>LValue</name></expr></argument>, <argument><expr><name>LValue</name></expr></argument>&gt;</argument_list></name><operator>(</operator>
<name>CodeGenFunction</name> <operator>&amp;</operator>, <specifier>const</specifier> <name>OMPExecutableDirective</name> <operator>&amp;</operator><name>S</name><operator>)</operator></expr></argument>&gt;</argument_list></name>
<name>CodeGenLoopBoundsTy</name></expr>;</expr_stmt></typedef>


<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>(</operator>
<name>CodeGenFunction</name> <operator>&amp;</operator>, <specifier>const</specifier> <name>OMPExecutableDirective</name> <operator>&amp;</operator><name>S</name>, <name>Address</name> <name>LB</name>,
<name>Address</name> <name>UB</name><operator>)</operator></expr></argument>&gt;</argument_list></name>
<name>CodeGenDispatchBoundsTy</name></expr>;</expr_stmt></typedef>



<decl_stmt><decl><type><name>void</name></type> <name>InsertHelper</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Instruction</name> <operator>*</operator><name>I</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>Twine</name> <operator>&amp;</operator><name>Name</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>BB</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name><operator>::</operator><name>iterator</name> <name>InsertPt</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>CurFuncDecl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>CurCodeDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>CGFunctionInfo</name> <modifier>*</modifier></type><name>CurFnInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>FnRetTy</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>CurFn</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ParmVarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>FnArgs</name></expr>;</expr_stmt>




<struct>struct <name>CGCoroInfo</name> <block>{
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CGCoroData</name></expr></argument>&gt;</argument_list></name> <name>Data</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CGCoroInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>~</operator><call><name>CGCoroInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name>CGCoroInfo</name></type> <name>CurCoro</name></decl>;</decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isCoroutine</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CurCoro</name><operator>.</operator><name>Data</name></name> <operator>!=</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>GlobalDecl</name></type> <name>CurGD</name></decl>;</decl_stmt>



<expr_stmt><expr><name>EHScopeStack</name><operator>::</operator><name>stable_iterator</name> <name>PrologueCleanupDepth</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>JumpDest</name></type> <name>ReturnBlock</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>Address</name></type> <name>ReturnValue</name> <init>= <expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>Address</name></type> <name>ReturnValuePointer</name> <init>= <expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>RetExpr</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasLabelBeenSeenInCurrentScope</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>CurLexicalScope</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>CurLexicalScope</name><operator>-&gt;</operator><name>hasLabels</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><operator>!</operator><call><name><name>LabelMap</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return>
}



llvm<expr_stmt><expr><operator>::</operator><name><name>AssertingVH</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Instruction</name></expr></argument>&gt;</argument_list></name> <name>AllocaInsertPt</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>CGCapturedStmtInfo</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <macro><name>CGCapturedStmtInfo</name><argument_list>(<argument>CapturedRegionKind K = CR_Default</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Kind</name><argument_list>(<argument><expr><name>K</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ThisValue</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>CXXThisFieldDecl</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{}</block>
<name>explicit</name> <macro><name>CGCapturedStmtInfo</name><argument_list>(<argument>const CapturedStmt &amp;S</argument>,
<argument>CapturedRegionKind K = CR_Default</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>K</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ThisValue</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>CXXThisFieldDecl</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{

<expr><name>RecordDecl</name><operator>::</operator><name>field_iterator</name> <name>Field</name> <operator>=</operator>
<call><name><name>S</name><operator>.</operator><name>getCapturedRecordDecl</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>field_begin</name><argument_list>()</argument_list></call></expr>;
<for>for <control>(<init><expr><name>CapturedStmt</name><operator>::</operator><name>const_capture_iterator</name> <name>I</name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>capture_begin</name></name><argument_list>()</argument_list></call></expr><operator>,</operator>
<expr><name>E</name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>capture_end</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>I</name> <operator>!=</operator> <name>E</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr><operator>,</operator> <expr><operator>++</operator><name>Field</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>I</name><operator>-&gt;</operator><name>capturesThis</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>CXXThisFieldDecl</name> <operator>=</operator> <operator>*</operator><name>Field</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name><name>I</name><operator>-&gt;</operator><name>capturesVariable</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>CaptureFields</name><index>[<expr><call><name><name>I</name><operator>-&gt;</operator><name>getCapturedVar</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>Field</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name><name>I</name><operator>-&gt;</operator><name>capturesVariableByCopy</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>CaptureFields</name><index>[<expr><call><name><name>I</name><operator>-&gt;</operator><name>getCapturedVar</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getCanonicalDecl</name><argument_list>()</argument_list></call></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>Field</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt/>}</block_content>
}

virtual ~CGCapturedStmtInfo(</block></for>)</block></expr>;</expr_stmt>

<expr_stmt><expr><name>CapturedRegionKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>setContextValue</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>V</name></expr></argument>)</argument_list> <block>{<block_content> <expr_stmt><expr><name>ThisValue</name> <operator>=</operator> <name>V</name></expr>;</expr_stmt> </block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>getContextValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ThisValue</name></expr>;</return> }</block></expr></expr_stmt>


<decl_stmt><decl><type><name>virtual</name> <specifier>const</specifier> <name>FieldDecl</name> <modifier>*</modifier></type><name>lookup</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>CaptureFields</name><operator>.</operator><name>lookup</name></name><argument_list>(<argument><expr><call><name><name>VD</name><operator>-&gt;</operator><name>getCanonicalDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isCXXThisExprCaptured</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getThisFieldDecl</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>virtual</name> <name>FieldDecl</name> <operator>*</operator><macro><name>getThisFieldDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CXXThisFieldDecl</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CGCapturedStmtInfo</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>virtual</name> <name>void</name></type> <name>EmitBody</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>incrementProfileCounter</name></name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>EmitStmt</name></name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>virtual</name> <name>StringRef</name> <macro><name>getHelperName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><literal type="string">"__captured_stmt"</literal></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>CapturedRegionKind</name></type> <name>Kind</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallDenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>FieldDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CaptureFields</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>ThisValue</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>CXXThisFieldDecl</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<decl_stmt><decl><type><name>CGCapturedStmtInfo</name> <modifier>*</modifier></type><name>CapturedStmtInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>CGCapturedStmtRAII</name> <block>{<block_content>
<label><name>private</name>:</label>
<decl_stmt><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CGCapturedStmtInfo</name> <modifier>*</modifier></type><name>PrevCapturedStmtInfo</name></decl>;</decl_stmt>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>CGCapturedStmtRAII</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><name>CGCapturedStmtInfo</name> <operator>*</operator><name>NewCapturedStmtInfo</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>CGF</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>PrevCapturedStmtInfo</name><argument_list>(<argument>CGF.CapturedStmtInfo</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CGF</name><operator>.</operator><name>CapturedStmtInfo</name></name> <operator>=</operator> <name>NewCapturedStmtInfo</name></expr>;
}</block>
<operator>~</operator><macro><name>CGCapturedStmtRAII</name><argument_list>()</argument_list></macro> <block>{ <expr><name><name>CGF</name><operator>.</operator><name>CapturedStmtInfo</name></name> <operator>=</operator> <name>PrevCapturedStmtInfo</name></expr>; }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>AbstractCallee</name> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>CalleeDecl</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>AbstractCallee</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>CalleeDecl</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <block>{}</block>
<call><name>AbstractCallee</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>FD</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>CalleeDecl</name><argument_list>(<argument>FD</argument>)</argument_list></macro> <block>{}</block>
<call><name>AbstractCallee</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCMethodDecl</name> <operator>*</operator><name>OMD</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>CalleeDecl</name><argument_list>(<argument>OMD</argument>)</argument_list></macro> <block>{}</block>
<name>bool</name> <macro><name>hasFunctionDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CalleeDecl</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CalleeDecl</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getNumParams</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>FD</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CalleeDecl</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>FD</name><operator>-&gt;</operator><name>getNumParams</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CalleeDecl</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>param_size</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ParmVarDecl</name> <modifier>*</modifier></type><name>getParamDecl</name><argument_list>(<argument><expr><name>unsigned</name> <name>I</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>FD</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CalleeDecl</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>FD</name><operator>-&gt;</operator><name>getParamDecl</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>*</operator><operator>(</operator><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CalleeDecl</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>param_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <name>I</name><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>
};


<decl_stmt><decl><type><name>SanitizerSet</name></type> <name>SanOpts</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>IsSanitizerScope</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>SanitizerScope</name> <block>{<block_content>
<decl_stmt><decl><type><name>CodeGenFunction</name> <modifier>*</modifier></type><name>CGF</name></decl>;</decl_stmt>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>SanitizerScope</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>*</operator><name>CGF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>~</operator><call><name>SanitizerScope</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>CurFuncIsThunk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>AutoreleaseResult</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>SawAsmBlock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>CurSEHParent</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>IsOutlinedSEHHelper</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>IsInPreservedAIRegion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>InNoMergeAttributedStmt</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>MustTailCall</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>



<function><type><name>bool</name></type> <name>checkIfFunctionMustProgress</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>CGM</name><operator>.</operator><name>getCodeGenOpts</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getFiniteLoops</name><argument_list>()</argument_list></call> <operator>==</operator>
<name>CodeGenOptions</name><operator>::</operator><name>FiniteLoopsKind</name><operator>::</operator><name>Never</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>









<return>return <expr><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>CPlusPlus11</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>bool</name></type> <name>checkIfLoopMustProgress</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>HasConstantCond</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>CGM</name><operator>.</operator><name>getCodeGenOpts</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getFiniteLoops</name><argument_list>()</argument_list></call> <operator>==</operator>
<name>CodeGenOptions</name><operator>::</operator><name>FiniteLoopsKind</name><operator>::</operator><name>Always</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>CGM</name><operator>.</operator><name>getCodeGenOpts</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getFiniteLoops</name><argument_list>()</argument_list></call> <operator>==</operator>
<name>CodeGenOptions</name><operator>::</operator><name>FiniteLoopsKind</name><operator>::</operator><name>Never</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name>checkIfFunctionMustProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>HasConstantCond</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>C11</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>CodeGen</name><operator>::</operator><name>CGBlockInfo</name> <operator>*</operator><name>BlockInfo</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>BlockPointer</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>FieldDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>LambdaCaptureFields</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>LambdaThisCaptureField</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>NRVOFlags</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>EHScopeStack</name></type> <name>EHStack</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>&gt;</argument_list></name> <name>LifetimeExtendedCleanupStack</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>JumpDest</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>SEHTryEpilogueStack</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Instruction</name> <operator>*</operator><name>CurrentFuncletPad</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>class</name> <name>CallLifetimeEnd</name></type> <name>final</name> <range>: <expr><name>public</name> <name>EHScopeStack</name><operator>::</operator><name>Cleanup</name> <block>{
<expr><name>bool</name> <macro><name>isRedundantBeforeReturn</name><argument_list>()</argument_list></macro> <name>override</name> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>

<name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Addr</name></expr>;
<expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Size</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>CallLifetimeEnd</name><argument_list>(<argument>Address addr</argument>, <argument>llvm::Value *size</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Addr</name><argument_list>(<argument><expr><call><name><name>addr</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>, <macro><name>Size</name><argument_list>(<argument>size</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>Emit</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>Flags flags</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>CGF</name><operator>.</operator><name>EmitLifetimeEnd</name></name><argument_list>(<argument><expr><name>Size</name></expr></argument>, <argument><expr><name>Addr</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>
}</block></expr></range></decl>;</decl_stmt>


<struct>struct <name>LifetimeExtendedCleanupHeader</name> <block>{

<decl_stmt><decl><type><name>unsigned</name></type> <name>Size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>Kind</name> <range>: <expr><literal type="number">31</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>IsConditional</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<expr_stmt><expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Size</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>CleanupKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>CleanupKind</name><operator>)</operator><name>Kind</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isConditional</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsConditional</name></expr>;</return> }</block></expr></expr_stmt>
}</block>;</struct>


<decl_stmt><decl><type><name>Address</name></type> <name>NormalCleanupDest</name> <init>= <expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>NextCleanupDestIndex</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>EHResumeBlock</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>ExceptionSlot</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>AllocaInst</name> <operator>*</operator><name>EHSelectorSlot</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Address</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name></type> <name>SEHCodeSlotStack</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>SEHInfo</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><call><name>EmitLandingPad</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><call><name>getInvokeDestImpl</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>*</modifier></type><name>OMPParentLoopDirectiveForScan</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>OMPBeforeScanBlock</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>OMPAfterScanBlock</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>OMPScanExitBlock</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>OMPScanDispatch</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>OMPFirstScanLoop</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>ParentLoopDirectiveForScanRegion</name> <block>{<block_content>
<decl_stmt><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>*</modifier></type><name>ParentLoopDirectiveForScan</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>ParentLoopDirectiveForScanRegion</name><argument_list>(
<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPExecutableDirective</name> <operator>&amp;</operator><name>ParentLoopDirectiveForScan</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>CGF</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>ParentLoopDirectiveForScan</name><argument_list>(<argument>CGF.OMPParentLoopDirectiveForScan</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CGF</name><operator>.</operator><name>OMPParentLoopDirectiveForScan</name></name> <operator>=</operator> <operator>&amp;</operator><name>ParentLoopDirectiveForScan</name></expr>;
}</block>
<operator>~</operator><macro><name>ParentLoopDirectiveForScanRegion</name><argument_list>()</argument_list></macro> <block>{
<expr><name><name>CGF</name><operator>.</operator><name>OMPParentLoopDirectiveForScan</name></name> <operator>=</operator> <name>ParentLoopDirectiveForScan</name></expr>;
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name><name>DominatingValue</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>saved_type</name> <macro><name>saveValueInCond</name><argument_list>(<argument>T value</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>DominatingValue</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>save</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CGFPOptionsRAII</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>CGFPOptionsRAII</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>FPOptions FPFeatures</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>CGFPOptionsRAII</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>~</operator><call><name>CGFPOptionsRAII</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>private</name>:</label>
<function_decl><type><name>void</name></type> <name>ConstructorHelper</name><parameter_list>(<parameter><decl><type><name>FPOptions</name></type> <name>FPFeatures</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FPOptions</name></type> <name>OldFPFeatures</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>fp</name><operator>::</operator><name>ExceptionBehavior</name> <name>OldExcept</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>RoundingMode</name> <name>OldRounding</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>CGBuilderTy</name><operator>::</operator><name>FastMathFlagGuard</name></expr></argument>&gt;</argument_list></name></type> <name>FMFGuard</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<decl_stmt><decl><type><name>FPOptions</name></type> <name>CurFPFeatures</name></decl>;</decl_stmt>

<label><name>public</name>:</label>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>ObjCEHValueStack</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>FinallyInfo</name> <block>{<block_content>

<decl_stmt><decl><type><name>JumpDest</name></type> <name>RethrowDest</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>BeginCatchFn</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>AllocaInst</name> <operator>*</operator><name>ForEHVar</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>AllocaInst</name> <operator>*</operator><name>SavedExnVar</name></expr>;</expr_stmt>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>void</name></type> <name>enter</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>Finally</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>beginCatchFn</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>endCatchFn</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>rethrowFn</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>exit</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>)</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isSEHTryScope</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name><name>SEHTryEpilogueStack</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isCleanupPadScope</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>CurrentFuncletPad</name> <operator>&amp;&amp;</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>CleanupPadInst</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CurrentFuncletPad</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>, <argument><expr><name>class</name><modifier>...</modifier> <name>As</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>pushFullExprCleanup</name><parameter_list>(<parameter><decl><type><name>CleanupKind</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>As</name><modifier>...</modifier></type> <name>A</name></decl></parameter>)</parameter_list> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isInConditionalBranch</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>EHStack</name><operator>.</operator><name>pushCleanup</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>kind</name><operator>,</operator> <name>A</name><operator>...</operator><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>


<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name><name>DominatingValue</name><argument_list type="generic">&lt;<argument><expr><name>As</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>saved_type</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name> <name>SavedTuple</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>SavedTuple</name></type> <name>Saved</name><block>{<block_content><expr><call><name>saveValueInCond</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call><operator>...</operator></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<typedef>typedef <expr_stmt><expr><name>EHScopeStack</name><operator>::</operator><name><name>ConditionalCleanup</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>As</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name> <name>CleanupType</name></expr>;</expr_stmt></typedef>
<expr_stmt><expr><name><name>EHStack</name><operator>.</operator><name>pushCleanupTuple</name></name><operator>&lt;</operator><name>CleanupType</name><operator>&gt;</operator><operator>(</operator><name>kind</name><operator>,</operator> <name>Saved</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>initFullExprCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>, <argument><expr><name>class</name><modifier>...</modifier> <name>As</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>pushCleanupAfterFullExpr</name><parameter_list>(<parameter><decl><type><name>CleanupKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>As</name><modifier>...</modifier></type> <name>A</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isInConditionalBranch</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>pushCleanupAfterFullExprWithActiveFlag</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>A</name><operator>...</operator></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>Address</name></type> <name>ActiveFlag</name> <init>= <expr><call><name>createCleanupActiveFlag</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>DominatingValue</name><argument_list type="generic">&lt;<argument><expr><name>Address</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>needsSaving</name><argument_list>(<argument><expr><name>ActiveFlag</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"cleanup active flag should never need saving"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name><name>DominatingValue</name><argument_list type="generic">&lt;<argument><expr><name>As</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>saved_type</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name> <name>SavedTuple</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>SavedTuple</name></type> <name>Saved</name><block>{<block_content><expr><call><name>saveValueInCond</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call><operator>...</operator></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<typedef>typedef <expr_stmt><expr><name>EHScopeStack</name><operator>::</operator><name><name>ConditionalCleanup</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>As</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name> <name>CleanupType</name></expr>;</expr_stmt></typedef>
<expr_stmt><expr><call><name><name>pushCleanupAfterFullExprWithActiveFlag</name><argument_list type="generic">&lt;<argument><expr><name>CleanupType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>ActiveFlag</name></expr></argument>, <argument><expr><name>Saved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>, <argument><expr><name>class</name><modifier>...</modifier> <name>As</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>pushCleanupAfterFullExprWithActiveFlag</name><parameter_list>(<parameter><decl><type><name>CleanupKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>Address</name></type> <name>ActiveFlag</name></decl></parameter>, <parameter><decl><type><name>As</name><modifier>...</modifier></type> <name>A</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>LifetimeExtendedCleanupHeader</name></type> <name>Header</name> <init>= <expr><block>{<expr><sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>Kind</name></expr>,
<macro><name>ActiveFlag</name></macro><expr><operator>.</operator><macro><name>isValid</name><argument_list>()</argument_list></macro></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>OldSize</name> <init>= <expr><call><name><name>LifetimeExtendedCleanupStack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>LifetimeExtendedCleanupStack</name><operator>.</operator><name>resize</name></name><argument_list>(
<argument><expr><call><name><name>LifetimeExtendedCleanupStack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Header</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>Header</name><operator>.</operator><name>Size</name></name> <operator>+</operator>
<operator>(</operator><ternary><condition><expr><name><name>Header</name><operator>.</operator><name>IsConditional</name></name></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>ActiveFlag</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Header</name></expr></argument>)</argument_list></sizeof> <operator>%</operator> <call><name>alignof</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><literal type="string">"Cleanup will be allocated on misaligned address"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>Buffer</name> <init>= <expr><operator>&amp;</operator><name><name>LifetimeExtendedCleanupStack</name><index>[<expr><name>OldSize</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<macro><name>new</name> <argument_list>(<argument>Buffer</argument>)</argument_list></macro> <expr_stmt><expr><call><name>LifetimeExtendedCleanupHeader</name><argument_list>(<argument><expr><name>Header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>new</name> <argument_list>(<argument>Buffer + sizeof(Header)</argument>)</argument_list></macro> <expr_stmt><expr><call><name>T</name><argument_list>(<argument><expr><name>A</name><operator>...</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>Header</name><operator>.</operator><name>IsConditional</name></name></expr>)</condition><block type="pseudo"><block_content>
<macro><name>new</name> <argument_list>(<argument>Buffer + sizeof(Header) + sizeof(T)</argument>)</argument_list></macro> <expr_stmt><expr><call><name>Address</name><argument_list>(<argument><expr><name>ActiveFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>initFullExprCleanup</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>initFullExprCleanupWithFlag</name><argument_list>(<argument><expr><call><name>createCleanupActiveFlag</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>initFullExprCleanupWithFlag</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>ActiveFlag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Address</name></type> <name>createCleanupActiveFlag</name><parameter_list>()</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type> <name>PushDestructorCleanup</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>Addr</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>PushDestructorCleanup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>Dtor</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>Address</name></type> <name>Addr</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>PopCleanupBlock</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>FallThroughIsBranchThrough</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>









<decl_stmt><decl><type><name>void</name></type> <name>DeactivateCleanupBlock</name><argument_list>(<argument><expr><name>EHScopeStack</name><operator>::</operator><name>stable_iterator</name> <name>Cleanup</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Instruction</name> <operator>*</operator><name>DominatingIP</name></expr></argument>)</argument_list></decl>;</decl_stmt>








<decl_stmt><decl><type><name>void</name></type> <name>ActivateCleanupBlock</name><argument_list>(<argument><expr><name>EHScopeStack</name><operator>::</operator><name>stable_iterator</name> <name>Cleanup</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Instruction</name> <operator>*</operator><name>DominatingIP</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>RunCleanupsScope</name> <block>{<block_content>
<expr_stmt><expr><name>EHScopeStack</name><operator>::</operator><name>stable_iterator</name> <name>CleanupStackDepth</name></expr><operator>,</operator> <expr><name>OldCleanupScopeDepth</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>LifetimeExtendedCleanupStackSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>OldDidCallStackSave</name></decl>;</decl_stmt>
<label><name>protected</name>:</label>
<decl_stmt><decl><type><name>bool</name></type> <name>PerformCleanup</name></decl>;</decl_stmt>
<label><name>private</name>:</label>

<expr_stmt><expr><call><name>RunCleanupsScope</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RunCleanupsScope</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>RunCleanupsScope</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>

<label><name>protected</name>:</label>
<decl_stmt><decl><type><name>CodeGenFunction</name><modifier>&amp;</modifier></type> <name>CGF</name></decl>;</decl_stmt>

<label><name>public</name>:</label>

<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>RunCleanupsScope</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>PerformCleanup</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>CGF</name><argument_list>(<argument>CGF</argument>)</argument_list></macro>
<expr><block>{
<expr><name>CleanupStackDepth</name> <operator>=</operator> <call><name><name>CGF</name><operator>.</operator><name>EHStack</name><operator>.</operator><name>stable_begin</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>LifetimeExtendedCleanupStackSize</name> <operator>=</operator>
<call><name><name>CGF</name><operator>.</operator><name>LifetimeExtendedCleanupStack</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>OldDidCallStackSave</name> <operator>=</operator> <name><name>CGF</name><operator>.</operator><name>DidCallStackSave</name></name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>DidCallStackSave</name></name> <operator>=</operator> <name>false</name></expr>;
<expr><name>OldCleanupScopeDepth</name> <operator>=</operator> <name><name>CGF</name><operator>.</operator><name>CurrentCleanupScopeDepth</name></name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>CurrentCleanupScopeDepth</name></name> <operator>=</operator> <name>CleanupStackDepth</name></expr>;
}</block>


<operator>~</operator><macro><name>RunCleanupsScope</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>PerformCleanup</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ForceCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>requiresCleanups</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>CGF</name><operator>.</operator><name>EHStack</name><operator>.</operator><name>stable_begin</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>CleanupStackDepth</name></expr>;</return>
}</block></expr></expr_stmt>







<decl_stmt><decl><type><name>void</name></type> <name>ForceCleanup</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>initializer_list</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name><operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ValuesToReload</name> <operator>=</operator> <block>{}</block></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>PerformCleanup</name> <operator>&amp;&amp;</operator> <literal type="string">"Already forced cleanup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>CGF</name><operator>.</operator><name>DidCallStackSave</name></name> <operator>=</operator> <name>OldDidCallStackSave</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>PopCleanupBlocks</name></name><argument_list>(<argument><expr><name>CleanupStackDepth</name></expr></argument>, <argument><expr><name>LifetimeExtendedCleanupStackSize</name></expr></argument>,
<argument><expr><name>ValuesToReload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>PerformCleanup</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>CGF</name><operator>.</operator><name>CurrentCleanupScopeDepth</name></name> <operator>=</operator> <name>OldCleanupScopeDepth</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<expr_stmt><expr><name>EHScopeStack</name><operator>::</operator><name>stable_iterator</name> <name>CurrentCleanupScopeDepth</name> <operator>=</operator>
<name>EHScopeStack</name><operator>::</operator><call><name>stable_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>LexicalScope</name> <range>: <expr><name>public</name> <name>RunCleanupsScope</name> <block>{
<expr><name>SourceRange</name> <name>Range</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>LabelDecl</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>Labels</name></expr>;
<expr><name>LexicalScope</name> <operator>*</operator><name>ParentScope</name></expr>;

<expr><call><name>LexicalScope</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LexicalScope</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><name>void</name> <name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>LexicalScope</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr>;

<expr><name>public</name><operator>:</operator>

<name>explicit</name> <macro><name>LexicalScope</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceRange Range</argument>)</argument_list></macro>
<operator>:</operator> <call><name>RunCleanupsScope</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Range</name><argument_list>(<argument><expr><name>Range</name></expr></argument>)</argument_list></call></expr>, <macro><name>ParentScope</name><argument_list>(<argument>CGF.CurLexicalScope</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CGF</name><operator>.</operator><name>CurLexicalScope</name></name> <operator>=</operator> <name>this</name></expr>;
<if_stmt><if>if <condition>(<decl><type><name>CGDebugInfo</name> <modifier>*</modifier></type><name>DI</name> <init>= <expr><call><name><name>CGF</name><operator>.</operator><name>getDebugInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>DI</name><operator>-&gt;</operator><name>EmitLexicalBlockStart</name></name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>Builder</name></name></expr></argument>, <argument><expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<name>void</name> <macro><name>addLabel</name><argument_list>(<argument>const LabelDecl *label</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>PerformCleanup</name> <operator>&amp;&amp;</operator> <literal type="string">"adding label to dead scope?"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Labels</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;
}</block>



<operator>~</operator><macro><name>LexicalScope</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<decl><type><name>CGDebugInfo</name> <modifier>*</modifier></type><name>DI</name> <init>= <expr><call><name><name>CGF</name><operator>.</operator><name>getDebugInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>DI</name><operator>-&gt;</operator><name>EmitLexicalBlockEnd</name></name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>Builder</name></name></expr></argument>, <argument><expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>



<if_stmt><if>if <condition>(<expr><name>PerformCleanup</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ApplyDebugLocation</name></type> <name>DL</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>, <argument><expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ForceCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}



void ForceCleanup(</block></if></if_stmt>) <block>{
<expr><name><name>CGF</name><operator>.</operator><name>CurLexicalScope</name></name> <operator>=</operator> <name>ParentScope</name></expr>;
<expr><name>RunCleanupsScope</name><operator>::</operator><call><name>ForceCleanup</name><argument_list>()</argument_list></call></expr>;

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Labels</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rescopeLabels</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<name>bool</name> <macro><name>hasLabels</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name><name>Labels</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <call><name>rescopeLabels</name><argument_list>()</argument_list></call></block></expr></range></decl>;</decl_stmt>
};

<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>Address</name></expr></argument>&gt;</argument_list></name> <name>DeclMapTy</name></expr>;</expr_stmt></typedef>


<decl_stmt><decl><type><name>class</name></type> <name>OMPMapVars</name> <block>{<block_content>
<decl_stmt><decl><type><name>DeclMapTy</name></type> <name>SavedLocals</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DeclMapTy</name></type> <name>SavedTempAddresses</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>OMPMapVars</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPMapVars</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>OMPMapVars</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>
<function_decl><type><name>explicit</name></type> <name>OMPMapVars</name><parameter_list>()</parameter_list> <init>= <expr/>default</init>;</function_decl>
<expr_stmt><expr><operator>~</operator><macro><name>OMPMapVars</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>SavedLocals</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Did not restored original addresses."</literal></expr></argument>)</argument_list></call></expr>;
}</block></expr>;</expr_stmt>




<function><type><name>bool</name></type> <name>setVarAddr</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>LocalVD</name></decl></parameter>,
<parameter><decl><type><name>Address</name></type> <name>TempAddr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>LocalVD</name> <operator>=</operator> <call><name><name>LocalVD</name><operator>-&gt;</operator><name>getCanonicalDecl</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>SavedLocals</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>LocalVD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>auto</name></type> <name>it</name> <init>= <expr><call><name><name>CGF</name><operator>.</operator><name>LocalDeclMap</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>LocalVD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>it</name> <operator>!=</operator> <call><name><name>CGF</name><operator>.</operator><name>LocalDeclMap</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>SavedLocals</name><operator>.</operator><name>try_emplace</name></name><argument_list>(<argument><expr><name>LocalVD</name></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>second</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>SavedLocals</name><operator>.</operator><name>try_emplace</name></name><argument_list>(<argument><expr><name>LocalVD</name></expr></argument>, <argument><expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>VarTy</name> <init>= <expr><call><name><name>LocalVD</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>VarTy</name><operator>-&gt;</operator><name>isReferenceType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Address</name></type> <name>Temp</name> <init>= <expr><call><name><name>CGF</name><operator>.</operator><name>CreateMemTemp</name></name><argument_list>(<argument><expr><name>VarTy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>Builder</name><operator>.</operator><name>CreateStore</name></name><argument_list>(<argument><expr><call><name><name>TempAddr</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>TempAddr</name> <operator>=</operator> <name>Temp</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name><name>SavedTempAddresses</name><operator>.</operator><name>try_emplace</name></name><argument_list>(<argument><expr><name>LocalVD</name></expr></argument>, <argument><expr><name>TempAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>bool</name></type> <name>apply</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>copyInto</name><argument_list>(<argument><expr><name>SavedTempAddresses</name></expr></argument>, <argument><expr><name><name>CGF</name><operator>.</operator><name>LocalDeclMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SavedTempAddresses</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>!</operator><call><name><name>SavedLocals</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>restore</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>SavedLocals</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>copyInto</name><argument_list>(<argument><expr><name>SavedLocals</name></expr></argument>, <argument><expr><name><name>CGF</name><operator>.</operator><name>LocalDeclMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SavedLocals</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<label><name>private</name>:</label>


<function><type><specifier>static</specifier> <name>void</name></type> <name>copyInto</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclMapTy</name> <modifier>&amp;</modifier></type><name>Src</name></decl></parameter>, <parameter><decl><type><name>DeclMapTy</name> <modifier>&amp;</modifier></type><name>Dest</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><expr><name>auto</name> <operator>&amp;</operator><name>Pair</name> <operator>:</operator> <name>Src</name></expr></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Pair</name><operator>.</operator><name>second</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Dest</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name><name>Pair</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>auto</name></type> <name>I</name> <init>= <expr><call><name><name>Dest</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name><name>Pair</name><operator>.</operator><name>first</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>I</name> <operator>!=</operator> <call><name><name>Dest</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>I</name><operator>-&gt;</operator><name>second</name></name> <operator>=</operator> <name><name>Pair</name><operator>.</operator><name>second</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Dest</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>Pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>OMPPrivateScope</name> <range>: <expr><name>public</name> <name>RunCleanupsScope</name> <block>{
<expr><name>OMPMapVars</name> <name>MappedVars</name></expr>;
<expr><call><name>OMPPrivateScope</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPPrivateScope</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><name>void</name> <name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>OMPPrivateScope</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr>;

<expr><name>public</name><operator>:</operator>

<name>explicit</name> <call><name>OMPPrivateScope</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>RunCleanupsScope</name><argument_list>(<argument>CGF</argument>)</argument_list></macro> <block>{}</block>






<name>bool</name> <macro><name>addPrivate</name><argument_list>(<argument>const VarDecl *LocalVD</argument>,
<argument>const llvm::function_ref&lt;Address()&gt; PrivateGen</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>PerformCleanup</name> <operator>&amp;&amp;</operator> <literal type="string">"adding private to dead scope"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>MappedVars</name><operator>.</operator><name>setVarAddr</name></name><argument_list>(<argument><expr><name>CGF</name></expr></argument>, <argument><expr><name>LocalVD</name></expr></argument>, <argument><expr><call><name>PrivateGen</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>









<name>bool</name> <macro><name>Privatize</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>MappedVars</name><operator>.</operator><name>apply</name></name><argument_list>(<argument><expr><name>CGF</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>ForceCleanup</name><argument_list>()</argument_list></macro> <block>{
<expr><name>RunCleanupsScope</name><operator>::</operator><call><name>ForceCleanup</name><argument_list>()</argument_list></call></expr>;
<expr><call><name><name>MappedVars</name><operator>.</operator><name>restore</name></name><argument_list>(<argument><expr><name>CGF</name></expr></argument>)</argument_list></call></expr>;
}</block>


<operator>~</operator><macro><name>OMPPrivateScope</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>PerformCleanup</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ForceCleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>


<name>bool</name> <macro><name>isGlobalVarCaptured</name><argument_list>(<argument>const VarDecl *VD</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>VD</name> <operator>=</operator> <call><name><name>VD</name><operator>-&gt;</operator><name>getCanonicalDecl</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><operator>!</operator><call><name><name>VD</name><operator>-&gt;</operator><name>isLocalVarDeclOrParm</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>CGF</name><operator>.</operator><name>LocalDeclMap</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>VD</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>OMPLocalDeclMapRAII</name> <block>{
<expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr>;
<expr><name>DeclMapTy</name> <name>SavedMap</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>OMPLocalDeclMapRAII</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>CGF</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>)</argument_list></call></expr>, <macro><name>SavedMap</name><argument_list>(<argument>CGF.LocalDeclMap</argument>)</argument_list></macro> <expr><block>{}</block>
<operator>~</operator><macro><name>OMPLocalDeclMapRAII</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name><name>SavedMap</name><operator>.</operator><name>swap</name></name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>LocalDeclMap</name></name></expr></argument>)</argument_list></call></expr>; }</block></expr>
}</block></expr>;



<expr><name>void</name>
<macro><name>PopCleanupBlocks</name><argument_list>(<argument>EHScopeStack::stable_iterator OldCleanupStackSize</argument>,
<argument>std::initializer_list&lt;llvm::Value **&gt; ValuesToReload = {}</argument>)</argument_list></macro></expr>;




<expr><name>void</name>
<macro><name>PopCleanupBlocks</name><argument_list>(<argument>EHScopeStack::stable_iterator OldCleanupStackSize</argument>,
<argument>size_t OldLifetimeExtendedStackSize</argument>,
<argument>std::initializer_list&lt;llvm::Value **&gt; ValuesToReload = {}</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <call><name>ResolveBranchFixups</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>Target</name></expr></argument>)</argument_list></call></expr>;




<expr><name>JumpDest</name> <macro><name>getJumpDestInCurrentScope</name><argument_list>(<argument>llvm::BasicBlock *Target</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>JumpDest</name><argument_list>(<argument><expr><name>Target</name></expr></argument>,
<argument><expr><call><name><name>EHStack</name><operator>.</operator><name>getInnermostNormalCleanup</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>NextCleanupDestIndex</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>JumpDest</name> <macro><name>getJumpDestInCurrentScope</name><argument_list>(<argument>StringRef Name = StringRef()</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getJumpDestInCurrentScope</name><argument_list>(<argument><expr><call><name>createBasicBlock</name><argument_list>(<argument><expr><name>Name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>void</name> <macro><name>EmitBranchThroughCleanup</name><argument_list>(<argument>JumpDest Dest</argument>)</argument_list></macro></expr>;




<expr><name>bool</name> <macro><name>isObviouslyBranchWithoutCleanups</name><argument_list>(<argument>JumpDest Dest</argument>)</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>void</name> <call><name>popCatchScope</name><argument_list>()</argument_list></call></expr>;

<expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><macro><name>getEHResumeBlock</name><argument_list>(<argument>bool isCleanup</argument>)</argument_list></macro></expr>;
<expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><macro><name>getEHDispatchBlock</name><argument_list>(<argument>EHScopeStack::stable_iterator scope</argument>)</argument_list></macro></expr>;
<expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator>
<macro><name>getFuncletEHDispatchBlock</name><argument_list>(<argument>EHScopeStack::stable_iterator scope</argument>)</argument_list></macro></expr>;


<expr><name>class</name> <name>ConditionalEvaluation</name> <block>{
<expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>StartBB</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>ConditionalEvaluation</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>StartBB</name><argument_list>(<argument>CGF.Builder.GetInsertBlock()</argument>)</argument_list></macro> <block>{}</block>

<name>void</name> <macro><name>begin</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>OutermostConditional</name></name> <operator>!=</operator> <name>this</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>CGF</name><operator>.</operator><name>OutermostConditional</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>CGF</name><operator>.</operator><name>OutermostConditional</name></name> <operator>=</operator> <name>this</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<name>void</name> <macro><name>end</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>OutermostConditional</name></name> <operator>!=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name><name>CGF</name><operator>.</operator><name>OutermostConditional</name></name> <operator>==</operator> <name>this</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>CGF</name><operator>.</operator><name>OutermostConditional</name></name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>



<name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><macro><name>getStartingBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>StartBB</name></expr>;</return>
}</block>
}</expr>;



<expr><name>bool</name> <macro><name>isInConditionalBranch</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OutermostConditional</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block>

<name>void</name> <macro><name>setBeforeOutermostConditional</name><argument_list>(<argument>llvm::Value *value</argument>, <argument>Address addr</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isInConditionalBranch</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>block</name> <operator>=</operator> <call><name><name>OutermostConditional</name><operator>-&gt;</operator><name>getStartingBlock</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>auto</name> <name>store</name> <operator>=</operator> <name>new</name> <name>llvm</name><operator>::</operator><call><name>StoreInst</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><call><name><name>addr</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><call><name><name>block</name><operator>-&gt;</operator><name>back</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>store</name><operator>-&gt;</operator><name>setAlignment</name></name><argument_list>(<argument><expr><call><name><name>addr</name><operator>.</operator><name>getAlignment</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAsAlign</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>



<name>class</name> <name>StmtExprEvaluation</name> <block>{
<expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr>;




<expr><name>ConditionalEvaluation</name> <operator>*</operator><name>SavedOutermostConditional</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>StmtExprEvaluation</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>CGF</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>)</argument_list></call></expr>, <macro><name>SavedOutermostConditional</name><argument_list>(<argument>CGF.OutermostConditional</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CGF</name><operator>.</operator><name>OutermostConditional</name></name> <operator>=</operator> <name>nullptr</name></expr>;
}</block>

<operator>~</operator><macro><name>StmtExprEvaluation</name><argument_list>()</argument_list></macro> <block>{
<expr><name><name>CGF</name><operator>.</operator><name>OutermostConditional</name></name> <operator>=</operator> <name>SavedOutermostConditional</name></expr>;
<expr><call><name><name>CGF</name><operator>.</operator><name>EnsureInsertPoint</name></name><argument_list>()</argument_list></call></expr>;
}</block></expr>
}</block></expr>;




<expr><name>class</name> <name>PeepholeProtection</name> <block>{
<expr><name>llvm</name><operator>::</operator><name>Instruction</name> <operator>*</operator><name>Inst</name></expr>;
<expr><name>friend</name> <name>class</name> <name>CodeGenFunction</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>PeepholeProtection</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Inst</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <block>{}</block></expr>
}</block></expr>;







<expr><name>class</name> <name>OpaqueValueMappingData</name> <block>{
<expr><specifier>const</specifier> <name>OpaqueValueExpr</name> <operator>*</operator><name>OpaqueValue</name></expr>;
<expr><name>bool</name> <name>BoundLValue</name></expr>;
<expr><name>CodeGenFunction</name><operator>::</operator><name>PeepholeProtection</name> <name>Protection</name></expr>;

<macro><name>OpaqueValueMappingData</name><argument_list>(<argument>const OpaqueValueExpr *ov</argument>,
<argument>bool boundLValue</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>OpaqueValue</name><argument_list>(<argument><expr><name>ov</name></expr></argument>)</argument_list></call></expr>, <macro><name>BoundLValue</name><argument_list>(<argument>boundLValue</argument>)</argument_list></macro> <expr><block>{}</block>
<name>public</name><operator>:</operator>
<call><name>OpaqueValueMappingData</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>OpaqueValue</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <block>{}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>shouldBindAsLValue</name><argument_list>(<argument>const Expr *expr</argument>)</argument_list></macro> <block>{





<return>return <expr><call><name><name>expr</name><operator>-&gt;</operator><name>isGLValue</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>expr</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isFunctionType</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name>hasAggregateEvaluationKind</name><argument_list>(<argument><expr><call><name><name>expr</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>OpaqueValueMappingData</name> <macro><name>bind</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>const OpaqueValueExpr *ov</argument>,
<argument>const Expr *e</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>shouldBindAsLValue</name><argument_list>(<argument><expr><name>ov</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>bind</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>, <argument><expr><name>ov</name></expr></argument>, <argument><expr><call><name><name>CGF</name><operator>.</operator><name>EmitLValue</name></name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>bind</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>, <argument><expr><name>ov</name></expr></argument>, <argument><expr><call><name><name>CGF</name><operator>.</operator><name>EmitAnyExpr</name></name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>OpaqueValueMappingData</name> <macro><name>bind</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>const OpaqueValueExpr *ov</argument>,
<argument>const LValue &amp;lv</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>shouldBindAsLValue</name><argument_list>(<argument><expr><name>ov</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>CGF</name><operator>.</operator><name>OpaqueLValues</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>make_pair</name><argument_list>(<argument><expr><name>ov</name></expr></argument>, <argument><expr><name>lv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>OpaqueValueMappingData</name><argument_list>(<argument><expr><name>ov</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>OpaqueValueMappingData</name> <macro><name>bind</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>const OpaqueValueExpr *ov</argument>,
<argument>const RValue &amp;rv</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>shouldBindAsLValue</name><argument_list>(<argument><expr><name>ov</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>CGF</name><operator>.</operator><name>OpaqueRValues</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>make_pair</name><argument_list>(<argument><expr><name>ov</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

<expr><name>OpaqueValueMappingData</name> <call><name>data</name><argument_list>(<argument><expr><name>ov</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;




<expr><name><name>data</name><operator>.</operator><name>Protection</name></name> <operator>=</operator> <call><name><name>CGF</name><operator>.</operator><name>protectFromPeepholes</name></name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;

<return>return <expr><name>data</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isValid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OpaqueValue</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block>
<name>void</name> <macro><name>clear</name><argument_list>()</argument_list></macro> <block>{ <expr><name>OpaqueValue</name> <operator>=</operator> <name>nullptr</name></expr>; }</block>

<name>void</name> <macro><name>unbind</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>OpaqueValue</name> <operator>&amp;&amp;</operator> <literal type="string">"no data to unbind!"</literal></expr></argument>)</argument_list></call></expr>;

<if_stmt><if>if <condition>(<expr><name>BoundLValue</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>OpaqueLValues</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>OpaqueValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content> else <block>{<block_content>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>OpaqueRValues</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>OpaqueValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>unprotectFromPeepholes</name></name><argument_list>(<argument><expr><name>Protection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}
}</block></block><empty_stmt>;</empty_stmt></if></if_stmt>


<name>class</name> <name>OpaqueValueMapping</name> <block>{
<expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr>;
<expr><name>OpaqueValueMappingData</name> <name>Data</name></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>bool</name> <macro><name>shouldBindAsLValue</name><argument_list>(<argument>const Expr *expr</argument>)</argument_list></macro> <block>{
<return>return <expr><name>OpaqueValueMappingData</name><operator>::</operator><call><name>shouldBindAsLValue</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>






<call><name>OpaqueValueMapping</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>AbstractConditionalOperator</name> <operator>*</operator><name>op</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>CGF</name><argument_list>(<argument>CGF</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ConditionalOperator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<specifier>const</specifier> <name>BinaryConditionalOperator</name> <operator>*</operator><name>e</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>BinaryConditionalOperator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></block></expr>;
<expr><name>Data</name> <operator>=</operator> <name>OpaqueValueMappingData</name><operator>::</operator><call><name>bind</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>, <argument><expr><call><name><name>e</name><operator>-&gt;</operator><name>getOpaqueValue</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>e</name><operator>-&gt;</operator><name>getCommon</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block></block>



<call><name>OpaqueValueMapping</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>OpaqueValueExpr</name> <operator>*</operator><name>OV</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CGF</name><argument_list>(<argument>CGF</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>OV</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>OV</name><operator>-&gt;</operator><name>getSourceExpr</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"wrong form of OpaqueValueMapping used "</literal>
<literal type="string">"for OVE with no source expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Data</name> <operator>=</operator> <name>OpaqueValueMappingData</name><operator>::</operator><call><name>bind</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>, <argument><expr><name>OV</name></expr></argument>, <argument><expr><call><name><name>OV</name><operator>-&gt;</operator><name>getSourceExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}

OpaqueValueMapping(CodeGenFunction &amp;CGF</block><operator>,</operator>
<decl_stmt><decl><type><specifier>const</specifier> <name>OpaqueValueExpr</name> <modifier>*</modifier></type><name>opaqueValue</name></decl>,
<decl><type ref="prev"/><name>LValue</name> <name>lvalue</name></decl>)
: CGF(CGF</decl_stmt></if></if_stmt>), <macro><name>Data</name><argument_list>(<argument>OpaqueValueMappingData::bind(CGF, opaqueValue, lvalue)</argument>)</argument_list></macro> <block>{
}</block></block>

<macro><name>OpaqueValueMapping</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>const OpaqueValueExpr *opaqueValue</argument>,
<argument>RValue rvalue</argument>)</argument_list></macro>
<operator>:</operator> <call><name>CGF</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>)</argument_list></call></expr>, <macro><name>Data</name><argument_list>(<argument>OpaqueValueMappingData::bind(CGF, opaqueValue, rvalue)</argument>)</argument_list></macro> <expr><block>{
}</block>

<name>void</name> <macro><name>pop</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name><name>Data</name><operator>.</operator><name>unbind</name></name><argument_list>(<argument><expr><name>CGF</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Data</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;
}</block>

<operator>~</operator><macro><name>OpaqueValueMapping</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Data</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>Data</name><operator>.</operator><name>unbind</name></name><argument_list>(<argument><expr><name>CGF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>
}</expr>;

<expr><name>private</name><operator>:</operator>
<name>CGDebugInfo</name> <operator>*</operator><name>DebugInfo</name></expr>;

<expr><name>unsigned</name> <name>VLAExprCounter</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>bool</name> <name>DisableDebugInfo</name> <operator>=</operator> <name>false</name></expr>;



<expr><name>bool</name> <name>DidCallStackSave</name> <operator>=</operator> <name>false</name></expr>;





<expr><name>llvm</name><operator>::</operator><name>IndirectBrInst</name> <operator>*</operator><name>IndirectBranch</name> <operator>=</operator> <name>nullptr</name></expr>;



<expr><name>DeclMapTy</name> <name>LocalDeclMap</name></expr>;



<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ParmVarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>EHScopeStack</name><operator>::</operator><name>stable_iterator</name></expr></argument>&gt;</argument_list></name>
<name>CalleeDestructedParamCleanups</name></expr>;




<expr><name>llvm</name><operator>::</operator><name><name>SmallDenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ParmVarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>ImplicitParamDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name>
<name>SizeArguments</name></expr>;



<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>AllocaInst</name> <operator>*</operator></expr></argument>, <argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <name>EscapedLocals</name></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>LabelDecl</name><operator>*</operator></expr></argument>, <argument><expr><name>JumpDest</name></expr></argument>&gt;</argument_list></name> <name>LabelMap</name></expr>;



struct <expr><name>BreakContinue</name> <block>{
<macro><name>BreakContinue</name><argument_list>(<argument>JumpDest Break</argument>, <argument>JumpDest Continue</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>BreakBlock</name><argument_list>(<argument><expr><name>Break</name></expr></argument>)</argument_list></call></expr>, <macro><name>ContinueBlock</name><argument_list>(<argument>Continue</argument>)</argument_list></macro> <expr><block>{}</block>

<name>JumpDest</name> <name>BreakBlock</name></expr>;
<expr><name>JumpDest</name> <name>ContinueBlock</name></expr>;
}</block></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>BreakContinue</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>BreakContinueStack</name></expr>;


<expr><name>class</name> <name>OpenMPCancelExitStack</name> <block>{


struct <expr><name>CancelExit</name> <block>{
<expr><call><name>CancelExit</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<macro><name>CancelExit</name><argument_list>(<argument>OpenMPDirectiveKind Kind</argument>, <argument>JumpDest ExitBlock</argument>,
<argument>JumpDest ContBlock</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Kind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ExitBlock</name><argument_list>(<argument><expr><name>ExitBlock</name></expr></argument>)</argument_list></call></expr>, <macro><name>ContBlock</name><argument_list>(<argument>ContBlock</argument>)</argument_list></macro> <expr><block>{}</block>
<name>OpenMPDirectiveKind</name> <name>Kind</name> <operator>=</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPD_unknown</name></expr>;


<expr><name>bool</name> <name>HasBeenEmitted</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>JumpDest</name> <name>ExitBlock</name></expr>;
<expr><name>JumpDest</name> <name>ContBlock</name></expr>;
}</block></expr>;

<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>CancelExit</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>Stack</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>OpenMPCancelExitStack</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Stack</name><argument_list>(<argument><literal type="number">1</literal></argument>)</argument_list></macro> <block>{}</block>
<operator>~</operator><call><name>OpenMPCancelExitStack</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>JumpDest</name> <macro><name>getExitBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>ExitBlock</name></expr>;</return> }</block>


<name>void</name> <macro><name>emitExit</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>OpenMPDirectiveKind Kind</argument>,
<argument>const llvm::function_ref&lt;void(CodeGenFunction &amp;)&gt; CodeGen</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>Kind</name> <operator>==</operator> <name>Kind</name> <operator>&amp;&amp;</operator> <call><name>getExitBlock</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>CGF</name><operator>.</operator><name>getOMPCancelDestination</name></name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>CGF</name><operator>.</operator><name>HaveInsertPoint</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>Stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>HasBeenEmitted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>auto</name></type> <name>IP</name> <init>= <expr><call><name><name>CGF</name><operator>.</operator><name>Builder</name><operator>.</operator><name>saveAndClearIP</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>EmitBlock</name></name><argument_list>(<argument><expr><call><name><name>Stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>ExitBlock</name><operator>.</operator><name>getBlock</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CodeGen</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>EmitBranch</name></name><argument_list>(<argument><expr><call><name><name>Stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>ContBlock</name><operator>.</operator><name>getBlock</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>Builder</name><operator>.</operator><name>restoreIP</name></name><argument_list>(<argument><expr><name>IP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>HasBeenEmitted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
CodeGen(CGF</block></if></if_stmt>)</block></expr>;
}</block>




<name>void</name> <macro><name>enter</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>OpenMPDirectiveKind Kind</argument>, <argument>bool HasCancel</argument>)</argument_list></macro> <block>{
<macro><name>Stack</name></macro><expr><operator>.</operator><macro><name>push_back</name><argument_list>(<argument>{Kind</argument>,
<argument>HasCancel ? CGF.getJumpDestInCurrentScope(<literal type="string">"cancel.exit"</literal>)
: JumpDest()</argument>,
<argument>HasCancel ? CGF.getJumpDestInCurrentScope(<literal type="string">"cancel.cont"</literal>)
: JumpDest()}</argument>)</argument_list></macro></expr>;
}</block>


<name>void</name> <macro><name>exit</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getExitBlock</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>CGF</name><operator>.</operator><name>getOMPCancelDestination</name></name><argument_list>(<argument><expr><call><name><name>Stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>Kind</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>HaveIP</name> <init>= <expr><call><name><name>CGF</name><operator>.</operator><name>HaveInsertPoint</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>HasBeenEmitted</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>HaveIP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>EmitBranchThroughCleanup</name></name><argument_list>(<argument><expr><call><name><name>Stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>ContBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>EmitBlock</name></name><argument_list>(<argument><expr><call><name><name>Stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>ExitBlock</name><operator>.</operator><name>getBlock</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>EmitBranchThroughCleanup</name></name><argument_list>(<argument><expr><call><name><name>Stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>ContBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
CGF.EmitBlock(Stack.back(</block></if></if_stmt>)</block_content>.ContBlock.getBlock(</block></if></if_stmt>))</block></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HaveIP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>Builder</name><operator>.</operator><name>CreateUnreachable</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>Builder</name><operator>.</operator><name>ClearInsertionPoint</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}
Stack.pop_back(</block></if></if_stmt>)</block></expr>;
}</block></expr></range></decl></decl_stmt>
};
<decl_stmt><decl><type><name>OpenMPCancelExitStack</name></type> <name>OMPCancelStack</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>emitCondLikelihoodViaExpectIntrinsic</name><argument_list>(<argument>llvm::Value *Cond</argument>,
<argument>Stmt::Likelihood LH</argument>)</argument_list></macro></expr>;</expr_stmt>

<decl_stmt><decl><type><name>CodeGenPGO</name></type> <name>PGO</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>MDNode</name> <operator>*</operator><macro><name>createProfileWeights</name><argument_list>(<argument>uint64_t TrueCount</argument>,
<argument>uint64_t FalseCount</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>MDNode</name> <operator>*</operator><macro><name>createProfileWeights</name><argument_list>(<argument>ArrayRef&lt;uint64_t&gt; Weights</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>MDNode</name> <operator>*</operator><macro><name>createProfileWeightsForLoop</name><argument_list>(<argument>const Stmt *Cond</argument>,
<argument>uint64_t LoopCount</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<label><name>public</name>:</label>


<decl_stmt><decl><type><name>void</name></type> <name>incrementProfileCounter</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>StepV</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>CGM</name><operator>.</operator><name>getCodeGenOpts</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasProfileClangInstr</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name><name>CurFn</name><operator>-&gt;</operator><name>hasFnAttribute</name></name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Attribute</name><operator>::</operator><name>NoProfile</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>PGO</name><operator>.</operator><name>emitCounterIncrement</name></name><argument_list>(<argument><expr><name>Builder</name></expr></argument>, <argument><expr><name>S</name></expr></argument>, <argument><expr><name>StepV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>PGO</name><operator>.</operator><name>setCurrentStmt</name></name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>


<function><type><name>uint64_t</name></type> <name>getProfileCount</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name></type> <name>Count</name> <init>= <expr><call><name><name>PGO</name><operator>.</operator><name>getStmtCount</name></name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Count</name><operator>.</operator><name>hasValue</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>*</operator><name>Count</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>setCurrentProfileCount</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>Count</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>PGO</name><operator>.</operator><name>setCurrentRegionCount</name></name><argument_list>(<argument><expr><name>Count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name>uint64_t</name></type> <name>getCurrentProfileCount</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>PGO</name><operator>.</operator><name>getCurrentRegionCount</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<label><name>private</name>:</label>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>SwitchInst</name> <operator>*</operator><name>SwitchInsn</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <modifier>*</modifier></type><name>SwitchWeights</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name><operator>::</operator><name>Likelihood</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <modifier>*</modifier></type><name>SwitchLikelihood</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>CaseRangeBlock</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>OpaqueValueExpr</name> <operator>*</operator></expr></argument>, <argument><expr><name>LValue</name></expr></argument>&gt;</argument_list></name> <name>OpaqueLValues</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>OpaqueValueExpr</name> <operator>*</operator></expr></argument>, <argument><expr><name>RValue</name></expr></argument>&gt;</argument_list></name> <name>OpaqueRValues</name></expr>;</expr_stmt>







<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name><operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>VLASizeMap</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>UnreachableBlock</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumReturnExprs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumSimpleReturnExprs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>LastStopPoint</name></decl>;</decl_stmt>

<label><name>public</name>:</label>


<decl_stmt><decl><type><name>CurrentSourceLocExprScope</name></type> <name>CurSourceLocExprScope</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>SourceLocExprScopeGuard</name> <init>=
<expr><name>CurrentSourceLocExprScope</name><operator>::</operator><name>SourceLocExprScopeGuard</name></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>FieldConstructionScope</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>FieldConstructionScope</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>Address This</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>CGF</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>OldCXXDefaultInitExprThis</name><argument_list>(<argument>CGF.CXXDefaultInitExprThis</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CGF</name><operator>.</operator><name>CXXDefaultInitExprThis</name></name> <operator>=</operator> <name>This</name></expr>;
}</block>
<operator>~</operator><macro><name>FieldConstructionScope</name><argument_list>()</argument_list></macro> <block>{
<expr><name><name>CGF</name><operator>.</operator><name>CXXDefaultInitExprThis</name></name> <operator>=</operator> <name>OldCXXDefaultInitExprThis</name></expr>;
}</block>

<name>private</name><operator>:</operator>
<name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Address</name></type> <name>OldCXXDefaultInitExprThis</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>CXXDefaultInitExprScope</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>CXXDefaultInitExprScope</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CXXDefaultInitExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>CGF</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>OldCXXThisValue</name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>CXXThisValue</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>OldCXXThisAlignment</name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>CXXThisAlignment</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>SourceLocScope</name><argument_list>(<argument>E</argument>, <argument>CGF.CurSourceLocExprScope</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CGF</name><operator>.</operator><name>CXXThisValue</name></name> <operator>=</operator> <call><name><name>CGF</name><operator>.</operator><name>CXXDefaultInitExprThis</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>CXXThisAlignment</name></name> <operator>=</operator> <call><name><name>CGF</name><operator>.</operator><name>CXXDefaultInitExprThis</name><operator>.</operator><name>getAlignment</name></name><argument_list>()</argument_list></call></expr>;
}</block>
<operator>~</operator><macro><name>CXXDefaultInitExprScope</name><argument_list>()</argument_list></macro> <block>{
<expr><name><name>CGF</name><operator>.</operator><name>CXXThisValue</name></name> <operator>=</operator> <name>OldCXXThisValue</name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>CXXThisAlignment</name></name> <operator>=</operator> <name>OldCXXThisAlignment</name></expr>;
}</block>

<name>public</name><operator>:</operator>
<name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>OldCXXThisValue</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>CharUnits</name></type> <name>OldCXXThisAlignment</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocExprScopeGuard</name></type> <name>SourceLocScope</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>CXXDefaultArgExprScope</name></name></type> <range>: <expr><name>SourceLocExprScopeGuard</name> <block>{
<expr><call><name>CXXDefaultArgExprScope</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CXXDefaultArgExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>SourceLocExprScopeGuard</name><argument_list>(<argument>E</argument>, <argument>CGF.CurSourceLocExprScope</argument>)</argument_list></macro> <block>{}</block></expr>
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>ArrayInitLoopExprScope</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>ArrayInitLoopExprScope</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Index</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>CGF</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>OldArrayInitIndex</name><argument_list>(<argument>CGF.ArrayInitIndex</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CGF</name><operator>.</operator><name>ArrayInitIndex</name></name> <operator>=</operator> <name>Index</name></expr>;
}</block>
<operator>~</operator><macro><name>ArrayInitLoopExprScope</name><argument_list>()</argument_list></macro> <block>{
<expr><name><name>CGF</name><operator>.</operator><name>ArrayInitIndex</name></name> <operator>=</operator> <name>OldArrayInitIndex</name></expr>;
}</block>

<name>private</name><operator>:</operator>
<name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>OldArrayInitIndex</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>InlinedInheritingConstructorScope</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>InlinedInheritingConstructorScope</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>GlobalDecl GD</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>CGF</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>OldCurGD</name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>CurGD</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>OldCurFuncDecl</name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>CurFuncDecl</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>OldCurCodeDecl</name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>CurCodeDecl</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>OldCXXABIThisDecl</name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>CXXABIThisDecl</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>OldCXXABIThisValue</name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>CXXABIThisValue</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>OldCXXThisValue</name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>CXXThisValue</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>OldCXXABIThisAlignment</name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>CXXABIThisAlignment</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>OldCXXThisAlignment</name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>CXXThisAlignment</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>OldReturnValue</name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>ReturnValue</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>OldFnRetTy</name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>FnRetTy</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>OldCXXInheritedCtorInitExprArgs</name><argument_list>(
<argument>std::move(CGF.CXXInheritedCtorInitExprArgs)</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CGF</name><operator>.</operator><name>CurGD</name></name> <operator>=</operator> <name>GD</name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>CurFuncDecl</name></name> <operator>=</operator> <name><name>CGF</name><operator>.</operator><name>CurCodeDecl</name></name> <operator>=</operator>
<call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructorDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>GD</name><operator>.</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>CXXABIThisDecl</name></name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>CXXABIThisValue</name></name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>CXXThisValue</name></name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>CXXABIThisAlignment</name></name> <operator>=</operator> <call><name>CharUnits</name><argument_list>()</argument_list></call></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>CXXThisAlignment</name></name> <operator>=</operator> <call><name>CharUnits</name><argument_list>()</argument_list></call></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>ReturnValue</name></name> <operator>=</operator> <name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>FnRetTy</name></name> <operator>=</operator> <call><name>QualType</name><argument_list>()</argument_list></call></expr>;
<expr><call><name><name>CGF</name><operator>.</operator><name>CXXInheritedCtorInitExprArgs</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;
}</block>
<operator>~</operator><macro><name>InlinedInheritingConstructorScope</name><argument_list>()</argument_list></macro> <block>{
<expr><name><name>CGF</name><operator>.</operator><name>CurGD</name></name> <operator>=</operator> <name>OldCurGD</name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>CurFuncDecl</name></name> <operator>=</operator> <name>OldCurFuncDecl</name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>CurCodeDecl</name></name> <operator>=</operator> <name>OldCurCodeDecl</name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>CXXABIThisDecl</name></name> <operator>=</operator> <name>OldCXXABIThisDecl</name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>CXXABIThisValue</name></name> <operator>=</operator> <name>OldCXXABIThisValue</name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>CXXThisValue</name></name> <operator>=</operator> <name>OldCXXThisValue</name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>CXXABIThisAlignment</name></name> <operator>=</operator> <name>OldCXXABIThisAlignment</name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>CXXThisAlignment</name></name> <operator>=</operator> <name>OldCXXThisAlignment</name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>ReturnValue</name></name> <operator>=</operator> <name>OldReturnValue</name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>FnRetTy</name></name> <operator>=</operator> <name>OldFnRetTy</name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>CXXInheritedCtorInitExprArgs</name></name> <operator>=</operator>
<name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>OldCXXInheritedCtorInitExprArgs</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator>
<name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>GlobalDecl</name></type> <name>OldCurGD</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>OldCurFuncDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>OldCurCodeDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ImplicitParamDecl</name> <modifier>*</modifier></type><name>OldCXXABIThisDecl</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>OldCXXABIThisValue</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>OldCXXThisValue</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>CharUnits</name></type> <name>OldCXXABIThisAlignment</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharUnits</name></type> <name>OldCXXThisAlignment</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Address</name></type> <name>OldReturnValue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>OldFnRetTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CallArgList</name></type> <name>OldCXXInheritedCtorInitExprArgs</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>












<struct>struct <name>OMPBuilderCBHelpers</name> <block>{

<expr_stmt><expr><call><name>OMPBuilderCBHelpers</name><argument_list>()</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OMPBuilderCBHelpers</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPBuilderCBHelpers</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>OMPBuilderCBHelpers</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>OMPBuilderCBHelpers</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>InsertPointTy</name> <init>= <expr><name>llvm</name><operator>::</operator><name>OpenMPIRBuilder</name><operator>::</operator><name>InsertPointTy</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>OMPAllocateCleanupTy</name></type> <name>final</name> <range>: <expr><name>public</name> <name>EHScopeStack</name><operator>::</operator><name>Cleanup</name> <block>{

<expr><name>private</name><operator>:</operator>
<name>llvm</name><operator>::</operator><name>CallInst</name> <operator>*</operator><name>RTLFnCI</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>OMPAllocateCleanupTy</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>CallInst</name> <operator>*</operator><name>RLFnCI</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>RTLFnCI</name><argument_list>(<argument>RLFnCI</argument>)</argument_list></macro> <block>{
<expr><call><name><name>RLFnCI</name><operator>-&gt;</operator><name>removeFromParent</name></name><argument_list>()</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>Emit</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>Flags</argument> )</argument_list></macro> <name>override</name> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>CGF</name><operator>.</operator><name>HaveInsertPoint</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<call><name><name>CGF</name><operator>.</operator><name>Builder</name><operator>.</operator><name>Insert</name></name><argument_list>(<argument><expr><name>RTLFnCI</name></expr></argument>)</argument_list></call></block></expr>;
}</block></expr></range></decl></decl_stmt>
}</block>;</struct>







<function_decl><type><specifier>static</specifier> <name>Address</name></type> <name>getAddrOfThreadPrivate</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>VDAddr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>Address</name></type> <name>getAddressOfLocalVariable</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>)</parameter_list>;</function_decl>






<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name> <macro><name>getNameWithSeparators</name><argument_list>(<argument>ArrayRef&lt;StringRef&gt; Parts</argument>,
<argument>StringRef FirstSeparator = <literal type="string">"."</literal></argument>,
<argument>StringRef Separator = <literal type="string">"."</literal></argument>)</argument_list></macro></expr>;</expr_stmt>



<function><type><specifier>static</specifier> <name>void</name></type> <name>FinalizeOMPRegion</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>InsertPointTy</name></type> <name>IP</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>CGBuilderTy</name><operator>::</operator><name>InsertPointGuard</name> <call><name>IPG</name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>Builder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>IP</name><operator>.</operator><name>getBlock</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>end</name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>IP</name><operator>.</operator><name>getPoint</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"OpenMP IR Builder should cause terminated block!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>IPBB</name> <operator>=</operator> <call><name><name>IP</name><operator>.</operator><name>getBlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>DestBB</name> <operator>=</operator> <call><name><name>IPBB</name><operator>-&gt;</operator><name>getUniqueSuccessor</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>DestBB</name> <operator>&amp;&amp;</operator> <literal type="string">"Finalization block should have one successor!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name><name>IPBB</name><operator>-&gt;</operator><name>getTerminator</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>eraseFromParent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>Builder</name><operator>.</operator><name>SetInsertPoint</name></name><argument_list>(<argument><expr><name>IPBB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>CodeGenFunction</name><operator>::</operator><name>JumpDest</name> <name>Dest</name> <operator>=</operator> <call><name><name>CGF</name><operator>.</operator><name>getJumpDestInCurrentScope</name></name><argument_list>(<argument><expr><name>DestBB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>EmitBranchThroughCleanup</name></name><argument_list>(<argument><expr><name>Dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>EmitOMPRegionBody</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>RegionBodyStmt</name></expr></argument>,
<argument><expr><name>InsertPointTy</name> <name>CodeGenIP</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>&amp;</operator><name>FiniBB</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>CodeGenIPBB</name> <operator>=</operator> <call><name><name>CodeGenIP</name><operator>.</operator><name>getBlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>llvm</name><operator>::</operator><name>Instruction</name> <operator>*</operator><name>CodeGenIPBBTI</name> <operator>=</operator> <call><name><name>CodeGenIPBB</name><operator>-&gt;</operator><name>getTerminator</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>CodeGenIPBBTI</name><operator>-&gt;</operator><name>eraseFromParent</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>Builder</name><operator>.</operator><name>SetInsertPoint</name></name><argument_list>(<argument><expr><name>CodeGenIPBB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>EmitStmt</name></name><argument_list>(<argument><expr><name>RegionBodyStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>CGF</name><operator>.</operator><name>Builder</name><operator>.</operator><name>saveIP</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isSet</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>Builder</name><operator>.</operator><name>CreateBr</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>FiniBB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>OutlinedRegionBodyRAII</name> <block>{<block_content>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>AssertingVH</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Instruction</name></expr></argument>&gt;</argument_list></name> <name>OldAllocaIP</name></expr>;</expr_stmt>
<expr_stmt><expr><name>CodeGenFunction</name><operator>::</operator><name>JumpDest</name> <name>OldReturnBlock</name></expr>;</expr_stmt>
<expr_stmt><expr><name>CGBuilderTy</name><operator>::</operator><name>InsertPoint</name> <name>IP</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>OutlinedRegionBodyRAII</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>cgf</name></expr></argument>, <argument><expr><name>InsertPointTy</name> <operator>&amp;</operator><name>AllocaIP</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>&amp;</operator><name>RetBB</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CGF</name><argument_list>(<argument>cgf</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>AllocaIP</name><operator>.</operator><name>isSet</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Must specify Insertion point for allocas of outlined function"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>OldAllocaIP</name> <operator>=</operator> <name><name>CGF</name><operator>.</operator><name>AllocaInsertPt</name></name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>AllocaInsertPt</name></name> <operator>=</operator> <operator>&amp;</operator><operator>*</operator><call><name><name>AllocaIP</name><operator>.</operator><name>getPoint</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>IP</name> <operator>=</operator> <call><name><name>CGF</name><operator>.</operator><name>Builder</name><operator>.</operator><name>saveIP</name></name><argument_list>()</argument_list></call></expr>;

<expr><name>OldReturnBlock</name> <operator>=</operator> <name><name>CGF</name><operator>.</operator><name>ReturnBlock</name></name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>ReturnBlock</name></name> <operator>=</operator> <call><name><name>CGF</name><operator>.</operator><name>getJumpDestInCurrentScope</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>RetBB</name></expr></argument>)</argument_list></call></expr>;
}</block>

<operator>~</operator><macro><name>OutlinedRegionBodyRAII</name><argument_list>()</argument_list></macro> <block>{
<expr><name><name>CGF</name><operator>.</operator><name>AllocaInsertPt</name></name> <operator>=</operator> <name>OldAllocaIP</name></expr>;
<expr><name><name>CGF</name><operator>.</operator><name>ReturnBlock</name></name> <operator>=</operator> <name>OldReturnBlock</name></expr>;
<expr><call><name><name>CGF</name><operator>.</operator><name>Builder</name><operator>.</operator><name>restoreIP</name></name><argument_list>(<argument><expr><name>IP</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>InlinedRegionBodyRAII</name> <block>{<block_content>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>AssertingVH</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Instruction</name></expr></argument>&gt;</argument_list></name> <name>OldAllocaIP</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>InlinedRegionBodyRAII</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>cgf</name></expr></argument>, <argument><expr><name>InsertPointTy</name> <operator>&amp;</operator><name>AllocaIP</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>&amp;</operator><name>FiniBB</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CGF</name><argument_list>(<argument>cgf</argument>)</argument_list></macro> <block>{




<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>!</operator><call><name><name>AllocaIP</name><operator>.</operator><name>isSet</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>CGF</name><operator>.</operator><name>AllocaInsertPt</name><operator>-&gt;</operator><name>getParent</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>AllocaIP</name><operator>.</operator><name>getBlock</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Insertion point should be in the entry block of containing "</literal>
<literal type="string">"function!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>OldAllocaIP</name> <operator>=</operator> <name><name>CGF</name><operator>.</operator><name>AllocaInsertPt</name></name></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>AllocaIP</name><operator>.</operator><name>isSet</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>CGF</name><operator>.</operator><name>AllocaInsertPt</name></name> <operator>=</operator> <operator>&amp;</operator><operator>*</operator><call><name><name>AllocaIP</name><operator>.</operator><name>getPoint</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>






<operator>(</operator><name>void</name><operator>)</operator><call><name><name>CGF</name><operator>.</operator><name>getJumpDestInCurrentScope</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>FiniBB</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><operator>~</operator><macro><name>InlinedRegionBodyRAII</name><argument_list>()</argument_list></macro> <block>{ <expr><name><name>CGF</name><operator>.</operator><name>AllocaInsertPt</name></name> <operator>=</operator> <name>OldAllocaIP</name></expr>; }</block></expr></expr_stmt>
};
};

<label><name>private</name>:</label>


<decl_stmt><decl><type><name>ImplicitParamDecl</name> <modifier>*</modifier></type><name>CXXABIThisDecl</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>CXXABIThisValue</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>CXXThisValue</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>CharUnits</name></type> <name>CXXABIThisAlignment</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharUnits</name></type> <name>CXXThisAlignment</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>Address</name></type> <name>CXXDefaultInitExprThis</name> <init>= <expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>ArrayInitIndex</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>CallArgList</name></type> <name>CXXInheritedCtorInitExprArgs</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>ImplicitParamDecl</name> <modifier>*</modifier></type><name>CXXStructorImplicitParamDecl</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>CXXStructorImplicitParamValue</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name>ConditionalEvaluation</name> <modifier>*</modifier></type><name>OutermostConditional</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>LexicalScope</name> <modifier>*</modifier></type><name>CurLexicalScope</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>SourceLocation</name></type> <name>CurEHLocation</name></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>BlockByrefInfo</name></expr></argument>&gt;</argument_list></name> <name>BlockByrefInfos</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>RetValNullabilityPrecondition</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>requiresReturnValueNullabilityCheck</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>RetValNullabilityPrecondition</name></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>Address</name></type> <name>ReturnLocation</name> <init>= <expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>requiresReturnValueCheck</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>TerminateLandingPad</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>TerminateHandler</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>TrapBBs</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>TerminateFunclets</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>LargestVectorWidth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>ShouldEmitLifetimeMarkers</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>EmitOpenCLKernelMetadata</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>FD</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Fn</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>CodeGenFunction</name><argument_list>(<argument>CodeGenModule &amp;cgm</argument>, <argument>bool suppressNewContext=false</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><operator>~</operator><call><name>CodeGenFunction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>CodeGenTypes</name> <operator>&amp;</operator><macro><name>getTypes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>CGM</name><operator>.</operator><name>getTypes</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>ASTContext</name> <operator>&amp;</operator><macro><name>getContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>CGM</name><operator>.</operator><name>getContext</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>CGDebugInfo</name> <modifier>*</modifier></type><name>getDebugInfo</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>DisableDebugInfo</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>DebugInfo</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>disableDebugInfo</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>DisableDebugInfo</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>enableDebugInfo</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>DisableDebugInfo</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>bool</name></type> <name>shouldUseFusedARCCalls</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>CGM</name><operator>.</operator><name>getCodeGenOpts</name></name><argument_list>()</argument_list></call><operator>.</operator><name>OptimizationLevel</name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><macro><name>getLangOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>CGM</name><operator>.</operator><name>getLangOpts</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<function_decl><type><name>Address</name></type> <name>getExceptionSlot</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>Address</name></type> <name>getEHSelectorSlot</name><parameter_list>()</parameter_list>;</function_decl>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>getExceptionFromSlot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>getSelectorFromSlot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>Address</name></type> <name>getNormalCleanupDestSlot</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><macro><name>getUnreachableBlock</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>UnreachableBlock</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>UnreachableBlock</name> <operator>=</operator> <call><name>createBasicBlock</name><argument_list>(<argument><expr><literal type="string">"unreachable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new</name> <name>llvm</name><operator>::</operator><call><name>UnreachableInst</name><argument_list>(<argument><expr><call><name>getLLVMContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>UnreachableBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
<return>return <expr><name>UnreachableBlock</name></expr>;</return>
}

llvm<expr_stmt><expr><operator>::</operator><name>BasicBlock</name> <operator>*</operator><macro><name>getInvokeDest</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>EHStack</name><operator>.</operator><name>requiresLandingPad</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getInvokeDestImpl</name><argument_list>()</argument_list></call></expr>;</return>
}

bool <macro><name>currentFunctionUsesSEHTry</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{ <return>return <expr><name>CurSEHParent</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>TargetInfo</name> <operator>&amp;</operator><macro><name>getTarget</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Target</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>LLVMContext</name> <operator>&amp;</operator><macro><name>getLLVMContext</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>CGM</name><operator>.</operator><name>getLLVMContext</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>TargetCodeGenInfo</name> <operator>&amp;</operator><macro><name>getTargetHooks</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>CGM</name><operator>.</operator><name>getTargetCodeGenInfo</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>





<typedef>typedef <function_decl><type><name>void</name></type> <name>Destroyer</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ty</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<decl_stmt><decl><type><name>void</name></type> <name>pushIrregularPartialArrayCleanup</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>arrayBegin</name></expr></argument>,
<argument><expr><name>Address</name> <name>arrayEndPointer</name></expr></argument>,
<argument><expr><name>QualType</name> <name>elementType</name></expr></argument>,
<argument><expr><name>CharUnits</name> <name>elementAlignment</name></expr></argument>,
<argument><expr><name>Destroyer</name> <operator>*</operator><name>destroyer</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>pushRegularPartialArrayCleanup</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>arrayBegin</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>arrayEnd</name></expr></argument>,
<argument><expr><name>QualType</name> <name>elementType</name></expr></argument>,
<argument><expr><name>CharUnits</name> <name>elementAlignment</name></expr></argument>,
<argument><expr><name>Destroyer</name> <operator>*</operator><name>destroyer</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>pushDestroy</name><argument_list>(<argument><expr><name>QualType</name><operator>::</operator><name>DestructionKind</name> <name>dtorKind</name></expr></argument>,
<argument><expr><name>Address</name> <name>addr</name></expr></argument>, <argument><expr><name>QualType</name> <name>type</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>pushEHDestroy</name><argument_list>(<argument><expr><name>QualType</name><operator>::</operator><name>DestructionKind</name> <name>dtorKind</name></expr></argument>,
<argument><expr><name>Address</name> <name>addr</name></expr></argument>, <argument><expr><name>QualType</name> <name>type</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>pushDestroy</name><parameter_list>(<parameter><decl><type><name>CleanupKind</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>type</name></decl></parameter>,
<parameter><decl><type><name>Destroyer</name> <modifier>*</modifier></type><name>destroyer</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>useEHCleanupForArray</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>pushLifetimeExtendedDestroy</name><parameter_list>(<parameter><decl><type><name>CleanupKind</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>addr</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Destroyer</name> <modifier>*</modifier></type><name>destroyer</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>useEHCleanupForArray</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>pushCallObjectDeleteCleanup</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>OperatorDelete</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>CompletePtr</name></expr></argument>,
<argument><expr><name>QualType</name> <name>ElementType</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>pushStackRestore</name><parameter_list>(<parameter><decl><type><name>CleanupKind</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>SPMem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>emitDestroy</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Destroyer</name> <modifier>*</modifier></type><name>destroyer</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>useEHCleanupForArray</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><macro><name>generateDestroyHelper</name><argument_list>(<argument>Address addr</argument>, <argument>QualType type</argument>,
<argument>Destroyer *destroyer</argument>,
<argument>bool useEHCleanupForArray</argument>,
<argument>const VarDecl *VD</argument>)</argument_list></macro></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>emitArrayDestroy</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>begin</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>end</name></expr></argument>,
<argument><expr><name>QualType</name> <name>elementType</name></expr></argument>, <argument><expr><name>CharUnits</name> <name>elementAlign</name></expr></argument>,
<argument><expr><name>Destroyer</name> <operator>*</operator><name>destroyer</name></expr></argument>,
<argument><expr><name>bool</name> <name>checkZeroLength</name></expr></argument>, <argument><expr><name>bool</name> <name>useEHCleanup</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Destroyer</name> <modifier>*</modifier></type><name>getDestroyer</name><argument_list>(<argument><expr><name>QualType</name><operator>::</operator><name>DestructionKind</name> <name>destructionKind</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>needsEHCleanup</name><argument_list>(<argument><expr><name>QualType</name><operator>::</operator><name>DestructionKind</name> <name>kind</name></expr></argument>)</argument_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>kind</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>QualType</name><operator>::</operator><name>DK_none</name></expr>:</case>
<return>return <expr><name>false</name></expr>;</return>
<case>case <expr><name>QualType</name><operator>::</operator><name>DK_cxx_destructor</name></expr>:</case>
<case>case <expr><name>QualType</name><operator>::</operator><name>DK_objc_weak_lifetime</name></expr>:</case>
<case>case <expr><name>QualType</name><operator>::</operator><name>DK_nontrivial_c_struct</name></expr>:</case>
<return>return <expr><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>Exceptions</name></expr>;</return>
<case>case <expr><name>QualType</name><operator>::</operator><name>DK_objc_strong_lifetime</name></expr>:</case>
<return>return <expr><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>Exceptions</name> <operator>&amp;&amp;</operator>
<call><name><name>CGM</name><operator>.</operator><name>getCodeGenOpts</name></name><argument_list>()</argument_list></call><operator>.</operator><name>ObjCAutoRefCountExceptions</name></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"bad destruction kind"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>CleanupKind</name></type> <name>getCleanupKind</name><argument_list>(<argument><expr><name>QualType</name><operator>::</operator><name>DestructionKind</name> <name>kind</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><operator>(</operator><ternary><condition><expr><call><name>needsEHCleanup</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NormalAndEHCleanup</name></expr> </then><else>: <expr><name>NormalCleanup</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<function_decl><type><name>void</name></type> <name>GenerateObjCMethod</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>OMD</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>StartObjCMethod</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ObjCContainerDecl</name> <modifier>*</modifier></type><name>CD</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>GenerateObjCGetter</name><parameter_list>(<parameter><decl><type><name>ObjCImplementationDecl</name> <modifier>*</modifier></type><name>IMP</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCPropertyImplDecl</name> <modifier>*</modifier></type><name>PID</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>generateObjCGetterBody</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCImplementationDecl</name> <operator>*</operator><name>classImpl</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ObjCPropertyImplDecl</name> <operator>*</operator><name>propImpl</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ObjCMethodDecl</name> <operator>*</operator><name>GetterMothodDecl</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>AtomicHelperFn</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>GenerateObjCCtorDtorMethod</name><parameter_list>(<parameter><decl><type><name>ObjCImplementationDecl</name> <modifier>*</modifier></type><name>IMP</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ctor</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>GenerateObjCSetter</name><parameter_list>(<parameter><decl><type><name>ObjCImplementationDecl</name> <modifier>*</modifier></type><name>IMP</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCPropertyImplDecl</name> <modifier>*</modifier></type><name>PID</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>generateObjCSetterBody</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCImplementationDecl</name> <operator>*</operator><name>classImpl</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ObjCPropertyImplDecl</name> <operator>*</operator><name>propImpl</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>AtomicHelperFn</name></expr></argument>)</argument_list></decl>;</decl_stmt>









<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitBlockLiteral</name><argument_list>(<argument><expr><specifier>const</specifier> <name>BlockExpr</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><macro><name>GenerateBlockFunction</name><argument_list>(<argument>GlobalDecl GD</argument>,
<argument>const CGBlockInfo &amp;Info</argument>,
<argument>const DeclMapTy &amp;ldm</argument>,
<argument>bool IsLambdaConversionToBlock</argument>,
<argument>bool BuildGlobalBlock</argument>)</argument_list></macro></expr>;</expr_stmt>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>cxxDestructorCanThrow</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><call><name>GenerateCopyHelperFunction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CGBlockInfo</name> <operator>&amp;</operator><name>blockInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><call><name>GenerateDestroyHelperFunction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CGBlockInfo</name> <operator>&amp;</operator><name>blockInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><call><name>GenerateObjCAtomicSetterCopyHelperFunction</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>ObjCPropertyImplDecl</name> <operator>*</operator><name>PID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><call><name>GenerateObjCAtomicGetterCopyHelperFunction</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>ObjCPropertyImplDecl</name> <operator>*</operator><name>PID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitBlockCopyAndAutorelease</name><argument_list>(<argument>llvm::Value *Block</argument>, <argument>QualType Ty</argument>)</argument_list></macro></expr>;</expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>BuildBlockRelease</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>DeclPtr</name></expr></argument>, <argument><expr><name>BlockFieldFlags</name> <name>flags</name></expr></argument>,
<argument><expr><name>bool</name> <name>CanThrow</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>AutoVarEmission</name></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>emitByrefStructureInit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AutoVarEmission</name> <modifier>&amp;</modifier></type><name>emission</name></decl></parameter>)</parameter_list>;</function_decl>

















<function_decl><type><name>void</name></type> <name>enterByrefCleanup</name><parameter_list>(<parameter><decl><type><name>CleanupKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>Addr</name></decl></parameter>, <parameter><decl><type><name>BlockFieldFlags</name></type> <name>Flags</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>LoadBlockVarAddr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>CanThrow</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>setBlockContextParameter</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ImplicitParamDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>unsigned</name> <name>argNum</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>ptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>Address</name></type> <name>LoadBlockStruct</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>Address</name></type> <name>GetAddrOfBlockDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>Address</name></type> <name>emitBlockByrefAddress</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>baseAddr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>V</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>followForward</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>Address</name></type> <name>emitBlockByrefAddress</name><argument_list>(<argument><expr><name>Address</name> <name>baseAddr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>BlockByrefInfo</name> <operator>&amp;</operator><name>info</name></expr></argument>,
<argument><expr><name>bool</name> <name>followForward</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>Twine</name> <operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><specifier>const</specifier> <name>BlockByrefInfo</name> <modifier>&amp;</modifier></type><name>getBlockByrefInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type> <name>BuildFunctionArgList</name><parameter_list>(<parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>, <parameter><decl><type><name>FunctionArgList</name> <modifier>&amp;</modifier></type><name>Args</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>GenerateCode</name><argument_list>(<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Fn</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CGFunctionInfo</name> <operator>&amp;</operator><name>FnInfo</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>markAsIgnoreThreadCheckingAtRuntime</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Fn</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<decl_stmt><decl><type><name>void</name></type> <name>StartFunction</name><argument_list>(<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>,
<argument><expr><name>QualType</name> <name>RetTy</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Fn</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CGFunctionInfo</name> <operator>&amp;</operator><name>FnInfo</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionArgList</name> <operator>&amp;</operator><name>Args</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>StartLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsConstructorDelegationValid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Ctor</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitConstructorBody</name><parameter_list>(<parameter><decl><type><name>FunctionArgList</name> <modifier>&amp;</modifier></type><name>Args</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitDestructorBody</name><parameter_list>(<parameter><decl><type><name>FunctionArgList</name> <modifier>&amp;</modifier></type><name>Args</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>emitImplicitAssignmentOperatorBody</name><parameter_list>(<parameter><decl><type><name>FunctionArgList</name> <modifier>&amp;</modifier></type><name>Args</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitFunctionBody</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>EmitBlockWithFallThrough</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>BB</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>EmitForwardingCallToLambda</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>LambdaCallOperator</name></decl></parameter>,
<parameter><decl><type><name>CallArgList</name> <modifier>&amp;</modifier></type><name>CallArgs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitLambdaBlockInvokeBody</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitLambdaDelegatingInvokeBody</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitLambdaStaticInvokeBody</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>void</name></type> <name>EmitLambdaVLACapture</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VariableArrayType</name> <modifier>*</modifier></type><name>VAT</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>LV</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>EmitStoreThroughLValue</name><argument_list>(<argument><expr><name>RValue</name><operator>::</operator><call><name>get</name><argument_list>(<argument><expr><name><name>VLASizeMap</name><index>[<expr><call><name><name>VAT</name><operator>-&gt;</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function_decl><type><name>void</name></type> <name>EmitAsanPrologueOrEpilogue</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Prologue</name></decl></parameter>)</parameter_list>;</function_decl>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name>DebugLoc</name> <call><name>EmitReturnBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>



<function_decl><type><name>void</name></type> <name>FinishFunction</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name><init>=<expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>StartThunk</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Fn</name></expr></argument>, <argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CGFunctionInfo</name> <operator>&amp;</operator><name>FnInfo</name></expr></argument>, <argument><expr><name>bool</name> <name>IsUnprototyped</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>EmitCallAndReturnForThunk</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>Callee</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ThunkInfo</name> <operator>*</operator><name>Thunk</name></expr></argument>, <argument><expr><name>bool</name> <name>IsUnprototyped</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>FinishThunk</name><parameter_list>()</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>void</name></type> <name>EmitMustTailThunk</name><argument_list>(<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>AdjustedThisPtr</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>Callee</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>generateThunk</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Fn</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CGFunctionInfo</name> <operator>&amp;</operator><name>FnInfo</name></expr></argument>,
<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ThunkInfo</name> <operator>&amp;</operator><name>Thunk</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsUnprototyped</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><macro><name>GenerateVarArgsThunk</name><argument_list>(<argument>llvm::Function *Fn</argument>,
<argument>const CGFunctionInfo &amp;FnInfo</argument>,
<argument>GlobalDecl GD</argument>, <argument>const ThunkInfo &amp;Thunk</argument>)</argument_list></macro></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>EmitCtorPrologue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>CD</name></decl></parameter>, <parameter><decl><type><name>CXXCtorType</name></type> <name>Type</name></decl></parameter>,
<parameter><decl><type><name>FunctionArgList</name> <modifier>&amp;</modifier></type><name>Args</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitInitializerForField</name><parameter_list>(<parameter><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>Field</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>LHS</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>)</parameter_list>;</function_decl>


<struct>struct <name>VPtr</name> <block>{
<decl_stmt><decl><type><name>BaseSubobject</name></type> <name>Base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>NearestVBase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharUnits</name></type> <name>OffsetFromNearestVBase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>VTableClass</name></decl>;</decl_stmt>
}</block>;</struct>


<function_decl><type><name>void</name></type> <name>InitializeVTablePointer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VPtr</name> <modifier>&amp;</modifier></type><name>vptr</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>VPtr</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>VPtrsVector</name></expr>;</expr_stmt></typedef>

<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>VisitedVirtualBasesSetTy</name></expr>;</expr_stmt></typedef>
<function_decl><type><name>VPtrsVector</name></type> <name>getVTablePointers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>VTableClass</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>getVTablePointers</name><parameter_list>(<parameter><decl><type><name>BaseSubobject</name></type> <name>Base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>NearestVBase</name></decl></parameter>,
<parameter><decl><type><name>CharUnits</name></type> <name>OffsetFromNearestVBase</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>BaseIsNonVirtualPrimaryBase</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>VTableClass</name></decl></parameter>,
<parameter><decl><type><name>VisitedVirtualBasesSetTy</name> <modifier>&amp;</modifier></type><name>VBases</name></decl></parameter>, <parameter><decl><type><name>VPtrsVector</name> <modifier>&amp;</modifier></type><name>vptrs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>InitializeVTablePointers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>ClassDecl</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>GetVTablePtr</name><argument_list>(<argument>Address This</argument>, <argument>llvm::Type *VTableTy</argument>,
<argument>const CXXRecordDecl *VTableClass</argument>)</argument_list></macro></expr>;</expr_stmt>

<enum>enum <name>CFITypeCheckKind</name> <block>{
<decl><name>CFITCK_VCall</name></decl>,
<decl><name>CFITCK_NVCall</name></decl>,
<decl><name>CFITCK_DerivedCast</name></decl>,
<decl><name>CFITCK_UnrelatedCast</name></decl>,
<decl><name>CFITCK_ICall</name></decl>,
<decl><name>CFITCK_NVMFCall</name></decl>,
<decl><name>CFITCK_VMFCall</name></decl>,
}</block>;</enum>




<decl_stmt><decl><type><name>void</name></type> <name>EmitVTablePtrCheckForCast</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Derived</name></expr></argument>,
<argument><expr><name>bool</name> <name>MayBeNull</name></expr></argument>, <argument><expr><name>CFITypeCheckKind</name> <name>TCK</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>EmitVTablePtrCheckForCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>VTable</name></expr></argument>,
<argument><expr><name>CFITypeCheckKind</name> <name>TCK</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>EmitVTablePtrCheck</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>VTable</name></expr></argument>,
<argument><expr><name>CFITypeCheckKind</name> <name>TCK</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<decl_stmt><decl><type><name>void</name></type> <name>EmitTypeMetadataCodeForVCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>VTable</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<function_decl><type><name>bool</name></type> <name>ShouldEmitVTableTypeCheckedLoad</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitVTableTypeCheckedLoad</name><argument_list>(<argument>const CXXRecordDecl *RD</argument>, <argument>llvm::Value *VTable</argument>,
<argument>uint64_t VTableByteOffset</argument>)</argument_list></macro></expr>;</expr_stmt>





<function_decl><type><name>void</name></type> <name>EnterDtorCleanups</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>Dtor</name></decl></parameter>, <parameter><decl><type><name>CXXDtorType</name></type> <name>Type</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>ShouldInstrumentFunction</name><parameter_list>()</parameter_list>;</function_decl>



<expr_stmt><expr><name>bool</name> <macro><name>ShouldXRayInstrumentFunction</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>AlwaysEmitXRayCustomEvents</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>AlwaysEmitXRayTypedEvents</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><call><name>EncodeAddrForUseInPrologue</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>F</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>Addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>DecodeAddrUsedInPrologue</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>F</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>EncodedAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<decl_stmt><decl><type><name>void</name></type> <name>EmitFunctionProlog</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CGFunctionInfo</name> <operator>&amp;</operator><name>FI</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Fn</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionArgList</name> <operator>&amp;</operator><name>Args</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>EmitFunctionEpilog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CGFunctionInfo</name> <modifier>&amp;</modifier></type><name>FI</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>EmitRetDbgLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>void</name></type> <name>EmitReturnValueCheck</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>RV</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>EmitStartEHSpec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitEndEHSpec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><call><name>getTerminateLandingPad</name><argument_list>()</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><call><name>getTerminateFunclet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><call><name>getTerminateHandler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><macro><name>ConvertTypeForMem</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><macro><name>ConvertType</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><macro><name>ConvertType</name><argument_list>(<argument>const TypeDecl *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>ConvertType</name><argument_list>(<argument><expr><call><name>getContext</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTypeDeclType</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>LoadObjCSelf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<function_decl><type><name>QualType</name></type> <name>TypeOfSelfObject</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>TypeEvaluationKind</name></type> <name>getEvaluationKind</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>hasScalarEvaluationKind</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getEvaluationKind</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TEK_Scalar</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>hasAggregateEvaluationKind</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getEvaluationKind</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TEK_Aggregate</name></expr>;</return>
</block_content>}</block></function>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><macro><name>createBasicBlock</name><argument_list>(<argument>const Twine &amp;name = <literal type="string">""</literal></argument>,
<argument>llvm::Function *parent = nullptr</argument>,
<argument>llvm::BasicBlock *before = nullptr</argument>)</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><name>BasicBlock</name><operator>::</operator><call><name>Create</name><argument_list>(<argument><expr><call><name>getLLVMContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>before</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<function_decl><type><name>JumpDest</name></type> <name>getJumpDestForLabel</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LabelDecl</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>void</name></type> <name>SimplifyForwardingBlocks</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>BB</name></expr></argument>)</argument_list></decl>;</decl_stmt>









<decl_stmt><decl><type><name>void</name></type> <name>EmitBlock</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>BB</name></expr></argument>, <argument><expr><name>bool</name> <name>IsFinished</name><operator>=</operator><name>false</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>EmitBlockAfterUses</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>BB</name></expr></argument>)</argument_list></decl>;</decl_stmt>









<decl_stmt><decl><type><name>void</name></type> <name>EmitBranch</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>Block</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>HaveInsertPoint</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Builder</name><operator>.</operator><name>GetInsertBlock</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>





<function><type><name>void</name></type> <name>EnsureInsertPoint</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HaveInsertPoint</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>EmitBlock</name><argument_list>(<argument><expr><call><name>createBasicBlock</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>



<function_decl><type><name>void</name></type> <name>ErrorUnsupported</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Type</name></decl></parameter>)</parameter_list>;</function_decl>





<function><type><name>LValue</name></type> <name>MakeAddrLValue</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>Addr</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>AlignmentSource</name></type> <name>Source</name> <init>= <expr><name>AlignmentSource</name><operator>::</operator><name>Type</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>LValue</name><operator>::</operator><call><name>MakeAddr</name><argument_list>(<argument><expr><name>Addr</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><call><name>getContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>LValueBaseInfo</name><argument_list>(<argument><expr><name>Source</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>CGM</name><operator>.</operator><name>getTBAAAccessInfo</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>LValue</name></type> <name>MakeAddrLValue</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>Addr</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>LValueBaseInfo</name></type> <name>BaseInfo</name></decl></parameter>,
<parameter><decl><type><name>TBAAAccessInfo</name></type> <name>TBAAInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>LValue</name><operator>::</operator><call><name>MakeAddr</name><argument_list>(<argument><expr><name>Addr</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><call><name>getContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>BaseInfo</name></expr></argument>, <argument><expr><name>TBAAInfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>LValue</name></type> <name>MakeAddrLValue</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>V</name></expr></argument>, <argument><expr><name>QualType</name> <name>T</name></expr></argument>, <argument><expr><name>CharUnits</name> <name>Alignment</name></expr></argument>,
<argument><expr><name>AlignmentSource</name> <name>Source</name> <operator>=</operator> <name>AlignmentSource</name><operator>::</operator><name>Type</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><name>LValue</name><operator>::</operator><call><name>MakeAddr</name><argument_list>(<argument><expr><call><name>Address</name><argument_list>(<argument><expr><name>V</name></expr></argument>, <argument><expr><name>Alignment</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><call><name>getContext</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>LValueBaseInfo</name><argument_list>(<argument><expr><name>Source</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>CGM</name><operator>.</operator><name>getTBAAAccessInfo</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>LValue</name></type> <name>MakeAddrLValue</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>V</name></expr></argument>, <argument><expr><name>QualType</name> <name>T</name></expr></argument>, <argument><expr><name>CharUnits</name> <name>Alignment</name></expr></argument>,
<argument><expr><name>LValueBaseInfo</name> <name>BaseInfo</name></expr></argument>, <argument><expr><name>TBAAAccessInfo</name> <name>TBAAInfo</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><name>LValue</name><operator>::</operator><call><name>MakeAddr</name><argument_list>(<argument><expr><call><name>Address</name><argument_list>(<argument><expr><name>V</name></expr></argument>, <argument><expr><name>Alignment</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><call><name>getContext</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>BaseInfo</name></expr></argument>, <argument><expr><name>TBAAInfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>LValue</name></type> <name>MakeNaturalAlignPointeeAddrLValue</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>V</name></expr></argument>, <argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LValue</name></type> <name>MakeNaturalAlignAddrLValue</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>V</name></expr></argument>, <argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>Address</name></type> <name>EmitLoadOfReference</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>RefLVal</name></decl></parameter>,
<parameter><decl><type><name>LValueBaseInfo</name> <modifier>*</modifier></type><name>PointeeBaseInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>TBAAAccessInfo</name> <modifier>*</modifier></type><name>PointeeTBAAInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitLoadOfReferenceLValue</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>RefLVal</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>LValue</name></type> <name>EmitLoadOfReferenceLValue</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>RefAddr</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>RefTy</name></decl></parameter>,
<parameter><decl><type><name>AlignmentSource</name></type> <name>Source</name> <init>=
<expr><name>AlignmentSource</name><operator>::</operator><name>Type</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>LValue</name></type> <name>RefLVal</name> <init>= <expr><call><name>MakeAddrLValue</name><argument_list>(<argument><expr><name>RefAddr</name></expr></argument>, <argument><expr><name>RefTy</name></expr></argument>, <argument><expr><call><name>LValueBaseInfo</name><argument_list>(<argument><expr><name>Source</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>CGM</name><operator>.</operator><name>getTBAAAccessInfo</name></name><argument_list>(<argument><expr><name>RefTy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>EmitLoadOfReferenceLValue</name><argument_list>(<argument><expr><name>RefLVal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>Address</name></type> <name>EmitLoadOfPointer</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>Ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PointerType</name> <modifier>*</modifier></type><name>PtrTy</name></decl></parameter>,
<parameter><decl><type><name>LValueBaseInfo</name> <modifier>*</modifier></type><name>BaseInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>TBAAAccessInfo</name> <modifier>*</modifier></type><name>TBAAInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitLoadOfPointerLValue</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>Ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PointerType</name> <modifier>*</modifier></type><name>PtrTy</name></decl></parameter>)</parameter_list>;</function_decl>



























<expr_stmt><expr><name>llvm</name><operator>::</operator><name>AllocaInst</name> <operator>*</operator><call><name>CreateTempAlloca</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Twine</name> <operator>&amp;</operator><name>Name</name> <operator>=</operator> <literal type="string">"tmp"</literal></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>ArraySize</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Address</name></type> <name>CreateTempAlloca</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>CharUnits</name> <name>align</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Twine</name> <operator>&amp;</operator><name>Name</name> <operator>=</operator> <literal type="string">"tmp"</literal></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>ArraySize</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>Address</name> <operator>*</operator><name>Alloca</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Address</name></type> <name>CreateTempAllocaWithoutCast</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>CharUnits</name> <name>align</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Twine</name> <operator>&amp;</operator><name>Name</name> <operator>=</operator> <literal type="string">"tmp"</literal></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>ArraySize</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>











<decl_stmt><decl><type><name>Address</name></type> <name>CreateDefaultAlignTempAlloca</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>Ty</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Twine</name> <operator>&amp;</operator><name>Name</name> <operator>=</operator> <literal type="string">"tmp"</literal></expr></argument>)</argument_list></decl>;</decl_stmt>








<decl_stmt><decl><type><name>void</name></type> <name>InitTempAlloca</name><argument_list>(<argument><expr><name>Address</name> <name>Alloca</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Value</name></expr></argument>)</argument_list></decl>;</decl_stmt>









<function_decl><type><name>Address</name></type> <name>CreateIRTemp</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Twine</name> <modifier>&amp;</modifier></type><name>Name</name> <init>= <expr><literal type="string">"tmp"</literal></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>Address</name></type> <name>CreateMemTemp</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Twine</name> <modifier>&amp;</modifier></type><name>Name</name> <init>= <expr><literal type="string">"tmp"</literal></expr></init></decl></parameter>,
<parameter><decl><type><name>Address</name> <modifier>*</modifier></type><name>Alloca</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Address</name></type> <name>CreateMemTemp</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>CharUnits</name></type> <name>Align</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Twine</name> <modifier>&amp;</modifier></type><name>Name</name> <init>= <expr><literal type="string">"tmp"</literal></expr></init></decl></parameter>,
<parameter><decl><type><name>Address</name> <modifier>*</modifier></type><name>Alloca</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>Address</name></type> <name>CreateMemTempWithoutCast</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Twine</name> <modifier>&amp;</modifier></type><name>Name</name> <init>= <expr><literal type="string">"tmp"</literal></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Address</name></type> <name>CreateMemTempWithoutCast</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>CharUnits</name></type> <name>Align</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Twine</name> <modifier>&amp;</modifier></type><name>Name</name> <init>= <expr><literal type="string">"tmp"</literal></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function><type><name>AggValueSlot</name></type> <name>CreateAggTemp</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Twine</name> <modifier>&amp;</modifier></type><name>Name</name> <init>= <expr><literal type="string">"tmp"</literal></expr></init></decl></parameter>,
<parameter><decl><type><name>Address</name> <modifier>*</modifier></type><name>Alloca</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>AggValueSlot</name><operator>::</operator><call><name>forAddr</name><argument_list>(<argument><expr><call><name>CreateMemTemp</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>Name</name></expr></argument>, <argument><expr><name>Alloca</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>T</name><operator>.</operator><name>getQualifiers</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>AggValueSlot</name><operator>::</operator><name>IsNotDestructed</name></expr></argument>,
<argument><expr><name>AggValueSlot</name><operator>::</operator><name>DoesNotNeedGCBarriers</name></expr></argument>,
<argument><expr><name>AggValueSlot</name><operator>::</operator><name>IsNotAliased</name></expr></argument>,
<argument><expr><name>AggValueSlot</name><operator>::</operator><name>DoesNotOverlap</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitCastToVoidPtr</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EvaluateExprAsBool</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function_decl><type><name>void</name></type> <name>EmitIgnoredExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>RValue</name></type> <name>EmitAnyExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>AggValueSlot</name></type> <name>aggSlot</name> <init>= <expr><name>AggValueSlot</name><operator>::</operator><call><name>ignored</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ignoreResult</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>Address</name></type> <name>EmitVAListRef</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>Address</name></type> <name>EmitMSVAListRef</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>RValue</name></type> <name>EmitAnyExprToTemp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>EmitAnyExprToMem</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>Location</name></decl></parameter>,
<parameter><decl><type><name>Qualifiers</name></type> <name>Quals</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsInitializer</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitAnyExprToExn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>Addr</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>EmitExprAsInit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>init</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ValueDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>lvalue</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>capturedByInit</name></decl></parameter>)</parameter_list>;</function_decl>



<function><type><name>bool</name></type> <name>hasVolatileMember</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>RecordType</name> <modifier>*</modifier></type><name>RT</name> <init>= <expr><name><name>T</name><operator>-&gt;</operator><name>getAs</name></name><operator>&lt;</operator><name>RecordType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>RecordDecl</name> <modifier>*</modifier></type><name>RD</name> <init>= <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>RecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>RT</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>RD</name><operator>-&gt;</operator><name>hasVolatileMember</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<expr_stmt><expr><name>AggValueSlot</name><operator>::</operator><name>Overlap_t</name> <macro><name>getOverlapForReturnValue</name><argument_list>()</argument_list></macro> <block>{



<return>return <expr><name>AggValueSlot</name><operator>::</operator><name>DoesNotOverlap</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>AggValueSlot</name><operator>::</operator><name>Overlap_t</name> <call><name>getOverlapForFieldInit</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><name>FD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>AggValueSlot</name><operator>::</operator><name>Overlap_t</name> <macro><name>getOverlapForBaseInit</name><argument_list>(<argument>const CXXRecordDecl *RD</argument>,
<argument>const CXXRecordDecl *BaseRD</argument>,
<argument>bool IsVirtual</argument>)</argument_list></macro></expr>;</expr_stmt>


<function><type><name>void</name></type> <name>EmitAggregateAssign</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>Dest</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>Src</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>EltTy</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>IsVolatile</name> <init>= <expr><call><name>hasVolatileMember</name><argument_list>(<argument><expr><name>EltTy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>EmitAggregateCopy</name><argument_list>(<argument><expr><name>Dest</name></expr></argument>, <argument><expr><name>Src</name></expr></argument>, <argument><expr><name>EltTy</name></expr></argument>, <argument><expr><name>AggValueSlot</name><operator>::</operator><name>MayOverlap</name></expr></argument>, <argument><expr><name>IsVolatile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name>void</name></type> <name>EmitAggregateCopyCtor</name><argument_list>(<argument><expr><name>LValue</name> <name>Dest</name></expr></argument>, <argument><expr><name>LValue</name> <name>Src</name></expr></argument>,
<argument><expr><name>AggValueSlot</name><operator>::</operator><name>Overlap_t</name> <name>MayOverlap</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>EmitAggregateCopy</name><argument_list>(<argument><expr><name>Dest</name></expr></argument>, <argument><expr><name>Src</name></expr></argument>, <argument><expr><call><name><name>Src</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>MayOverlap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>








<decl_stmt><decl><type><name>void</name></type> <name>EmitAggregateCopy</name><argument_list>(<argument><expr><name>LValue</name> <name>Dest</name></expr></argument>, <argument><expr><name>LValue</name> <name>Src</name></expr></argument>, <argument><expr><name>QualType</name> <name>EltTy</name></expr></argument>,
<argument><expr><name>AggValueSlot</name><operator>::</operator><name>Overlap_t</name> <name>MayOverlap</name></expr></argument>,
<argument><expr><name>bool</name> <name>isVolatile</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function><type><name>Address</name></type> <name>GetAddrOfLocalVar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>it</name> <init>= <expr><call><name><name>LocalDeclMap</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>VD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>it</name> <operator>!=</operator> <call><name><name>LocalDeclMap</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Invalid argument to GetAddrOfLocalVar(), no decl!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>it</name><operator>-&gt;</operator><name>second</name></name></expr>;</return>
</block_content>}</block></function>



<function_decl><type><name>LValue</name></type> <name>getOrCreateOpaqueLValueMapping</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OpaqueValueExpr</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>RValue</name></type> <name>getOrCreateOpaqueRValueMapping</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OpaqueValueExpr</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>getArrayInitIndex</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>ArrayInitIndex</name></expr>;</return> }</block></expr></expr_stmt>



<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name></type> <name>getAccessedFieldNo</name><argument_list>(<argument><expr><name>unsigned</name> <name>Idx</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>Elts</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BlockAddress</name> <operator>*</operator><call><name>GetAddrOfLabel</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LabelDecl</name> <operator>*</operator><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><call><name>GetIndirectGotoBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsWrappedCXXThis</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>EmitNullInitialization</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>DestPtr</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>)</parameter_list>;</function_decl>







<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitVAStartEnd</name><argument_list>(<argument>llvm::Value *ArgValue</argument>, <argument>bool IsStart</argument>)</argument_list></macro></expr>;</expr_stmt>









<function_decl><type><name>Address</name></type> <name>EmitVAArg</name><parameter_list>(<parameter><decl><type><name>VAArgExpr</name> <modifier>*</modifier></type><name>VE</name></decl></parameter>, <parameter><decl><type><name>Address</name> <modifier>&amp;</modifier></type><name>VAListAddr</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>emitArrayLength</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ArrayType</name> <operator>*</operator><name>arrayType</name></expr></argument>,
<argument><expr><name>QualType</name> <operator>&amp;</operator><name>baseType</name></expr></argument>,
<argument><expr><name>Address</name> <operator>&amp;</operator><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<function_decl><type><name>void</name></type> <name>EmitVariablyModifiedType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>VlaSizePair</name> <block>{
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>NumElts</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>Type</name></decl>;</decl_stmt>

<macro><name>VlaSizePair</name><argument_list>(<argument>llvm::Value *NE</argument>, <argument>QualType T</argument>)</argument_list></macro> : <expr_stmt><expr><call><name>NumElts</name><argument_list>(<argument><expr><name>NE</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Type</name><argument_list>(<argument>T</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>



<function_decl><type><name>VlaSizePair</name></type> <name>getVLAElements1D</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VariableArrayType</name> <modifier>*</modifier></type><name>vla</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>VlaSizePair</name></type> <name>getVLAElements1D</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>vla</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>VlaSizePair</name></type> <name>getVLASize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VariableArrayType</name> <modifier>*</modifier></type><name>vla</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>VlaSizePair</name></type> <name>getVLASize</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>vla</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>LoadCXXThis</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>CXXThisValue</name> <operator>&amp;&amp;</operator> <literal type="string">"no 'this' value for this function"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>CXXThisValue</name></expr>;</return>
}</block></expr></expr_stmt>
<function_decl><type><name>Address</name></type> <name>LoadCXXThisAddress</name><parameter_list>()</parameter_list>;</function_decl>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>LoadCXXVTT</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>CXXStructorImplicitParamValue</name> <operator>&amp;&amp;</operator> <literal type="string">"no VTT value for this function"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>CXXStructorImplicitParamValue</name></expr>;</return>
}</block></expr></expr_stmt>



<function_decl><type><name>Address</name></type>
<name>GetAddressOfDirectBaseInCompleteClass</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>Value</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Derived</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>BaseIsVirtual</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldNullCheckClassCastValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CastExpr</name> <modifier>*</modifier></type><name>Cast</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>Address</name></type> <name>GetAddressOfBaseClass</name><argument_list>(<argument><expr><name>Address</name> <name>Value</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>Derived</name></expr></argument>,
<argument><expr><name>CastExpr</name><operator>::</operator><name>path_const_iterator</name> <name>PathBegin</name></expr></argument>,
<argument><expr><name>CastExpr</name><operator>::</operator><name>path_const_iterator</name> <name>PathEnd</name></expr></argument>,
<argument><expr><name>bool</name> <name>NullCheckValue</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Address</name></type> <name>GetAddressOfDerivedClass</name><argument_list>(<argument><expr><name>Address</name> <name>Value</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>Derived</name></expr></argument>,
<argument><expr><name>CastExpr</name><operator>::</operator><name>path_const_iterator</name> <name>PathBegin</name></expr></argument>,
<argument><expr><name>CastExpr</name><operator>::</operator><name>path_const_iterator</name> <name>PathEnd</name></expr></argument>,
<argument><expr><name>bool</name> <name>NullCheckValue</name></expr></argument>)</argument_list></decl>;</decl_stmt>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>GetVTTParameter</name><argument_list>(<argument>GlobalDecl GD</argument>, <argument>bool ForVirtualBase</argument>,
<argument>bool Delegating</argument>)</argument_list></macro></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>EmitDelegateCXXConstructorCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Ctor</name></decl></parameter>,
<parameter><decl><type><name>CXXCtorType</name></type> <name>CtorType</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionArgList</name> <modifier>&amp;</modifier></type><name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>EmitDelegatingCXXConstructorCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Ctor</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionArgList</name> <modifier>&amp;</modifier></type><name>Args</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type> <name>EmitInlinedInheritingCXXConstructorCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Ctor</name></decl></parameter>,
<parameter><decl><type><name>CXXCtorType</name></type> <name>CtorType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ForVirtualBase</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Delegating</name></decl></parameter>,
<parameter><decl><type><name>CallArgList</name> <modifier>&amp;</modifier></type><name>Args</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>EmitInheritedCXXConstructorCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ForVirtualBase</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>This</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>InheritedFromVBase</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXInheritedCtorInitExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitCXXConstructorCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>CXXCtorType</name></type> <name>Type</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ForVirtualBase</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Delegating</name></decl></parameter>,
<parameter><decl><type><name>AggValueSlot</name></type> <name>ThisAVS</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXConstructExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>EmitCXXConstructorCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXConstructorDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>CXXCtorType</name> <name>Type</name></expr></argument>,
<argument><expr><name>bool</name> <name>ForVirtualBase</name></expr></argument>, <argument><expr><name>bool</name> <name>Delegating</name></expr></argument>,
<argument><expr><name>Address</name> <name>This</name></expr></argument>, <argument><expr><name>CallArgList</name> <operator>&amp;</operator><name>Args</name></expr></argument>,
<argument><expr><name>AggValueSlot</name><operator>::</operator><name>Overlap_t</name> <name>Overlap</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>bool</name> <name>NewPointerIsChecked</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>EmitVTableAssumptionLoads</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>ClassDecl</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>This</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitVTableAssumptionLoad</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VPtr</name> <modifier>&amp;</modifier></type><name>vptr</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>This</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitSynthesizedCXXCopyCtorCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>Address</name></type> <name>This</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>Src</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXConstructExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitCXXAggrConstructorCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ArrayType</name> <modifier>*</modifier></type><name>ArrayTy</name></decl></parameter>,
<parameter><decl><type><name>Address</name></type> <name>ArrayPtr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXConstructExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>NewPointerIsChecked</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ZeroInitialization</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>EmitCXXAggrConstructorCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXConstructorDecl</name> <operator>*</operator><name>D</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>NumElements</name></expr></argument>,
<argument><expr><name>Address</name> <name>ArrayPtr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CXXConstructExpr</name> <operator>*</operator><name>E</name></expr></argument>,
<argument><expr><name>bool</name> <name>NewPointerIsChecked</name></expr></argument>,
<argument><expr><name>bool</name> <name>ZeroInitialization</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Destroyer</name></type> <name>destroyCXXObject</name></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>EmitCXXDestructorCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>CXXDtorType</name></type> <name>Type</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ForVirtualBase</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Delegating</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>This</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>ThisTy</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>EmitNewArrayInitializer</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXNewExpr</name> <operator>*</operator><name>E</name></expr></argument>, <argument><expr><name>QualType</name> <name>elementType</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>ElementTy</name></expr></argument>, <argument><expr><name>Address</name> <name>NewPtr</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>NumElements</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>AllocSizeWithoutCookie</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>EmitCXXTemporary</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXTemporary</name> <modifier>*</modifier></type><name>Temporary</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>TempType</name></decl></parameter>,
<parameter><decl><type><name>Address</name></type> <name>Ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitSehCppScopeBegin</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitSehCppScopeEnd</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitSehTryScopeBegin</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitSehTryScopeEnd</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitLifetimeStart</name><argument_list>(<argument>llvm::TypeSize Size</argument>, <argument>llvm::Value *Addr</argument>)</argument_list></macro></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>EmitLifetimeEnd</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Size</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Addr</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitCXXNewExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXNewExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function_decl><type><name>void</name></type> <name>EmitCXXDeleteExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXDeleteExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>EmitDeleteCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>DeleteFD</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Ptr</name></expr></argument>,
<argument><expr><name>QualType</name> <name>DeleteTy</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>NumElements</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>CharUnits</name> <name>CookieSize</name> <operator>=</operator> <call><name>CharUnits</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>RValue</name></type> <name>EmitBuiltinNewDeleteCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>Type</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>TheCallExpr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsDelete</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitCXXTypeidExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXTypeidExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitDynamicCast</name><argument_list>(<argument>Address V</argument>, <argument>const CXXDynamicCastExpr *DCE</argument>)</argument_list></macro></expr>;</expr_stmt>
<function_decl><type><name>Address</name></type> <name>EmitCXXUuidofExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXUuidofExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>




<enum>enum <name>TypeCheckKind</name> <block>{

<decl><name>TCK_Load</name></decl>,

<decl><name>TCK_Store</name></decl>,



<decl><name>TCK_ReferenceBinding</name></decl>,


<decl><name>TCK_MemberAccess</name></decl>,


<decl><name>TCK_MemberCall</name></decl>,

<decl><name>TCK_ConstructorCall</name></decl>,


<decl><name>TCK_DowncastPointer</name></decl>,


<decl><name>TCK_DowncastReference</name></decl>,


<decl><name>TCK_Upcast</name></decl>,


<decl><name>TCK_UpcastToVirtualBase</name></decl>,

<decl><name>TCK_NonnullAssign</name></decl>,


<decl><name>TCK_DynamicOperation</name></decl>
}</block>;</enum>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isNullPointerAllowed</name><parameter_list>(<parameter><decl><type><name>TypeCheckKind</name></type> <name>TCK</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isVptrCheckRequired</name><parameter_list>(<parameter><decl><type><name>TypeCheckKind</name></type> <name>TCK</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>bool</name> <macro><name>sanitizePerformTypeCheck</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<decl_stmt><decl><type><name>void</name></type> <name>EmitTypeCheck</name><argument_list>(<argument><expr><name>TypeCheckKind</name> <name>TCK</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>V</name></expr></argument>,
<argument><expr><name>QualType</name> <name>Type</name></expr></argument>, <argument><expr><name>CharUnits</name> <name>Alignment</name> <operator>=</operator> <name>CharUnits</name><operator>::</operator><call><name>Zero</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>SanitizerSet</name> <name>SkippedChecks</name> <operator>=</operator> <call><name>SanitizerSet</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>ArraySize</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<decl_stmt><decl><type><name>void</name></type> <name>EmitBoundsCheck</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>E</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>Base</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Index</name></expr></argument>,
<argument><expr><name>QualType</name> <name>IndexType</name></expr></argument>, <argument><expr><name>bool</name> <name>Accessed</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitScalarPrePostIncDec</name><argument_list>(<argument>const UnaryOperator *E</argument>, <argument>LValue LV</argument>,
<argument>bool isInc</argument>, <argument>bool isPre</argument>)</argument_list></macro></expr>;</expr_stmt>
<function_decl><type><name>ComplexPairTy</name></type> <name>EmitComplexPrePostIncDec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UnaryOperator</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>LV</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isInc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isPre</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>DebugLoc</name> <macro><name>SourceLocToDebugLoc</name><argument_list>(<argument>SourceLocation Location</argument>)</argument_list></macro></expr>;</expr_stmt>


<function_decl><type><name>unsigned</name></type> <name>getDebugInfoFIndex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RecordDecl</name> <modifier>*</modifier></type><name>Rec</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>FieldIndex</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>void</name></type> <name>EmitDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>EmitVarDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitScalarInit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>init</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ValueDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>lvalue</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>capturedByInit</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><name>void</name></type> <name>SpecialInitFn</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>Init</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Address</name></expr></argument>)</argument_list>;</typedef>



<function_decl><type><name>bool</name></type> <name>isTrivialInitializer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>EmitAutoVarDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>class</name></type> <name>AutoVarEmission</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CodeGenFunction</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>Variable</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>Address</name></type> <name>Addr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>NRVOFlag</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>IsEscapingByRef</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>IsConstantAggregate</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>SizeForLifetimeMarkers</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>Address</name></type> <name>AllocaAddr</name></decl>;</decl_stmt>

<struct>struct <name>Invalid</name> <block>{}</block>;</struct>
<expr_stmt><expr><call><name>AutoVarEmission</name><argument_list>(<argument><expr><name>Invalid</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Variable</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Addr</name><argument_list>(<argument><expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>AllocaAddr</name><argument_list>(<argument>Address::invalid()</argument>)</argument_list></macro> <expr><block>{}</block>

<call><name>AutoVarEmission</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>&amp;</operator><name>variable</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Variable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>variable</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Addr</name><argument_list>(<argument><expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>NRVOFlag</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>IsEscapingByRef</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IsConstantAggregate</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>SizeForLifetimeMarkers</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>AllocaAddr</name><argument_list>(<argument>Address::invalid()</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>wasEmittedAsGlobal</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name><name>Addr</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<label><name>public</name>:</label>
<function><type><specifier>static</specifier> <name>AutoVarEmission</name></type> <name>invalid</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>AutoVarEmission</name><argument_list>(<argument><expr><call><name>Invalid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>useLifetimeMarkers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>SizeForLifetimeMarkers</name> <operator>!=</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>getSizeForLifetimeMarkers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>useLifetimeMarkers</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>SizeForLifetimeMarkers</name></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name>Address</name> <macro><name>getAllocatedAddress</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Addr</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>Address</name> <macro><name>getOriginalAllocatedAddress</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AllocaAddr</name></expr>;</return> }</block></expr></expr_stmt>




<decl_stmt><decl><type><name>Address</name></type> <name>getObjectAddress</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsEscapingByRef</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Addr</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name><name>CGF</name><operator>.</operator><name>emitBlockByrefAddress</name></name><argument_list>(<argument><expr><name>Addr</name></expr></argument>, <argument><expr><name>Variable</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<function_decl><type><name>AutoVarEmission</name></type> <name>EmitAutoVarAlloca</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>&amp;</modifier></type><name>var</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitAutoVarInit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AutoVarEmission</name> <modifier>&amp;</modifier></type><name>emission</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitAutoVarCleanups</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AutoVarEmission</name> <modifier>&amp;</modifier></type><name>emission</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>emitAutoVarTypeCleanup</name><argument_list>(<argument><expr><specifier>const</specifier> <name>AutoVarEmission</name> <operator>&amp;</operator><name>emission</name></expr></argument>,
<argument><expr><name>QualType</name><operator>::</operator><name>DestructionKind</name> <name>dtorKind</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<function_decl><type><name>void</name></type> <name>EmitAndRegisterVariableArrayDimensions</name><parameter_list>(<parameter><decl><type><name>CGDebugInfo</name> <modifier>*</modifier></type><name>DI</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>EmitDebugInfo</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>EmitStaticVarDecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name><operator>::</operator><name>LinkageTypes</name> <name>Linkage</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>ParamValue</name> <block>{<block_content>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Value</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>Alignment</name></decl>;</decl_stmt>
<macro><name>ParamValue</name><argument_list>(<argument>llvm::Value *V</argument>, <argument>unsigned A</argument>)</argument_list></macro> : <expr_stmt><expr><call><name>Value</name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Alignment</name><argument_list>(<argument>A</argument>)</argument_list></macro> <expr><block>{}</block>
<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>ParamValue</name> <macro><name>forDirect</name><argument_list>(<argument>llvm::Value *value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>ParamValue</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><specifier>static</specifier> <name>ParamValue</name></type> <name>forIndirect</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>addr</name><operator>.</operator><name>getAlignment</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isZero</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ParamValue</name><argument_list>(<argument><expr><call><name><name>addr</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>addr</name><operator>.</operator><name>getAlignment</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getQuantity</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>isIndirect</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Alignment</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>getAnyValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Value</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>getDirectValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isIndirect</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Value</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>Address</name> <macro><name>getIndirectAddress</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isIndirect</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>Address</name><argument_list>(<argument><expr><name>Value</name></expr></argument>, <argument><expr><name>CharUnits</name><operator>::</operator><call><name>fromQuantity</name><argument_list>(<argument><expr><name>Alignment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<function_decl><type><name>void</name></type> <name>EmitParmDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>ParamValue</name></type> <name>Arg</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ArgNo</name></decl></parameter>)</parameter_list>;</function_decl>










<function_decl><type><name>PeepholeProtection</name></type> <name>protectFromPeepholes</name><parameter_list>(<parameter><decl><type><name>RValue</name></type> <name>rvalue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>unprotectFromPeepholes</name><parameter_list>(<parameter><decl><type><name>PeepholeProtection</name></type> <name>protection</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>emitAlignmentAssumptionCheck</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Ptr</name></expr></argument>, <argument><expr><name>QualType</name> <name>Ty</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>AssumptionLoc</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Alignment</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>OffsetValue</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>TheCheck</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Instruction</name> <operator>*</operator><name>Assumption</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>emitAlignmentAssumption</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>PtrValue</name></expr></argument>, <argument><expr><name>QualType</name> <name>Ty</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>AssumptionLoc</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Alignment</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>OffsetValue</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>emitAlignmentAssumption</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>PtrValue</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>E</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>AssumptionLoc</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Alignment</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>OffsetValue</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<function_decl><type><name>void</name></type> <name>EmitStopPoint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>void</name></type> <name>EmitStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Attr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Attrs</name> <init>= <expr><name>None</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>bool</name></type> <name>EmitSimpleStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Attr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Attrs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Address</name></type> <name>EmitCompoundStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CompoundStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>GetLast</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>AggValueSlot</name></type> <name>AVS</name> <init>= <expr><name>AggValueSlot</name><operator>::</operator><call><name>ignored</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Address</name></type> <name>EmitCompoundStmtWithoutScope</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CompoundStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>GetLast</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>AggValueSlot</name></type> <name>AVS</name> <init>=
<expr><name>AggValueSlot</name><operator>::</operator><call><name>ignored</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>EmitLabel</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LabelDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitLabelStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LabelStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitAttributedStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AttributedStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitGotoStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GotoStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitIndirectGotoStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IndirectGotoStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitIfStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IfStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitWhileStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>WhileStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Attr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Attrs</name> <init>= <expr><name>None</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitDoStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DoStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Attr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Attrs</name> <init>= <expr><name>None</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitForStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ForStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Attr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Attrs</name> <init>= <expr><name>None</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitReturnStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ReturnStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitDeclStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitBreakStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BreakStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitContinueStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ContinueStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitSwitchStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SwitchStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitDefaultStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DefaultStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Attr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitCaseStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CaseStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Attr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitCaseStmtRange</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CaseStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Attr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Attrs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitAsmStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AsmStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitObjCForCollectionStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCForCollectionStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitObjCAtTryStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCAtTryStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitObjCAtThrowStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCAtThrowStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitObjCAtSynchronizedStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCAtSynchronizedStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitObjCAutoreleasePoolStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCAutoreleasePoolStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitCoroutineBody</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CoroutineBodyStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitCoreturnStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CoreturnStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>RValue</name></type> <name>EmitCoawaitExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CoawaitExpr</name> <modifier>&amp;</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>AggValueSlot</name></type> <name>aggSlot</name> <init>= <expr><name>AggValueSlot</name><operator>::</operator><call><name>ignored</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ignoreResult</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitCoawaitLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CoawaitExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>RValue</name></type> <name>EmitCoyieldExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CoyieldExpr</name> <modifier>&amp;</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>AggValueSlot</name></type> <name>aggSlot</name> <init>= <expr><name>AggValueSlot</name><operator>::</operator><call><name>ignored</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ignoreResult</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitCoyieldLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CoyieldExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>RValue</name></type> <name>EmitCoroutineIntrinsic</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>IID</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EnterCXXTryStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXTryStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsFnTryBlock</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ExitCXXTryStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXTryStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsFnTryBlock</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitCXXTryStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXTryStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitSEHTryStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SEHTryStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitSEHLeaveStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SEHLeaveStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EnterSEHTryStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SEHTryStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ExitSEHTryStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SEHTryStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>VolatilizeTryBlocks</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>BB</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>V</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>pushSEHCleanup</name><argument_list>(<argument><expr><name>CleanupKind</name> <name>kind</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>FinallyFunc</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>startOutlinedSEHHelper</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>ParentCGF</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsFilter</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>OutlinedStmt</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><call><name>GenerateSEHFilterFunction</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>ParentCGF</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>SEHExceptStmt</name> <operator>&amp;</operator><name>Except</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><call><name>GenerateSEHFinallyFunction</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>ParentCGF</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>SEHFinallyStmt</name> <operator>&amp;</operator><name>Finally</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>EmitSEHExceptionCodeSave</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>ParentCGF</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>ParentFP</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>EntryEBP</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitSEHExceptionCode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitSEHExceptionInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitSEHAbnormalTermination</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<function_decl><type><name>void</name></type> <name>EmitSimpleOMPExecutableDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>EmitCapturedLocals</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>ParentCGF</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>OutlinedStmt</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsFilter</name></decl></parameter>)</parameter_list>;</function_decl>






<decl_stmt><decl><type><name>Address</name></type> <name>recoverAddrOfEscapedLocal</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>ParentCGF</name></expr></argument>,
<argument><expr><name>Address</name> <name>ParentVar</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>ParentFP</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>EmitCXXForRangeStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXForRangeStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Attr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Attrs</name> <init>= <expr><name>None</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>class</name></type> <name>OMPCancelStackRAII</name> <block>{<block_content>
<decl_stmt><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>OMPCancelStackRAII</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>OpenMPDirectiveKind Kind</argument>,
<argument>bool HasCancel</argument>)</argument_list></macro>
: <macro><name>CGF</name><argument_list>(<argument>CGF</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>OMPCancelStack</name><operator>.</operator><name>enter</name></name><argument_list>(<argument><expr><name>CGF</name></expr></argument>, <argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>HasCancel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><operator>~</operator><macro><name>OMPCancelStackRAII</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name><name>CGF</name><operator>.</operator><name>OMPCancelStack</name><operator>.</operator><name>exit</name></name><argument_list>(<argument><expr><name>CGF</name></expr></argument>)</argument_list></call></expr>; }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>getTypeSize</name><argument_list>(<argument>QualType Ty</argument>)</argument_list></macro></expr>;</expr_stmt>
<function_decl><type><name>LValue</name></type> <name>InitCapturedStruct</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CapturedStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><macro><name>EmitCapturedStmt</name><argument_list>(<argument>const CapturedStmt &amp;S</argument>, <argument>CapturedRegionKind K</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><call><name>GenerateCapturedStmtFunction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CapturedStmt</name> <operator>&amp;</operator><name>S</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function_decl><type><name>Address</name></type> <name>GenerateCapturedStmtArgument</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CapturedStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><macro><name>GenerateOpenMPCapturedStmtFunction</name><argument_list>(<argument>const CapturedStmt &amp;S</argument>,
<argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;</expr_stmt>
<function_decl><type><name>void</name></type> <name>GenerateOpenMPCapturedVars</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CapturedStmt</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>CapturedVars</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>emitOMPSimpleStore</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>LVal</name></decl></parameter>, <parameter><decl><type><name>RValue</name></type> <name>RVal</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>RValTy</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>









<decl_stmt><decl><type><name>void</name></type> <name>EmitOMPAggregateAssign</name><argument_list>(
<argument><expr><name>Address</name> <name>DestAddr</name></expr></argument>, <argument><expr><name>Address</name> <name>SrcAddr</name></expr></argument>, <argument><expr><name>QualType</name> <name>OriginalType</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>Address</name>, <name>Address</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>CopyGen</name></expr></argument>)</argument_list></decl>;</decl_stmt>











<function_decl><type><name>void</name></type> <name>EmitOMPCopy</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>OriginalType</name></decl></parameter>,
<parameter><decl><type><name>Address</name></type> <name>DestAddr</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>SrcAddr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>DestVD</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>SrcVD</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Copy</name></decl></parameter>)</parameter_list>;</function_decl>













<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>, <argument><expr><name>RValue</name></expr></argument>&gt;</argument_list></name> <macro><name>EmitOMPAtomicSimpleUpdateExpr</name><argument_list>(
<argument>LValue X</argument>, <argument>RValue E</argument>, <argument>BinaryOperatorKind BO</argument>, <argument>bool IsXLHSInRHSPart</argument>,
<argument>llvm::AtomicOrdering AO</argument>, <argument>SourceLocation Loc</argument>,
<argument>const llvm::function_ref&lt;RValue(RValue)&gt; CommonGen</argument>)</argument_list></macro></expr>;</expr_stmt>
<function_decl><type><name>bool</name></type> <name>EmitOMPFirstprivateClause</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>OMPPrivateScope</name> <modifier>&amp;</modifier></type><name>PrivateScope</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPPrivateClause</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>OMPPrivateScope</name> <modifier>&amp;</modifier></type><name>PrivateScope</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>EmitOMPUseDevicePtrClause</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>OMPUseDevicePtrClause</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>OMPPrivateScope</name> <operator>&amp;</operator><name>PrivateScope</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>Address</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>CaptureDeviceAddrMap</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>EmitOMPUseDeviceAddrClause</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>OMPUseDeviceAddrClause</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>OMPPrivateScope</name> <operator>&amp;</operator><name>PrivateScope</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>Address</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>CaptureDeviceAddrMap</name></expr></argument>)</argument_list></decl>;</decl_stmt>











<function_decl><type><name>bool</name></type> <name>EmitOMPCopyinClause</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>











<function_decl><type><name>bool</name></type> <name>EmitOMPLastprivateClauseInit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>OMPPrivateScope</name> <modifier>&amp;</modifier></type><name>PrivateScope</name></decl></parameter>)</parameter_list>;</function_decl>







<decl_stmt><decl><type><name>void</name></type> <name>EmitOMPLastprivateClauseFinal</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPExecutableDirective</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><name>bool</name> <name>NoFinals</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>IsLastIterCond</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>EmitOMPLinearClause</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPLoopDirective</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><name>CodeGenFunction</name><operator>::</operator><name>OMPPrivateScope</name> <operator>&amp;</operator><name>PrivateScope</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>EmitOMPLinearClauseFinal</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>OMPLoopDirective</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><operator>(</operator><name>CodeGenFunction</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>CondGen</name></expr></argument>)</argument_list></decl>;</decl_stmt>







<function_decl><type><name>void</name></type> <name>EmitOMPReductionClauseInit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>OMPPrivateScope</name> <modifier>&amp;</modifier></type><name>PrivateScope</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ForInscan</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type> <name>EmitOMPReductionClauseFinal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OpenMPDirectiveKind</name></type> <name>ReductionKind</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>bool</name></type> <name>EmitOMPLinearClauseInit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPLoopDirective</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <expr_stmt><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>CodeGenFunction</name> <operator>&amp;</operator> ,
<name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator> ,
<specifier>const</specifier> <name>OMPTaskDataTy</name> <operator>&amp;</operator> <operator>)</operator></expr></argument>&gt;</argument_list></name>
<name>TaskGenTy</name></expr>;</expr_stmt></typedef>
<function_decl><type><name>void</name></type> <name>EmitOMPTaskBasedDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OpenMPDirectiveKind</name></type> <name>CapturedRegion</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegionCodeGenTy</name> <modifier>&amp;</modifier></type><name>BodyGen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TaskGenTy</name> <modifier>&amp;</modifier></type><name>TaskGen</name></decl></parameter>, <parameter><decl><type><name>OMPTaskDataTy</name> <modifier>&amp;</modifier></type><name>Data</name></decl></parameter>)</parameter_list>;</function_decl>
<struct>struct <name>OMPTargetDataInfo</name> <block>{
<decl_stmt><decl><type><name>Address</name></type> <name>BasePointersArray</name> <init>= <expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Address</name></type> <name>PointersArray</name> <init>= <expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Address</name></type> <name>SizesArray</name> <init>= <expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Address</name></type> <name>MappersArray</name> <init>= <expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumberOfTargetItems</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<function_decl><type><name>explicit</name></type> <name>OMPTargetDataInfo</name><parameter_list>()</parameter_list> <init>= <expr/>default</init>;</function_decl>
<macro><name>OMPTargetDataInfo</name><argument_list>(<argument>Address BasePointersArray</argument>, <argument>Address PointersArray</argument>,
<argument>Address SizesArray</argument>, <argument>Address MappersArray</argument>,
<argument>unsigned NumberOfTargetItems</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>BasePointersArray</name><argument_list>(<argument><expr><name>BasePointersArray</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>PointersArray</name><argument_list>(<argument><expr><name>PointersArray</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>SizesArray</name><argument_list>(<argument><expr><name>SizesArray</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>MappersArray</name><argument_list>(<argument><expr><name>MappersArray</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>NumberOfTargetItems</name><argument_list>(<argument>NumberOfTargetItems</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>
<function_decl><type><name>void</name></type> <name>EmitOMPTargetTaskBasedDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegionCodeGenTy</name> <modifier>&amp;</modifier></type><name>BodyGen</name></decl></parameter>,
<parameter><decl><type><name>OMPTargetDataInfo</name> <modifier>&amp;</modifier></type><name>InputInfo</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitOMPParallelDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPParallelDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPSimdDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPSimdDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTileDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTileDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPUnrollDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPUnrollDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPForDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPForDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPForSimdDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPForSimdDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPSectionsDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPSectionsDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPSectionDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPSectionDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPSingleDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPSingleDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPMasterDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPMasterDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPMaskedDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPMaskedDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPCriticalDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPCriticalDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPParallelForDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPParallelForDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPParallelForSimdDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPParallelForSimdDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPParallelSectionsDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPParallelSectionsDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPParallelMasterDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPParallelMasterDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTaskDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTaskDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTaskyieldDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTaskyieldDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPBarrierDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPBarrierDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTaskwaitDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTaskwaitDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTaskgroupDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTaskgroupDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPFlushDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPFlushDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPDepobjDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPDepobjDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPScanDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPScanDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPOrderedDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPOrderedDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPAtomicDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPAtomicDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTargetDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTargetDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTargetDataDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTargetDataDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTargetEnterDataDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTargetEnterDataDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTargetExitDataDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTargetExitDataDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTargetUpdateDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTargetUpdateDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTargetParallelDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTargetParallelDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>
<name>EmitOMPTargetParallelForDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTargetParallelForDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTeamsDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTeamsDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>
<name>EmitOMPCancellationPointDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPCancellationPointDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPCancelDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPCancelDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTaskLoopBasedDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPLoopDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTaskLoopDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTaskLoopDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTaskLoopSimdDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTaskLoopSimdDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPMasterTaskLoopDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPMasterTaskLoopDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>
<name>EmitOMPMasterTaskLoopSimdDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPMasterTaskLoopSimdDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPParallelMasterTaskLoopDirective</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>OMPParallelMasterTaskLoopDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPParallelMasterTaskLoopSimdDirective</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>OMPParallelMasterTaskLoopSimdDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPDistributeDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPDistributeDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPDistributeParallelForDirective</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>OMPDistributeParallelForDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPDistributeParallelForSimdDirective</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>OMPDistributeParallelForSimdDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPDistributeSimdDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPDistributeSimdDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTargetParallelForSimdDirective</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>OMPTargetParallelForSimdDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTargetSimdDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTargetSimdDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTeamsDistributeDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTeamsDistributeDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>
<name>EmitOMPTeamsDistributeSimdDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTeamsDistributeSimdDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTeamsDistributeParallelForSimdDirective</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>OMPTeamsDistributeParallelForSimdDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTeamsDistributeParallelForDirective</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>OMPTeamsDistributeParallelForDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTargetTeamsDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPTargetTeamsDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTargetTeamsDistributeDirective</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>OMPTargetTeamsDistributeDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTargetTeamsDistributeParallelForDirective</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>OMPTargetTeamsDistributeParallelForDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTargetTeamsDistributeParallelForSimdDirective</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>OMPTargetTeamsDistributeParallelForSimdDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPTargetTeamsDistributeSimdDirective</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>OMPTargetTeamsDistributeSimdDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EmitOMPTargetDeviceFunction</name><parameter_list>(<parameter><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>ParentName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPTargetDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>EmitOMPTargetParallelDeviceFunction</name><parameter_list>(<parameter><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>ParentName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPTargetParallelDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EmitOMPTargetParallelForDeviceFunction</name><parameter_list>(
<parameter><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>ParentName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPTargetParallelForDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EmitOMPTargetParallelForSimdDeviceFunction</name><parameter_list>(
<parameter><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>ParentName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPTargetParallelForSimdDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>EmitOMPTargetTeamsDeviceFunction</name><parameter_list>(<parameter><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>ParentName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPTargetTeamsDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EmitOMPTargetTeamsDistributeDeviceFunction</name><parameter_list>(
<parameter><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>ParentName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPTargetTeamsDistributeDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EmitOMPTargetTeamsDistributeSimdDeviceFunction</name><parameter_list>(
<parameter><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>ParentName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPTargetTeamsDistributeSimdDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EmitOMPTargetSimdDeviceFunction</name><parameter_list>(<parameter><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>ParentName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPTargetSimdDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EmitOMPTargetTeamsDistributeParallelForSimdDeviceFunction</name><parameter_list>(
<parameter><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>ParentName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPTargetTeamsDistributeParallelForSimdDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>EmitOMPTargetTeamsDistributeParallelForDeviceFunction</name><parameter_list>(
<parameter><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>ParentName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPTargetTeamsDistributeParallelForDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>






<expr_stmt><expr><name>llvm</name><operator>::</operator><name>CanonicalLoopInfo</name> <operator>*</operator><macro><name>EmitOMPCollapsedCanonicalLoopNest</name><argument_list>(<argument>const Stmt *S</argument>,
<argument>int Depth</argument>)</argument_list></macro></expr>;</expr_stmt>


<function_decl><type><name>void</name></type> <name>EmitOMPCanonicalLoop</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPCanonicalLoop</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>











<decl_stmt><decl><type><name>void</name></type> <name>EmitOMPInnerLoop</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>OMPExecutableDirective</name> <operator>&amp;</operator><name>S</name></expr></argument>, <argument><expr><name>bool</name> <name>RequiresCleanup</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>LoopCond</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>IncExpr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>CodeGenFunction</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>BodyGen</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>CodeGenFunction</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>PostIncGen</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>JumpDest</name></type> <name>getOMPCancelDestination</name><parameter_list>(<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>Kind</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitOMPPrivateLoopCounters</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPLoopDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>OMPPrivateScope</name> <modifier>&amp;</modifier></type><name>LoopScope</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitOMPLoopBody</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPLoopDirective</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>JumpDest</name></type> <name>LoopExit</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>EmitOMPWorksharingLoop</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPLoopDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>EUB</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CodeGenLoopBoundsTy</name> <modifier>&amp;</modifier></type><name>CodeGenLoopBounds</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CodeGenDispatchBoundsTy</name> <modifier>&amp;</modifier></type><name>CGDispatchBounds</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitOMPDistributeLoop</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPLoopDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CodeGenLoopTy</name> <modifier>&amp;</modifier></type><name>CodeGenLoop</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>IncExpr</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitOMPSimdInit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPLoopDirective</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>EmitOMPSimdFinal</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>OMPLoopDirective</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><operator>(</operator><name>CodeGenFunction</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>CondGen</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>LValue</name></type> <name>EmitOMPSharedLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitBlockLiteral</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CGBlockInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<struct>struct <name>OMPLoopArguments</name> <block>{

<decl_stmt><decl><type><name>Address</name></type> <name>LB</name> <init>= <expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Address</name></type> <name>UB</name> <init>= <expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Address</name></type> <name>ST</name> <init>= <expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Address</name></type> <name>IL</name> <init>= <expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Chunk</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>EUB</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>IncExpr</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Cond</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NextLB</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NextUB</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>OMPLoopArguments</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<macro><name>OMPLoopArguments</name><argument_list>(<argument>Address LB</argument>, <argument>Address UB</argument>, <argument>Address ST</argument>, <argument>Address IL</argument>,
<argument>llvm::Value *Chunk = nullptr</argument>, <argument>Expr *EUB = nullptr</argument>,
<argument>Expr *IncExpr = nullptr</argument>, <argument>Expr *Init = nullptr</argument>,
<argument>Expr *Cond = nullptr</argument>, <argument>Expr *NextLB = nullptr</argument>,
<argument>Expr *NextUB = nullptr</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>LB</name><argument_list>(<argument><expr><name>LB</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>UB</name><argument_list>(<argument><expr><name>UB</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ST</name><argument_list>(<argument><expr><name>ST</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IL</name><argument_list>(<argument><expr><name>IL</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Chunk</name><argument_list>(<argument><expr><name>Chunk</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>EUB</name><argument_list>(<argument><expr><name>EUB</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>IncExpr</name><argument_list>(<argument><expr><name>IncExpr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Init</name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Cond</name><argument_list>(<argument><expr><name>Cond</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>NextLB</name><argument_list>(<argument><expr><name>NextLB</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>NextUB</name><argument_list>(<argument>NextUB</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>
<function_decl><type><name>void</name></type> <name>EmitOMPOuterLoop</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>DynamicOrOrdered</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsMonotonic</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPLoopDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>OMPPrivateScope</name> <modifier>&amp;</modifier></type><name>LoopScope</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPLoopArguments</name> <modifier>&amp;</modifier></type><name>LoopArgs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CodeGenLoopTy</name> <modifier>&amp;</modifier></type><name>CodeGenLoop</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CodeGenOrderedTy</name> <modifier>&amp;</modifier></type><name>CodeGenOrdered</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPForOuterLoop</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OpenMPScheduleTy</name> <modifier>&amp;</modifier></type><name>ScheduleKind</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsMonotonic</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OMPLoopDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>OMPPrivateScope</name> <modifier>&amp;</modifier></type><name>LoopScope</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Ordered</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPLoopArguments</name> <modifier>&amp;</modifier></type><name>LoopArgs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CodeGenDispatchBoundsTy</name> <modifier>&amp;</modifier></type><name>CGDispatchBounds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitOMPDistributeOuterLoop</name><parameter_list>(<parameter><decl><type><name>OpenMPDistScheduleClauseKind</name></type> <name>ScheduleKind</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPLoopDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>OMPPrivateScope</name> <modifier>&amp;</modifier></type><name>LoopScope</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPLoopArguments</name> <modifier>&amp;</modifier></type><name>LoopArgs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CodeGenLoopTy</name> <modifier>&amp;</modifier></type><name>CodeGenLoopContent</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitSections</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>






<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitNonNullRValueCheck</name><argument_list>(<argument>RValue RV</argument>, <argument>QualType T</argument>)</argument_list></macro></expr>;</expr_stmt>


<function_decl><type><name>RValue</name></type> <name>GetUndefRValue</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>RValue</name></type> <name>EmitUnsupportedRValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Name</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>LValue</name></type> <name>EmitUnsupportedLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Name</name></decl></parameter>)</parameter_list>;</function_decl>

















<function_decl><type><name>LValue</name></type> <name>EmitLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>LValue</name></type> <name>EmitCheckedLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>TypeCheckKind</name></type> <name>TCK</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>RValue</name></type> <name>convertTempToRValue</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>type</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitAtomicInit</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>lvalue</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>LValueIsSuitableForInlineAtomic</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>Src</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>RValue</name></type> <name>EmitAtomicLoad</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>LV</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>SL</name></decl></parameter>,
<parameter><decl><type><name>AggValueSlot</name></type> <name>Slot</name> <init>= <expr><name>AggValueSlot</name><operator>::</operator><call><name>ignored</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>RValue</name></type> <name>EmitAtomicLoad</name><argument_list>(<argument><expr><name>LValue</name> <name>lvalue</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>loc</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>AtomicOrdering</name> <name>AO</name></expr></argument>, <argument><expr><name>bool</name> <name>IsVolatile</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>AggValueSlot</name> <name>slot</name> <operator>=</operator> <name>AggValueSlot</name><operator>::</operator><call><name>ignored</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>EmitAtomicStore</name><parameter_list>(<parameter><decl><type><name>RValue</name></type> <name>rvalue</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>lvalue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isInit</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>EmitAtomicStore</name><argument_list>(<argument><expr><name>RValue</name> <name>rvalue</name></expr></argument>, <argument><expr><name>LValue</name> <name>lvalue</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>AtomicOrdering</name> <name>AO</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsVolatile</name></expr></argument>, <argument><expr><name>bool</name> <name>isInit</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>RValue</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>EmitAtomicCompareExchange</name><argument_list>(
<argument>LValue Obj</argument>, <argument>RValue Expected</argument>, <argument>RValue Desired</argument>, <argument>SourceLocation Loc</argument>,
<argument>llvm::AtomicOrdering Success =
llvm::AtomicOrdering::SequentiallyConsistent</argument>,
<argument>llvm::AtomicOrdering Failure =
llvm::AtomicOrdering::SequentiallyConsistent</argument>,
<argument>bool IsWeak = false</argument>, <argument>AggValueSlot Slot = AggValueSlot::ignored()</argument>)</argument_list></macro></expr>;</expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>EmitAtomicUpdate</name><argument_list>(<argument><expr><name>LValue</name> <name>LVal</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>AtomicOrdering</name> <name>AO</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>RValue</name><operator>(</operator><name>RValue</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>UpdateOp</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsVolatile</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitToMemory</name><argument_list>(<argument>llvm::Value *Value</argument>, <argument>QualType Ty</argument>)</argument_list></macro></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitFromMemory</name><argument_list>(<argument>llvm::Value *Value</argument>, <argument>QualType Ty</argument>)</argument_list></macro></expr>;</expr_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>EmitScalarRangeCheck</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Value</name></expr></argument>, <argument><expr><name>QualType</name> <name>Ty</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitLoadOfScalar</name><argument_list>(<argument>Address Addr</argument>, <argument>bool Volatile</argument>, <argument>QualType Ty</argument>,
<argument>SourceLocation Loc</argument>,
<argument>AlignmentSource Source = AlignmentSource::Type</argument>,
<argument>bool isNontemporal = false</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>EmitLoadOfScalar</name><argument_list>(<argument><expr><name>Addr</name></expr></argument>, <argument><expr><name>Volatile</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>, <argument><expr><call><name>LValueBaseInfo</name><argument_list>(<argument><expr><name>Source</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>CGM</name><operator>.</operator><name>getTBAAAccessInfo</name></name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>isNontemporal</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitLoadOfScalar</name><argument_list>(<argument>Address Addr</argument>, <argument>bool Volatile</argument>, <argument>QualType Ty</argument>,
<argument>SourceLocation Loc</argument>, <argument>LValueBaseInfo BaseInfo</argument>,
<argument>TBAAAccessInfo TBAAInfo</argument>,
<argument>bool isNontemporal = false</argument>)</argument_list></macro></expr>;</expr_stmt>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitLoadOfScalar</name><argument_list>(<argument>LValue lvalue</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;</expr_stmt>




<decl_stmt><decl><type><name>void</name></type> <name>EmitStoreOfScalar</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Value</name></expr></argument>, <argument><expr><name>Address</name> <name>Addr</name></expr></argument>,
<argument><expr><name>bool</name> <name>Volatile</name></expr></argument>, <argument><expr><name>QualType</name> <name>Ty</name></expr></argument>,
<argument><expr><name>AlignmentSource</name> <name>Source</name> <operator>=</operator> <name>AlignmentSource</name><operator>::</operator><name>Type</name></expr></argument>,
<argument><expr><name>bool</name> <name>isInit</name> <operator>=</operator> <name>false</name></expr></argument>, <argument><expr><name>bool</name> <name>isNontemporal</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>EmitStoreOfScalar</name><argument_list>(<argument><expr><name>Value</name></expr></argument>, <argument><expr><name>Addr</name></expr></argument>, <argument><expr><name>Volatile</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><call><name>LValueBaseInfo</name><argument_list>(<argument><expr><name>Source</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>CGM</name><operator>.</operator><name>getTBAAAccessInfo</name></name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>isInit</name></expr></argument>, <argument><expr><name>isNontemporal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>EmitStoreOfScalar</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Value</name></expr></argument>, <argument><expr><name>Address</name> <name>Addr</name></expr></argument>,
<argument><expr><name>bool</name> <name>Volatile</name></expr></argument>, <argument><expr><name>QualType</name> <name>Ty</name></expr></argument>,
<argument><expr><name>LValueBaseInfo</name> <name>BaseInfo</name></expr></argument>, <argument><expr><name>TBAAAccessInfo</name> <name>TBAAInfo</name></expr></argument>,
<argument><expr><name>bool</name> <name>isInit</name> <operator>=</operator> <name>false</name></expr></argument>, <argument><expr><name>bool</name> <name>isNontemporal</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<decl_stmt><decl><type><name>void</name></type> <name>EmitStoreOfScalar</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>, <argument><expr><name>LValue</name> <name>lvalue</name></expr></argument>, <argument><expr><name>bool</name> <name>isInit</name><operator>=</operator><name>false</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<function_decl><type><name>RValue</name></type> <name>EmitLoadOfLValue</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>V</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>RValue</name></type> <name>EmitLoadOfExtVectorElementLValue</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>V</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>RValue</name></type> <name>EmitLoadOfBitfieldLValue</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>LV</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>RValue</name></type> <name>EmitLoadOfGlobalRegLValue</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>LV</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>EmitStoreThroughLValue</name><parameter_list>(<parameter><decl><type><name>RValue</name></type> <name>Src</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>Dst</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isInit</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitStoreThroughExtVectorComponentLValue</name><parameter_list>(<parameter><decl><type><name>RValue</name></type> <name>Src</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>Dst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitStoreThroughGlobalRegLValue</name><parameter_list>(<parameter><decl><type><name>RValue</name></type> <name>Src</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>Dst</name></decl></parameter>)</parameter_list>;</function_decl>







<decl_stmt><decl><type><name>void</name></type> <name>EmitStoreThroughBitfieldLValue</name><argument_list>(<argument><expr><name>RValue</name> <name>Src</name></expr></argument>, <argument><expr><name>LValue</name> <name>Dst</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><operator>*</operator><name>Result</name><operator>=</operator><name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>LValue</name></type> <name>EmitComplexAssignmentLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BinaryOperator</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitComplexCompoundAssignmentLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CompoundAssignOperator</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>LValue</name></type> <name>EmitScalarCompoundAssignWithComplex</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CompoundAssignOperator</name> <operator>*</operator><name>E</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><operator>&amp;</operator><name>Result</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>LValue</name></type> <name>EmitBinaryOperatorLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BinaryOperator</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitCompoundAssignmentLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CompoundAssignOperator</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>LValue</name></type> <name>EmitCallExprLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>LValue</name></type> <name>EmitVAArgExprLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VAArgExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitDeclRefLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclRefExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitStringLiteralLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>StringLiteral</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitObjCEncodeExprLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCEncodeExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitPredefinedLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PredefinedExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitUnaryOpLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UnaryOperator</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitArraySubscriptExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ArraySubscriptExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Accessed</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitMatrixSubscriptExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MatrixSubscriptExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitOMPArraySectionExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPArraySectionExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsLowerBound</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitExtVectorElementExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExtVectorElementExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitMemberExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MemberExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitObjCIsaExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCIsaExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitCompoundLiteralLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CompoundLiteralExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitInitListLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InitListExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitConditionalOperatorLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AbstractConditionalOperator</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitCastLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CastExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitMaterializeTemporaryExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MaterializeTemporaryExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitOpaqueValueLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OpaqueValueExpr</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Address</name></type> <name>EmitExtVectorElementLValue</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>V</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>RValue</name></type> <name>EmitRValueForField</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>LV</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FieldDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Address</name></type> <name>EmitArrayToPointerDecay</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Array</name></decl></parameter>,
<parameter><decl><type><name>LValueBaseInfo</name> <modifier>*</modifier></type><name>BaseInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>TBAAAccessInfo</name> <modifier>*</modifier></type><name>TBAAInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>class</name></type> <name>ConstantEmission</name> <block>{<block_content>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>ValueAndIsReference</name></expr>;</expr_stmt>
<macro><name>ConstantEmission</name><argument_list>(<argument>llvm::Constant *C</argument>, <argument>bool isReference</argument>)</argument_list></macro>
: <macro><name>ValueAndIsReference</name><argument_list>(<argument>C</argument>, <argument>isReference</argument>)</argument_list></macro> <block>{<block_content/>}</block>
<label><name>public</name>:</label>
<macro><name>ConstantEmission</name><argument_list>()</argument_list></macro> <block>{<block_content/>}</block>
<decl_stmt><decl><type><specifier>static</specifier> <name>ConstantEmission</name></type> <name>forReference</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>C</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>ConstantEmission</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ConstantEmission</name></type> <name>forValue</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>C</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>ConstantEmission</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>explicit</name> <name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>ValueAndIsReference</name><operator>.</operator><name>getOpaqueValue</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isReference</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>ValueAndIsReference</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<decl_stmt><decl><type><name>LValue</name></type> <name>getReferenceLValue</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>refExpr</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isReference</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>CGF</name><operator>.</operator><name>MakeNaturalAlignAddrLValue</name></name><argument_list>(<argument><expr><call><name><name>ValueAndIsReference</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>refExpr</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>getValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isReference</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>ValueAndIsReference</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<function_decl><type><name>ConstantEmission</name></type> <name>tryEmitAsConstant</name><parameter_list>(<parameter><decl><type><name>DeclRefExpr</name> <modifier>*</modifier></type><name>refExpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ConstantEmission</name></type> <name>tryEmitAsConstant</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MemberExpr</name> <modifier>*</modifier></type><name>ME</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>emitScalarConstant</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ConstantEmission</name> <operator>&amp;</operator><name>Constant</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>RValue</name></type> <name>EmitPseudoObjectRValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PseudoObjectExpr</name> <modifier>*</modifier></type><name>e</name></decl></parameter>,
<parameter><decl><type><name>AggValueSlot</name></type> <name>slot</name> <init>= <expr><name>AggValueSlot</name><operator>::</operator><call><name>ignored</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitPseudoObjectLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PseudoObjectExpr</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitIvarOffset</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator><name>Interface</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ObjCIvarDecl</name> <operator>*</operator><name>Ivar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function_decl><type><name>LValue</name></type> <name>EmitLValueForField</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>Base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FieldDecl</name><modifier>*</modifier></type> <name>Field</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitLValueForLambdaField</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FieldDecl</name> <modifier>*</modifier></type><name>Field</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>LValue</name></type> <name>EmitLValueForFieldInitialization</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>Base</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FieldDecl</name><modifier>*</modifier></type> <name>Field</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>LValue</name></type> <name>EmitLValueForIvar</name><argument_list>(<argument><expr><name>QualType</name> <name>ObjectTy</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name><operator>*</operator> <name>Base</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ObjCIvarDecl</name> <operator>*</operator><name>Ivar</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>CVRQualifiers</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>LValue</name></type> <name>EmitCXXConstructLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXConstructExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitCXXBindTemporaryLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXBindTemporaryExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitCXXTypeidLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXTypeidExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitCXXUuidofLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXUuidofExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>LValue</name></type> <name>EmitObjCMessageExprLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCMessageExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitObjCIvarRefLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCIvarRefExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitStmtExprLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>StmtExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitPointerToDataMemberBinaryExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BinaryOperator</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LValue</name></type> <name>EmitObjCSelectorLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCSelectorExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitDeclRefExprDbgValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclRefExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>APValue</name> <modifier>&amp;</modifier></type><name>Init</name></decl></parameter>)</parameter_list>;</function_decl>








<decl_stmt><decl><type><name>RValue</name></type> <name>EmitCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CGFunctionInfo</name> <operator>&amp;</operator><name>CallInfo</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CGCallee</name> <operator>&amp;</operator><name>Callee</name></expr></argument>,
<argument><expr><name>ReturnValueSlot</name> <name>ReturnValue</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CallArgList</name> <operator>&amp;</operator><name>Args</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>CallBase</name> <operator>*</operator><operator>*</operator><name>callOrInvoke</name></expr></argument>, <argument><expr><name>bool</name> <name>IsMustTail</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RValue</name></type> <name>EmitCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CGFunctionInfo</name> <operator>&amp;</operator><name>CallInfo</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CGCallee</name> <operator>&amp;</operator><name>Callee</name></expr></argument>,
<argument><expr><name>ReturnValueSlot</name> <name>ReturnValue</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CallArgList</name> <operator>&amp;</operator><name>Args</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>CallBase</name> <operator>*</operator><operator>*</operator><name>callOrInvoke</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsMustTail</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>EmitCall</name><argument_list>(<argument><expr><name>CallInfo</name></expr></argument>, <argument><expr><name>Callee</name></expr></argument>, <argument><expr><name>ReturnValue</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>, <argument><expr><name>callOrInvoke</name></expr></argument>,
<argument><expr><name>IsMustTail</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>RValue</name></type> <name>EmitCall</name><argument_list>(<argument><expr><name>QualType</name> <name>FnType</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CGCallee</name> <operator>&amp;</operator><name>Callee</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CallExpr</name> <operator>*</operator><name>E</name></expr></argument>,
<argument><expr><name>ReturnValueSlot</name> <name>ReturnValue</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Chain</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>RValue</name></type> <name>EmitCallExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>ReturnValueSlot</name></type> <name>ReturnValue</name> <init>= <expr><call><name>ReturnValueSlot</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>RValue</name></type> <name>EmitSimpleCallExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>ReturnValueSlot</name></type> <name>ReturnValue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>CGCallee</name></type> <name>EmitCallee</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>checkTargetFeatures</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>TargetDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>checkTargetFeatures</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>TargetDecl</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>CallInst</name> <operator>*</operator><macro><name>EmitRuntimeCall</name><argument_list>(<argument>llvm::FunctionCallee callee</argument>,
<argument>const Twine &amp;name = <literal type="string">""</literal></argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>CallInst</name> <operator>*</operator><macro><name>EmitRuntimeCall</name><argument_list>(<argument>llvm::FunctionCallee callee</argument>,
<argument>ArrayRef&lt;llvm::Value *&gt; args</argument>,
<argument>const Twine &amp;name = <literal type="string">""</literal></argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>CallInst</name> <operator>*</operator><macro><name>EmitNounwindRuntimeCall</name><argument_list>(<argument>llvm::FunctionCallee callee</argument>,
<argument>const Twine &amp;name = <literal type="string">""</literal></argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>CallInst</name> <operator>*</operator><macro><name>EmitNounwindRuntimeCall</name><argument_list>(<argument>llvm::FunctionCallee callee</argument>,
<argument>ArrayRef&lt;llvm::Value *&gt; args</argument>,
<argument>const Twine &amp;name = <literal type="string">""</literal></argument>)</argument_list></macro></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>OperandBundleDef</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name></type>
<name>getBundlesForFunclet</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Callee</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>CallBase</name> <operator>*</operator><macro><name>EmitCallOrInvoke</name><argument_list>(<argument>llvm::FunctionCallee Callee</argument>,
<argument>ArrayRef&lt;llvm::Value *&gt; Args</argument>,
<argument>const Twine &amp;Name = <literal type="string">""</literal></argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>CallBase</name> <operator>*</operator><macro><name>EmitRuntimeCallOrInvoke</name><argument_list>(<argument>llvm::FunctionCallee callee</argument>,
<argument>ArrayRef&lt;llvm::Value *&gt; args</argument>,
<argument>const Twine &amp;name = <literal type="string">""</literal></argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>CallBase</name> <operator>*</operator><macro><name>EmitRuntimeCallOrInvoke</name><argument_list>(<argument>llvm::FunctionCallee callee</argument>,
<argument>const Twine &amp;name = <literal type="string">""</literal></argument>)</argument_list></macro></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>EmitNoreturnRuntimeCallOrInvoke</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>callee</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>args</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CGCallee</name></type> <name>BuildAppleKextVirtualCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXMethodDecl</name> <operator>*</operator><name>MD</name></expr></argument>,
<argument><expr><name>NestedNameSpecifier</name> <operator>*</operator><name>Qual</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>Ty</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>CGCallee</name></type> <name>BuildAppleKextVirtualDestructorCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>DD</name></decl></parameter>,
<parameter><decl><type><name>CXXDtorType</name></type> <name>Type</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name> <macro><name>getNonTrivialCopyConstructorStr</name><argument_list>(<argument>QualType QT</argument>,
<argument>CharUnits Alignment</argument>,
<argument>bool IsVolatile</argument>,
<argument>ASTContext &amp;Ctx</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name> <macro><name>getNonTrivialDestructorStr</name><argument_list>(<argument>QualType QT</argument>,
<argument>CharUnits Alignment</argument>,
<argument>bool IsVolatile</argument>,
<argument>ASTContext &amp;Ctx</argument>)</argument_list></macro></expr>;</expr_stmt>



<function_decl><type><name>void</name></type> <name>defaultInitNonTrivialCStructVar</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>Dst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>callCStructDefaultConstructor</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>Dst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>callCStructDestructor</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>Dst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>callCStructCopyConstructor</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>Dst</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>Src</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>callCStructMoveConstructor</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>Dst</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>Src</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>callCStructCopyAssignmentOperator</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>Dst</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>Src</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>callCStructMoveAssignmentOperator</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>Dst</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>Src</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>RValue</name></type>
<name>EmitCXXMemberOrOperatorCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXMethodDecl</name> <operator>*</operator><name>Method</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CGCallee</name> <operator>&amp;</operator><name>Callee</name></expr></argument>,
<argument><expr><name>ReturnValueSlot</name> <name>ReturnValue</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>This</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>ImplicitParam</name></expr></argument>,
<argument><expr><name>QualType</name> <name>ImplicitParamTy</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CallExpr</name> <operator>*</operator><name>E</name></expr></argument>,
<argument><expr><name>CallArgList</name> <operator>*</operator><name>RtlArgs</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RValue</name></type> <name>EmitCXXDestructorCall</name><argument_list>(<argument><expr><name>GlobalDecl</name> <name>Dtor</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CGCallee</name> <operator>&amp;</operator><name>Callee</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>This</name></expr></argument>, <argument><expr><name>QualType</name> <name>ThisTy</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>ImplicitParam</name></expr></argument>,
<argument><expr><name>QualType</name> <name>ImplicitParamTy</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CallExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>RValue</name></type> <name>EmitCXXMemberCallExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXMemberCallExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>ReturnValueSlot</name></type> <name>ReturnValue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>RValue</name></type> <name>EmitCXXMemberOrOperatorMemberCallExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>CE</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>,
<parameter><decl><type><name>ReturnValueSlot</name></type> <name>ReturnValue</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>HasQualifier</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecifier</name> <modifier>*</modifier></type><name>Qualifier</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsArrow</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>Address</name></type> <name>EmitCXXMemberDataPointerAddress</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>E</name></expr></argument>, <argument><expr><name>Address</name> <name>base</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>memberPtr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MemberPointerType</name> <operator>*</operator><name>memberPtrType</name></expr></argument>,
<argument><expr><name>LValueBaseInfo</name> <operator>*</operator><name>BaseInfo</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>TBAAAccessInfo</name> <operator>*</operator><name>TBAAInfo</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>RValue</name></type> <name>EmitCXXMemberPointerCallExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXMemberCallExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>ReturnValueSlot</name></type> <name>ReturnValue</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>RValue</name></type> <name>EmitCXXOperatorMemberCallExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXOperatorCallExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>,
<parameter><decl><type><name>ReturnValueSlot</name></type> <name>ReturnValue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>RValue</name></type> <name>EmitCXXPseudoDestructorExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXPseudoDestructorExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>RValue</name></type> <name>EmitCUDAKernelCallExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CUDAKernelCallExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>ReturnValueSlot</name></type> <name>ReturnValue</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>RValue</name></type> <name>EmitNVPTXDevicePrintfCallExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>ReturnValueSlot</name></type> <name>ReturnValue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>RValue</name></type> <name>EmitAMDGPUDevicePrintfCallExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>ReturnValueSlot</name></type> <name>ReturnValue</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>RValue</name></type> <name>EmitBuiltinExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GlobalDecl</name></type> <name>GD</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>ReturnValueSlot</name></type> <name>ReturnValue</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>RValue</name></type> <name>emitRotate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsRotateRight</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>RValue</name></type> <name>emitBuiltinOSLogFormat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>&amp;</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>RValue</name></type> <name>EmitBuiltinIsAligned</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>RValue</name></type> <name>EmitBuiltinAlignTo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>AlignUp</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><macro><name>generateBuiltinOSLogHelperFunction</name><argument_list>(
<argument>const analyze_os_log::OSLogBufferLayout &amp;Layout</argument>,
<argument>CharUnits BufferAlignment</argument>)</argument_list></macro></expr>;</expr_stmt>

<function_decl><type><name>RValue</name></type> <name>EmitBlockCallExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>ReturnValueSlot</name></type> <name>ReturnValue</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitTargetBuiltinExpr</name><argument_list>(<argument>unsigned BuiltinID</argument>, <argument>const CallExpr *E</argument>,
<argument>ReturnValueSlot ReturnValue</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitAArch64CompareBuiltinExpr</name><argument_list>(<argument>llvm::Value *Op</argument>, <argument>llvm::Type *Ty</argument>,
<argument>const llvm::CmpInst::Predicate Fp</argument>,
<argument>const llvm::CmpInst::Predicate Ip</argument>,
<argument>const llvm::Twine &amp;Name = <literal type="string">""</literal></argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitARMBuiltinExpr</name><argument_list>(<argument>unsigned BuiltinID</argument>, <argument>const CallExpr *E</argument>,
<argument>ReturnValueSlot ReturnValue</argument>,
<argument>llvm::Triple::ArchType Arch</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitARMMVEBuiltinExpr</name><argument_list>(<argument>unsigned BuiltinID</argument>, <argument>const CallExpr *E</argument>,
<argument>ReturnValueSlot ReturnValue</argument>,
<argument>llvm::Triple::ArchType Arch</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitARMCDEBuiltinExpr</name><argument_list>(<argument>unsigned BuiltinID</argument>, <argument>const CallExpr *E</argument>,
<argument>ReturnValueSlot ReturnValue</argument>,
<argument>llvm::Triple::ArchType Arch</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitCMSEClearRecord</name><argument_list>(<argument>llvm::Value *V</argument>, <argument>llvm::IntegerType *ITy</argument>,
<argument>QualType RTy</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitCMSEClearRecord</name><argument_list>(<argument>llvm::Value *V</argument>, <argument>llvm::ArrayType *ATy</argument>,
<argument>QualType RTy</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitCommonNeonBuiltinExpr</name><argument_list>(<argument>unsigned BuiltinID</argument>,
<argument>unsigned LLVMIntrinsic</argument>,
<argument>unsigned AltLLVMIntrinsic</argument>,
<argument>const char *NameHint</argument>,
<argument>unsigned Modifier</argument>,
<argument>const CallExpr *E</argument>,
<argument>SmallVectorImpl&lt;llvm::Value *&gt; &amp;Ops</argument>,
<argument>Address PtrOp0</argument>, <argument>Address PtrOp1</argument>,
<argument>llvm::Triple::ArchType Arch</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><macro><name>LookupNeonLLVMIntrinsic</name><argument_list>(<argument>unsigned IntrinsicID</argument>,
<argument>unsigned Modifier</argument>, <argument>llvm::Type *ArgTy</argument>,
<argument>const CallExpr *E</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitNeonCall</name><argument_list>(<argument>llvm::Function *F</argument>,
<argument>SmallVectorImpl&lt;llvm::Value*&gt; &amp;O</argument>,
<argument>const char *name</argument>,
<argument>unsigned shift = <literal type="number">0</literal></argument>, <argument>bool rightshift = false</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitNeonSplat</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>V</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>Idx</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>ElementCount</name> <operator>&amp;</operator><name>Count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitNeonSplat</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>V</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>Idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitNeonShiftVector</name><argument_list>(<argument>llvm::Value *V</argument>, <argument>llvm::Type *Ty</argument>,
<argument>bool negateForRightShift</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitNeonRShiftImm</name><argument_list>(<argument>llvm::Value *Vec</argument>, <argument>llvm::Value *Amt</argument>,
<argument>llvm::Type *Ty</argument>, <argument>bool usgn</argument>, <argument>const char *name</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>vectorWrapScalar16</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><macro><name>SVEBuiltinMemEltTy</name><argument_list>(<argument>SVETypeFlags TypeFlags</argument>)</argument_list></macro></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>getSVEOverloadTypes</name><argument_list>(<argument><expr><name>SVETypeFlags</name> <name>TypeFlags</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>ReturnType</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Ops</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><macro><name>getEltType</name><argument_list>(<argument>SVETypeFlags TypeFlags</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>ScalableVectorType</name> <operator>*</operator><call><name>getSVEType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>SVETypeFlags</name> <operator>&amp;</operator><name>TypeFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>ScalableVectorType</name> <operator>*</operator><macro><name>getSVEPredType</name><argument_list>(<argument>SVETypeFlags TypeFlags</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitSVEAllTruePred</name><argument_list>(<argument>SVETypeFlags TypeFlags</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitSVEDupX</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Scalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitSVEDupX</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Scalar</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>Ty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitSVEReinterpret</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Val</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>Ty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitSVEPMull</name><argument_list>(<argument>SVETypeFlags TypeFlags</argument>,
<argument>llvm::SmallVectorImpl&lt;llvm::Value *&gt; &amp;Ops</argument>,
<argument>unsigned BuiltinID</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitSVEMovl</name><argument_list>(<argument>SVETypeFlags TypeFlags</argument>,
<argument>llvm::ArrayRef&lt;llvm::Value *&gt; Ops</argument>,
<argument>unsigned BuiltinID</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitSVEPredicateCast</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Pred</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>ScalableVectorType</name> <operator>*</operator><name>VTy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitSVEGatherLoad</name><argument_list>(<argument>SVETypeFlags TypeFlags</argument>,
<argument>llvm::SmallVectorImpl&lt;llvm::Value *&gt; &amp;Ops</argument>,
<argument>unsigned IntID</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitSVEScatterStore</name><argument_list>(<argument>SVETypeFlags TypeFlags</argument>,
<argument>llvm::SmallVectorImpl&lt;llvm::Value *&gt; &amp;Ops</argument>,
<argument>unsigned IntID</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitSVEMaskedLoad</name><argument_list>(<argument>const CallExpr *</argument>, <argument>llvm::Type *ReturnTy</argument>,
<argument>SmallVectorImpl&lt;llvm::Value *&gt; &amp;Ops</argument>,
<argument>unsigned BuiltinID</argument>, <argument>bool IsZExtReturn</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitSVEMaskedStore</name><argument_list>(<argument>const CallExpr *</argument>,
<argument>SmallVectorImpl&lt;llvm::Value *&gt; &amp;Ops</argument>,
<argument>unsigned BuiltinID</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitSVEPrefetchLoad</name><argument_list>(<argument>SVETypeFlags TypeFlags</argument>,
<argument>SmallVectorImpl&lt;llvm::Value *&gt; &amp;Ops</argument>,
<argument>unsigned BuiltinID</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitSVEGatherPrefetch</name><argument_list>(<argument>SVETypeFlags TypeFlags</argument>,
<argument>SmallVectorImpl&lt;llvm::Value *&gt; &amp;Ops</argument>,
<argument>unsigned IntID</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitSVEStructLoad</name><argument_list>(<argument>SVETypeFlags TypeFlags</argument>,
<argument>SmallVectorImpl&lt;llvm::Value *&gt; &amp;Ops</argument>, <argument>unsigned IntID</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitSVEStructStore</name><argument_list>(<argument>SVETypeFlags TypeFlags</argument>,
<argument>SmallVectorImpl&lt;llvm::Value *&gt; &amp;Ops</argument>,
<argument>unsigned IntID</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitAArch64SVEBuiltinExpr</name><argument_list>(<argument>unsigned BuiltinID</argument>, <argument>const CallExpr *E</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitAArch64BuiltinExpr</name><argument_list>(<argument>unsigned BuiltinID</argument>, <argument>const CallExpr *E</argument>,
<argument>llvm::Triple::ArchType Arch</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitBPFBuiltinExpr</name><argument_list>(<argument>unsigned BuiltinID</argument>, <argument>const CallExpr *E</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>BuildVector</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitX86BuiltinExpr</name><argument_list>(<argument>unsigned BuiltinID</argument>, <argument>const CallExpr *E</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitPPCBuiltinExpr</name><argument_list>(<argument>unsigned BuiltinID</argument>, <argument>const CallExpr *E</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitAMDGPUBuiltinExpr</name><argument_list>(<argument>unsigned BuiltinID</argument>, <argument>const CallExpr *E</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitSystemZBuiltinExpr</name><argument_list>(<argument>unsigned BuiltinID</argument>, <argument>const CallExpr *E</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitNVPTXBuiltinExpr</name><argument_list>(<argument>unsigned BuiltinID</argument>, <argument>const CallExpr *E</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitWebAssemblyBuiltinExpr</name><argument_list>(<argument>unsigned BuiltinID</argument>,
<argument>const CallExpr *E</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitHexagonBuiltinExpr</name><argument_list>(<argument>unsigned BuiltinID</argument>, <argument>const CallExpr *E</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitRISCVBuiltinExpr</name><argument_list>(<argument>unsigned BuiltinID</argument>, <argument>const CallExpr *E</argument>,
<argument>ReturnValueSlot ReturnValue</argument>)</argument_list></macro></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ProcessOrderScopeAMDGCN</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Order</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Scope</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>AtomicOrdering</name> <operator>&amp;</operator><name>AO</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>SyncScope</name><operator>::</operator><name>ID</name> <operator>&amp;</operator><name>SSID</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>MSVCIntrin</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitMSVCBuiltinExpr</name><argument_list>(<argument>MSVCIntrin BuiltinID</argument>, <argument>const CallExpr *E</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitBuiltinAvailable</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VersionTuple</name> <operator>&amp;</operator><name>Version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitObjCProtocolExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCProtocolExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitObjCStringLiteral</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCStringLiteral</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitObjCBoxedExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCBoxedExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitObjCArrayLiteral</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCArrayLiteral</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitObjCDictionaryLiteral</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCDictionaryLiteral</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitObjCCollectionLiteral</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>E</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ObjCMethodDecl</name> <operator>*</operator><name>MethodWithObjects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitObjCSelectorExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCSelectorExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function_decl><type><name>RValue</name></type> <name>EmitObjCMessageExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCMessageExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>ReturnValueSlot</name></type> <name>Return</name> <init>= <expr><call><name>ReturnValueSlot</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function><type><name>CleanupKind</name></type> <name>getARCCleanupKind</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><call><name><name>CGM</name><operator>.</operator><name>getCodeGenOpts</name></name><argument_list>()</argument_list></call><operator>.</operator><name>ObjCAutoRefCountExceptions</name></expr>
?</condition><then> <expr><name>NormalAndEHCleanup</name></expr> </then><else>: <expr><name>NormalCleanup</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name>void</name></type> <name>EmitARCInitWeak</name><argument_list>(<argument><expr><name>Address</name> <name>addr</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>EmitARCDestroyWeak</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>addr</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitARCLoadWeak</name><argument_list>(<argument>Address addr</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitARCLoadWeakRetained</name><argument_list>(<argument>Address addr</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitARCStoreWeak</name><argument_list>(<argument>Address addr</argument>, <argument>llvm::Value *value</argument>, <argument>bool ignored</argument>)</argument_list></macro></expr>;</expr_stmt>
<function_decl><type><name>void</name></type> <name>emitARCCopyAssignWeak</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>DstAddr</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>SrcAddr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>emitARCMoveAssignWeak</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>DstAddr</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>SrcAddr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitARCCopyWeak</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>src</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>EmitARCMoveWeak</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>src</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitARCRetainAutorelease</name><argument_list>(<argument>QualType type</argument>, <argument>llvm::Value *value</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitARCRetainAutoreleaseNonBlock</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitARCStoreStrong</name><argument_list>(<argument>LValue lvalue</argument>, <argument>llvm::Value *value</argument>,
<argument>bool resultIgnored</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitARCStoreStrongCall</name><argument_list>(<argument>Address addr</argument>, <argument>llvm::Value *value</argument>,
<argument>bool resultIgnored</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitARCRetain</name><argument_list>(<argument>QualType type</argument>, <argument>llvm::Value *value</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitARCRetainNonBlock</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitARCRetainBlock</name><argument_list>(<argument>llvm::Value *value</argument>, <argument>bool mandatory</argument>)</argument_list></macro></expr>;</expr_stmt>
<function_decl><type><name>void</name></type> <name>EmitARCDestroyStrong</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ARCPreciseLifetime_t</name></type> <name>precise</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>EmitARCRelease</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>, <argument><expr><name>ARCPreciseLifetime_t</name> <name>precise</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitARCAutorelease</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitARCAutoreleaseReturnValue</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitARCRetainAutoreleaseReturnValue</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitARCRetainAutoreleasedReturnValue</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitARCUnsafeClaimAutoreleasedReturnValue</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitObjCAutorelease</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>returnType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitObjCRetainNonBlock</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>returnType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>EmitObjCRelease</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>, <argument><expr><name>ARCPreciseLifetime_t</name> <name>precise</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>LValue</name></expr></argument>,<argument><expr><name>llvm</name><operator>::</operator><name>Value</name><operator>*</operator></expr></argument>&gt;</argument_list></name>
<call><name>EmitARCStoreAutoreleasing</name><argument_list>(<argument><expr><specifier>const</specifier> <name>BinaryOperator</name> <operator>*</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>LValue</name></expr></argument>,<argument><expr><name>llvm</name><operator>::</operator><name>Value</name><operator>*</operator></expr></argument>&gt;</argument_list></name>
<macro><name>EmitARCStoreStrong</name><argument_list>(<argument>const BinaryOperator *e</argument>, <argument>bool ignored</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>LValue</name></expr></argument>,<argument><expr><name>llvm</name><operator>::</operator><name>Value</name><operator>*</operator></expr></argument>&gt;</argument_list></name>
<macro><name>EmitARCStoreUnsafeUnretained</name><argument_list>(<argument>const BinaryOperator *e</argument>, <argument>bool ignored</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitObjCAlloc</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>returnType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitObjCAllocWithZone</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>returnType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitObjCAllocInit</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>value</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>resultType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitObjCThrowOperand</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitObjCConsumeObject</name><argument_list>(<argument>QualType T</argument>, <argument>llvm::Value *Ptr</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitObjCExtendObjectLifetime</name><argument_list>(<argument>QualType T</argument>, <argument>llvm::Value *Ptr</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitARCExtendBlockObject</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitARCReclaimReturnedObject</name><argument_list>(<argument>const Expr *e</argument>,
<argument>bool allowUnsafeClaim</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitARCRetainScalarExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitARCRetainAutoreleaseScalarExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitARCUnsafeUnretainedScalarExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>EmitARCIntrinsicUse</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>values</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitARCNoopIntrinsicUse</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>values</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>Destroyer</name></type> <name>destroyARCStrongImprecise</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Destroyer</name></type> <name>destroyARCStrongPrecise</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Destroyer</name></type> <name>destroyARCWeak</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Destroyer</name></type> <name>emitARCIntrinsicUse</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Destroyer</name></type> <name>destroyNonTrivialCStruct</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>EmitObjCAutoreleasePoolPop</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Ptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitObjCAutoreleasePoolPush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitObjCMRRAutoreleasePoolPush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>EmitObjCAutoreleasePoolCleanup</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Ptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>EmitObjCMRRAutoreleasePoolPop</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Ptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>RValue</name></type> <name>EmitReferenceBindingToExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>









<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitScalarExpr</name><argument_list>(<argument>const Expr *E</argument> , <argument>bool IgnoreResultAssign = false</argument>)</argument_list></macro></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitScalarConversion</name><argument_list>(<argument>llvm::Value *Src</argument>, <argument>QualType SrcTy</argument>,
<argument>QualType DstTy</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitComplexToScalarConversion</name><argument_list>(<argument>ComplexPairTy Src</argument>, <argument>QualType SrcTy</argument>,
<argument>QualType DstTy</argument>,
<argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;</expr_stmt>




<function_decl><type><name>void</name></type> <name>EmitAggExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>AggValueSlot</name></type> <name>AS</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>LValue</name></type> <name>EmitAggExprToLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>void</name></type> <name>EmitAggregateStore</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Val</name></expr></argument>, <argument><expr><name>Address</name> <name>Dest</name></expr></argument>, <argument><expr><name>bool</name> <name>DestIsVolatile</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>EmitExtendGCLifetime</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>object</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>ComplexPairTy</name></type> <name>EmitComplexExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IgnoreReal</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IgnoreImag</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>EmitComplexExprIntoLValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isInit</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitStoreOfComplex</name><parameter_list>(<parameter><decl><type><name>ComplexPairTy</name></type> <name>V</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isInit</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ComplexPairTy</name></type> <name>EmitLoadOfComplex</name><parameter_list>(<parameter><decl><type><name>LValue</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>loc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Address</name></type> <name>emitAddrOfRealComponent</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>complex</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>complexType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Address</name></type> <name>emitAddrOfImagComponent</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>complex</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>complexType</name></decl></parameter>)</parameter_list>;</function_decl>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator>
<call><name>AddInitializerToStaticVarDecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator><name>GV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>EmitInvariantStart</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>Addr</name></expr></argument>, <argument><expr><name>CharUnits</name> <name>Size</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>EmitCXXGlobalVarDeclInit</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>&amp;</operator><name>D</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>DeclPtr</name></expr></argument>,
<argument><expr><name>bool</name> <name>PerformInit</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><macro><name>createAtExitStub</name><argument_list>(<argument>const VarDecl &amp;VD</argument>, <argument>llvm::FunctionCallee Dtor</argument>,
<argument>llvm::Constant *Addr</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><macro><name>createTLSAtExitStub</name><argument_list>(<argument>const VarDecl &amp;VD</argument>,
<argument>llvm::FunctionCallee Dtor</argument>,
<argument>llvm::Constant *Addr</argument>,
<argument>llvm::FunctionCallee &amp;AtExit</argument>)</argument_list></macro></expr>;</expr_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>registerGlobalDtorWithAtExit</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>&amp;</operator><name>D</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>fn</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>addr</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>registerGlobalDtorWithAtExit</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>dtorStub</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>unregisterGlobalDtorWithUnAtExit</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>dtorStub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<decl_stmt><decl><type><name>void</name></type> <name>EmitCXXGuardedInit</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>&amp;</operator><name>D</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator><name>DeclPtr</name></expr></argument>,
<argument><expr><name>bool</name> <name>PerformInit</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>GuardKind</name> <block>{<block_content> <expr_stmt><expr><name>VariableGuard</name></expr><operator>,</operator> <expr><name>TlsGuard</name></expr></expr_stmt> </block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>EmitCXXGuardedInitBranch</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>NeedsInit</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>InitBlock</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>NoInitBlock</name></expr></argument>,
<argument><expr><name>GuardKind</name> <name>Kind</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type>
<name>GenerateCXXGlobalInitFunc</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Fn</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CXXThreadLocals</name></expr></argument>,
<argument><expr><name>ConstantAddress</name> <name>Guard</name> <operator>=</operator> <name>ConstantAddress</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>GenerateCXXGlobalCleanUpFunc</name><argument_list>(
<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Fn</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>FunctionType</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>WeakTrackingVH</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>DtorsOrStermFinalizers</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>GenerateCXXGlobalVarDeclInitFunc</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Fn</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>D</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator><name>Addr</name></expr></argument>,
<argument><expr><name>bool</name> <name>PerformInit</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>EmitCXXConstructExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXConstructExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>AggValueSlot</name></type> <name>Dest</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitSynthesizedCXXCopyCtor</name><parameter_list>(<parameter><decl><type><name>Address</name></type> <name>Dest</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>Src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Exp</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitCXXThrowExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXThrowExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>KeepInsertionPoint</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>RValue</name></type> <name>EmitAtomicExpr</name><parameter_list>(<parameter><decl><type><name>AtomicExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>






<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitAnnotationCall</name><argument_list>(<argument>llvm::Function *AnnotationFn</argument>,
<argument>llvm::Value *AnnotatedVal</argument>,
<argument>StringRef AnnotationStr</argument>,
<argument>SourceLocation Location</argument>,
<argument>const AnnotateAttr *Attr</argument>)</argument_list></macro></expr>;</expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>EmitVarAnnotations</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>V</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>Address</name></type> <name>EmitFieldAnnotations</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FieldDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>V</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ContainsLabel</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IgnoreCaseStmts</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>containsBreak</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>mightAddDeclToScope</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>ConstantFoldsToSimpleInteger</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Cond</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowLabels</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>bool</name></type> <name>ConstantFoldsToSimpleInteger</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>Cond</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>APSInt</name> <operator>&amp;</operator><name>Result</name></expr></argument>,
<argument><expr><name>bool</name> <name>AllowLabels</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isInstrumentedCondition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>C</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name>void</name></type> <name>EmitBranchToCounterBlock</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>Cond</name></expr></argument>, <argument><expr><name>BinaryOperator</name><operator>::</operator><name>Opcode</name> <name>LOp</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>TrueBlock</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>FalseBlock</name></expr></argument>,
<argument><expr><name>uint64_t</name> <name>TrueCount</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><name>Stmt</name><operator>::</operator><name>Likelihood</name> <name>LH</name> <operator>=</operator> <name>Stmt</name><operator>::</operator><name>LH_None</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>CntrIdx</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<decl_stmt><decl><type><name>void</name></type> <name>EmitBranchOnBoolExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>Cond</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>TrueBlock</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>FalseBlock</name></expr></argument>, <argument><expr><name>uint64_t</name> <name>TrueCount</name></expr></argument>,
<argument><expr><name>Stmt</name><operator>::</operator><name>Likelihood</name> <name>LH</name> <operator>=</operator> <name>Stmt</name><operator>::</operator><name>LH_None</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>EmitNullabilityCheck</name><argument_list>(<argument><expr><name>LValue</name> <name>LHS</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>RHS</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<enum>enum <block>{ <decl><name>NotSubtraction</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><name>IsSubtraction</name> <init>= <expr><name>true</name></expr></init></decl> }</block>;</enum>






<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitCheckedInBoundsGEP</name><argument_list>(<argument>llvm::Value *Ptr</argument>,
<argument>ArrayRef&lt;llvm::Value *&gt; IdxList</argument>,
<argument>bool SignedIndices</argument>,
<argument>bool IsSubtraction</argument>,
<argument>SourceLocation Loc</argument>,
<argument>const Twine &amp;Name = <literal type="string">""</literal></argument>)</argument_list></macro></expr>;</expr_stmt>



<enum>enum <name>BuiltinCheckKind</name> <block>{
<decl><name>BCK_CTZPassedZero</name></decl>,
<decl><name>BCK_CLZPassedZero</name></decl>,
}</block>;</enum>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitCheckedArgForBuiltin</name><argument_list>(<argument>const Expr *E</argument>, <argument>BuiltinCheckKind Kind</argument>)</argument_list></macro></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>EmitCheckTypeDescriptor</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitCheckValue</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>V</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>EmitCheckSourceLocation</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;</expr_stmt>




<function_decl><type><name>void</name></type> <name>EmitCheck</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <modifier>*</modifier></expr></argument>, <argument><expr><name>SanitizerMask</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>Checked</name></decl></parameter>,
<parameter><decl><type><name>SanitizerHandler</name></type> <name>Check</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>StaticArgs</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>DynamicArgs</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>void</name></type> <name>EmitCfiSlowPathCheck</name><argument_list>(<argument><expr><name>SanitizerMask</name> <name>Kind</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Cond</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>ConstantInt</name> <operator>*</operator><name>TypeId</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Ptr</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>StaticArgs</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>EmitUnreachable</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>void</name></type> <name>EmitTrapCheck</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Checked</name></expr></argument>, <argument><expr><name>SanitizerHandler</name> <name>CheckHandlerID</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>CallInst</name> <operator>*</operator><macro><name>EmitTrapCall</name><argument_list>(<argument>llvm::Intrinsic::ID IntrID</argument>)</argument_list></macro></expr>;</expr_stmt>


<function_decl><type><name>void</name></type> <name>EmitCfiCheckStub</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitCfiCheckFail</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>EmitNonNullArgCheck</name><parameter_list>(<parameter><decl><type><name>RValue</name></type> <name>RV</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ArgType</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ArgLoc</name></decl></parameter>,
<parameter><decl><type><name>AbstractCallee</name></type> <name>AC</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ParmNum</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>EmitCallArg</name><parameter_list>(<parameter><decl><type><name>CallArgList</name> <modifier>&amp;</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ArgType</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>EmitDelegateCallArg</name><parameter_list>(<parameter><decl><type><name>CallArgList</name> <modifier>&amp;</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>param</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>loc</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>void</name></type> <name>SetFPAccuracy</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Val</name></expr></argument>, <argument><expr><name>float</name> <name>Accuracy</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>SetFPModel</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>SetFastMathFlags</name><parameter_list>(<parameter><decl><type><name>FPOptions</name></type> <name>FPFeatures</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>MDNode</name> <operator>*</operator><macro><name>getRangeForLoadFromType</name><argument_list>(<argument>QualType Ty</argument>)</argument_list></macro></expr>;</expr_stmt>
<function_decl><type><name>void</name></type> <name>EmitReturnOfRValue</name><parameter_list>(<parameter><decl><type><name>RValue</name></type> <name>RV</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>deferPlaceholderReplacement</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Instruction</name> <operator>*</operator><name>Old</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>New</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>WeakTrackingVH</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name>
<name>DeferredReplacements</name></expr>;</expr_stmt>


<function><type><name>void</name></type> <name>setAddrOfLocalVar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>Addr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>LocalDeclMap</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>VD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Decl already exists in LocalDeclMap!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>LocalDeclMap</name></macro><expr_stmt><expr><operator>.</operator><macro><name>insert</name><argument_list>(<argument>{VD</argument>, <argument>Addr}</argument>)</argument_list></macro></expr>;</expr_stmt>
</block_content>}</block></function>





<decl_stmt><decl><type><name>void</name></type> <name>ExpandTypeFromArgs</name><argument_list>(<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>, <argument><expr><name>LValue</name> <name>Dst</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Function</name><operator>::</operator><name>arg_iterator</name> <operator>&amp;</operator><name>AI</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<decl_stmt><decl><type><name>void</name></type> <name>ExpandTypeToArgs</name><argument_list>(<argument><expr><name>QualType</name> <name>Ty</name></expr></argument>, <argument><expr><name>CallArg</name> <name>Arg</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>FunctionType</name> <operator>*</operator><name>IRFuncTy</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>IRCallArgs</name></expr></argument>,
<argument><expr><name>unsigned</name> <operator>&amp;</operator><name>IRCallArgPos</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name><operator>*</operator> <call><name>EmitAsmInput</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TargetInfo</name><operator>::</operator><name>ConstraintInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>InputExpr</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>ConstraintStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name><operator>*</operator> <macro><name>EmitAsmInputLValue</name><argument_list>(<argument>const TargetInfo::ConstraintInfo &amp;Info</argument>,
<argument>LValue InputValue</argument>, <argument>QualType InputType</argument>,
<argument>std::string &amp;ConstraintStr</argument>,
<argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;</expr_stmt>






<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>evaluateOrEmitBuiltinObjectSize</name><argument_list>(<argument>const Expr *E</argument>, <argument>unsigned Type</argument>,
<argument>llvm::IntegerType *ResType</argument>,
<argument>llvm::Value *EmittedE</argument>,
<argument>bool IsDynamic</argument>)</argument_list></macro></expr>;</expr_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>emitBuiltinObjectSize</name><argument_list>(<argument>const Expr *E</argument>, <argument>unsigned Type</argument>,
<argument>llvm::IntegerType *ResType</argument>,
<argument>llvm::Value *EmittedE</argument>,
<argument>bool IsDynamic</argument>)</argument_list></macro></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>emitZeroOrPatternForAutoVarInit</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>Address</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>EvaluationOrder</name> <block>{<block_content>

<expr_stmt><expr><name>Default</name></expr><operator>,</operator>

<expr><name>ForceLeftToRight</name></expr><operator>,</operator>

<expr><name>ForceRightToLeft</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<struct>struct <name>PrototypeWrapper</name> <block>{
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>FunctionProtoType</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>ObjCMethodDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>P</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PrototypeWrapper</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionProtoType</name> <operator>*</operator><name>FT</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>P</name><argument_list>(<argument>FT</argument>)</argument_list></macro> <block>{}</block>
<call><name>PrototypeWrapper</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCMethodDecl</name> <operator>*</operator><name>MD</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>P</name><argument_list>(<argument>MD</argument>)</argument_list></macro> <block>{}</block></expr></expr_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name>void</name></type> <name>EmitCallArgs</name><argument_list>(<argument><expr><name>CallArgList</name> <operator>&amp;</operator><name>Args</name></expr></argument>, <argument><expr><name>PrototypeWrapper</name> <name>Prototype</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>CallExpr</name><operator>::</operator><name>const_arg_iterator</name></expr></argument>&gt;</argument_list></name> <name>ArgRange</name></expr></argument>,
<argument><expr><name>AbstractCallee</name> <name>AC</name> <operator>=</operator> <call><name>AbstractCallee</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>unsigned</name> <name>ParamsToSkip</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><name>EvaluationOrder</name> <name>Order</name> <operator>=</operator> <name>EvaluationOrder</name><operator>::</operator><name>Default</name></expr></argument>)</argument_list></decl>;</decl_stmt>


















<function_decl><type><name>Address</name></type> <name>EmitPointerWithAlignment</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Addr</name></decl></parameter>,
<parameter><decl><type><name>LValueBaseInfo</name> <modifier>*</modifier></type><name>BaseInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>TBAAAccessInfo</name> <modifier>*</modifier></type><name>TBAAInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>LoadPassedObjectSize</name><argument_list>(<argument>const Expr *E</argument>, <argument>QualType EltTy</argument>)</argument_list></macro></expr>;</expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>EmitSanitizerStatReport</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>SanitizerStatKind</name> <name>SSK</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<struct>struct <name>MultiVersionResolverOption</name> <block>{
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Function</name></expr>;</expr_stmt>
<struct>struct <name>Conds</name> <block>{
<decl_stmt><decl><type><name>StringRef</name></type> <name>Architecture</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>Features</name></expr>;</expr_stmt>

<macro><name>Conds</name><argument_list>(<argument>StringRef Arch</argument>, <argument>ArrayRef&lt;StringRef&gt; Feats</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Architecture</name><argument_list>(<argument><expr><name>Arch</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Features</name><argument_list>(<argument>Feats.begin()</argument>, <argument>Feats.end()</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block> <decl><name>Conditions</name></decl>;</struct>

<macro><name>MultiVersionResolverOption</name><argument_list>(<argument>llvm::Function *F</argument>, <argument>StringRef Arch</argument>,
<argument>ArrayRef&lt;StringRef&gt; Feats</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Function</name><argument_list>(<argument><expr><name>F</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Conditions</name><argument_list>(<argument>Arch</argument>, <argument>Feats</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>




<decl_stmt><decl><type><name>void</name></type> <name>EmitMultiVersionResolver</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Resolver</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>MultiVersionResolverOption</name></expr></argument>&gt;</argument_list></name> <name>Options</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>GetX86CpuSupportsMask</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name></type> <name>FeatureStrs</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
<function_decl><type><name>QualType</name></type> <name>getVarArgType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EmitDeclMetadata</name><parameter_list>()</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>BlockByrefHelpers</name> <modifier>*</modifier></type><name>buildByrefHelpers</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>StructType</name> <operator>&amp;</operator><name>byrefType</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>AutoVarEmission</name> <operator>&amp;</operator><name>emission</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>AddObjCARCExceptionMetadata</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Instruction</name> <operator>*</operator><name>Inst</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>GetValueForARMHint</name><argument_list>(<argument>unsigned BuiltinID</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitX86CpuIs</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CallExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitX86CpuIs</name><argument_list>(<argument>StringRef CPUStr</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitX86CpuSupports</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CallExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitX86CpuSupports</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <name>FeatureStrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitX86CpuSupports</name><argument_list>(<argument>uint64_t Mask</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitX86CpuInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>FormResolverCondition</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MultiVersionResolverOption</name> <operator>&amp;</operator><name>RO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};











<decl_stmt><decl><type><name>class</name></type> <name>TargetFeatures</name> <block>{<block_content>
<struct>struct <name>FeatureListStatus</name> <block>{
<decl_stmt><decl><type><name>bool</name></type> <name>HasFeatures</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StringRef</name></type> <name>CurFeaturesList</name></decl>;</decl_stmt>
}</block>;</struct>

<expr_stmt><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>CallerFeatureMap</name></expr>;</expr_stmt>

<function><type><name>FeatureListStatus</name></type> <name>getAndFeatures</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>FeatureList</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>InParentheses</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>HasFeatures</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>SubexpressionStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>e</name> <init>= <expr><call><name><name>FeatureList</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>e</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>CurrentToken</name> <init>= <expr><name><name>FeatureList</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>CurrentToken</name></expr>)</condition> <block>{<block_content>
<default>default:</default>
<break>break;</break>
<case>case <expr><literal type="char">'('</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>InParentheses</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>SubexpressionStart</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>InParentheses</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">')'</literal></expr>:</case>
<expr_stmt><expr><operator>--</operator><name>InParentheses</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>InParentheses</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="string">"Parentheses are not in pair"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>LLVM_FALLTHROUGH</name></expr>;</expr_stmt>
<case>case <expr><literal type="char">'|'</literal></expr>:</case>
<case>case <expr><literal type="char">','</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>InParentheses</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>HasFeatures</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>!=</operator> <name>SubexpressionStart</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>StringRef</name></type> <name>F</name> <init>= <expr><call><name><name>FeatureList</name><operator>.</operator><name>slice</name></name><argument_list>(<argument><expr><name>SubexpressionStart</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>HasFeatures</name> <operator>=</operator> <ternary><condition><expr><name>CurrentToken</name> <operator>==</operator> <literal type="char">')'</literal></expr> ?</condition><then> <expr><call><name>hasRequiredFeatures</name><argument_list>(<argument><expr><name>F</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name><name>CallerFeatureMap</name><operator>.</operator><name>lookup</name></name><argument_list>(<argument><expr><name>F</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>SubexpressionStart</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>CurrentToken</name> <operator>==</operator> <literal type="char">'|'</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><block>{<expr><name>HasFeatures</name></expr>, <macro><name>FeatureList</name></macro><expr><operator>.</operator><macro><name>substr</name><argument_list>(<argument>SubexpressionStart</argument>)</argument_list></macro></expr>}</block></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>InParentheses</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="string">"Parentheses are not in pair"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>HasFeatures</name> <operator>&amp;&amp;</operator> <name>SubexpressionStart</name> <operator>!=</operator> <call><name><name>FeatureList</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>HasFeatures</name> <operator>=</operator>
<call><name><name>CallerFeatureMap</name><operator>.</operator><name>lookup</name></name><argument_list>(<argument><expr><call><name><name>FeatureList</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><name>SubexpressionStart</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><block>{<expr><name>HasFeatures</name></expr>, <macro><name>StringRef</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
</block_content>}</block></function>

<label><name>public</name>:</label>
<function><type><name>bool</name></type> <name>hasRequiredFeatures</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>FeatureList</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>FeatureListStatus</name></type> <name>FS</name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>FeatureList</name></expr>}</block></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>!</operator><name><name>FS</name><operator>.</operator><name>HasFeatures</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>FS</name><operator>.</operator><name>CurFeaturesList</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>FS</name> <operator>=</operator> <call><name>getAndFeatures</name><argument_list>(<argument><expr><name><name>FS</name><operator>.</operator><name>CurFeaturesList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><name><name>FS</name><operator>.</operator><name>HasFeatures</name></name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>TargetFeatures</name><argument_list>(<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>CallerFeatureMap</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CallerFeatureMap</name><argument_list>(<argument>CallerFeatureMap</argument>)</argument_list></macro> <block>{}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>DominatingLLVMValue</name><operator>::</operator><name>saved_type</name>
<name>DominatingLLVMValue</name><operator>::</operator><macro><name>save</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>llvm::Value *value</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>needsSaving</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>saved_type</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>auto</name> <name>align</name> <operator>=</operator> <name>CharUnits</name><operator>::</operator><call><name>fromQuantity</name><argument_list>(
<argument><expr><call><name><name>CGF</name><operator>.</operator><name>CGM</name><operator>.</operator><name>getDataLayout</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPrefTypeAlignment</name><argument_list>(<argument><expr><call><name><name>value</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Address</name></type> <name>alloca</name> <init>=
<expr><call><name><name>CGF</name><operator>.</operator><name>CreateTempAlloca</name></name><argument_list>(<argument><expr><call><name><name>value</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>align</name></expr></argument>, <argument><expr><literal type="string">"cond-cleanup.save"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>CGF</name><operator>.</operator><name>Builder</name><operator>.</operator><name>CreateStore</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>alloca</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>saved_type</name><argument_list>(<argument><expr><call><name><name>alloca</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
}

inline <expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>DominatingLLVMValue</name><operator>::</operator><macro><name>restore</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>saved_type value</argument>)</argument_list></macro> <block>{

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>value</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name><name>value</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>auto</name> <name>alloca</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>AllocaInst</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>value</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<return>return <expr><call><name><name>CGF</name><operator>.</operator><name>Builder</name><operator>.</operator><name>CreateAlignedLoad</name></name><argument_list>(<argument><expr><call><name><name>alloca</name><operator>-&gt;</operator><name>getAllocatedType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>alloca</name></expr></argument>,
<argument><expr><call><name><name>alloca</name><operator>-&gt;</operator><name>getAlign</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

}



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>fp</name><operator>::</operator><name>ExceptionBehavior</name>
<macro><name>ToConstrainedExceptMD</name><argument_list>(<argument>LangOptions::FPExceptionModeKind Kind</argument>)</argument_list></macro></expr>;</expr_stmt>
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
