<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" xmlns:omp="http://www.srcML.org/srcML/openmp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/lib/Headers/__clang_hip_cmath.h">








<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CLANG_HIP_CMATH_H__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__CLANG_HIP_CMATH_H__</name></cpp:macro></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__HIP__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__OPENMP_AMDGCN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"This file is for HIP and OpenMP AMDGCN device compilation only."</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__HIPCC_RTC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;type_traits&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>push_macro</name><name>(</name><cpp:literal>"__DEVICE__"</cpp:literal><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>push_macro</name><name>(</name><cpp:literal>"__CONSTEXPR__"</cpp:literal><name>)</name></cpp:pragma>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__OPENMP_AMDGCN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__DEVICE__</name></cpp:macro> <cpp:value>static __attribute__((always_inline, nothrow))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__CONSTEXPR__</name></cpp:macro> <cpp:value>constexpr</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__DEVICE__</name></cpp:macro> <cpp:value>static __device__ inline __attribute__((always_inline))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__CONSTEXPR__</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__OPENMP_AMDGCN__</name></expr></cpp:if>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>float</name></type> <name>fabs</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>fabsf</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>float</name></type> <name>sin</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>sinf</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>float</name></type> <name>cos</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>cosf</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>double</name></type> <name>abs</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>fabs</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>float</name></type> <name>abs</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>fabsf</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>long</name> <name>long</name></type> <name>abs</name><parameter_list>(<parameter><decl><type><name>long</name> <name>long</name></type> <name>__n</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>llabs</name><argument_list>(<argument><expr><name>__n</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>long</name></type> <name>abs</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>__n</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>labs</name><argument_list>(<argument><expr><name>__n</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>float</name></type> <name>fma</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>__y</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>__z</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>::</operator><call><name>fmaf</name><argument_list>(<argument><expr><name>__x</name></expr></argument>, <argument><expr><name>__y</name></expr></argument>, <argument><expr><name>__z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__HIPCC_RTC__</name></expr></argument>)</argument_list></call></expr></cpp:if>


<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>int</name></type> <name>fpclassify</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__builtin_fpclassify</name><argument_list>(<argument><expr><name>FP_NAN</name></expr></argument>, <argument><expr><name>FP_INFINITE</name></expr></argument>, <argument><expr><name>FP_NORMAL</name></expr></argument>, <argument><expr><name>FP_SUBNORMAL</name></expr></argument>,
<argument><expr><name>FP_ZERO</name></expr></argument>, <argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>int</name></type> <name>fpclassify</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__builtin_fpclassify</name><argument_list>(<argument><expr><name>FP_NAN</name></expr></argument>, <argument><expr><name>FP_INFINITE</name></expr></argument>, <argument><expr><name>FP_NORMAL</name></expr></argument>, <argument><expr><name>FP_SUBNORMAL</name></expr></argument>,
<argument><expr><name>FP_ZERO</name></expr></argument>, <argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>float</name></type> <name>frexp</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__arg</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>__exp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>::</operator><call><name>frexpf</name><argument_list>(<argument><expr><name>__arg</name></expr></argument>, <argument><expr><name>__exp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__OPENMP_AMDGCN__</name></expr></argument>)</argument_list></call></expr></cpp:if>






<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>begin</omp:name> <omp:name>declare</omp:name> <omp:name>variant</omp:name> <omp:clause><omp:name>match</omp:name><omp:argument_list>( <omp:argument><omp:expr>implementation = {extension(disable_implicit_base</omp:expr></omp:argument>)</omp:argument_list></omp:clause><omp:name>}</omp:name><omp:name>)</omp:name></omp:directive></cpp:pragma>








<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>begin</omp:name> <omp:name>declare</omp:name> <omp:name>variant</omp:name> <omp:clause><omp:name>match</omp:name><omp:argument_list>(<omp:argument><omp:expr>implementation = {vendor(llvm</omp:expr></omp:argument>)</omp:argument_list></omp:clause><omp:name>}</omp:name><omp:name>)</omp:name></omp:directive></cpp:pragma>

<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>int</name></type> <name>isinf</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>__isinff</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>int</name></type> <name>isinf</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>__isinf</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>int</name></type> <name>isfinite</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>__finitef</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>int</name></type> <name>isfinite</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>__finite</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>int</name></type> <name>isnan</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>__isnanf</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>int</name></type> <name>isnan</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>__isnan</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>end</omp:name> <omp:name>declare</omp:name> <omp:name>variant</omp:name></omp:directive></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>isinf</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>__isinff</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>isinf</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>__isinf</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>isfinite</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>__finitef</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>isfinite</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>__finite</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>isnan</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>__isnanf</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>isnan</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>__isnan</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__OPENMP_AMDGCN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:name>end</omp:name> <omp:name>declare</omp:name> <omp:name>variant</omp:name></omp:directive></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>isgreater</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>__y</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__builtin_isgreater</name><argument_list>(<argument><expr><name>__x</name></expr></argument>, <argument><expr><name>__y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>isgreater</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>__x</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>__y</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__builtin_isgreater</name><argument_list>(<argument><expr><name>__x</name></expr></argument>, <argument><expr><name>__y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>isgreaterequal</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>__y</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__builtin_isgreaterequal</name><argument_list>(<argument><expr><name>__x</name></expr></argument>, <argument><expr><name>__y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>isgreaterequal</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>__x</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>__y</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__builtin_isgreaterequal</name><argument_list>(<argument><expr><name>__x</name></expr></argument>, <argument><expr><name>__y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>isless</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>__y</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__builtin_isless</name><argument_list>(<argument><expr><name>__x</name></expr></argument>, <argument><expr><name>__y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>isless</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>__x</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>__y</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__builtin_isless</name><argument_list>(<argument><expr><name>__x</name></expr></argument>, <argument><expr><name>__y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>islessequal</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>__y</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__builtin_islessequal</name><argument_list>(<argument><expr><name>__x</name></expr></argument>, <argument><expr><name>__y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>islessequal</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>__x</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>__y</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__builtin_islessequal</name><argument_list>(<argument><expr><name>__x</name></expr></argument>, <argument><expr><name>__y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>islessgreater</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>__y</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__builtin_islessgreater</name><argument_list>(<argument><expr><name>__x</name></expr></argument>, <argument><expr><name>__y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>islessgreater</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>__x</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>__y</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__builtin_islessgreater</name><argument_list>(<argument><expr><name>__x</name></expr></argument>, <argument><expr><name>__y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>isnormal</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__builtin_isnormal</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>isnormal</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__builtin_isnormal</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>isunordered</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>__y</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__builtin_isunordered</name><argument_list>(<argument><expr><name>__x</name></expr></argument>, <argument><expr><name>__y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>isunordered</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>__x</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>__y</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__builtin_isunordered</name><argument_list>(<argument><expr><name>__x</name></expr></argument>, <argument><expr><name>__y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>float</name></type> <name>modf</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>, <parameter><decl><type><name>float</name> <modifier>*</modifier></type><name>__iptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>::</operator><call><name>modff</name><argument_list>(<argument><expr><name>__x</name></expr></argument>, <argument><expr><name>__iptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>float</name></type> <name>pow</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>__iexp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>::</operator><call><name>powif</name><argument_list>(<argument><expr><name>__base</name></expr></argument>, <argument><expr><name>__iexp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>double</name></type> <name>pow</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>__base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>__iexp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>::</operator><call><name>powi</name><argument_list>(<argument><expr><name>__base</name></expr></argument>, <argument><expr><name>__iexp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>float</name></type> <name>remquo</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>__y</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>__quo</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>::</operator><call><name>remquof</name><argument_list>(<argument><expr><name>__x</name></expr></argument>, <argument><expr><name>__y</name></expr></argument>, <argument><expr><name>__quo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>float</name></type> <name>scalbln</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>int</name></type> <name>__n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>::</operator><call><name>scalblnf</name><argument_list>(<argument><expr><name>__x</name></expr></argument>, <argument><expr><name>__n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>signbit</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>__signbitf</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>bool</name></type> <name>signbit</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>__x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><call><name>__signbit</name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>






<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>_Float16</name></type> <name>fma</name><parameter_list>(<parameter><decl><type><name>_Float16</name></type> <name>__x</name></decl></parameter>, <parameter><decl><type><name>_Float16</name></type> <name>__y</name></decl></parameter>,
<parameter><decl><type><name>_Float16</name></type> <name>__z</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__ocml_fma_f16</name><argument_list>(<argument><expr><name>__x</name></expr></argument>, <argument><expr><name>__y</name></expr></argument>, <argument><expr><name>__z</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>_Float16</name></type> <name>pow</name><parameter_list>(<parameter><decl><type><name>_Float16</name></type> <name>__base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>__iexp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__ocml_pown_f16</name><argument_list>(<argument><expr><name>__base</name></expr></argument>, <argument><expr><name>__iexp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__OPENMP_AMDGCN__</name></expr></argument>)</argument_list></call></expr></cpp:if>




<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>push_macro</name><name>(</name><cpp:literal>"__DEF_FUN1"</cpp:literal><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>push_macro</name><name>(</name><cpp:literal>"__DEF_FUN2"</cpp:literal><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>push_macro</name><name>(</name><cpp:literal>"__DEF_FUN2_FI"</cpp:literal><name>)</name></cpp:pragma>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__DEF_FUN1</name><parameter_list>(<parameter><type><name>__retty</name></type></parameter>, <parameter><type><name>__func</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__DEVICE__ __CONSTEXPR__ __retty __func(float __x) { return __func##f(__x); }</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__DEF_FUN2</name><parameter_list>(<parameter><type><name>__retty</name></type></parameter>, <parameter><type><name>__func</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__DEVICE__ __CONSTEXPR__ __retty __func(float __x, float __y) { return __func##f(__x, __y); }</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__DEF_FUN2_FI</name><parameter_list>(<parameter><type><name>__retty</name></type></parameter>, <parameter><type><name>__func</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__DEVICE__ __CONSTEXPR__ __retty __func(float __x, int __y) { return __func##f(__x, __y); }</cpp:value></cpp:define>




<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>acos</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>acosh</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>asin</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>asinh</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>atan</argument>)</argument_list></macro>
<macro><name>__DEF_FUN2</name><argument_list>(<argument>float</argument>, <argument>atan2</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>atanh</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>cbrt</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>ceil</argument>)</argument_list></macro>
<macro><name>__DEF_FUN2</name><argument_list>(<argument>float</argument>, <argument>copysign</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>cos</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>cosh</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>erf</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>erfc</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>exp</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>exp2</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>expm1</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>fabs</argument>)</argument_list></macro>
<macro><name>__DEF_FUN2</name><argument_list>(<argument>float</argument>, <argument>fdim</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>floor</argument>)</argument_list></macro>
<macro><name>__DEF_FUN2</name><argument_list>(<argument>float</argument>, <argument>fmax</argument>)</argument_list></macro>
<macro><name>__DEF_FUN2</name><argument_list>(<argument>float</argument>, <argument>fmin</argument>)</argument_list></macro>
<macro><name>__DEF_FUN2</name><argument_list>(<argument>float</argument>, <argument>fmod</argument>)</argument_list></macro>
<macro><name>__DEF_FUN2</name><argument_list>(<argument>float</argument>, <argument>hypot</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>int</argument>, <argument>ilogb</argument>)</argument_list></macro>
<macro><name>__DEF_FUN2_FI</name><argument_list>(<argument>float</argument>, <argument>ldexp</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>lgamma</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>log</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>log10</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>log1p</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>log2</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>logb</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>long long</argument>, <argument>llrint</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>long long</argument>, <argument>llround</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>long</argument>, <argument>lrint</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>long</argument>, <argument>lround</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>nearbyint</argument>)</argument_list></macro>
<macro><name>__DEF_FUN2</name><argument_list>(<argument>float</argument>, <argument>nextafter</argument>)</argument_list></macro>
<macro><name>__DEF_FUN2</name><argument_list>(<argument>float</argument>, <argument>pow</argument>)</argument_list></macro>
<macro><name>__DEF_FUN2</name><argument_list>(<argument>float</argument>, <argument>remainder</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>rint</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>round</argument>)</argument_list></macro>
<macro><name>__DEF_FUN2_FI</name><argument_list>(<argument>float</argument>, <argument>scalbn</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>sin</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>sinh</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>sqrt</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>tan</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>tanh</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>tgamma</argument>)</argument_list></macro>
<macro><name>__DEF_FUN1</name><argument_list>(<argument>float</argument>, <argument>trunc</argument>)</argument_list></macro>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>pop_macro</name><name>(</name><cpp:literal>"__DEF_FUN1"</cpp:literal><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>pop_macro</name><name>(</name><cpp:literal>"__DEF_FUN2"</cpp:literal><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>pop_macro</name><name>(</name><cpp:literal>"__DEF_FUN2_FI"</cpp:literal><name>)</name></cpp:pragma>





<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>push_macro</name><name>(</name><cpp:literal>"__HIP_OVERLOAD1"</cpp:literal><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>push_macro</name><name>(</name><cpp:literal>"__HIP_OVERLOAD2"</cpp:literal><name>)</name></cpp:pragma>


<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>bool</name> <name>__B</name></expr><operator>,</operator> <expr><name>class</name> <name>__T</name> <operator>=</operator> <name>void</name><operator>&gt;</operator> struct <name>__hip_enable_if</name> <block>{}</block></expr>;</expr_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>__T</name><operator>&gt;</operator> struct <name><name>__hip_enable_if</name><argument_list type="generic">&lt;<argument><expr><name>true</name></expr></argument>, <argument><expr><name>__T</name></expr></argument>&gt;</argument_list></name> <block>{ <typedef>typedef <type><name>__T</name></type> <name>type</name>;</typedef> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>__hip</name> <block>{<block_content>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>_Tp</name><operator>&gt;</operator> struct <name>is_integral</name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name>signed</name> <name>char</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name>wchar_t</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name>short</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>short</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>int</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name>long</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>long</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>


<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>_Tp</name><operator>&gt;</operator> struct <name>is_arithmetic</name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>signed</name> <name>char</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>char</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>wchar_t</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>short</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>short</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>int</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>long</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>long</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
}</block></expr>;</expr_stmt>

<struct>struct <name>true_type</name> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>__constant__</name> <name>bool</name></type> <name>value</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
}</block>;</struct>
<struct>struct <name>false_type</name> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>__constant__</name> <name>bool</name></type> <name>value</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>__T</name></expr></argument>, <argument><expr><name>typename</name> <name>__U</name></expr></argument>&gt;</argument_list></name> struct</type> <name>is_same</name> <range>: <expr><name>public</name> <name>false_type</name> <block>{}</block></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>__T</name></expr></argument>&gt;</argument_list></name> struct</type> <name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>__T</name></expr></argument>, <argument><expr><name>__T</name></expr></argument>&gt;</argument_list></name> <range>: <expr><name>public</name> <name>true_type</name> <block>{}</block></expr></range></decl>;</decl_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>__T</name><operator>&gt;</operator> struct <name>add_rvalue_reference</name> <block>{ <typedef>typedef <expr_stmt><expr><name>__T</name> <operator>&amp;&amp;</operator><name>type</name></expr>;</expr_stmt></typedef> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>__T</name></expr></argument>&gt;</argument_list></name> <name>typename</name> <name><name>add_rvalue_reference</name><argument_list type="generic">&lt;<argument><expr><name>__T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <call><name>declval</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__cplusplus</name> <operator>&gt;=</operator> <literal type="number">201103L</literal></expr></cpp:if>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>_Tp</name><operator>&gt;</operator> struct <name>__numeric_type</name> <block>{
<expr><specifier>static</specifier> <name>void</name> <call><name>__test</name><argument_list>(<argument><expr><operator>...</operator></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>_Float16</name> <call><name>__test</name><argument_list>(<argument><expr><name>_Float16</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>float</name> <call><name>__test</name><argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>double</name> <call><name>__test</name><argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>double</name> <call><name>__test</name><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>double</name> <call><name>__test</name><argument_list>(<argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>double</name> <call><name>__test</name><argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>double</name> <macro><name>__test</name><argument_list>(<argument>unsigned long</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>double</name> <macro><name>__test</name><argument_list>(<argument>long long</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>double</name> <macro><name>__test</name><argument_list>(<argument>unsigned long long</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>double</name> <call><name>__test</name><argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>double</name> <macro><name>__test</name><argument_list>(<argument>long double</argument>)</argument_list></macro></expr>;

<typedef>typedef <macro><name>decltype</name><argument_list>(<argument>__test(declval&lt;_Tp&gt;())</argument>)</argument_list></macro> <expr_stmt><expr><name>type</name></expr>;</expr_stmt></typedef>
<specifier>static</specifier> <specifier>const</specifier> <name>bool</name> <name>value</name> <operator>=</operator> <operator>!</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>type</name></expr></argument>, <argument><expr><name>void</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></block></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>__numeric_type</name><argument_list type="generic">&lt;<argument><expr><name>void</name></expr></argument>&gt;</argument_list></name> <block>{ <expr><specifier>static</specifier> <specifier>const</specifier> <name>bool</name> <name>value</name> <operator>=</operator> <name>true</name></expr>; }</block></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_A1</name></expr></argument>, <argument><expr><name>class</name> <name>_A2</name> <operator>=</operator> <name>void</name></expr></argument>, <argument><expr><name>class</name> <name>_A3</name> <operator>=</operator> <name>void</name></expr></argument>,
<argument><expr><name>bool</name> <operator>=</operator> <name><name>__numeric_type</name><argument_list type="generic">&lt;<argument><expr><name>_A1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator><name><name>__numeric_type</name><argument_list type="generic">&lt;<argument><expr><name>_A2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name>
<operator>&amp;&amp;</operator><name><name>__numeric_type</name><argument_list type="generic">&lt;<argument><expr><name>_A3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>__promote_imp</name> <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name>value</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_A1</name></expr></argument>, <argument><expr><name>class</name> <name>_A2</name></expr></argument>, <argument><expr><name>class</name> <name>_A3</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>__promote_imp</name><argument_list type="generic">&lt;<argument><expr><name>_A1</name></expr></argument>, <argument><expr><name>_A2</name></expr></argument>, <argument><expr><name>_A3</name></expr></argument>, <argument><expr><name>true</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>private</name>:</label>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>__promote_imp</name><argument_list type="generic">&lt;<argument><expr><name>_A1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>__type1</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>__promote_imp</name><argument_list type="generic">&lt;<argument><expr><name>_A2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>__type2</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>__promote_imp</name><argument_list type="generic">&lt;<argument><expr><name>_A3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>__type3</name></expr>;</expr_stmt></typedef>

<label><name>public</name>:</label>
<typedef>typedef <macro><name>decltype</name><argument_list>(<argument>__type1() + __type2() + __type3()</argument>)</argument_list></macro> <expr_stmt><expr><name>type</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name>value</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_A1</name></expr></argument>, <argument><expr><name>class</name> <name>_A2</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name><name>__promote_imp</name><argument_list type="generic">&lt;<argument><expr><name>_A1</name></expr></argument>, <argument><expr><name>_A2</name></expr></argument>, <argument><expr><name>void</name></expr></argument>, <argument><expr><name>true</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>private</name>:</label>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>__promote_imp</name><argument_list type="generic">&lt;<argument><expr><name>_A1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>__type1</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>__promote_imp</name><argument_list type="generic">&lt;<argument><expr><name>_A2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>__type2</name></expr>;</expr_stmt></typedef>

<label><name>public</name>:</label>
<typedef>typedef <macro><name>decltype</name><argument_list>(<argument>__type1() + __type2()</argument>)</argument_list></macro> <expr_stmt><expr><name>type</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name>value</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_A1</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name><name>__promote_imp</name><argument_list type="generic">&lt;<argument><expr><name>_A1</name></expr></argument>, <argument><expr><name>void</name></expr></argument>, <argument><expr><name>void</name></expr></argument>, <argument><expr><name>true</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>__numeric_type</name><argument_list type="generic">&lt;<argument><expr><name>_A1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>type</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name>value</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_A1</name></expr></argument>, <argument><expr><name>class</name> <name>_A2</name> <operator>=</operator> <name>void</name></expr></argument>, <argument><expr><name>class</name> <name>_A3</name> <operator>=</operator> <name>void</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>__promote</name> <range>: <expr><name>public</name> <name><name>__promote_imp</name><argument_list type="generic">&lt;<argument><expr><name>_A1</name></expr></argument>, <argument><expr><name>_A2</name></expr></argument>, <argument><expr><name>_A3</name></expr></argument>&gt;</argument_list></name> <block>{}</block></expr></range></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__HIP_OVERLOAD1</name><parameter_list>(<parameter><type><name>__retty</name></type></parameter>, <parameter><type><name>__fn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>template &lt;typename __T&gt; __DEVICE__ __CONSTEXPR__ typename __hip_enable_if&lt;__hip::is_integral&lt;__T&gt;::value, __retty&gt;::type __fn(__T __x) { return ::__fn((double)__x); }</cpp:value></cpp:define>










<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__cplusplus</name> <operator>&gt;=</operator> <literal type="number">201103L</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__HIP_OVERLOAD2</name><parameter_list>(<parameter><type><name>__retty</name></type></parameter>, <parameter><type><name>__fn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>template &lt;typename __T1, typename __T2&gt; __DEVICE__ __CONSTEXPR__ typename __hip_enable_if&lt; __hip::is_arithmetic&lt;__T1&gt;::value &amp;&amp; __hip::is_arithmetic&lt;__T2&gt;::value, typename __hip::__promote&lt;__T1, __T2&gt;::type&gt;::type __fn(__T1 __x, __T2 __y) { typedef typename __hip::__promote&lt;__T1, __T2&gt;::type __result_type; return __fn((__result_type)__x, (__result_type)__y); }</cpp:value></cpp:define>








<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__HIP_OVERLOAD2</name><parameter_list>(<parameter><type><name>__retty</name></type></parameter>, <parameter><type><name>__fn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>template &lt;typename __T1, typename __T2&gt; __DEVICE__ __CONSTEXPR__ typename __hip_enable_if&lt;__hip::is_arithmetic&lt;__T1&gt;::value &amp;&amp; __hip::is_arithmetic&lt;__T2&gt;::value, __retty&gt;::type __fn(__T1 __x, __T2 __y) { return __fn((double)__x, (double)__y); }</cpp:value></cpp:define>








<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

__HIP_OVERLOAD1<expr_stmt><expr><operator>(</operator><name>double</name><operator>,</operator> <name>acos</name><operator>)</operator>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>acosh</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>asin</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>asinh</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>atan</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD2</name><argument_list>(<argument>double</argument>, <argument>atan2</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>atanh</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>cbrt</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>ceil</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD2</name><argument_list>(<argument>double</argument>, <argument>copysign</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>cos</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>cosh</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>erf</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>erfc</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>exp</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>exp2</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>expm1</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>fabs</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD2</name><argument_list>(<argument>double</argument>, <argument>fdim</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>floor</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD2</name><argument_list>(<argument>double</argument>, <argument>fmax</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD2</name><argument_list>(<argument>double</argument>, <argument>fmin</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD2</name><argument_list>(<argument>double</argument>, <argument>fmod</argument>)</argument_list></macro>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__HIPCC_RTC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>int</argument>, <argument>fpclassify</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>__HIP_OVERLOAD2</name><argument_list>(<argument>double</argument>, <argument>hypot</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>int</argument>, <argument>ilogb</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>bool</argument>, <argument>isfinite</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD2</name><argument_list>(<argument>bool</argument>, <argument>isgreater</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD2</name><argument_list>(<argument>bool</argument>, <argument>isgreaterequal</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>bool</argument>, <argument>isinf</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD2</name><argument_list>(<argument>bool</argument>, <argument>isless</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD2</name><argument_list>(<argument>bool</argument>, <argument>islessequal</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD2</name><argument_list>(<argument>bool</argument>, <argument>islessgreater</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>bool</argument>, <argument>isnan</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>bool</argument>, <argument>isnormal</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD2</name><argument_list>(<argument>bool</argument>, <argument>isunordered</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>lgamma</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>log</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>log10</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>log1p</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>log2</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>logb</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>long long</argument>, <argument>llrint</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>long long</argument>, <argument>llround</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>long</argument>, <argument>lrint</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>long</argument>, <argument>lround</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>nearbyint</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD2</name><argument_list>(<argument>double</argument>, <argument>nextafter</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD2</name><argument_list>(<argument>double</argument>, <argument>pow</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD2</name><argument_list>(<argument>double</argument>, <argument>remainder</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>rint</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>round</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>bool</argument>, <argument>signbit</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>sin</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>sinh</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>sqrt</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>tan</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>tanh</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>tgamma</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD1</name><argument_list>(<argument>double</argument>, <argument>trunc</argument>)</argument_list></macro>


<macro><name>__HIP_OVERLOAD2</name><argument_list>(<argument>double</argument>, <argument>max</argument>)</argument_list></macro>
<macro><name>__HIP_OVERLOAD2</name><argument_list>(<argument>double</argument>, <argument>min</argument>)</argument_list></macro>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__cplusplus</name> <operator>&gt;=</operator> <literal type="number">201103L</literal></expr></cpp:if>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>__T1</name></expr></argument>, <argument><expr><name>typename</name> <name>__T2</name></expr></argument>, <argument><expr><name>typename</name> <name>__T3</name></expr></argument>&gt;</argument_list></name>
<name>__DEVICE__</name> <name>__CONSTEXPR__</name> <name>typename</name> <name><name>__hip_enable_if</name><argument_list type="generic">&lt;
<argument><expr><name>__hip</name><operator>::</operator><name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>__T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator> <name>__hip</name><operator>::</operator><name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>__T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator>
<name>__hip</name><operator>::</operator><name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>__T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><name>typename</name> <name>__hip</name><operator>::</operator><name><name>__promote</name><argument_list type="generic">&lt;<argument><expr><name>__T1</name></expr></argument>, <argument><expr><name>__T2</name></expr></argument>, <argument><expr><name>__T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>fma</name><argument_list>(<argument>__T1 __x</argument>, <argument>__T2 __y</argument>, <argument>__T3 __z</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>__hip</name><operator>::</operator><name><name>__promote</name><argument_list type="generic">&lt;<argument><expr><name>__T1</name></expr></argument>, <argument><expr><name>__T2</name></expr></argument>, <argument><expr><name>__T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>__result_type</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><operator>::</operator><call><name>fma</name><argument_list>(<argument><expr><operator>(</operator><name>__result_type</name><operator>)</operator><name>__x</name></expr></argument>, <argument><expr><operator>(</operator><name>__result_type</name><operator>)</operator><name>__y</name></expr></argument>, <argument><expr><operator>(</operator><name>__result_type</name><operator>)</operator><name>__z</name></expr></argument>)</argument_list></call></expr>;</return>
}
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>__T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>__T2</name></expr><operator>,</operator> <expr><name>typename</name> <name>__T3</name><operator>&gt;</operator>
<name>__DEVICE__</name> <name>__CONSTEXPR__</name>
<name>typename</name> <name><name>__hip_enable_if</name><argument_list type="generic">&lt;<argument><expr><name>__hip</name><operator>::</operator><name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>__T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator>
<name>__hip</name><operator>::</operator><name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>__T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator>
<name>__hip</name><operator>::</operator><name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>__T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>fma</name><argument_list>(<argument>__T1 __x</argument>, <argument>__T2 __y</argument>, <argument>__T3 __z</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>::</operator><call><name>fma</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>__x</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>__y</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>__z</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>__T</name></expr></argument>&gt;</argument_list></name>
<name>__DEVICE__</name> <name>__CONSTEXPR__</name>
<name>typename</name> <name><name>__hip_enable_if</name><argument_list type="generic">&lt;<argument><expr><name>__hip</name><operator>::</operator><name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name>__T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>, <argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>frexp</name><argument_list>(<argument>__T __x</argument>, <argument>int *__exp</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>::</operator><call><name>frexp</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>__x</name></expr></argument>, <argument><expr><name>__exp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>__T</name></expr></argument>&gt;</argument_list></name>
<name>__DEVICE__</name> <name>__CONSTEXPR__</name>
<name>typename</name> <name><name>__hip_enable_if</name><argument_list type="generic">&lt;<argument><expr><name>__hip</name><operator>::</operator><name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name>__T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>, <argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>ldexp</name><argument_list>(<argument>__T __x</argument>, <argument>int __exp</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>::</operator><call><name>ldexp</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>__x</name></expr></argument>, <argument><expr><name>__exp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>__T</name></expr></argument>&gt;</argument_list></name>
<name>__DEVICE__</name> <name>__CONSTEXPR__</name>
<name>typename</name> <name><name>__hip_enable_if</name><argument_list type="generic">&lt;<argument><expr><name>__hip</name><operator>::</operator><name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name>__T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>, <argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>modf</name><argument_list>(<argument>__T __x</argument>, <argument>double *__exp</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>::</operator><call><name>modf</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>__x</name></expr></argument>, <argument><expr><name>__exp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__cplusplus</name> <operator>&gt;=</operator> <literal type="number">201103L</literal></expr></cpp:if>
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>__T1</name></expr></argument>, <argument><expr><name>typename</name> <name>__T2</name></expr></argument>&gt;</argument_list></name>
<name>__DEVICE__</name> <name>__CONSTEXPR__</name>
<name>typename</name> <name><name>__hip_enable_if</name><argument_list type="generic">&lt;<argument><expr><name>__hip</name><operator>::</operator><name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>__T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator>
<name>__hip</name><operator>::</operator><name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>__T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><name>typename</name> <name>__hip</name><operator>::</operator><name><name>__promote</name><argument_list type="generic">&lt;<argument><expr><name>__T1</name></expr></argument>, <argument><expr><name>__T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>remquo</name><argument_list>(<argument>__T1 __x</argument>, <argument>__T2 __y</argument>, <argument>int *__quo</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>__hip</name><operator>::</operator><name><name>__promote</name><argument_list type="generic">&lt;<argument><expr><name>__T1</name></expr></argument>, <argument><expr><name>__T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>__result_type</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><operator>::</operator><call><name>remquo</name><argument_list>(<argument><expr><operator>(</operator><name>__result_type</name><operator>)</operator><name>__x</name></expr></argument>, <argument><expr><operator>(</operator><name>__result_type</name><operator>)</operator><name>__y</name></expr></argument>, <argument><expr><name>__quo</name></expr></argument>)</argument_list></call></expr>;</return>
}
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>__T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>__T2</name><operator>&gt;</operator>
<name>__DEVICE__</name> <name>__CONSTEXPR__</name>
<name>typename</name> <name><name>__hip_enable_if</name><argument_list type="generic">&lt;<argument><expr><name>__hip</name><operator>::</operator><name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>__T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator>
<name>__hip</name><operator>::</operator><name><name>is_arithmetic</name><argument_list type="generic">&lt;<argument><expr><name>__T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>remquo</name><argument_list>(<argument>__T1 __x</argument>, <argument>__T2 __y</argument>, <argument>int *__quo</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>::</operator><call><name>remquo</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>__x</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>__y</name></expr></argument>, <argument><expr><name>__quo</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>__T</name></expr></argument>&gt;</argument_list></name>
<name>__DEVICE__</name> <name>__CONSTEXPR__</name>
<name>typename</name> <name><name>__hip_enable_if</name><argument_list type="generic">&lt;<argument><expr><name>__hip</name><operator>::</operator><name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name>__T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>, <argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>scalbln</name><argument_list>(<argument>__T __x</argument>, <argument>long int __exp</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>::</operator><call><name>scalbln</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>__x</name></expr></argument>, <argument><expr><name>__exp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>__T</name></expr></argument>&gt;</argument_list></name>
<name>__DEVICE__</name> <name>__CONSTEXPR__</name>
<name>typename</name> <name><name>__hip_enable_if</name><argument_list type="generic">&lt;<argument><expr><name>__hip</name><operator>::</operator><name><name>is_integral</name><argument_list type="generic">&lt;<argument><expr><name>__T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>, <argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>scalbn</name><argument_list>(<argument>__T __x</argument>, <argument>int __exp</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>::</operator><call><name>scalbn</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>__x</name></expr></argument>, <argument><expr><name>__exp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>pop_macro</name><name>(</name><cpp:literal>"__HIP_OVERLOAD1"</cpp:literal><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>pop_macro</name><name>(</name><cpp:literal>"__HIP_OVERLOAD2"</cpp:literal><name>)</name></cpp:pragma>





<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__OPENMP_AMDGCN__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__HIPCC_RTC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_LIBCPP_BEGIN_NAMESPACE_STD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>_LIBCPP_BEGIN_NAMESPACE_STD</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<name>namespace</name></type> <name>std</name> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_GLIBCXX_BEGIN_NAMESPACE_VERSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>_GLIBCXX_BEGIN_NAMESPACE_VERSION</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<name>using</name> <operator>::</operator><name>acos</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>acosh</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>asin</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>asinh</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>atan</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>atan2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>atanh</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>cbrt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>ceil</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>copysign</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>cos</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>cosh</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>erf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>erfc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>exp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>exp2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>expm1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>fabs</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>fdim</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>floor</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>fma</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>fmax</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>fmin</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>fmod</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>fpclassify</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>frexp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>hypot</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>ilogb</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>isfinite</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>isgreater</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>isgreaterequal</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>isless</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>islessequal</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>islessgreater</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>isnormal</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>isunordered</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>ldexp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>lgamma</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>llrint</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>llround</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>log</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>log10</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>log1p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>log2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>logb</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>lrint</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>lround</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>modf</name></expr>;</expr_stmt>



<expr_stmt><expr><name>using</name> <operator>::</operator><name>nearbyint</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>nextafter</name></expr>;</expr_stmt>

<expr_stmt><expr><name>using</name> <operator>::</operator><name>pow</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>remainder</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>remquo</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>rint</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>round</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>scalbln</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>scalbn</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>signbit</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>sin</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>sinh</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>sqrt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>tan</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>tanh</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>tgamma</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>trunc</name></expr>;</expr_stmt>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GLIBCXX__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>isinf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>isnan</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><name>using</name> <operator>::</operator><name>acosf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>acoshf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>asinf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>asinhf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>atan2f</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>atanf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>atanhf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>cbrtf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>ceilf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>copysignf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>cosf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>coshf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>erfcf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>erff</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>exp2f</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>expf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>expm1f</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>fabsf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>fdimf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>floorf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>fmaf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>fmaxf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>fminf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>fmodf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>frexpf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>hypotf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>ilogbf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>ldexpf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>lgammaf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>llrintf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>llroundf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>log10f</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>log1pf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>log2f</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>logbf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>logf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>lrintf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>lroundf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>modff</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>nearbyintf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>nextafterf</name></expr>;</expr_stmt>

<expr_stmt><expr><name>using</name> <operator>::</operator><name>powf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>remainderf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>remquof</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>rintf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>roundf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>scalblnf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>scalbnf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>sinf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>sinhf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>sqrtf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>tanf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>tanhf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>tgammaf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>using</name> <operator>::</operator><name>truncf</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_LIBCPP_END_NAMESPACE_STD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>_LIBCPP_END_NAMESPACE_STD</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_GLIBCXX_BEGIN_NAMESPACE_VERSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>_GLIBCXX_END_NAMESPACE_VERSION</name></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__HIPCC_RTC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>





<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ymath.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>overloadable</name><operator>)</operator></expr></argument>)</argument_list> <name>double</name> <name>_Cosh</name><argument_list>(<argument><expr><name>double</name> <name>x</name></expr></argument>,
<argument><expr><name>double</name> <name>y</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>cosh</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>y</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>overloadable</name><operator>)</operator></expr></argument>)</argument_list> <name>float</name> <name>_FCosh</name><argument_list>(<argument><expr><name>float</name> <name>x</name></expr></argument>,
<argument><expr><name>float</name> <name>y</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>coshf</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>y</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>overloadable</name><operator>)</operator></expr></argument>)</argument_list> <name>short</name> <name>_Dtest</name><argument_list>(<argument><expr><name>double</name> <operator>*</operator><name>p</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>fpclassify</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>overloadable</name><operator>)</operator></expr></argument>)</argument_list> <name>short</name> <name>_FDtest</name><argument_list>(<argument><expr><name>float</name> <operator>*</operator><name>p</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>fpclassify</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>overloadable</name><operator>)</operator></expr></argument>)</argument_list> <name>double</name> <name>_Sinh</name><argument_list>(<argument><expr><name>double</name> <name>x</name></expr></argument>,
<argument><expr><name>double</name> <name>y</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>sinh</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>y</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>__DEVICE__</name> <name>__CONSTEXPR__</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>overloadable</name><operator>)</operator></expr></argument>)</argument_list> <name>float</name> <name>_FSinh</name><argument_list>(<argument><expr><name>float</name> <name>x</name></expr></argument>,
<argument><expr><name>float</name> <name>y</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>sinhf</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>y</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>pop_macro</name><name>(</name><cpp:literal>"__DEVICE__"</cpp:literal><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>pop_macro</name><name>(</name><cpp:literal>"__CONSTEXPR__"</cpp:literal><name>)</name></cpp:pragma>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
