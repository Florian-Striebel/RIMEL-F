<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/lib/Format/FormatToken.h">













<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_LIB_FORMAT_FORMATTOKEN_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_LIB_FORMAT_FORMATTOKEN_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/IdentifierTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OperatorPrecedence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Format/Format.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/Lexer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unordered_set&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>format</name> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIST_TOKEN_TYPES</name></cpp:macro> <cpp:value>TYPE(ArrayInitializerLSquare) TYPE(ArraySubscriptLSquare) TYPE(AttributeColon) TYPE(AttributeMacro) TYPE(AttributeParen) TYPE(AttributeSquare) TYPE(BinaryOperator) TYPE(BitFieldColon) TYPE(BlockComment) TYPE(CastRParen) TYPE(ConditionalExpr) TYPE(ConflictAlternative) TYPE(ConflictEnd) TYPE(ConflictStart) TYPE(ConstraintJunctions) TYPE(CtorInitializerColon) TYPE(CtorInitializerComma) TYPE(DesignatedInitializerLSquare) TYPE(DesignatedInitializerPeriod) TYPE(DictLiteral) TYPE(FatArrow) TYPE(ForEachMacro) TYPE(FunctionAnnotationRParen) TYPE(FunctionDeclarationName) TYPE(FunctionLBrace) TYPE(FunctionTypeLParen) TYPE(IfMacro) TYPE(ImplicitStringLiteral) TYPE(InheritanceColon) TYPE(InheritanceComma) TYPE(InlineASMBrace) TYPE(InlineASMColon) TYPE(InlineASMSymbolicNameLSquare) TYPE(JavaAnnotation) TYPE(JsComputedPropertyName) TYPE(JsExponentiation) TYPE(JsExponentiationEqual) TYPE(JsPipePipeEqual) TYPE(JsPrivateIdentifier) TYPE(JsTypeColon) TYPE(JsTypeOperator) TYPE(JsTypeOptionalQuestion) TYPE(JsAndAndEqual) TYPE(LambdaArrow) TYPE(LambdaLBrace) TYPE(LambdaLSquare) TYPE(LeadingJavaAnnotation) TYPE(LineComment) TYPE(MacroBlockBegin) TYPE(MacroBlockEnd) TYPE(NamespaceMacro) TYPE(NonNullAssertion) TYPE(NullCoalescingEqual) TYPE(NullCoalescingOperator) TYPE(NullPropagatingOperator) TYPE(ObjCBlockLBrace) TYPE(ObjCBlockLParen) TYPE(ObjCDecl) TYPE(ObjCForIn) TYPE(ObjCMethodExpr) TYPE(ObjCMethodSpecifier) TYPE(ObjCProperty) TYPE(ObjCStringLiteral) TYPE(OverloadedOperator) TYPE(OverloadedOperatorLParen) TYPE(PointerOrReference) TYPE(PureVirtualSpecifier) TYPE(RangeBasedForLoopColon) TYPE(RegexLiteral) TYPE(SelectorName) TYPE(StartOfName) TYPE(StatementAttributeLikeMacro) TYPE(StatementMacro) TYPE(StructuredBindingLSquare) TYPE(TemplateCloser) TYPE(TemplateOpener) TYPE(TemplateString) TYPE(ProtoExtensionLSquare) TYPE(TrailingAnnotation) TYPE(TrailingReturnArrow) TYPE(TrailingUnaryOperator) TYPE(TypeDeclarationParen) TYPE(TypenameMacro) TYPE(UnaryOperator) TYPE(UntouchableMacroFunc) TYPE(CSharpStringLiteral) TYPE(CSharpNamedArgumentColon) TYPE(CSharpNullable) TYPE(CSharpNullConditionalLSquare) TYPE(CSharpGenericTypeConstraint) TYPE(CSharpGenericTypeConstraintColon) TYPE(CSharpGenericTypeConstraintComma) TYPE(Unknown)</cpp:value></cpp:define>
































































































<enum>enum <name>TokenType</name> : <type><name>uint8_t</name></type> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPE</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>TT_##X,</cpp:value></cpp:define>
<decl><name>LIST_TOKEN_TYPES</name>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TYPE</name></cpp:undef>
<name>NUM_TOKEN_TYPES</name></decl>
}</block>;</enum>


<function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getTokenTypeName</name><parameter_list>(<parameter><decl><type><name>TokenType</name></type> <name>Type</name></decl></parameter>)</parameter_list>;</function_decl>


<enum>enum <name>BraceBlockKind</name> <block>{ <decl><name>BK_Unknown</name></decl>, <decl><name>BK_Block</name></decl>, <decl><name>BK_BracedInit</name></decl> }</block>;</enum>


<enum>enum <name>ParameterPackingKind</name> <block>{ <decl><name>PPK_BinPacked</name></decl>, <decl><name>PPK_OnePerLine</name></decl>, <decl><name>PPK_Inconclusive</name></decl> }</block>;</enum>

<enum>enum <name>FormatDecision</name> <block>{ <decl><name>FD_Unformatted</name></decl>, <decl><name>FD_Continue</name></decl>, <decl><name>FD_Break</name></decl> }</block>;</enum>


<enum>enum <name>MacroRole</name> <block>{


<decl><name>MR_ExpandedArg</name></decl>,


<decl><name>MR_UnexpandedArg</name></decl>,


<decl><name>MR_Hidden</name></decl>,
}</block>;</enum>

<struct_decl>struct <name>FormatToken</name>;</struct_decl>


























<struct>struct <name>MacroExpansion</name> <block>{
<macro><name>MacroExpansion</name><argument_list>(<argument>MacroRole Role</argument>)</argument_list></macro> : <macro><name>Role</name><argument_list>(<argument>Role</argument>)</argument_list></macro> <block>{<block_content/>}</block>







<decl_stmt><decl><type><name>MacroRole</name></type> <name>Role</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>FormatToken</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <name>ExpandedFrom</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>StartOfExpansion</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>EndOfExpansion</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name>class</name></type> <name>TokenRole</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>AnnotatedLine</name></decl>;</decl_stmt>



<struct>struct <name>FormatToken</name> <block>{
<expr_stmt><expr><call><name>FormatToken</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>HasUnescapedNewline</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IsMultiline</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IsFirst</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>MustBreakBefore</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IsUnterminatedLiteral</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>CanBreakBefore</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ClosesTemplateDeclaration</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>StartsBinaryExpression</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>EndsBinaryExpression</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>PartOfMultiVariableDeclStmt</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ContinuesLineCommentSection</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>Finalized</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>BlockKind</name><argument_list>(<argument><expr><name>BK_Unknown</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Decision</name><argument_list>(<argument><expr><name>FD_Unformatted</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>PackingKind</name><argument_list>(<argument><expr><name>PPK_Inconclusive</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Type</name><argument_list>(<argument>TT_Unknown</argument>)</argument_list></macro> <expr><block>{}</block>


<name>Token</name> <name>Tok</name></expr>;</expr_stmt>





<decl_stmt><decl><type><name>StringRef</name></type> <name>TokenText</name></decl>;</decl_stmt>





<expr_stmt><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>TokenRole</name></expr></argument>&gt;</argument_list></name> <name>Role</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>SourceRange</name></type> <name>WhitespaceRange</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>HasUnescapedNewline</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>IsMultiline</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>IsFirst</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>unsigned</name></type> <name>MustBreakBefore</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>IsUnterminatedLiteral</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>CanBreakBefore</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>ClosesTemplateDeclaration</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>StartsBinaryExpression</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>EndsBinaryExpression</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>PartOfMultiVariableDeclStmt</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>ContinuesLineCommentSection</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>Finalized</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>unsigned</name></type> <name>BlockKind</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><name>BraceBlockKind</name> <macro><name>getBlockKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>BraceBlockKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>BlockKind</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setBlockKind</name><parameter_list>(<parameter><decl><type><name>BraceBlockKind</name></type> <name>BBK</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>BlockKind</name> <operator>=</operator> <name>BBK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getBlockKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>BBK</name> <operator>&amp;&amp;</operator> <literal type="string">"BraceBlockKind overflow!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>unsigned</name></type> <name>Decision</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><name>FormatDecision</name> <macro><name>getDecision</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>FormatDecision</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Decision</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setDecision</name><parameter_list>(<parameter><decl><type><name>FormatDecision</name></type> <name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Decision</name> <operator>=</operator> <name>D</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getDecision</name><argument_list>()</argument_list></call> <operator>==</operator> <name>D</name> <operator>&amp;&amp;</operator> <literal type="string">"FormatDecision overflow!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>unsigned</name></type> <name>PackingKind</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><name>ParameterPackingKind</name> <macro><name>getPackingKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ParameterPackingKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>PackingKind</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setPackingKind</name><parameter_list>(<parameter><decl><type><name>ParameterPackingKind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>PackingKind</name> <operator>=</operator> <name>K</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getPackingKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>K</name> <operator>&amp;&amp;</operator> <literal type="string">"ParameterPackingKind overflow!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>TokenType</name></type> <name>Type</name></decl>;</decl_stmt>

<label><name>public</name>:</label>


<expr_stmt><expr><name>TokenType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Type</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setType</name><parameter_list>(<parameter><decl><type><name>TokenType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Type</name> <operator>=</operator> <name>T</name></expr>;</expr_stmt> </block_content>}</block></function>





<decl_stmt><decl><type><name>unsigned</name></type> <name>NewlinesBefore</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>LastNewlineOffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>ColumnWidth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>LastLineColumnWidth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>SpacesRequiredBefore</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>ParameterCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>BlockParameterCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>ParentBracket</name> <operator>=</operator> <name>tok</name><operator>::</operator><name>unknown</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>TotalLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>OriginalColumn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>UnbreakableTailLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>BindingStrength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NestingLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>IndentLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>SplitPenalty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>






<decl_stmt><decl><type><name>unsigned</name></type> <name>LongestObjCSelectorName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>ObjCSelectorNameParts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>ParameterIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>






<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>prec</name><operator>::</operator><name>Level</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>FakeLParens</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>FakeRParens</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>OperatorIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>FormatToken</name> <modifier>*</modifier></type><name>NextOperator</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>FormatToken</name> <modifier>*</modifier></type><name>MatchingParen</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>FormatToken</name> <modifier>*</modifier></type><name>Previous</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>FormatToken</name> <modifier>*</modifier></type><name>Next</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>StartsColumn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>ArrayInitializerLineStart</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>IsArrayInitializer</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>AnnotatedLine</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name></type> <name>Children</name></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>MacroExpansion</name></expr></argument>&gt;</argument_list></name> <name>MacroCtx</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>is</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Kind</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is</name><argument_list>(<argument><expr><name>TokenType</name> <name>TT</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><call><name>getType</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TT</name></expr>;</return> </block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is</name><argument_list>(<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>II</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>II</name> <operator>&amp;&amp;</operator> <name>II</name> <operator>==</operator> <call><name><name>Tok</name><operator>.</operator><name>getIdentifierInfo</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>PPKeywordKind</name> <name>Kind</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>Tok</name><operator>.</operator><name>getIdentifierInfo</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Tok</name><operator>.</operator><name>getIdentifierInfo</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getPPKeywordID</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Kind</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is</name><argument_list>(<argument><expr><name>BraceBlockKind</name> <name>BBK</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><call><name>getBlockKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>BBK</name></expr>;</return> </block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is</name><argument_list>(<argument><expr><name>ParameterPackingKind</name> <name>PPK</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><call><name>getPackingKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>PPK</name></expr>;</return> </block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>A</name></expr></argument>, <argument><expr><name>typename</name> <name>B</name></expr></argument>&gt;</argument_list></name> <name>bool</name></type> <name>isOneOf</name><argument_list>(<argument><expr><name>A</name> <name>K1</name></expr></argument>, <argument><expr><name>B</name> <name>K2</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>is</name><argument_list>(<argument><expr><name>K1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is</name><argument_list>(<argument><expr><name>K2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>A</name></expr></argument>, <argument><expr><name>typename</name> <name>B</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>Ts</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>isOneOf</name><argument_list>(<argument><expr><name>A</name> <name>K1</name></expr></argument>, <argument><expr><name>B</name> <name>K2</name></expr></argument>, <argument><expr><name>Ts</name><operator>...</operator> <name>Ks</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>is</name><argument_list>(<argument><expr><name>K1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isOneOf</name><argument_list>(<argument><expr><name>K2</name></expr></argument>, <argument><expr><name>Ks</name><operator>...</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>bool</name></type> <name>isNot</name><argument_list>(<argument><expr><name>T</name> <name>Kind</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><operator>!</operator><call><name>is</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isIf</name><argument_list>(<argument><expr><name>bool</name> <name>AllowConstexprMacro</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>is</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>kw_if</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>endsSequence</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>kw_constexpr</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw_if</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><call><name>endsSequence</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>identifier</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw_if</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>AllowConstexprMacro</name><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>closesScopeAfterBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getBlockKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>BK_Block</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>closesScope</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Previous</name><operator>-&gt;</operator><name>closesScopeAfterBlock</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
}</block>



<decl><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>A</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>Ts</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name>startsSequence</name><argument_list>(<argument><expr><name>A</name> <name>K1</name></expr></argument>, <argument><expr><name>Ts</name><operator>...</operator> <name>Tokens</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>startsSequenceInternal</name><argument_list>(<argument><expr><name>K1</name></expr></argument>, <argument><expr><name>Tokens</name><operator>...</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl>







<decl><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>A</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>Ts</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name>endsSequence</name><argument_list>(<argument><expr><name>A</name> <name>K1</name></expr></argument>, <argument><expr><name>Ts</name><operator>...</operator> <name>Tokens</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>endsSequenceInternal</name><argument_list>(<argument><expr><name>K1</name></expr></argument>, <argument><expr><name>Tokens</name><operator>...</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl>

<decl><name>bool</name> <name>isStringLiteral</name><argument_list>()</argument_list> const <block>{<block_content> <return>return <expr><name>tok</name><operator>::</operator><call><name>isStringLiteral</name><argument_list>(<argument><expr><call><name><name>Tok</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></decl>

<decl><name>bool</name> <name>isObjCAtKeyword</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>ObjCKeywordKind</name> <name>Kind</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>Tok</name><operator>.</operator><name>isObjCAtKeyword</name></name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl>

<decl><name>bool</name> <name>isAccessSpecifier</name><argument_list>(<argument><expr><name>bool</name> <name>ColonRequired</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>isOneOf</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>kw_public</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw_protected</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw_private</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><name>ColonRequired</name> <operator>||</operator> <operator>(</operator><name>Next</name> <operator>&amp;&amp;</operator> <call><name><name>Next</name><operator>-&gt;</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>colon</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></decl>

<decl><name>bool</name> <name>canBePointerOrReferenceQualifier</name><argument_list>()</argument_list> const <block>{<block_content>
<return>return <expr><call><name>isOneOf</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>kw_const</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw_restrict</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw_volatile</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>kw___attribute</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw__Nonnull</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw__Nullable</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>kw__Null_unspecified</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw___ptr32</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw___ptr64</name></expr></argument>,
<argument><expr><name>TT_AttributeMacro</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl>


<decl><name>bool</name> <name>isSimpleTypeSpecifier</name><argument_list>()</argument_list> const</decl>;</struct>

<expr_stmt><expr><name>bool</name> <macro><name>isObjCAccessSpecifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>is</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>at</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>Next</name> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name><name>Next</name><operator>-&gt;</operator><name>isObjCAtKeyword</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>objc_public</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>Next</name><operator>-&gt;</operator><name>isObjCAtKeyword</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>objc_protected</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>Next</name><operator>-&gt;</operator><name>isObjCAtKeyword</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>objc_package</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>Next</name><operator>-&gt;</operator><name>isObjCAtKeyword</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>objc_private</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>opensScope</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>is</name><argument_list>(<argument><expr><name>TT_TemplateString</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>TokenText</name><operator>.</operator><name>endswith</name></name><argument_list>(<argument><expr><literal type="string">"${"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is</name><argument_list>(<argument><expr><name>TT_DictLiteral</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>less</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>isOneOf</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>l_paren</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>l_brace</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>l_square</name></expr></argument>,
<argument><expr><name>TT_TemplateOpener</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>closesScope</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>is</name><argument_list>(<argument><expr><name>TT_TemplateString</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>TokenText</name><operator>.</operator><name>startswith</name></name><argument_list>(<argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is</name><argument_list>(<argument><expr><name>TT_DictLiteral</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>greater</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>isOneOf</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>r_paren</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>r_brace</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>r_square</name></expr></argument>,
<argument><expr><name>TT_TemplateCloser</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isMemberAccess</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isOneOf</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>arrow</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>period</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>arrowstar</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>isOneOf</name><argument_list>(<argument><expr><name>TT_DesignatedInitializerPeriod</name></expr></argument>, <argument><expr><name>TT_TrailingReturnArrow</name></expr></argument>,
<argument><expr><name>TT_LambdaArrow</name></expr></argument>, <argument><expr><name>TT_LeadingJavaAnnotation</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isUnaryOperator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<switch>switch <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>tok</name><operator>::</operator><name>plus</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>plusplus</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>minus</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>minusminus</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>exclaim</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>tilde</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_sizeof</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_alignof</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>
<default>default:</default>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/></block_content></block></switch>}</block></expr></expr_stmt>
}

bool <macro><name>isBinaryOperator</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{

<return>return <expr><call><name>getPrecedence</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>prec</name><operator>::</operator><name>Comma</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isTrailingComment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>is</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>comment</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>is</name><argument_list>(<argument><expr><name>TT_LineComment</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name>Next</name> <operator>||</operator> <name><name>Next</name><operator>-&gt;</operator><name>NewlinesBefore</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isFunctionLikeKeyword</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<switch>switch <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_throw</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_typeid</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_return</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_sizeof</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_alignof</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_alignas</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_decltype</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_noexcept</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_static_assert</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw__Atomic</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw___attribute</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw___underlying_type</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_requires</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>
<default>default:</default>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/></block_content></block></switch>}</block></expr></expr_stmt>
}



bool <macro><name>isLabelString</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>string_literal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<name>StringRef</name> <name>Content</name> <operator>=</operator> <name>TokenText</name></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Content</name><operator>.</operator><name>startswith</name></name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>Content</name><operator>.</operator><name>startswith</name></name><argument_list>(<argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Content</name> <operator>=</operator> <call><name><name>Content</name><operator>.</operator><name>drop_front</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Content</name><operator>.</operator><name>endswith</name></name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>Content</name><operator>.</operator><name>endswith</name></name><argument_list>(<argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Content</name> <operator>=</operator> <call><name><name>Content</name><operator>.</operator><name>drop_back</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>Content</name> <operator>=</operator> <call><name><name>Content</name><operator>.</operator><name>trim</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>Content</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name><name>Content</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">':'</literal> <operator>||</operator> <call><name><name>Content</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">'='</literal><operator>)</operator></expr>;</return>
}






SourceLocation <macro><name>getStartOfNonWhitespace</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<return>return <expr><call><name><name>WhitespaceRange</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>prec</name><operator>::</operator><name>Level</name> <macro><name>getPrecedence</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getBinOpPrecedence</name><argument_list>(<argument><expr><call><name><name>Tok</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>FormatToken</name> <operator>*</operator><macro><name>getPreviousNonComment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>FormatToken</name> <operator>*</operator><name>Tok</name> <operator>=</operator> <name>Previous</name></expr>;
<while>while <condition>(<expr><name>Tok</name> <operator>&amp;&amp;</operator> <call><name><name>Tok</name><operator>-&gt;</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>comment</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Tok</name> <operator>=</operator> <name><name>Tok</name><operator>-&gt;</operator><name>Previous</name></name></expr>;</expr_stmt></block_content></block></while></block></expr></expr_stmt>
<return>return <expr><name>Tok</name></expr>;</return>
}


const <expr_stmt><expr><name>FormatToken</name> <operator>*</operator><macro><name>getNextNonComment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>FormatToken</name> <operator>*</operator><name>Tok</name> <operator>=</operator> <name>Next</name></expr>;
<while>while <condition>(<expr><name>Tok</name> <operator>&amp;&amp;</operator> <call><name><name>Tok</name><operator>-&gt;</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>comment</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Tok</name> <operator>=</operator> <name><name>Tok</name><operator>-&gt;</operator><name>Next</name></name></expr>;</expr_stmt></block_content></block></while></block></expr></expr_stmt>
<return>return <expr><name>Tok</name></expr>;</return>
}



bool <macro><name>opensBlockOrBlockTypeList</name><argument_list>(<argument>const FormatStyle &amp;Style</argument>)</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{

<if_stmt><if>if <condition>(<expr><call><name>is</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>l_brace</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>getBlockKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>BK_BracedInit</name> <operator>&amp;&amp;</operator> <call><name><name>Style</name><operator>.</operator><name>isCSharp</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is</name><argument_list>(<argument><expr><name>TT_TemplateString</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>opensScope</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>is</name><argument_list>(<argument><expr><name>TT_ArrayInitializerLSquare</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is</name><argument_list>(<argument><expr><name>TT_ProtoExtensionLSquare</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><call><name>is</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>l_brace</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>getBlockKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>BK_Block</name> <operator>||</operator> <call><name>is</name><argument_list>(<argument><expr><name>TT_DictLiteral</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><operator>!</operator><name><name>Style</name><operator>.</operator><name>Cpp11BracedListStyle</name></name> <operator>&amp;&amp;</operator> <name>NestingLevel</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>is</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>less</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>Style</name><operator>.</operator><name>Language</name></name> <operator>==</operator> <name>FormatStyle</name><operator>::</operator><name>LK_Proto</name> <operator>||</operator>
<name><name>Style</name><operator>.</operator><name>Language</name></name> <operator>==</operator> <name>FormatStyle</name><operator>::</operator><name>LK_TextProto</name><operator>)</operator><operator>)</operator></expr>;</return>
}



bool <macro><name>isCppStructuredBinding</name><argument_list>(<argument>const FormatStyle &amp;Style</argument>)</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Style</name><operator>.</operator><name>isCpp</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isNot</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>l_square</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<specifier>const</specifier> <name>FormatToken</name> <operator>*</operator><name>T</name> <operator>=</operator> <name>this</name></block></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>T</name> <operator>=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getPreviousNonComment</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>T</name> <operator>&amp;&amp;</operator> <call><name><name>T</name><operator>-&gt;</operator><name>isOneOf</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>kw_const</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw_volatile</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>amp</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>ampamp</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<return>return <expr><name>T</name> <operator>&amp;&amp;</operator> <call><name><name>T</name><operator>-&gt;</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>kw_auto</name></expr></argument>)</argument_list></call></expr>;</return>
}


bool <macro><name>closesBlockOrBlockTypeList</name><argument_list>(<argument>const FormatStyle &amp;Style</argument>)</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>is</name><argument_list>(<argument><expr><name>TT_TemplateString</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>closesScope</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>MatchingParen</name> <operator>&amp;&amp;</operator> <call><name><name>MatchingParen</name><operator>-&gt;</operator><name>opensBlockOrBlockTypeList</name></name><argument_list>(<argument><expr><name>Style</name></expr></argument>)</argument_list></call></expr>;</return>
}



const <expr_stmt><expr><name>FormatToken</name> <operator>*</operator><macro><name>getNamespaceToken</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>FormatToken</name> <operator>*</operator><name>NamespaceTok</name> <operator>=</operator> <name>this</name></expr>;
<if_stmt><if>if <condition>(<expr><call><name>is</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>comment</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>NamespaceTok</name> <operator>=</operator> <call><name><name>NamespaceTok</name><operator>-&gt;</operator><name>getNextNonComment</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><name>NamespaceTok</name> <operator>&amp;&amp;</operator> <call><name><name>NamespaceTok</name><operator>-&gt;</operator><name>isOneOf</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>kw_inline</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw_export</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>NamespaceTok</name> <operator>=</operator> <call><name><name>NamespaceTok</name><operator>-&gt;</operator><name>getNextNonComment</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><ternary><condition><expr><name>NamespaceTok</name> <operator>&amp;&amp;</operator>
<call><name><name>NamespaceTok</name><operator>-&gt;</operator><name>isOneOf</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>kw_namespace</name></expr></argument>, <argument><expr><name>TT_NamespaceMacro</name></expr></argument>)</argument_list></call></expr>
?</condition><then> <expr><name>NamespaceTok</name></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}

void <macro><name>copyFrom</name><argument_list>(<argument>const FormatToken &amp;Tok</argument>)</argument_list></macro> <block>{<block_content> <expr_stmt><expr><operator>*</operator><name>this</name> <operator>=</operator> <name>Tok</name></expr>;</expr_stmt> </block_content>}</block>

<label><name>private</name>:</label>

<expr_stmt><expr><call><name>FormatToken</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FormatToken</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>FormatToken</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>FormatToken</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> default</expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>A</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>Ts</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>startsSequenceInternal</name><argument_list>(<argument><expr><name>A</name> <name>K1</name></expr></argument>, <argument><expr><name>Ts</name><operator>...</operator> <name>Tokens</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>comment</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>Next</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Next</name><operator>-&gt;</operator><name>startsSequenceInternal</name></name><argument_list>(<argument><expr><name>K1</name></expr></argument>, <argument><expr><name>Tokens</name><operator>...</operator></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>is</name><argument_list>(<argument><expr><name>K1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>Next</name> <operator>&amp;&amp;</operator> <call><name><name>Next</name><operator>-&gt;</operator><name>startsSequenceInternal</name></name><argument_list>(<argument><expr><name>Tokens</name><operator>...</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>A</name></expr></argument>&gt;</argument_list></name> <name>bool</name></type> <name>startsSequenceInternal</name><argument_list>(<argument><expr><name>A</name> <name>K1</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>comment</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>Next</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Next</name><operator>-&gt;</operator><name>startsSequenceInternal</name></name><argument_list>(<argument><expr><name>K1</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>is</name><argument_list>(<argument><expr><name>K1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>A</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>Ts</name></expr></argument>&gt;</argument_list></name> <name>bool</name></type> <name>endsSequenceInternal</name><argument_list>(<argument><expr><name>A</name> <name>K1</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>comment</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>Previous</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Previous</name><operator>-&gt;</operator><name>endsSequenceInternal</name></name><argument_list>(<argument><expr><name>K1</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>is</name><argument_list>(<argument><expr><name>K1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>A</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>Ts</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>endsSequenceInternal</name><argument_list>(<argument><expr><name>A</name> <name>K1</name></expr></argument>, <argument><expr><name>Ts</name><operator>...</operator> <name>Tokens</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>comment</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>Previous</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Previous</name><operator>-&gt;</operator><name>endsSequenceInternal</name></name><argument_list>(<argument><expr><name>K1</name></expr></argument>, <argument><expr><name>Tokens</name><operator>...</operator></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>is</name><argument_list>(<argument><expr><name>K1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>Previous</name> <operator>&amp;&amp;</operator> <call><name><name>Previous</name><operator>-&gt;</operator><name>endsSequenceInternal</name></name><argument_list>(<argument><expr><name>Tokens</name><operator>...</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
};

<decl_stmt><decl><type><name>class</name></type> <name>ContinuationIndenter</name></decl>;</decl_stmt>
<struct_decl>struct <name>LineState</name>;</struct_decl>

<decl_stmt><decl><type><name>class</name></type> <name>TokenRole</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>TokenRole</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FormatStyle</name> <operator>&amp;</operator><name>Style</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>Style</name><argument_list>(<argument>Style</argument>)</argument_list></macro> <block>{}</block>
<name>virtual</name> <operator>~</operator><call><name>TokenRole</name><argument_list>()</argument_list></call></expr>;</expr_stmt>



<function_decl><type><name>virtual</name> <name>void</name></type> <name>precomputeFormattingInfos</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FormatToken</name> <modifier>*</modifier></type><name>Token</name></decl></parameter>)</parameter_list>;</function_decl>







<function><type><name>virtual</name> <name>unsigned</name></type> <name>formatFromToken</name><parameter_list>(<parameter><decl><type><name>LineState</name> <modifier>&amp;</modifier></type><name>State</name></decl></parameter>,
<parameter><decl><type><name>ContinuationIndenter</name> <modifier>*</modifier></type><name>Indenter</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DryRun</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<function><type><name>virtual</name> <name>unsigned</name></type> <name>formatAfterToken</name><parameter_list>(<parameter><decl><type><name>LineState</name> <modifier>&amp;</modifier></type><name>State</name></decl></parameter>,
<parameter><decl><type><name>ContinuationIndenter</name> <modifier>*</modifier></type><name>Indenter</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DryRun</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>virtual</name> <name>void</name></type> <name>CommaFound</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FormatToken</name> <modifier>*</modifier></type><name>Token</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>

<function><type><name>virtual</name> <specifier>const</specifier> <name>FormatToken</name> <modifier>*</modifier></type><name>lastComma</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>nullptr</name></expr>;</return> </block_content>}</block></function>

<label><name>protected</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>FormatStyle</name> <modifier>&amp;</modifier></type><name>Style</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CommaSeparatedList</name> <range>: <expr><name>public</name> <name>TokenRole</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>CommaSeparatedList</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FormatStyle</name> <operator>&amp;</operator><name>Style</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>TokenRole</name><argument_list>(<argument><expr><name>Style</name></expr></argument>)</argument_list></call></expr>, <macro><name>HasNestedBracedList</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>precomputeFormattingInfos</name><argument_list>(<argument>const FormatToken *Token</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>unsigned</name> <macro><name>formatAfterToken</name><argument_list>(<argument>LineState &amp;State</argument>, <argument>ContinuationIndenter *Indenter</argument>,
<argument>bool DryRun</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>unsigned</name> <macro><name>formatFromToken</name><argument_list>(<argument>LineState &amp;State</argument>, <argument>ContinuationIndenter *Indenter</argument>,
<argument>bool DryRun</argument>)</argument_list></macro> <name>override</name></expr>;


<expr><name>void</name> <macro><name>CommaFound</name><argument_list>(<argument>const FormatToken *Token</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>Commas</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>Token</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>const</specifier> <name>FormatToken</name> <operator>*</operator><macro><name>lastComma</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Commas</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>Commas</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<label><name>private</name>:</label>


<struct>struct <name>ColumnFormat</name> <block>{

<decl_stmt><decl><type><name>unsigned</name></type> <name>Columns</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>TotalWidth</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>LineCount</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>ColumnSizes</name></decl>;</decl_stmt>
}</block>;</struct>



<decl_stmt><decl><type><specifier>const</specifier> <name>ColumnFormat</name> <modifier>*</modifier></type><name>getColumnFormat</name><argument_list>(<argument><expr><name>unsigned</name> <name>RemainingCharacters</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>FormatToken</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>Commas</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>ItemLengths</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ColumnFormat</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>Formats</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>HasNestedBracedList</name></decl>;</decl_stmt>
};



<struct>struct <name>AdditionalKeywords</name> <block>{
<macro><name>AdditionalKeywords</name><argument_list>(<argument>IdentifierTable &amp;IdentTable</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>kw_final</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"final"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_override</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"override"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_in</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"in"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_of</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"of"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_CF_CLOSED_ENUM</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"CF_CLOSED_ENUM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_CF_ENUM</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"CF_ENUM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_CF_OPTIONS</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"CF_OPTIONS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_NS_CLOSED_ENUM</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"NS_CLOSED_ENUM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_NS_ENUM</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"NS_ENUM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_NS_OPTIONS</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"NS_OPTIONS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>kw_as</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"as"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_async</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"async"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_await</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"await"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_declare</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"declare"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_finally</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"finally"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_from</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"from"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_function</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_get</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"get"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_import</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"import"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_infer</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"infer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_is</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"is"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_let</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"let"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_module</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"module"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_readonly</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"readonly"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_set</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_type</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_typeof</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"typeof"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_var</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"var"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_yield</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"yield"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>kw_abstract</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"abstract"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_assert</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"assert"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_extends</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"extends"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_implements</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"implements"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_instanceof</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"instanceof"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_interface</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"interface"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_native</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"native"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_package</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"package"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_synchronized</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"synchronized"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_throws</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"throws"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw___except</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"__except"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw___has_include</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"__has_include"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw___has_include_next</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"__has_include_next"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>kw_mark</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"mark"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>kw_extend</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"extend"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_option</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"option"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_optional</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"optional"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_repeated</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"repeated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_required</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"required"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_returns</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"returns"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>kw_signals</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"signals"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_qsignals</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"Q_SIGNALS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_slots</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"slots"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_qslots</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"Q_SLOTS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>kw_dollar</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"dollar"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_base</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"base"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_byte</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"byte"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_checked</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"checked"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_decimal</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"decimal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_delegate</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"delegate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_event</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"event"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_fixed</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"fixed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_foreach</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"foreach"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_implicit</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"implicit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_internal</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_lock</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"lock"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_null</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_object</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_out</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"out"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_params</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"params"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_ref</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"ref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_string</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_stackalloc</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"stackalloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_sbyte</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"sbyte"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_sealed</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"sealed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_uint</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"uint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_ulong</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"ulong"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_unchecked</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"unchecked"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_unsafe</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"unsafe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_ushort</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"ushort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_when</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"when"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kw_where</name> <operator>=</operator> <operator>&amp;</operator><call><name><name>IdentTable</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"where"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>JsExtraKeywords</name> <operator>=</operator> <name>std</name><operator>::</operator><macro><name>unordered_set</name></macro><operator>&lt;</operator><name>IdentifierInfo</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator>
<block>{<expr><name>kw_as</name></expr>, <expr><name>kw_async</name></expr>, <expr><name>kw_await</name></expr>, <expr><name>kw_declare</name></expr>, <expr><name>kw_finally</name></expr>, <expr><name>kw_from</name></expr>,
<expr><name>kw_function</name></expr>, <expr><name>kw_get</name></expr>, <expr><name>kw_import</name></expr>, <expr><name>kw_is</name></expr>, <expr><name>kw_let</name></expr>, <expr><name>kw_module</name></expr>, <expr><name>kw_readonly</name></expr>,
<expr><name>kw_set</name></expr>, <expr><name>kw_type</name></expr>, <expr><name>kw_typeof</name></expr>, <expr><name>kw_var</name></expr>, <expr><name>kw_yield</name></expr>,

<expr><name>kw_abstract</name></expr>, <expr><name>kw_extends</name></expr>, <expr><name>kw_implements</name></expr>, <expr><name>kw_instanceof</name></expr>, <expr><name>kw_interface</name></expr>}</block><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>CSharpExtraKeywords</name> <operator>=</operator> <name>std</name><operator>::</operator><macro><name>unordered_set</name></macro><operator>&lt;</operator><name>IdentifierInfo</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator>
<block>{<expr><name>kw_base</name></expr>, <expr><name>kw_byte</name></expr>, <expr><name>kw_checked</name></expr>, <expr><name>kw_decimal</name></expr>, <expr><name>kw_delegate</name></expr>, <expr><name>kw_event</name></expr>,
<expr><name>kw_fixed</name></expr>, <expr><name>kw_foreach</name></expr>, <expr><name>kw_implicit</name></expr>, <expr><name>kw_in</name></expr>, <expr><name>kw_interface</name></expr>, <expr><name>kw_internal</name></expr>,
<expr><name>kw_is</name></expr>, <expr><name>kw_lock</name></expr>, <expr><name>kw_null</name></expr>, <expr><name>kw_object</name></expr>, <expr><name>kw_out</name></expr>, <expr><name>kw_override</name></expr>, <expr><name>kw_params</name></expr>,
<expr><name>kw_readonly</name></expr>, <expr><name>kw_ref</name></expr>, <expr><name>kw_string</name></expr>, <expr><name>kw_stackalloc</name></expr>, <expr><name>kw_sbyte</name></expr>, <expr><name>kw_sealed</name></expr>,
<expr><name>kw_uint</name></expr>, <expr><name>kw_ulong</name></expr>, <expr><name>kw_unchecked</name></expr>, <expr><name>kw_unsafe</name></expr>, <expr><name>kw_ushort</name></expr>, <expr><name>kw_when</name></expr>,
<expr><name>kw_where</name></expr>,

<expr><name>kw_as</name></expr>, <expr><name>kw_async</name></expr>, <expr><name>kw_await</name></expr>, <expr><name>kw_declare</name></expr>, <expr><name>kw_finally</name></expr>, <expr><name>kw_from</name></expr>,
<expr><name>kw_function</name></expr>, <expr><name>kw_get</name></expr>, <expr><name>kw_import</name></expr>, <expr><name>kw_is</name></expr>, <expr><name>kw_let</name></expr>, <expr><name>kw_module</name></expr>, <expr><name>kw_readonly</name></expr>,
<expr><name>kw_set</name></expr>, <expr><name>kw_type</name></expr>, <expr><name>kw_typeof</name></expr>, <expr><name>kw_var</name></expr>, <expr><name>kw_yield</name></expr>,

<expr><name>kw_abstract</name></expr>, <expr><name>kw_extends</name></expr>, <expr><name>kw_implements</name></expr>, <expr><name>kw_instanceof</name></expr>, <expr><name>kw_interface</name></expr>}</block><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block>


<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_final</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_override</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_in</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_of</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_CF_CLOSED_ENUM</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_CF_ENUM</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_CF_OPTIONS</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_NS_CLOSED_ENUM</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_NS_ENUM</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_NS_OPTIONS</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw___except</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw___has_include</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw___has_include_next</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_as</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_async</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_await</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_declare</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_finally</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_from</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_function</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_get</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_import</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_infer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_is</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_let</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_module</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_readonly</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_set</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_typeof</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_var</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_yield</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_abstract</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_assert</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_extends</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_implements</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_instanceof</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_interface</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_native</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_package</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_synchronized</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_throws</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_mark</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_extend</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_option</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_optional</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_repeated</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_required</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_returns</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_signals</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_qsignals</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_slots</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_qslots</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_dollar</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_byte</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_checked</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_decimal</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_delegate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_event</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_fixed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_foreach</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_implicit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_internal</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_lock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_null</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_object</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_out</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_params</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_stackalloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_sbyte</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_sealed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_uint</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_ulong</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_unchecked</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_unsafe</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_ushort</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_when</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>kw_where</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>bool</name></type> <name>IsJavaScriptIdentifier</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FormatToken</name> <operator>&amp;</operator><name>Tok</name></expr></argument>,
<argument><expr><name>bool</name> <name>AcceptIdentifierName</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list> const <block>{<block_content>


<switch>switch <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>Tok</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_break</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_case</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_catch</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_class</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_continue</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_const</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_default</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_delete</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_do</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_else</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_enum</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_export</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_false</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_for</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_if</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_import</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_module</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_new</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_private</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_protected</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_public</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_return</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_static</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_switch</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_this</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_throw</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_true</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_try</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_typeof</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_void</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_while</name></expr>:</case>

<return>return <expr><name>false</name></expr>;</return>
<case>case <expr><name>tok</name><operator>::</operator><name>identifier</name></expr>:</case> <block>{<block_content>


<decl_stmt><decl><type><name>bool</name></type> <name>IsPseudoKeyword</name> <init>=
<expr><call><name><name>JsExtraKeywords</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><call><name><name>Tok</name><operator>.</operator><name>Tok</name><operator>.</operator><name>getIdentifierInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator>
<call><name><name>JsExtraKeywords</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>AcceptIdentifierName</name> <operator>||</operator> <operator>!</operator><name>IsPseudoKeyword</name></expr>;</return>
</block_content>}</block>
<default>default:</default>


<break>break;</break>
</block_content>}</block></switch>

<switch>switch <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>Tok</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KEYWORD</name><parameter_list>(<parameter><type><name>X</name></type></parameter>, <parameter><type><name>Y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case tok::kw_##X:</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TokenKinds.def"</cpp:file></cpp:include>


<return>return <expr><name>true</name></expr>;</return>
<default>default:</default>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isCSharpKeyword</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FormatToken</name> <operator>&amp;</operator><name>Tok</name></expr></argument>)</argument_list> const <block>{<block_content>
<switch>switch <condition>(<expr><call><name><name>Tok</name><operator>.</operator><name>Tok</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_bool</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_break</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_case</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_catch</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_char</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_class</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_const</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_continue</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_default</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_do</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_double</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_else</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_enum</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_explicit</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_extern</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_false</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_float</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_for</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_goto</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_if</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_int</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_long</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_namespace</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_new</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_operator</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_private</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_protected</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_public</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_return</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_short</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_sizeof</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_static</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_struct</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_switch</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_this</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_throw</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_true</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_try</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_typeof</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_using</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_virtual</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_void</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_volatile</name></expr>:</case>
<case>case <expr><name>tok</name><operator>::</operator><name>kw_while</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>
<default>default:</default>
<return>return <expr><call><name><name>Tok</name><operator>.</operator><name>is</name></name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>identifier</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>CSharpExtraKeywords</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><call><name><name>Tok</name><operator>.</operator><name>Tok</name><operator>.</operator><name>getIdentifierInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator>
<call><name><name>CSharpExtraKeywords</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unordered_set</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>JsExtraKeywords</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unordered_set</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CSharpExtraKeywords</name></expr>;</expr_stmt>
}</block>;</struct>

}
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
