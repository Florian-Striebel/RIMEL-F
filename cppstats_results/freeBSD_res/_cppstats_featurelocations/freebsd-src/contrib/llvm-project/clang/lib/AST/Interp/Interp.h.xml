<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/lib/AST/Interp/Interp.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_INTERP_INTERP_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_INTERP_INTERP_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Function.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"InterpFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"InterpStack.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"InterpState.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Opcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"PrimType.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Program.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"State.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTDiagnostic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/CXXInheritance.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/APFloat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/APSInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Endian.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>interp</name> <block>{<block_content>

<decl_stmt><decl><type><name>using</name></type> <name>APInt</name> <init>= <expr><name>llvm</name><operator>::</operator><name>APInt</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>APSInt</name> <init>= <expr><name>llvm</name><operator>::</operator><name>APSInt</name></expr></init></decl>;</decl_stmt>


<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>bool</name></type> <name>ReturnValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>V</name></decl></parameter>, <parameter><decl><type><name>APValue</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>R</name> <operator>=</operator> <call><name><name>V</name><operator>.</operator><name>toAPValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name>bool</name></type> <name>CheckExtern</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>CheckArray</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>CheckLive</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name></decl></parameter>,
<parameter><decl><type><name>AccessKinds</name></type> <name>AK</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckNull</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name></decl></parameter>,
<parameter><decl><type><name>CheckSubobjectKind</name></type> <name>CSK</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>CheckRange</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name></decl></parameter>,
<parameter><decl><type><name>AccessKinds</name></type> <name>AK</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>CheckRange</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name></decl></parameter>,
<parameter><decl><type><name>CheckSubobjectKind</name></type> <name>CSK</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>CheckConst</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>CheckMutable</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>CheckLoad</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>CheckStore</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>CheckInvoke</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>CheckInit</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>CheckCallable</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>Function</name> <modifier>*</modifier></type><name>F</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>CheckThis</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>This</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>CheckPure</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <specifier>inline</specifier> <name>bool</name></type> <name>IsTrue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>V</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>!</operator><call><name><name>V</name><operator>.</operator><name>isZero</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>





<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>bool</name> <operator>(</operator><operator>*</operator><name>OpFW</name><operator>)</operator><operator>(</operator><name>T</name>, <name>T</name>, <name>unsigned</name>, <name>T</name> <modifier>*</modifier><operator>)</operator></expr></argument>,
<argument><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>OpAP</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>AddSubMulHelper</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Bits</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>T</name></type> <name>Result</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OpFW</name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>, <argument><expr><name>Bits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr>;</expr_stmt>


<decl_stmt><decl><type><name>APSInt</name></type> <name>Value</name> <init>= <expr><call><call><name><name>OpAP</name><argument_list type="generic">&lt;<argument><expr><name>APSInt</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><argument_list>(<argument><expr><call><name><name>LHS</name><operator>.</operator><name>toAPSInt</name></name><argument_list>(<argument><expr><name>Bits</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>RHS</name><operator>.</operator><name>toAPSInt</name></name><argument_list>(<argument><expr><name>Bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name> <init>= <expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getExpr</name></name><argument_list>(<argument><expr><name>OpPC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>Type</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>checkingForUndefinedBehavior</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>SmallString</name><argument_list type="generic">&lt;<argument><expr><literal type="number">32</literal></expr></argument>&gt;</argument_list></name></type> <name>Trunc</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Value</name><operator>.</operator><name>trunc</name></name><argument_list>(<argument><expr><call><name><name>Result</name><operator>.</operator><name>bitWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>toString</name><argument_list>(<argument><expr><name>Trunc</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>auto</name></type> <name>Loc</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getExprLoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>report</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>warn_integer_constant_overflow</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>Trunc</name> <operator>&lt;&lt;</operator> <name>Type</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>CCEDiag</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>note_constexpr_overflow</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>Value</name> <operator>&lt;&lt;</operator> <name>Type</name></expr>;</expr_stmt>
<return>return <expr><call><name><name>S</name><operator>.</operator><name>noteUndefinedBehavior</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>Add</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>RHS</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>LHS</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>Bits</name> <init>= <expr><call><name><name>RHS</name><operator>.</operator><name>bitWidth</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>AddSubMulHelper</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>T</name><operator>::</operator><name>add</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>plus</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Bits</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>Sub</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>RHS</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>LHS</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>Bits</name> <init>= <expr><call><name><name>RHS</name><operator>.</operator><name>bitWidth</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>AddSubMulHelper</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>T</name><operator>::</operator><name>sub</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>minus</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Bits</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>Mul</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>RHS</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>LHS</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>Bits</name> <init>= <expr><call><name><name>RHS</name><operator>.</operator><name>bitWidth</name></name><argument_list>()</argument_list></call> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>AddSubMulHelper</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>T</name><operator>::</operator><name>mul</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>multiplies</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Bits</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<decl_stmt><decl><type><name>using</name></type> <name>CompareFn</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>bool</name><operator>(</operator><name>ComparisonCategoryResult</name><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>CmpHelper</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>CompareFn</name></type> <name>Fn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>using</name></type> <name>BoolT</name> <init>= <expr><name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>PT_Bool</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>RHS</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>LHS</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>BoolT</name><operator>&gt;</operator><operator>(</operator><name>BoolT</name><operator>::</operator><call><name>from</name><argument_list>(<argument><expr><call><name>Fn</name><argument_list>(<argument><expr><call><name><name>LHS</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>CmpHelperEQ</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>CompareFn</name></type> <name>Fn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>CmpHelper</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Fn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>bool</name></type> <name><name>CmpHelper</name><argument_list type="generic">&lt;<argument><expr><name>Pointer</name></expr></argument>&gt;</argument_list></name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>CompareFn</name></type> <name>Fn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>using</name></type> <name>BoolT</name> <init>= <expr><name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>PT_Bool</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>RHS</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>LHS</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Pointer</name><operator>::</operator><call><name>hasSameBase</name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>SourceInfo</name> <modifier>&amp;</modifier></type><name>Loc</name> <init>= <expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getSource</name></name><argument_list>(<argument><expr><name>OpPC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>FFDiag</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>note_invalid_subexpr_in_const_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>VL</name> <init>= <expr><call><name><name>LHS</name><operator>.</operator><name>getByteOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>VR</name> <init>= <expr><call><name><name>RHS</name><operator>.</operator><name>getByteOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>BoolT</name><operator>&gt;</operator><operator>(</operator><name>BoolT</name><operator>::</operator><call><name>from</name><argument_list>(<argument><expr><call><name>Fn</name><argument_list>(<argument><expr><call><name>Compare</name><argument_list>(<argument><expr><name>VL</name></expr></argument>, <argument><expr><name>VR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>bool</name></type> <name><name>CmpHelperEQ</name><argument_list type="generic">&lt;<argument><expr><name>Pointer</name></expr></argument>&gt;</argument_list></name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>CompareFn</name></type> <name>Fn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>using</name></type> <name>BoolT</name> <init>= <expr><name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>PT_Bool</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>RHS</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>LHS</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>LHS</name><operator>.</operator><name>isZero</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>RHS</name><operator>.</operator><name>isZero</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>BoolT</name><operator>&gt;</operator><operator>(</operator><name>BoolT</name><operator>::</operator><call><name>from</name><argument_list>(<argument><expr><call><name>Fn</name><argument_list>(<argument><expr><name>ComparisonCategoryResult</name><operator>::</operator><name>Equal</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Pointer</name><operator>::</operator><call><name>hasSameBase</name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>BoolT</name><operator>&gt;</operator><operator>(</operator><name>BoolT</name><operator>::</operator><call><name>from</name><argument_list>(<argument><expr><call><name>Fn</name><argument_list>(<argument><expr><name>ComparisonCategoryResult</name><operator>::</operator><name>Unordered</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>VL</name> <init>= <expr><call><name><name>LHS</name><operator>.</operator><name>getByteOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>VR</name> <init>= <expr><call><name><name>RHS</name><operator>.</operator><name>getByteOffset</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>BoolT</name><operator>&gt;</operator><operator>(</operator><name>BoolT</name><operator>::</operator><call><name>from</name><argument_list>(<argument><expr><call><name>Fn</name><argument_list>(<argument><expr><call><name>Compare</name><argument_list>(<argument><expr><name>VL</name></expr></argument>, <argument><expr><name>VR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>EQ</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>CmpHelperEQ</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><index>[]</index><operator>(</operator><name>ComparisonCategoryResult</name> <name>R</name><operator>)</operator> <block>{
<return>return <expr><name>R</name> <operator>==</operator> <name>ComparisonCategoryResult</name><operator>::</operator><name>Equal</name></expr>;</return>
}</block></expr></argument></argument_list></call></expr></return>)</block_content></block>;</function>
</block_content>}</block></decl></decl_stmt>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>NE</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>CmpHelperEQ</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><index>[]</index><operator>(</operator><name>ComparisonCategoryResult</name> <name>R</name><operator>)</operator> <block>{
<return>return <expr><name>R</name> <operator>!=</operator> <name>ComparisonCategoryResult</name><operator>::</operator><name>Equal</name></expr>;</return>
}</block></expr></argument></argument_list></call></expr></return>)</block_content></block>;</function>
</block_content>}</block></decl></decl_stmt>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>LT</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>CmpHelper</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><index>[]</index><operator>(</operator><name>ComparisonCategoryResult</name> <name>R</name><operator>)</operator> <block>{
<return>return <expr><name>R</name> <operator>==</operator> <name>ComparisonCategoryResult</name><operator>::</operator><name>Less</name></expr>;</return>
}</block></expr></argument></argument_list></call></expr></return>)</block_content></block>;</function>
}

template <expr_stmt><expr><operator>&lt;</operator><name>PrimType</name> <name>Name</name></expr><operator>,</operator> <expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name><operator>&gt;</operator>
<name>bool</name> <macro><name>LE</name><argument_list>(<argument>InterpState &amp;S</argument>, <argument>CodePtr OpPC</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>CmpHelper</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><index>[]</index><operator>(</operator><name>ComparisonCategoryResult</name> <name>R</name><operator>)</operator> <block>{
<return>return <expr><name>R</name> <operator>==</operator> <name>ComparisonCategoryResult</name><operator>::</operator><name>Less</name> <operator>||</operator>
<name>R</name> <operator>==</operator> <name>ComparisonCategoryResult</name><operator>::</operator><name>Equal</name></expr>;</return>
}</block></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>GT</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>CmpHelper</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><index>[]</index><operator>(</operator><name>ComparisonCategoryResult</name> <name>R</name><operator>)</operator> <block>{
<return>return <expr><name>R</name> <operator>==</operator> <name>ComparisonCategoryResult</name><operator>::</operator><name>Greater</name></expr>;</return>
}</block></expr></argument></argument_list></call></expr></return>)</block_content></block>;</function>
}

template <expr_stmt><expr><operator>&lt;</operator><name>PrimType</name> <name>Name</name></expr><operator>,</operator> <expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name><operator>&gt;</operator>
<name>bool</name> <macro><name>GE</name><argument_list>(<argument>InterpState &amp;S</argument>, <argument>CodePtr OpPC</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>CmpHelper</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><index>[]</index><operator>(</operator><name>ComparisonCategoryResult</name> <name>R</name><operator>)</operator> <block>{
<return>return <expr><name>R</name> <operator>==</operator> <name>ComparisonCategoryResult</name><operator>::</operator><name>Greater</name> <operator>||</operator>
<name>R</name> <operator>==</operator> <name>ComparisonCategoryResult</name><operator>::</operator><name>Equal</name></expr>;</return>
}</block></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>





<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>InRange</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name></type> <name>RHS</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name></type> <name>LHS</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name></type> <name>Value</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>bool</name><operator>&gt;</operator><operator>(</operator><name>LHS</name> <operator>&lt;=</operator> <name>Value</name> <operator>&amp;&amp;</operator> <name>Value</name> <operator>&lt;=</operator> <name>RHS</name><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>





<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>Dup</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>peek</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>Pop</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>





<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>Const</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>Arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>Arg</name><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>





<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>GetLocal</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getLocal</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>I</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>SetLocal</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>setLocal</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>I</name><operator>,</operator> <name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>GetParam</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>checkingPotentialConstantExpression</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getParam</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>I</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>SetParam</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>setParam</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>I</name><operator>,</operator> <name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>GetField</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Obj</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>peek</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckNull</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Obj</name></expr></argument>, <argument><expr><name>CSK_Field</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckRange</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Obj</name></expr></argument>, <argument><expr><name>CSK_Field</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Field</name> <init>= <expr><call><name><name>Obj</name><operator>.</operator><name>atField</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckLoad</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Field</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name><name>Field</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>SetField</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>Value</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Obj</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>peek</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckNull</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Obj</name></expr></argument>, <argument><expr><name>CSK_Field</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckRange</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Obj</name></expr></argument>, <argument><expr><name>CSK_Field</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Field</name> <init>= <expr><call><name><name>Obj</name><operator>.</operator><name>atField</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckStore</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Field</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>Field</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>=</operator> <name>Value</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>GetFieldPop</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Obj</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckNull</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Obj</name></expr></argument>, <argument><expr><name>CSK_Field</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckRange</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Obj</name></expr></argument>, <argument><expr><name>CSK_Field</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Field</name> <init>= <expr><call><name><name>Obj</name><operator>.</operator><name>atField</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckLoad</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Field</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name><name>Field</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>GetThisField</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>checkingPotentialConstantExpression</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>This</name> <init>= <expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getThis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckThis</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>This</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Field</name> <init>= <expr><call><name><name>This</name><operator>.</operator><name>atField</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckLoad</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Field</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name><name>Field</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>SetThisField</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>checkingPotentialConstantExpression</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>Value</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>This</name> <init>= <expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getThis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckThis</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>This</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Field</name> <init>= <expr><call><name><name>This</name><operator>.</operator><name>atField</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckStore</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Field</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>Field</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>=</operator> <name>Value</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>GetGlobal</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>B</name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>P</name><operator>.</operator><name>getGlobal</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>B</name><operator>-&gt;</operator><name>isExtern</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name><name>B</name><operator>-&gt;</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>SetGlobal</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>InitGlobal</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>P</name><operator>.</operator><name>getGlobal</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name><name>deref</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>=</operator> <name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>InitThisField</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>checkingPotentialConstantExpression</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>This</name> <init>= <expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getThis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckThis</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>This</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Field</name> <init>= <expr><call><name><name>This</name><operator>.</operator><name>atField</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Field</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>=</operator> <name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Field</name><operator>.</operator><name>initialize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>InitThisBitField</name><argument_list>(<argument><expr><name>InterpState</name> <operator>&amp;</operator><name>S</name></expr></argument>, <argument><expr><name>CodePtr</name> <name>OpPC</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Record</name><operator>::</operator><name>Field</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>checkingPotentialConstantExpression</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>This</name> <init>= <expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getThis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckThis</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>This</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Field</name> <init>= <expr><call><name><name>This</name><operator>.</operator><name>atField</name></name><argument_list>(<argument><expr><name><name>F</name><operator>-&gt;</operator><name>Offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>Value</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Field</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>=</operator> <call><name><name>Value</name><operator>.</operator><name>truncate</name></name><argument_list>(<argument><expr><call><name><name>F</name><operator>-&gt;</operator><name>Decl</name><operator>-&gt;</operator><name>getBitWidthValue</name></name><argument_list>(<argument><expr><call><name><name>S</name><operator>.</operator><name>getCtx</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Field</name><operator>.</operator><name>initialize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>InitThisFieldActive</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>checkingPotentialConstantExpression</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>This</name> <init>= <expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getThis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckThis</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>This</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Field</name> <init>= <expr><call><name><name>This</name><operator>.</operator><name>atField</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Field</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>=</operator> <name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Field</name><operator>.</operator><name>activate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Field</name><operator>.</operator><name>initialize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>InitField</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>Value</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Field</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>.</operator><call><name>atField</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Field</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>=</operator> <name>Value</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Field</name><operator>.</operator><name>activate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Field</name><operator>.</operator><name>initialize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>InitBitField</name><argument_list>(<argument><expr><name>InterpState</name> <operator>&amp;</operator><name>S</name></expr></argument>, <argument><expr><name>CodePtr</name> <name>OpPC</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Record</name><operator>::</operator><name>Field</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>Value</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Field</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>.</operator><call><name>atField</name><argument_list>(<argument><expr><name><name>F</name><operator>-&gt;</operator><name>Offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Field</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>=</operator> <call><name><name>Value</name><operator>.</operator><name>truncate</name></name><argument_list>(<argument><expr><call><name><name>F</name><operator>-&gt;</operator><name>Decl</name><operator>-&gt;</operator><name>getBitWidthValue</name></name><argument_list>(<argument><expr><call><name><name>S</name><operator>.</operator><name>getCtx</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Field</name><operator>.</operator><name>activate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Field</name><operator>.</operator><name>initialize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>InitFieldActive</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>Value</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Field</name> <init>= <expr><call><name><name>Ptr</name><operator>.</operator><name>atField</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Field</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>=</operator> <name>Value</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Field</name><operator>.</operator><name>activate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Field</name><operator>.</operator><name>initialize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>inline</specifier> <name>bool</name></type> <name>GetPtrLocal</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getLocalPointer</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>GetPtrParam</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>checkingPotentialConstantExpression</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getParamPointer</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>GetPtrGlobal</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><call><name><name>S</name><operator>.</operator><name>P</name><operator>.</operator><name>getPtrGlobal</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>GetPtrField</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Off</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckNull</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>, <argument><expr><name>CSK_Field</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckExtern</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckRange</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>, <argument><expr><name>CSK_Field</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><call><name><name>Ptr</name><operator>.</operator><name>atField</name></name><argument_list>(<argument><expr><name>Off</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>GetPtrThisField</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Off</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>checkingPotentialConstantExpression</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>This</name> <init>= <expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getThis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckThis</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>This</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><call><name><name>This</name><operator>.</operator><name>atField</name></name><argument_list>(<argument><expr><name>Off</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>GetPtrActiveField</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Off</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckNull</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>, <argument><expr><name>CSK_Field</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckRange</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>, <argument><expr><name>CSK_Field</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>Pointer</name></type> <name>Field</name> <init>= <expr><call><name><name>Ptr</name><operator>.</operator><name>atField</name></name><argument_list>(<argument><expr><name>Off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Ptr</name><operator>.</operator><name>deactivate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Field</name><operator>.</operator><name>activate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Field</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>GetPtrActiveThisField</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Off</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>checkingPotentialConstantExpression</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>This</name> <init>= <expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getThis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckThis</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>This</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>Pointer</name></type> <name>Field</name> <init>= <expr><call><name><name>This</name><operator>.</operator><name>atField</name></name><argument_list>(<argument><expr><name>Off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>This</name><operator>.</operator><name>deactivate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Field</name><operator>.</operator><name>activate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Field</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>GetPtrBase</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Off</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckNull</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>, <argument><expr><name>CSK_Base</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><call><name><name>Ptr</name><operator>.</operator><name>atField</name></name><argument_list>(<argument><expr><name>Off</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>GetPtrThisBase</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Off</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>checkingPotentialConstantExpression</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>This</name> <init>= <expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getThis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckThis</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>This</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><call><name><name>This</name><operator>.</operator><name>atField</name></name><argument_list>(<argument><expr><name>Off</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>VirtBaseHelper</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RecordDecl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>Pointer</name></type> <name>Base</name> <init>= <expr><name>Ptr</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name><name>Base</name><operator>.</operator><name>isBaseClass</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Base</name> <operator>=</operator> <call><name><name>Base</name><operator>.</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>auto</name> <operator>*</operator><name>Field</name> <operator>=</operator> <call><name><name>Base</name><operator>.</operator><name>getRecord</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getVirtualBase</name><argument_list>(<argument><expr><name>Decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><call><name><name>Base</name><operator>.</operator><name>atField</name></name><argument_list>(<argument><expr><name><name>Field</name><operator>-&gt;</operator><name>Offset</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>GetPtrVirtBase</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RecordDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckNull</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>, <argument><expr><name>CSK_Base</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>VirtBaseHelper</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>D</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>GetPtrThisVirtBase</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RecordDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>checkingPotentialConstantExpression</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>This</name> <init>= <expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getThis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckThis</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>This</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>VirtBaseHelper</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>D</name></expr></argument>, <argument><expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getThis</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>Load</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>peek</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckLoad</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name><name>Ptr</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>LoadPop</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckLoad</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name><name>Ptr</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>Store</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>Value</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>peek</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckStore</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>Ptr</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>=</operator> <name>Value</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>StorePop</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>Value</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckStore</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>Ptr</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>=</operator> <name>Value</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>StoreBitField</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>Value</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>peek</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckStore</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>FD</name> <operator>=</operator> <call><name><name>Ptr</name><operator>.</operator><name>getField</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>Ptr</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>=</operator> <call><name><name>Value</name><operator>.</operator><name>truncate</name></name><argument_list>(<argument><expr><call><name><name>FD</name><operator>-&gt;</operator><name>getBitWidthValue</name></name><argument_list>(<argument><expr><call><name><name>S</name><operator>.</operator><name>getCtx</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>Ptr</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>=</operator> <name>Value</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>StoreBitFieldPop</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>Value</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckStore</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>FD</name> <operator>=</operator> <call><name><name>Ptr</name><operator>.</operator><name>getField</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>Ptr</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>=</operator> <call><name><name>Value</name><operator>.</operator><name>truncate</name></name><argument_list>(<argument><expr><call><name><name>FD</name><operator>-&gt;</operator><name>getBitWidthValue</name></name><argument_list>(<argument><expr><call><name><name>S</name><operator>.</operator><name>getCtx</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>Ptr</name><operator>.</operator><name>deref</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>=</operator> <name>Value</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>InitPop</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>Value</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckInit</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Ptr</name><operator>.</operator><name>initialize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<macro><name>new</name> <argument_list>(<argument>&amp;Ptr.deref&lt;T&gt;()</argument>)</argument_list></macro> <expr_stmt><expr><call><name>T</name><argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>InitElem</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>Value</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>peek</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>.</operator><call><name>atIndex</name><argument_list>(<argument><expr><name>Idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckInit</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Ptr</name><operator>.</operator><name>initialize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<macro><name>new</name> <argument_list>(<argument>&amp;Ptr.deref&lt;T&gt;()</argument>)</argument_list></macro> <expr_stmt><expr><call><name>T</name><argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>InitElemPop</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>Idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>Value</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>.</operator><call><name>atIndex</name><argument_list>(<argument><expr><name>Idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckInit</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Ptr</name><operator>.</operator><name>initialize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<macro><name>new</name> <argument_list>(<argument>&amp;Ptr.deref&lt;T&gt;()</argument>)</argument_list></macro> <expr_stmt><expr><call><name>T</name><argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>





<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>, <argument><expr><name>bool</name> <name>Add</name></expr></argument>&gt;</argument_list></name> <name>bool</name></type> <name>OffsetHelper</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>Offset</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckNull</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>, <argument><expr><name>CSK_ArrayIndex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckRange</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>, <argument><expr><name>CSK_ArrayToPointer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>T</name></type> <name>Index</name> <init>= <expr><name>T</name><operator>::</operator><call><name>from</name><argument_list>(<argument><expr><call><name><name>Ptr</name><operator>.</operator><name>getIndex</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Offset</name><operator>.</operator><name>bitWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>Offset</name><operator>.</operator><name>isZero</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><ternary><condition><expr><call><name><name>Index</name><operator>.</operator><name>isZero</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>Ptr</name><operator>.</operator><name>atIndex</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>Ptr</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckArray</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>MaxIndex</name> <init>= <expr><call><name><name>Ptr</name><operator>.</operator><name>getNumElems</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>auto</name></type> <name>InvalidOffset</name> <init>= <expr><index>[<expr><operator>&amp;</operator></expr>]</index><operator>(</operator><operator>)</operator> <block>{
<expr><specifier>const</specifier> <name>unsigned</name> <name>Bits</name> <operator>=</operator> <call><name><name>Offset</name><operator>.</operator><name>bitWidth</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>APSInt</name> <call><name>APOffset</name><argument_list>(<argument><expr><call><name><name>Offset</name><operator>.</operator><name>toAPSInt</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>extend</name><argument_list>(<argument><expr><name>Bits</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;
<expr><name>APSInt</name> <call><name>APIndex</name><argument_list>(<argument><expr><call><name><name>Index</name><operator>.</operator><name>toAPSInt</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>extend</name><argument_list>(<argument><expr><name>Bits</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;
<expr><name>APSInt</name> <name>NewIndex</name> <operator>=</operator> <ternary><condition><expr><name>Add</name></expr> ?</condition><then> <expr><operator>(</operator><name>APIndex</name> <operator>+</operator> <name>APOffset</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>APIndex</name> <operator>-</operator> <name>APOffset</name><operator>)</operator></expr></else></ternary></expr>;
<expr><call><name><name>S</name><operator>.</operator><name>CCEDiag</name></name><argument_list>(<argument><expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getSource</name></name><argument_list>(<argument><expr><name>OpPC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>note_constexpr_array_index</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <name>NewIndex</name>
<operator>&lt;&lt;</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>!</operator><call><name><name>Ptr</name><operator>.</operator><name>inArray</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>MaxIndex</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>false</name></expr>;</return>
}</block></expr></init></decl></decl_stmt><empty_stmt>;</empty_stmt>


<if_stmt><if>if <condition>(<expr><name>Add</name> <operator>&amp;&amp;</operator> <call><name><name>Offset</name><operator>.</operator><name>isNegative</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>Offset</name><operator>.</operator><name>isMin</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>-</operator><name>Offset</name> <operator>&gt;</operator> <name>Index</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>InvalidOffset</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Add</name> <operator>&amp;&amp;</operator> <call><name><name>Offset</name><operator>.</operator><name>isPositive</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>Index</name> <operator>&lt;</operator> <name>Offset</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>InvalidOffset</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>MaxOffset</name> <init>= <expr><name>MaxIndex</name> <operator>-</operator> <call><name><name>Ptr</name><operator>.</operator><name>getIndex</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>Add</name> <operator>&amp;&amp;</operator> <call><name><name>Offset</name><operator>.</operator><name>isPositive</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>Offset</name> <operator>&gt;</operator> <name>MaxOffset</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>InvalidOffset</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Add</name> <operator>&amp;&amp;</operator> <call><name><name>Offset</name><operator>.</operator><name>isNegative</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>Offset</name><operator>.</operator><name>isMin</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>-</operator><name>Offset</name> <operator>&gt;</operator> <name>MaxOffset</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>InvalidOffset</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>int64_t</name></type> <name>WideIndex</name> <init>= <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>WideOffset</name> <init>= <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>Result</name> <init>= <expr><ternary><condition><expr><name>Add</name></expr> ?</condition><then> <expr><operator>(</operator><name>WideIndex</name> <operator>+</operator> <name>WideOffset</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>WideIndex</name> <operator>-</operator> <name>WideOffset</name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><call><name><name>Ptr</name><operator>.</operator><name>atIndex</name></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>AddOffset</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>OffsetHelper</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>true</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>SubOffset</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>OffsetHelper</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>false</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>inline</specifier> <name>bool</name></type> <name>Destroy</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>destroy</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>





<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>TIn</name></expr></argument>, <argument><expr><name>PrimType</name> <name>TOut</name></expr></argument>&gt;</argument_list></name> <name>bool</name></type> <name>Cast</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>using</name></type> <name>T</name> <init>= <expr><name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>TIn</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>U</name> <init>= <expr><name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>TOut</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>U</name><operator>&gt;</operator><operator>(</operator><name>U</name><operator>::</operator><call><name>from</name><argument_list>(<argument><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>





<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>Zero</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>T</name><operator>::</operator><call><name>zero</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>Name</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>Name</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>bool</name></type> <name>Null</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>inline</specifier> <name>bool</name></type> <name>This</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>.</operator><name>checkingPotentialConstantExpression</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>This</name> <init>= <expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getThis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CheckThis</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>This</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><name>This</name><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>





<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>TR</name></expr></argument>, <argument><expr><name>PrimType</name> <name>TL</name></expr></argument>, <argument><expr><name>class</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>TR</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<name>unsigned</name></type> <name>Trunc</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Bits</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>V</name></decl></parameter>)</parameter_list> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>Bits</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>V</name> <operator>&gt;=</operator> <name>T</name><operator>::</operator><call><name>from</name><argument_list>(<argument><expr><name>Bits</name></expr></argument>, <argument><expr><call><name><name>V</name><operator>.</operator><name>bitWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name> <init>= <expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getExpr</name></name><argument_list>(<argument><expr><name>OpPC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>APSInt</name></type> <name>Val</name> <init>= <expr><call><name><name>V</name><operator>.</operator><name>toAPSInt</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>Ty</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>CCEDiag</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>note_constexpr_large_shift</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>Val</name> <operator>&lt;&lt;</operator> <name>Ty</name> <operator>&lt;&lt;</operator> <name>Bits</name></expr>;</expr_stmt>
<return>return <expr><name>Bits</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>TL</name></expr></argument>, <argument><expr><name>PrimType</name> <name>TR</name></expr></argument>, <argument><expr><name>typename</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>TL</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>bool</name></type> <name>ShiftRight</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>V</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>RHS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>RHS</name> <operator>&gt;=</operator> <call><name><name>V</name><operator>.</operator><name>bitWidth</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>T</name><operator>::</operator><call><name>from</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>V</name><operator>.</operator><name>bitWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>T</name><operator>::</operator><call><name>from</name><argument_list>(<argument><expr><name>V</name> <operator>&gt;&gt;</operator> <name>RHS</name></expr></argument>, <argument><expr><call><name><name>V</name><operator>.</operator><name>bitWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>TL</name></expr></argument>, <argument><expr><name>PrimType</name> <name>TR</name></expr></argument>, <argument><expr><name>typename</name> <name>T</name> <operator>=</operator> <name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>TL</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>bool</name></type> <name>ShiftLeft</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>V</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>RHS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>V</name><operator>.</operator><name>isSigned</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>S</name><operator>.</operator><name>getLangOpts</name></name><argument_list>()</argument_list></call><operator>.</operator><name>CPlusPlus20</name></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name><name>V</name><operator>.</operator><name>isNegative</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name> <init>= <expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getExpr</name></name><argument_list>(<argument><expr><name>OpPC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>CCEDiag</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>note_constexpr_lshift_of_negative</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <call><name><name>V</name><operator>.</operator><name>toAPSInt</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>V</name><operator>.</operator><name>countLeadingZeros</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>RHS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>CCEDiag</name></name><argument_list>(<argument><expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getExpr</name></name><argument_list>(<argument><expr><name>OpPC</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>note_constexpr_lshift_discards</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>V</name><operator>.</operator><name>bitWidth</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>V</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>RHS</name> <operator>&gt;=</operator> <call><name><name>V</name><operator>.</operator><name>bitWidth</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>T</name><operator>::</operator><call><name>from</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>V</name><operator>.</operator><name>bitWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>T</name><operator>::</operator><call><name>from</name><argument_list>(<argument><expr><call><name><name>V</name><operator>.</operator><name>toUnsigned</name></name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <name>RHS</name></expr></argument>, <argument><expr><call><name><name>V</name><operator>.</operator><name>bitWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>TL</name></expr></argument>, <argument><expr><name>PrimType</name> <name>TR</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>bool</name></type> <name>Shr</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>RHS</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>TR</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>LHS</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>TL</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>Bits</name> <init>= <expr><call><name><name>LHS</name><operator>.</operator><name>bitWidth</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>RHS</name><operator>.</operator><name>isSigned</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>RHS</name><operator>.</operator><name>isNegative</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>SourceInfo</name> <modifier>&amp;</modifier></type><name>Loc</name> <init>= <expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getSource</name></name><argument_list>(<argument><expr><name>OpPC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>CCEDiag</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>note_constexpr_negative_shift</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <call><name><name>RHS</name><operator>.</operator><name>toAPSInt</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>ShiftLeft</name><argument_list type="generic">&lt;<argument><expr><name>TL</name></expr></argument>, <argument><expr><name>TR</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><call><name><name>Trunc</name><argument_list type="generic">&lt;<argument><expr><name>TR</name></expr></argument>, <argument><expr><name>TL</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Bits</name></expr></argument>, <argument><expr><operator>-</operator><name>RHS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><call><name><name>ShiftRight</name><argument_list type="generic">&lt;<argument><expr><name>TL</name></expr></argument>, <argument><expr><name>TR</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><call><name><name>Trunc</name><argument_list type="generic">&lt;<argument><expr><name>TR</name></expr></argument>, <argument><expr><name>TL</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Bits</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>PrimType</name> <name>TL</name></expr></argument>, <argument><expr><name>PrimType</name> <name>TR</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>bool</name></type> <name>Shl</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>RHS</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>TR</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>LHS</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>typename</name> <name><name>PrimConv</name><argument_list type="generic">&lt;<argument><expr><name>TL</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>Bits</name> <init>= <expr><call><name><name>LHS</name><operator>.</operator><name>bitWidth</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>RHS</name><operator>.</operator><name>isSigned</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>RHS</name><operator>.</operator><name>isNegative</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>SourceInfo</name> <modifier>&amp;</modifier></type><name>Loc</name> <init>= <expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getSource</name></name><argument_list>(<argument><expr><name>OpPC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>CCEDiag</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>note_constexpr_negative_shift</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <call><name><name>RHS</name><operator>.</operator><name>toAPSInt</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>ShiftRight</name><argument_list type="generic">&lt;<argument><expr><name>TL</name></expr></argument>, <argument><expr><name>TR</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><call><name><name>Trunc</name><argument_list type="generic">&lt;<argument><expr><name>TR</name></expr></argument>, <argument><expr><name>TL</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Bits</name></expr></argument>, <argument><expr><operator>-</operator><name>RHS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><call><name><name>ShiftLeft</name><argument_list type="generic">&lt;<argument><expr><name>TL</name></expr></argument>, <argument><expr><name>TR</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><call><name><name>Trunc</name><argument_list type="generic">&lt;<argument><expr><name>TR</name></expr></argument>, <argument><expr><name>TL</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>OpPC</name></expr></argument>, <argument><expr><name>Bits</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>





<function><type><specifier>inline</specifier> <name>bool</name></type> <name>NoRet</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>EndLoc</name> <init>= <expr><call><name><name>S</name><operator>.</operator><name>Current</name><operator>-&gt;</operator><name>getCallee</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>FFDiag</name></name><argument_list>(<argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>note_constexpr_no_return</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>inline</specifier> <name>bool</name></type> <name>NarrowPtr</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><call><name><name>Ptr</name><operator>.</operator><name>narrow</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>ExpandPtr</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CodePtr</name></type> <name>OpPC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Pointer</name> <modifier>&amp;</modifier></type><name>Ptr</name> <init>= <expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>pop</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>Stk</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><call><name><name>Ptr</name><operator>.</operator><name>expand</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name>bool</name></type> <name>Interpret</name><parameter_list>(<parameter><decl><type><name>InterpState</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>APValue</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>)</parameter_list>;</function_decl>

}
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
