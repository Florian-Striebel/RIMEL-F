<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_LIB_CODEGEN_CGOPENMPRUNTIME_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_LIB_CODEGEN_CGOPENMPRUNTIME_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"CGValue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclOpenMP.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/GlobalDecl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenMPKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerIntPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallPtrSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Frontend/OpenMP/OMPConstants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Frontend/OpenMP/OMPIRBuilder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/IR/Function.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/IR/ValueHandle.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/AtomicOrdering.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>ArrayType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Constant</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>GlobalVariable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>StructType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>OpenMPIRBuilder</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>OMPDependClause</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>OMPExecutableDirective</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>OMPLoopDirective</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VarDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>OMPDeclareReductionDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>IdentifierInfo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>CodeGen</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>Address</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CodeGenFunction</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CodeGenModule</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>PrePostActionTy</name> <block>{<block_content>
<label><name>public</name>:</label>
<function><type><name>explicit</name></type> <name>PrePostActionTy</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>
<function><type><name>virtual</name> <name>void</name></type> <name>Enter</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>
<function><type><name>virtual</name> <name>void</name></type> <name>Exit</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><macro><name>PrePostActionTy</name><argument_list>()</argument_list></macro> <block>{}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name> <name>RegionCodeGenTy</name></type> <name>final</name> <block>{<block_content>
<decl_stmt><decl><type><name>intptr_t</name></type> <name>CodeGen</name></decl>;</decl_stmt>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>CodeGenTy</name>)<parameter_list>(<parameter><decl><type><name>intptr_t</name></type></decl></parameter>, <parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type></decl></parameter>, <parameter><decl><type><name>PrePostActionTy</name> <modifier>&amp;</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<decl_stmt><decl><type><name>CodeGenTy</name></type> <name>Callback</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mutable</name> <name>PrePostActionTy</name> <modifier>*</modifier></type><name>PrePostAction</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>RegionCodeGenTy</name><argument_list>()</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Callable</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>void</name></type> <name>CallbackFn</name><parameter_list>(<parameter><decl><type><name>intptr_t</name></type> <name>CodeGen</name></decl></parameter>, <parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><name>PrePostActionTy</name> <modifier>&amp;</modifier></type><name>Action</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>(</operator><operator>*</operator><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Callable</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CodeGen</name></expr></argument>)</argument_list></call><operator>)</operator><operator>(</operator><name>CGF</name><operator>,</operator> <name>Action</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Callable</name></expr></argument>&gt;</argument_list></name></type>
<name>RegionCodeGenTy</name><argument_list>(
<argument><expr><name>Callable</name> <operator>&amp;&amp;</operator><name>CodeGen</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>enable_if_t</name><argument_list type="generic">&lt;<argument><expr><operator>!</operator><name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>remove_reference_t</name><argument_list type="generic">&lt;<argument><expr><name>Callable</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>RegionCodeGenTy</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name> <operator>*</operator> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list>
<range>: <expr><call><name>CodeGen</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>intptr_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>CodeGen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></range></decl>,
<decl><type ref="prev"/><name>Callback</name><argument_list>(<argument><expr><name><name>CallbackFn</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>remove_reference_t</name><argument_list type="generic">&lt;<argument><expr><name>Callable</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></argument>)</argument_list></decl>,
<decl><type ref="prev"/><name>PrePostAction</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list> <block>{<block_content/>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>setAction</name><argument_list>(<argument><expr><name>PrePostActionTy</name> <operator>&amp;</operator><name>Action</name></expr></argument>)</argument_list> const <block>{<block_content> <expr_stmt><expr><name>PrePostAction</name> <operator>=</operator> <operator>&amp;</operator><name>Action</name></expr>;</expr_stmt> </block_content>}</block></decl></decl_stmt>
<expr_stmt><expr><name>void</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name><operator>)</operator> <specifier>const</specifier></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<struct>struct <macro><name>OMPTaskDataTy</name></macro> <name>final</name> <block>{
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>PrivateVars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>PrivateCopies</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>FirstprivateVars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>FirstprivateCopies</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>FirstprivateInits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>LastprivateVars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>LastprivateCopies</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>ReductionVars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>ReductionOrigs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>ReductionCopies</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>ReductionOps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name><name>CanonicalDeclPtr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>PrivateLocals</name></decl>;</decl_stmt>
<struct>struct <name>DependData</name> <block>{
<decl_stmt><decl><type><name>OpenMPDependClauseKind</name></type> <name>DepKind</name> <init>= <expr><name>OMPC_DEPEND_unknown</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>IteratorExpr</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>DepExprs</name></decl>;</decl_stmt>
<function_decl><type><name>explicit</name></type> <name>DependData</name><parameter_list>()</parameter_list> <init>= <expr/>default</init>;</function_decl>
<macro><name>DependData</name><argument_list>(<argument>OpenMPDependClauseKind DepKind</argument>, <argument>const Expr *IteratorExpr</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>DepKind</name><argument_list>(<argument><expr><name>DepKind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>IteratorExpr</name><argument_list>(<argument>IteratorExpr</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>DependData</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>Dependences</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>Final</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>Schedule</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>Priority</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Reductions</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumberOfParts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Tied</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Nogroup</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>IsReductionWithTaskMod</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>IsWorksharingReduction</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
}</block>;</struct>


<decl_stmt><decl><type><name>class</name></type> <name>ReductionCodeGen</name> <block>{<block_content>
<label><name>private</name>:</label>

<struct>struct <name>ReductionData</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Shared</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Ref</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Private</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>ReductionOp</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ReductionData</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>Shared</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>Ref</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>Private</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>ReductionOp</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Shared</name><argument_list>(<argument><expr><name>Shared</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Ref</name><argument_list>(<argument><expr><name>Ref</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Private</name><argument_list>(<argument><expr><name>Private</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>ReductionOp</name><argument_list>(<argument>ReductionOp</argument>)</argument_list></macro> <expr><block>{
}</block></expr></expr_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ReductionData</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>ClausesData</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>LValue</name></expr></argument>, <argument><expr><name>LValue</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>SharedAddresses</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>LValue</name></expr></argument>, <argument><expr><name>LValue</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>OrigAddresses</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <modifier>*</modifier></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>Sizes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>BaseDecls</name></decl>;</decl_stmt>


<function_decl><type><name>LValue</name></type> <name>emitSharedLValue</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>LValue</name></type> <name>emitSharedLValueUB</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type> <name>emitAggregateInitialization</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>N</name></decl></parameter>,
<parameter><decl><type><name>Address</name></type> <name>PrivateAddr</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>SharedLVal</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPDeclareReductionDecl</name> <modifier>*</modifier></type><name>DRD</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>ReductionCodeGen</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Shareds</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Origs</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Privates</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ReductionOps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function_decl><type><name>void</name></type> <name>emitSharedOrigLValue</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>N</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>emitAggregateType</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>N</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>void</name></type> <name>emitAggregateType</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><name>unsigned</name> <name>N</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Size</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<decl_stmt><decl><type><name>void</name></type>
<name>emitInitialization</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><name>unsigned</name> <name>N</name></expr></argument>, <argument><expr><name>Address</name> <name>PrivateAddr</name></expr></argument>,
<argument><expr><name>LValue</name> <name>SharedLVal</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>bool</name><operator>(</operator><name>CodeGenFunction</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>DefaultInit</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>bool</name></type> <name>needCleanups</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>N</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>emitCleanups</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>N</name></decl></parameter>, <parameter><decl><type><name>Address</name></type> <name>PrivateAddr</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>Address</name></type> <name>adjustPrivateAddress</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>N</name></decl></parameter>,
<parameter><decl><type><name>Address</name></type> <name>PrivateAddr</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>LValue</name></type> <name>getSharedLValue</name><argument_list>(<argument><expr><name>unsigned</name> <name>N</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><name><name>SharedAddresses</name><index>[<expr><name>N</name></expr>]</index></name><operator>.</operator><name>first</name></expr>;</return> </block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>LValue</name></type> <name>getOrigLValue</name><argument_list>(<argument><expr><name>unsigned</name> <name>N</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><name><name>OrigAddresses</name><index>[<expr><name>N</name></expr>]</index></name><operator>.</operator><name>first</name></expr>;</return> </block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getSizes</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Sizes</name><index>[<expr><name>N</name></expr>]</index></name></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>getBaseDecl</name><argument_list>(<argument><expr><name>unsigned</name> <name>N</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><name><name>BaseDecls</name><index>[<expr><name>N</name></expr>]</index></name></expr>;</return> </block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>getRefExpr</name><argument_list>(<argument><expr><name>unsigned</name> <name>N</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><name><name>ClausesData</name><index>[<expr><name>N</name></expr>]</index></name><operator>.</operator><name>Ref</name></expr>;</return> </block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>usesReductionInitializer</name><argument_list>(<argument><expr><name>unsigned</name> <name>N</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CGOpenMPRuntime</name> <block>{<block_content>
<label><name>public</name>:</label>


<decl_stmt><decl><type><name>class</name></type> <name>DisableAutoDeclareTargetRAII</name> <block>{<block_content>
<decl_stmt><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>SavedShouldMarkAsGlobal</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>DisableAutoDeclareTargetRAII</name><argument_list>(<argument><expr><name>CodeGenModule</name> <operator>&amp;</operator><name>CGM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>~</operator><call><name>DisableAutoDeclareTargetRAII</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>NontemporalDeclsRAII</name> <block>{<block_content>
<decl_stmt><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>NeedToPush</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>NontemporalDeclsRAII</name><argument_list>(<argument><expr><name>CodeGenModule</name> <operator>&amp;</operator><name>CGM</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>OMPLoopDirective</name> <operator>&amp;</operator><name>S</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>~</operator><call><name>NontemporalDeclsRAII</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>UntiedTaskLocalDeclsRAII</name> <block>{<block_content>
<decl_stmt><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>NeedToPush</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>UntiedTaskLocalDeclsRAII</name><argument_list>(
<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name><name>CanonicalDeclPtr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>Address</name></expr></argument>, <argument><expr><name>Address</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>LocalVars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>~</operator><call><name>UntiedTaskLocalDeclsRAII</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>







<struct>struct <name>LastprivateConditionalData</name> <block>{
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name><name>CanonicalDeclPtr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name><name>SmallString</name><argument_list type="generic">&lt;<argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>DeclToUniqueName</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>LValue</name></type> <name>IVLVal</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Fn</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Disabled</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name>class</name></type> <name>LastprivateConditionalRAII</name> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>ActionToDo</name> <block>{<block_content>
<expr_stmt><expr><name>DoNotPush</name></expr><operator>,</operator>
<expr><name>PushAsLastprivateConditional</name></expr><operator>,</operator>
<expr><name>DisableLastprivateConditional</name></expr><operator>,</operator></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<decl_stmt><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ActionToDo</name></type> <name>Action</name> <init>= <expr><name>ActionToDo</name><operator>::</operator><name>DoNotPush</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>tryToDisableInnerAnalysis</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPExecutableDirective</name> <operator>&amp;</operator><name>S</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>DenseSet</name><argument_list type="generic">&lt;<argument><expr><name><name>CanonicalDeclPtr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<operator>&amp;</operator><name>NeedToAddForLPCsAsDisabled</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><call><name>LastprivateConditionalRAII</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPExecutableDirective</name> <operator>&amp;</operator><name>S</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>public</name>:</label>
<function_decl><type><name>explicit</name></type> <name>LastprivateConditionalRAII</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>LValue</name></type> <name>IVLVal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>LastprivateConditionalRAII</name></type> <name>disable</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><operator>~</operator><call><name>LastprivateConditionalRAII</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>OpenMPIRBuilder</name> <operator>&amp;</operator><macro><name>getOMPBuilder</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>OMPBuilder</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>protected</name>:</label>
<decl_stmt><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StringRef</name></type> <name>FirstSeparator</name></decl>, <decl><type ref="prev"/><name>Separator</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>OpenMPIRBuilder</name> <name>OMPBuilder</name></expr>;</expr_stmt>


<function_decl><type><name>explicit</name></type> <name>CGOpenMPRuntime</name><parameter_list>(<parameter><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>FirstSeparator</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Separator</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>createOffloadEntry</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>ID</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>Addr</name></expr></argument>,
<argument><expr><name>uint64_t</name> <name>Size</name></expr></argument>, <argument><expr><name>int32_t</name> <name>Flags</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name><operator>::</operator><name>LinkageTypes</name> <name>Linkage</name></expr></argument>)</argument_list></decl>;</decl_stmt>










<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>emitTargetOutlinedFunctionHelper</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPExecutableDirective</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><name>StringRef</name> <name>ParentName</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><operator>&amp;</operator><name>OutlinedFn</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><operator>&amp;</operator><name>OutlinedFnID</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsOffloadEntry</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>RegionCodeGenTy</name> <operator>&amp;</operator><name>CodeGen</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>emitUpdateLocation</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>unsigned Flags = <literal type="number">0</literal></argument>)</argument_list></macro></expr>;</expr_stmt>









<function_decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>getNumTeamsExprForTargetDirective</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>int32_t</name> <modifier>&amp;</modifier></type><name>DefaultVal</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>emitNumTeamsForTargetDirective</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPExecutableDirective</name> <operator>&amp;</operator><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>








<function_decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>getNumThreadsExprForTargetDirective</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>int32_t</name> <modifier>&amp;</modifier></type><name>DefaultVal</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator>
<call><name>emitNumThreadsForTargetDirective</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPExecutableDirective</name> <operator>&amp;</operator><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><call><name>getIdentTyPointerTy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>getThreadID</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;</expr_stmt>




<expr_stmt><expr><name>virtual</name> <name>StringRef</name> <macro><name>getOutlinedHelperName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><literal type="string">".omp_outlined."</literal></expr>;</return> }</block></expr></expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>emitCall</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>Callee</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Args</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name>None</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<function_decl><type><name>virtual</name> <name>Address</name></type> <name>emitThreadIDAddress</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>setLocThreadIdInsertPt</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AtCurrentPoint</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>clearLocThreadIdInsertPt</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>isDefaultLocationConstant</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>virtual</name> <name>unsigned</name> <macro><name>getDefaultLocationReserved2Flags</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>



<function_decl><type><specifier>static</specifier> <name>unsigned</name></type> <name>getDefaultFlagsForBarriers</name><parameter_list>(<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>Kind</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>ArrayType</name> <operator>*</operator><macro><name>getKmpCriticalNameTy</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{<return>return <expr><name>KmpCriticalNameTy</name></expr>;</return>}</block></expr></expr_stmt>






<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>getCriticalRegionLock</name><argument_list>(<argument>StringRef CriticalName</argument>)</argument_list></macro></expr>;</expr_stmt>

<label><name>private</name>:</label>


<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>OpenMPDebugLocMapTy</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>OpenMPDebugLocMapTy</name></type> <name>OpenMPDebugLocMap</name></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionType</name> <operator>*</operator><name>Kmpc_MicroTy</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<struct>struct <name>DebugLocThreadIdTy</name> <block>{
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>DebugLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>ThreadID</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>AssertingVH</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Instruction</name></expr></argument>&gt;</argument_list></name> <name>ServiceInsertPt</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
}</block>;</struct>

<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator></expr></argument>, <argument><expr><name>DebugLocThreadIdTy</name></expr></argument>&gt;</argument_list></name>
<name>OpenMPLocThreadIDMapTy</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>OpenMPLocThreadIDMapTy</name></type> <name>OpenMPLocThreadIDMap</name></decl>;</decl_stmt>

<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>OMPDeclareReductionDecl</name> <operator>*</operator></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>UDRMapTy</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>UDRMapTy</name></type> <name>UDRMap</name></decl>;</decl_stmt>

<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator></expr></argument>,
<argument><expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>OMPDeclareReductionDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>FunctionUDRMapTy</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>FunctionUDRMapTy</name></type> <name>FunctionUDRMap</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>OMPDeclareMapperDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>UDMMap</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>FunctionUDMMapTy</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator></expr></argument>,
<argument><expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>OMPDeclareMapperDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FunctionUDMMapTy</name></type> <name>FunctionUDMMap</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name><name>CanonicalDeclPtr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>LValue</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>LastprivateConditionalToTypes</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>FunctionToUntiedTaskStackMap</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>ArrayType</name> <operator>*</operator><name>KmpCriticalNameTy</name></expr>;</expr_stmt>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name><name>AssertingVH</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name></expr></argument>&gt;</argument_list></name>
<name>InternalVars</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>KmpRoutineEntryPtrTy</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>KmpRoutineEntryPtrQTy</name></decl>;</decl_stmt>









<decl_stmt><decl><type><name>QualType</name></type> <name>KmpTaskTQTy</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>SavedKmpTaskTQTy</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>SavedKmpTaskloopTQTy</name></decl>;</decl_stmt>








<decl_stmt><decl><type><name>QualType</name></type> <name>KmpDependInfoTy</name></decl>;</decl_stmt>









<decl_stmt><decl><type><name>QualType</name></type> <name>KmpTaskAffinityInfoTy</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>QualType</name></type> <name>KmpDimTy</name></decl>;</decl_stmt>








<decl_stmt><decl><type><name>QualType</name></type> <name>TgtOffloadEntryQTy</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>OffloadEntriesInfoManagerTy</name> <block>{<block_content>
<decl_stmt><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>OffloadingEntriesNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>

<decl_stmt><decl><type><name>class</name></type> <name>OffloadEntryInfo</name> <block>{<block_content>
<label><name>public</name>:</label>

<enum>enum <name>OffloadingEntryInfoKinds</name> : <type><name>unsigned</name></type> <block>{

<decl><name>OffloadingEntryInfoTargetRegion</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,

<decl><name>OffloadingEntryInfoDeviceGlobalVar</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,

<decl><name>OffloadingEntryInfoInvalid</name> <init>= <expr><operator>~</operator><literal type="number">0u</literal></expr></init></decl>
}</block>;</enum>

<label><name>protected</name>:</label>
<expr_stmt><expr><call><name>OffloadEntryInfo</name><argument_list>()</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<macro><name>explicit</name></macro> <macro><name>OffloadEntryInfo</name><argument_list>(<argument>OffloadingEntryInfoKinds Kind</argument>)</argument_list></macro> : <macro><name>Kind</name><argument_list>(<argument>Kind</argument>)</argument_list></macro> <block>{<block_content/>}</block>
<macro><name>explicit</name></macro> <macro><name>OffloadEntryInfo</name><argument_list>(<argument>OffloadingEntryInfoKinds Kind</argument>, <argument>unsigned Order</argument>,
<argument>uint32_t Flags</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Flags</name><argument_list>(<argument><expr><name>Flags</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Order</name><argument_list>(<argument><expr><name>Order</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Kind</name><argument_list>(<argument>Kind</argument>)</argument_list></macro> <expr><block>{}</block>
<operator>~</operator><call><name>OffloadEntryInfo</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><name>bool</name> <macro><name>isValid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Order</name> <operator>!=</operator> <operator>~</operator><literal type="number">0u</literal></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getOrder</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Order</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>OffloadingEntryInfoKinds</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>uint32_t</name> <macro><name>getFlags</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Flags</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setFlags</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>NewFlags</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Flags</name> <operator>=</operator> <name>NewFlags</name></expr>;</expr_stmt> </block_content>}</block></function>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>getAddress</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Addr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>setAddress</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>V</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>Addr</name><operator>.</operator><name>pointsToAliveValue</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Address has been set before!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Addr</name> <operator>=</operator> <name>V</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OffloadEntryInfo</name> <modifier>*</modifier></type><name>Info</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>true</name></expr>;</return> </block_content>}</block></function>

<label><name>private</name>:</label>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>WeakTrackingVH</name> <name>Addr</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>uint32_t</name></type> <name>Flags</name> <init>= <expr><literal type="number">0u</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>Order</name> <init>= <expr><operator>~</operator><literal type="number">0u</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OffloadingEntryInfoKinds</name></type> <name>Kind</name> <init>= <expr><name>OffloadingEntryInfoInvalid</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>OffloadingEntriesNum</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><call><name>OffloadEntriesInfoManagerTy</name><argument_list>(<argument><expr><name>CodeGenModule</name> <operator>&amp;</operator><name>CGM</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>CGM</name><argument_list>(<argument>CGM</argument>)</argument_list></macro> <block>{}</block>






enum <name>OMPTargetRegionEntryKind</name> <operator>:</operator> <name>uint32_t</name> <block>{

<expr><name>OMPTargetRegionEntryTargetRegion</name> <operator>=</operator> <literal type="number">0x0</literal></expr>,

<expr><name>OMPTargetRegionEntryCtor</name> <operator>=</operator> <literal type="number">0x02</literal></expr>,

<expr><name>OMPTargetRegionEntryDtor</name> <operator>=</operator> <literal type="number">0x04</literal></expr>,
}</block></expr>;</expr_stmt>


<decl_stmt><decl><type><name>class</name> <name>OffloadEntryInfoTargetRegion</name></type> <name>final</name> <range>: <expr><name>public</name> <name>OffloadEntryInfo</name> <block>{

<expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>ID</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>OffloadEntryInfoTargetRegion</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OffloadEntryInfo</name><argument_list>(<argument>OffloadingEntryInfoTargetRegion</argument>)</argument_list></macro> <block>{}</block>
<name>explicit</name> <macro><name>OffloadEntryInfoTargetRegion</name><argument_list>(<argument>unsigned Order</argument>,
<argument>llvm::Constant *Addr</argument>,
<argument>llvm::Constant *ID</argument>,
<argument>OMPTargetRegionEntryKind Flags</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OffloadEntryInfo</name><argument_list>(<argument><expr><name>OffloadingEntryInfoTargetRegion</name></expr></argument>, <argument><expr><name>Order</name></expr></argument>, <argument><expr><name>Flags</name></expr></argument>)</argument_list></call></expr>,
<macro><name>ID</name><argument_list>(<argument>ID</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setAddress</name><argument_list>(<argument><expr><name>Addr</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>getID</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ID</name></expr>;</return> }</block>
<name>void</name> <macro><name>setID</name><argument_list>(<argument>llvm::Constant *V</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>ID</name> <operator>&amp;&amp;</operator> <literal type="string">"ID has been set before!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>ID</name> <operator>=</operator> <name>V</name></expr>;
}</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OffloadEntryInfo *Info</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Info</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OffloadingEntryInfoTargetRegion</name></expr>;</return>
}</block>
}</expr>;


<expr><name>void</name> <macro><name>initializeTargetRegionEntryInfo</name><argument_list>(<argument>unsigned DeviceID</argument>, <argument>unsigned FileID</argument>,
<argument>StringRef ParentName</argument>, <argument>unsigned LineNum</argument>,
<argument>unsigned Order</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <macro><name>registerTargetRegionEntryInfo</name><argument_list>(<argument>unsigned DeviceID</argument>, <argument>unsigned FileID</argument>,
<argument>StringRef ParentName</argument>, <argument>unsigned LineNum</argument>,
<argument>llvm::Constant *Addr</argument>, <argument>llvm::Constant *ID</argument>,
<argument>OMPTargetRegionEntryKind Flags</argument>)</argument_list></macro></expr>;


<expr><name>bool</name> <macro><name>hasTargetRegionEntryInfo</name><argument_list>(<argument>unsigned DeviceID</argument>, <argument>unsigned FileID</argument>,
<argument>StringRef ParentName</argument>, <argument>unsigned LineNum</argument>,
<argument>bool IgnoreAddressId = false</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>unsigned</name>, <name>unsigned</name>, <name>StringRef</name>, <name>unsigned</name>,
<specifier>const</specifier> <name>OffloadEntryInfoTargetRegion</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name>
<name>OffloadTargetRegionEntryInfoActTy</name></expr>;</expr_stmt></typedef>
<name>void</name> <call><name>actOnTargetRegionEntriesInfo</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>OffloadTargetRegionEntryInfoActTy</name> <operator>&amp;</operator><name>Action</name></expr></argument>)</argument_list></call></block></expr></range></decl>;</decl_stmt>






<enum>enum <name>OMPTargetGlobalVarEntryKind</name> : <type><name>uint32_t</name></type> <block>{

<decl><name>OMPTargetGlobalVarEntryTo</name> <init>= <expr><literal type="number">0x0</literal></expr></init></decl>,

<decl><name>OMPTargetGlobalVarEntryLink</name> <init>= <expr><literal type="number">0x1</literal></expr></init></decl>,
}</block>;</enum>


<decl_stmt><decl><type><name>class</name> <name>OffloadEntryInfoDeviceGlobalVar</name></type> <name>final</name> <range>: <expr><name>public</name> <name>OffloadEntryInfo</name> <block>{

<expr><name>CharUnits</name> <name>VarSize</name></expr>;
<expr><name>llvm</name><operator>::</operator><name>GlobalValue</name><operator>::</operator><name>LinkageTypes</name> <name>Linkage</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>OffloadEntryInfoDeviceGlobalVar</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OffloadEntryInfo</name><argument_list>(<argument>OffloadingEntryInfoDeviceGlobalVar</argument>)</argument_list></macro> <block>{}</block>
<name>explicit</name> <macro><name>OffloadEntryInfoDeviceGlobalVar</name><argument_list>(<argument>unsigned Order</argument>,
<argument>OMPTargetGlobalVarEntryKind Flags</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OffloadEntryInfo</name><argument_list>(<argument>OffloadingEntryInfoDeviceGlobalVar</argument>, <argument>Order</argument>, <argument>Flags</argument>)</argument_list></macro> <block>{}</block>
<name>explicit</name> <macro><name>OffloadEntryInfoDeviceGlobalVar</name><argument_list>(
<argument>unsigned Order</argument>, <argument>llvm::Constant *Addr</argument>, <argument>CharUnits VarSize</argument>,
<argument>OMPTargetGlobalVarEntryKind Flags</argument>,
<argument>llvm::GlobalValue::LinkageTypes Linkage</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OffloadEntryInfo</name><argument_list>(<argument><expr><name>OffloadingEntryInfoDeviceGlobalVar</name></expr></argument>, <argument><expr><name>Order</name></expr></argument>, <argument><expr><name>Flags</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>VarSize</name><argument_list>(<argument><expr><name>VarSize</name></expr></argument>)</argument_list></call></expr>, <macro><name>Linkage</name><argument_list>(<argument>Linkage</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setAddress</name><argument_list>(<argument><expr><name>Addr</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>CharUnits</name> <macro><name>getVarSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>VarSize</name></expr>;</return> }</block>
<name>void</name> <macro><name>setVarSize</name><argument_list>(<argument>CharUnits Size</argument>)</argument_list></macro> <block>{ <expr><name>VarSize</name> <operator>=</operator> <name>Size</name></expr>; }</block>
<name>llvm</name><operator>::</operator><name>GlobalValue</name><operator>::</operator><name>LinkageTypes</name> <macro><name>getLinkage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Linkage</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLinkage</name><argument_list>(<argument>llvm::GlobalValue::LinkageTypes LT</argument>)</argument_list></macro> <block>{ <expr><name>Linkage</name> <operator>=</operator> <name>LT</name></expr>; }</block>
<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OffloadEntryInfo *Info</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Info</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OffloadingEntryInfoDeviceGlobalVar</name></expr>;</return>
}</block>
}</expr>;


<expr><name>void</name> <macro><name>initializeDeviceGlobalVarEntryInfo</name><argument_list>(<argument>StringRef Name</argument>,
<argument>OMPTargetGlobalVarEntryKind Flags</argument>,
<argument>unsigned Order</argument>)</argument_list></macro></expr>;


<expr><name>void</name>
<macro><name>registerDeviceGlobalVarEntryInfo</name><argument_list>(<argument>StringRef VarName</argument>, <argument>llvm::Constant *Addr</argument>,
<argument>CharUnits VarSize</argument>,
<argument>OMPTargetGlobalVarEntryKind Flags</argument>,
<argument>llvm::GlobalValue::LinkageTypes Linkage</argument>)</argument_list></macro></expr>;

<expr><name>bool</name> <macro><name>hasDeviceGlobalVarEntryInfo</name><argument_list>(<argument>StringRef VarName</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>OffloadEntriesDeviceGlobalVar</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>VarName</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
}</block></expr>

<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>StringRef</name>,
<specifier>const</specifier> <name>OffloadEntryInfoDeviceGlobalVar</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name>
<name>OffloadDeviceGlobalVarEntryInfoActTy</name></expr>;</expr_stmt></typedef>
<name>void</name> <call><name>actOnDeviceGlobalVarEntriesInfo</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>OffloadDeviceGlobalVarEntryInfoActTy</name> <operator>&amp;</operator><name>Action</name></expr></argument>)</argument_list></call></block></expr></range></decl>;</decl_stmt>

<label><name>private</name>:</label>


<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>OffloadEntryInfoTargetRegion</name></expr></argument>&gt;</argument_list></name>
<name>OffloadEntriesTargetRegionPerLine</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>OffloadEntriesTargetRegionPerLine</name></expr></argument>&gt;</argument_list></name>
<name>OffloadEntriesTargetRegionPerParentName</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>OffloadEntriesTargetRegionPerParentName</name></expr></argument>&gt;</argument_list></name>
<name>OffloadEntriesTargetRegionPerFile</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>OffloadEntriesTargetRegionPerFile</name></expr></argument>&gt;</argument_list></name>
<name>OffloadEntriesTargetRegionPerDevice</name></expr>;</expr_stmt></typedef>
<typedef>typedef <type><name>OffloadEntriesTargetRegionPerDevice</name></type> <name>OffloadEntriesTargetRegionTy</name>;</typedef>
<decl_stmt><decl><type><name>OffloadEntriesTargetRegionTy</name></type> <name>OffloadEntriesTargetRegion</name></decl>;</decl_stmt>


<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>OffloadEntryInfoDeviceGlobalVar</name></expr></argument>&gt;</argument_list></name>
<name>OffloadEntriesDeviceGlobalVarTy</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>OffloadEntriesDeviceGlobalVarTy</name></type> <name>OffloadEntriesDeviceGlobalVar</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<decl_stmt><decl><type><name>OffloadEntriesInfoManagerTy</name></type> <name>OffloadEntriesInfoManager</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>ShouldMarkAsGlobal</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseSet</name><argument_list type="generic">&lt;<argument><expr><name><name>CanonicalDeclPtr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>AlreadyEmittedTargetDecls</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>WeakTrackingVH</name></expr></argument>&gt;</argument_list></name> <name>EmittedNonTargetVariables</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallDenseSet</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>DeferredGlobalVariables</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>NontemporalDeclsSet</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>SmallDenseSet</name><argument_list type="generic">&lt;<argument><expr><name><name>CanonicalDeclPtr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>NontemporalDeclsSet</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>NontemporalDeclsStack</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>UntiedLocalVarsAddressesMap</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name><name>CanonicalDeclPtr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>Address</name></expr></argument>, <argument><expr><name>Address</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>UntiedLocalVarsAddressesMap</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>UntiedLocalVarsStack</name></expr>;</expr_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>LastprivateConditionalData</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>LastprivateConditionalStack</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>HasRequiresUnifiedSharedMemory</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>AtomicOrdering</name> <name>RequiresAtomicOrdering</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name>AtomicOrdering</name><operator>::</operator><name>Monotonic</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>HasEmittedTargetRegion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>HasEmittedDeclareTargetRegion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>loadOffloadInfoMetadata</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>QualType</name></type> <name>getTgtOffloadEntryQTy</name><parameter_list>()</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type> <name>scanForTargetRegionsFunctions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>ParentName</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>emitKmpRoutineEntryT</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>KmpInt32Ty</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><call><name>getKmpc_MicroPointerTy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <macro><name>createForStaticInitFunction</name><argument_list>(<argument>unsigned IVSize</argument>,
<argument>bool IVSigned</argument>)</argument_list></macro></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <macro><name>createDispatchInitFunction</name><argument_list>(<argument>unsigned IVSize</argument>,
<argument>bool IVSigned</argument>)</argument_list></macro></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <macro><name>createDispatchNextFunction</name><argument_list>(<argument>unsigned IVSize</argument>,
<argument>bool IVSigned</argument>)</argument_list></macro></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <macro><name>createDispatchFiniFunction</name><argument_list>(<argument>unsigned IVSize</argument>,
<argument>bool IVSigned</argument>)</argument_list></macro></expr>;</expr_stmt>






<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><call><name>getOrCreateThreadPrivateCache</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>getOrCreateInternalVariable</name><argument_list>(<argument>llvm::Type *Ty</argument>,
<argument>const llvm::Twine &amp;Name</argument>,
<argument>unsigned AddressSpace = <literal type="number">0</literal></argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringSet</name><argument_list type="generic">&lt;&gt;</argument_list></name> <name>ThreadPrivateWithDefinition</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringSet</name><argument_list type="generic">&lt;&gt;</argument_list></name> <name>DeclareTargetWithDefinition</name></expr>;</expr_stmt>







<decl_stmt><decl><type><name>void</name></type> <name>emitThreadPrivateVarInit</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><name>Address</name> <name>VDAddr</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Ctor</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>CopyCtor</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Dtor</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>emitUDMapperArrayInitOrDel</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>MapperCGF</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Handle</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>BasePtr</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Ptr</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Size</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>MapType</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>MapName</name></expr></argument>,
<argument><expr><name>CharUnits</name> <name>ElementSize</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>ExitBB</name></expr></argument>, <argument><expr><name>bool</name> <name>IsInit</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<struct>struct <name>TaskResultTy</name> <block>{
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>NewTask</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>TaskEntry</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>NewTaskNewTaskTTy</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>LValue</name></type> <name>TDBase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>RecordDecl</name> <modifier>*</modifier></type><name>KmpTaskTQTyRD</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>TaskDupFn</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
}</block>;</struct>






















<decl_stmt><decl><type><name>TaskResultTy</name></type> <name>emitTaskInit</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPExecutableDirective</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>TaskFunction</name></expr></argument>, <argument><expr><name>QualType</name> <name>SharedsTy</name></expr></argument>,
<argument><expr><name>Address</name> <name>Shareds</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>OMPTaskDataTy</name> <operator>&amp;</operator><name>Data</name></expr></argument>)</argument_list></decl>;</decl_stmt>





<decl_stmt><decl><type><name>void</name></type> <name>emitTargetNumIterationsCall</name><argument_list>(
<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>OMPExecutableDirective</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>DeviceID</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><operator>(</operator><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name>,
<specifier>const</specifier> <name>OMPLoopDirective</name> <operator>&amp;</operator><name>D</name><operator>)</operator></expr></argument>&gt;</argument_list></name>
<name>SizeEmitter</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>emitLastprivateConditionalUpdate</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>IVLVal</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>UniqueDeclName</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>LVal</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>





<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>, <argument><expr><name>LValue</name></expr></argument>&gt;</argument_list></name> <macro><name>getDepobjElements</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>LValue DepobjLVal</argument>,
<argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;</expr_stmt>

<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>CGOpenMPRuntime</name><argument_list>(<argument><expr><name>CodeGenModule</name> <operator>&amp;</operator><name>CGM</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CGOpenMPRuntime</name><argument_list>(<argument>CGM</argument>, <argument><literal type="string">"."</literal></argument>, <argument><literal type="string">"."</literal></argument>)</argument_list></macro> <block>{}</block>
<name>virtual</name> <operator>~</operator><macro><name>CGOpenMPRuntime</name><argument_list>()</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>void</name> <call><name>clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>








<function_decl><type><name>void</name></type> <name>emitIfClause</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Cond</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegionCodeGenTy</name> <modifier>&amp;</modifier></type><name>ThenGen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegionCodeGenTy</name> <modifier>&amp;</modifier></type><name>ElseGen</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>getSingleCompoundChild</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getName</name><argument_list>(<argument>ArrayRef&lt;StringRef&gt; Parts</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitUserDefinedReduction</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>*</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPDeclareReductionDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>virtual</name> <name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<call><name>getUserDefinedReduction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPDeclareReductionDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function_decl><type><name>void</name></type> <name>emitUserDefinedMapper</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPDeclareMapperDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>CodeGenFunction</name> <modifier>*</modifier></type><name>CGF</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator>
<call><name>getOrCreateUserDefinedMapperFunc</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPDeclareMapperDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>









<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><macro><name>emitParallelOutlinedFunction</name><argument_list>(
<argument>const OMPExecutableDirective &amp;D</argument>, <argument>const VarDecl *ThreadIDVar</argument>,
<argument>OpenMPDirectiveKind InnermostKind</argument>, <argument>const RegionCodeGenTy &amp;CodeGen</argument>)</argument_list></macro></expr>;</expr_stmt>









<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><macro><name>emitTeamsOutlinedFunction</name><argument_list>(
<argument>const OMPExecutableDirective &amp;D</argument>, <argument>const VarDecl *ThreadIDVar</argument>,
<argument>OpenMPDirectiveKind InnermostKind</argument>, <argument>const RegionCodeGenTy &amp;CodeGen</argument>)</argument_list></macro></expr>;</expr_stmt>
















<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><macro><name>emitTaskOutlinedFunction</name><argument_list>(
<argument>const OMPExecutableDirective &amp;D</argument>, <argument>const VarDecl *ThreadIDVar</argument>,
<argument>const VarDecl *PartIDVar</argument>, <argument>const VarDecl *TaskTVar</argument>,
<argument>OpenMPDirectiveKind InnermostKind</argument>, <argument>const RegionCodeGenTy &amp;CodeGen</argument>,
<argument>bool Tied</argument>, <argument>unsigned &amp;NumberOfParts</argument>)</argument_list></macro></expr>;</expr_stmt>



<function_decl><type><name>virtual</name> <name>void</name></type> <name>functionFinished</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>)</parameter_list>;</function_decl>











<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>emitParallelCall</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>OutlinedFn</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CapturedVars</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>IfCond</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitCriticalRegion</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>CriticalName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegionCodeGenTy</name> <modifier>&amp;</modifier></type><name>CriticalOpGen</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Hint</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitMasterRegion</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegionCodeGenTy</name> <modifier>&amp;</modifier></type><name>MasterOpGen</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitMaskedRegion</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegionCodeGenTy</name> <modifier>&amp;</modifier></type><name>MaskedOpGen</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Filter</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitTaskyieldCall</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitTaskgroupRegion</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegionCodeGenTy</name> <modifier>&amp;</modifier></type><name>TaskgroupOpGen</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitSingleRegion</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegionCodeGenTy</name> <modifier>&amp;</modifier></type><name>SingleOpGen</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>CopyprivateVars</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>DestExprs</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>SrcExprs</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>AssignmentOps</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitOrderedRegion</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegionCodeGenTy</name> <modifier>&amp;</modifier></type><name>OrderedOpGen</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsThreads</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitBarrierCall</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>EmitChecks</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ForceSimpleCall</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>






<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>isStaticNonchunked</name><argument_list>(<argument><expr><name>OpenMPScheduleClauseKind</name> <name>ScheduleKind</name></expr></argument>,
<argument><expr><name>bool</name> <name>Chunked</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>






<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>isStaticNonchunked</name><argument_list>(<argument><expr><name>OpenMPDistScheduleClauseKind</name> <name>ScheduleKind</name></expr></argument>,
<argument><expr><name>bool</name> <name>Chunked</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>isStaticChunked</name><argument_list>(<argument><expr><name>OpenMPScheduleClauseKind</name> <name>ScheduleKind</name></expr></argument>,
<argument><expr><name>bool</name> <name>Chunked</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>isStaticChunked</name><argument_list>(<argument><expr><name>OpenMPDistScheduleClauseKind</name> <name>ScheduleKind</name></expr></argument>,
<argument><expr><name>bool</name> <name>Chunked</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>isDynamic</name><argument_list>(<argument><expr><name>OpenMPScheduleClauseKind</name> <name>ScheduleKind</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<struct>struct <name>DispatchRTInput</name> <block>{

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>LB</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>UB</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Chunk</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DispatchRTInput</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<expr_stmt><expr><call><name>DispatchRTInput</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>LB</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>UB</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Chunk</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>LB</name><argument_list>(<argument><expr><name>LB</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>UB</name><argument_list>(<argument><expr><name>UB</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Chunk</name><argument_list>(<argument>Chunk</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>




















<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitForDispatchInit</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OpenMPScheduleTy</name> <modifier>&amp;</modifier></type><name>ScheduleKind</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>IVSize</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IVSigned</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Ordered</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DispatchRTInput</name> <modifier>&amp;</modifier></type><name>DispatchValues</name></decl></parameter>)</parameter_list>;</function_decl>


<struct>struct <name>StaticRTInput</name> <block>{

<decl_stmt><decl><type><name>unsigned</name></type> <name>IVSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>IVSigned</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>Ordered</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Address</name></type> <name>IL</name> <init>= <expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Address</name></type> <name>LB</name> <init>= <expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Address</name></type> <name>UB</name> <init>= <expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Address</name></type> <name>ST</name> <init>= <expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Chunk</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<macro><name>StaticRTInput</name><argument_list>(<argument>unsigned IVSize</argument>, <argument>bool IVSigned</argument>, <argument>bool Ordered</argument>, <argument>Address IL</argument>,
<argument>Address LB</argument>, <argument>Address UB</argument>, <argument>Address ST</argument>,
<argument>llvm::Value *Chunk = nullptr</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>IVSize</name><argument_list>(<argument><expr><name>IVSize</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IVSigned</name><argument_list>(<argument><expr><name>IVSigned</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Ordered</name><argument_list>(<argument><expr><name>Ordered</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IL</name><argument_list>(<argument><expr><name>IL</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>LB</name><argument_list>(<argument><expr><name>LB</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>UB</name><argument_list>(<argument><expr><name>UB</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ST</name><argument_list>(<argument><expr><name>ST</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Chunk</name><argument_list>(<argument>Chunk</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>















<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitForStaticInit</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>DKind</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OpenMPScheduleTy</name> <modifier>&amp;</modifier></type><name>ScheduleKind</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>StaticRTInput</name> <modifier>&amp;</modifier></type><name>Values</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitDistributeStaticInit</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDistScheduleClauseKind</name></type> <name>SchedKind</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>StaticRTInput</name> <modifier>&amp;</modifier></type><name>Values</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitForOrderedIterationEnd</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>IVSize</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IVSigned</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitForStaticFinish</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>DKind</name></decl></parameter>)</parameter_list>;</function_decl>















<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>emitForNext</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>unsigned IVSize</argument>, <argument>bool IVSigned</argument>,
<argument>Address IL</argument>, <argument>Address LB</argument>,
<argument>Address UB</argument>, <argument>Address ST</argument>)</argument_list></macro></expr>;</expr_stmt>





<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>emitNumThreadsClause</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>NumThreads</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>emitProcBindClause</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>ProcBindKind</name> <name>ProcBind</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list></decl>;</decl_stmt>







<function_decl><type><name>virtual</name> <name>Address</name></type> <name>getAddrOfThreadPrivate</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>,
<parameter><decl><type><name>Address</name></type> <name>VDAddr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>virtual</name> <name>Address</name></type> <name>getAddrOfDeclareTargetVar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>)</parameter_list>;</function_decl>









<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator>
<macro><name>emitThreadPrivateVarDefinition</name><argument_list>(<argument>const VarDecl *VD</argument>, <argument>Address VDAddr</argument>,
<argument>SourceLocation Loc</argument>, <argument>bool PerformInit</argument>,
<argument>CodeGenFunction *CGF = nullptr</argument>)</argument_list></macro></expr>;</expr_stmt>





<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>emitDeclareTargetVarDefinition</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator><name>Addr</name></expr></argument>,
<argument><expr><name>bool</name> <name>PerformInit</name></expr></argument>)</argument_list></decl>;</decl_stmt>





<function_decl><type><name>virtual</name> <name>Address</name></type> <name>getAddrOfArtificialThreadPrivate</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>VarType</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Name</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>emitFlush</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>AtomicOrdering</name> <name>AO</name></expr></argument>)</argument_list></decl>;</decl_stmt>




























<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>emitTaskCall</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPExecutableDirective</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>TaskFunction</name></expr></argument>, <argument><expr><name>QualType</name> <name>SharedsTy</name></expr></argument>,
<argument><expr><name>Address</name> <name>Shareds</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>IfCond</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPTaskDataTy</name> <operator>&amp;</operator><name>Data</name></expr></argument>)</argument_list></decl>;</decl_stmt>






























<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>emitTaskLoopCall</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPLoopDirective</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>TaskFunction</name></expr></argument>,
<argument><expr><name>QualType</name> <name>SharedsTy</name></expr></argument>, <argument><expr><name>Address</name> <name>Shareds</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>IfCond</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>OMPTaskDataTy</name> <operator>&amp;</operator><name>Data</name></expr></argument>)</argument_list></decl>;</decl_stmt>








<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitInlinedDirective</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>InnermostKind</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegionCodeGenTy</name> <modifier>&amp;</modifier></type><name>CodeGen</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>HasCancel</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>








<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><macro><name>emitReductionFunction</name><argument_list>(<argument>SourceLocation Loc</argument>,
<argument>llvm::Type *ArgsType</argument>,
<argument>ArrayRef&lt;const Expr *&gt; Privates</argument>,
<argument>ArrayRef&lt;const Expr *&gt; LHSExprs</argument>,
<argument>ArrayRef&lt;const Expr *&gt; RHSExprs</argument>,
<argument>ArrayRef&lt;const Expr *&gt; ReductionOps</argument>)</argument_list></macro></expr>;</expr_stmt>


<function_decl><type><name>void</name></type> <name>emitSingleReductionCombiner</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>ReductionOp</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>PrivateRef</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclRefExpr</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclRefExpr</name> <modifier>*</modifier></type><name>RHS</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>ReductionOptionsTy</name> <block>{
<decl_stmt><decl><type><name>bool</name></type> <name>WithNowait</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>SimpleReduction</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OpenMPDirectiveKind</name></type> <name>ReductionKind</name></decl>;</decl_stmt>
}</block>;</struct>










































<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitReduction</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Privates</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>LHSExprs</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>RHSExprs</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>ReductionOps</name></decl></parameter>,
<parameter><decl><type><name>ReductionOptionsTy</name></type> <name>Options</name></decl></parameter>)</parameter_list>;</function_decl>





































<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>emitTaskReductionInit</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>SourceLocation Loc</argument>,
<argument>ArrayRef&lt;const Expr *&gt; LHSExprs</argument>,
<argument>ArrayRef&lt;const Expr *&gt; RHSExprs</argument>,
<argument>const OMPTaskDataTy &amp;Data</argument>)</argument_list></macro></expr>;</expr_stmt>





<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitTaskReductionFini</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsWorksharingReduction</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitTaskReductionFixups</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>ReductionCodeGen</name> <modifier>&amp;</modifier></type><name>RCG</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>N</name></decl></parameter>)</parameter_list>;</function_decl>






<decl_stmt><decl><type><name>virtual</name> <name>Address</name></type> <name>getTaskReductionItem</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>ReductionsPtr</name></expr></argument>,
<argument><expr><name>LValue</name> <name>SharedLVal</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitTaskwaitCall</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitCancellationPointCall</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>CancelRegion</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitCancelCall</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>IfCond</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>CancelRegion</name></decl></parameter>)</parameter_list>;</function_decl>










<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>emitTargetOutlinedFunction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPExecutableDirective</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><name>StringRef</name> <name>ParentName</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><operator>&amp;</operator><name>OutlinedFn</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><operator>&amp;</operator><name>OutlinedFnID</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsOffloadEntry</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>RegionCodeGenTy</name> <operator>&amp;</operator><name>CodeGen</name></expr></argument>)</argument_list></decl>;</decl_stmt>













<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>emitTargetCall</name><argument_list>(
<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>OMPExecutableDirective</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>OutlinedFn</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>OutlinedFnID</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>IfCond</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OpenMPDeviceClauseModifier</name></expr></argument>&gt;</argument_list></name> <name>Device</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><operator>(</operator><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name>,
<specifier>const</specifier> <name>OMPLoopDirective</name> <operator>&amp;</operator><name>D</name><operator>)</operator></expr></argument>&gt;</argument_list></name>
<name>SizeEmitter</name></expr></argument>)</argument_list></decl>;</decl_stmt>





<function_decl><type><name>virtual</name> <name>bool</name></type> <name>emitTargetFunctions</name><parameter_list>(<parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>virtual</name> <name>bool</name></type> <name>emitTargetGlobalVariable</name><parameter_list>(<parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>registerTargetGlobalVariable</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>Addr</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<function_decl><type><name>virtual</name> <name>bool</name></type> <name>emitTargetGlobal</name><parameter_list>(<parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><call><name>emitRequiresDirectiveRegFun</name><argument_list>()</argument_list></call></expr>;</expr_stmt>



<function_decl><type><name>void</name></type> <name>createOffloadEntriesAndInfoMetadata</name><parameter_list>()</parameter_list>;</function_decl>









<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>emitTeamsCall</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPExecutableDirective</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>OutlinedFn</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CapturedVars</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitNumTeamsClause</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>NumTeams</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>ThreadLimit</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>class</name></type> <name>TargetDataInfo</name> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>RequiresDevicePointerInfo</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>SeparateBeginEndCalls</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>BasePointersArray</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>PointersArray</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>SizesArray</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>MapTypesArray</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>MapTypesArrayEnd</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>MappersArray</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>MapNamesArray</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>HasMapper</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>NumberOfPtrs</name> <init>= <expr><literal type="number">0u</literal></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>Address</name></expr></argument>&gt;</argument_list></name> <name>CaptureDeviceAddrMap</name></expr>;</expr_stmt>

<function><type><name>explicit</name></type> <name>TargetDataInfo</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>
<macro><name>explicit</name></macro> <macro><name>TargetDataInfo</name><argument_list>(<argument>bool RequiresDevicePointerInfo</argument>,
<argument>bool SeparateBeginEndCalls</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>RequiresDevicePointerInfo</name><argument_list>(<argument><expr><name>RequiresDevicePointerInfo</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>SeparateBeginEndCalls</name><argument_list>(<argument>SeparateBeginEndCalls</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>clearArrayInfo</name><argument_list>()</argument_list></macro> <block>{
<expr><name>BasePointersArray</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>PointersArray</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>SizesArray</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>MapTypesArray</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>MapTypesArrayEnd</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>MapNamesArray</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>MappersArray</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>HasMapper</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>NumberOfPtrs</name> <operator>=</operator> <literal type="number">0u</literal></expr>;
}</block>

<name>bool</name> <macro><name>isValid</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>BasePointersArray</name> <operator>&amp;&amp;</operator> <name>PointersArray</name> <operator>&amp;&amp;</operator> <name>SizesArray</name> <operator>&amp;&amp;</operator>
<name>MapTypesArray</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>HasMapper</name> <operator>||</operator> <name>MappersArray</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>NumberOfPtrs</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>bool</name></type> <name>requiresDevicePointerInfo</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>RequiresDevicePointerInfo</name></expr>;</return> </block_content>}</block></function>
<function><type><name>bool</name></type> <name>separateBeginEndCalls</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>SeparateBeginEndCalls</name></expr>;</return> </block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>









<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitTargetDataCalls</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>IfCond</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Device</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegionCodeGenTy</name> <modifier>&amp;</modifier></type><name>CodeGen</name></decl></parameter>,
<parameter><decl><type><name>TargetDataInfo</name> <modifier>&amp;</modifier></type><name>Info</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitTargetDataStandAloneCall</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>IfCond</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Device</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>emitDeclareSimdFunction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>FD</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Fn</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitDoacrossInit</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OMPLoopDirective</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>NumIterations</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitDoacrossOrdered</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPDependClause</name> <modifier>*</modifier></type><name>C</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name>virtual</name> <specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>translateParameter</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><name>FD</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>NativeParam</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>NativeParam</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<decl_stmt><decl><type><name>virtual</name> <name>Address</name></type> <name>getParameterAddress</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>NativeParam</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>TargetParam</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>getDefaultDistScheduleAndChunk</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPLoopDirective</name> <operator>&amp;</operator><name>S</name></expr></argument>, <argument><expr><name>OpenMPDistScheduleClauseKind</name> <operator>&amp;</operator><name>ScheduleKind</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><operator>&amp;</operator><name>Chunk</name></expr></argument>)</argument_list> const <block>{<block_content/>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>getDefaultScheduleAndChunk</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPLoopDirective</name> <operator>&amp;</operator><name>S</name></expr></argument>, <argument><expr><name>OpenMPScheduleClauseKind</name> <operator>&amp;</operator><name>ScheduleKind</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><operator>&amp;</operator><name>ChunkExpr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>void</name></type>
<name>emitOutlinedFunctionCall</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>OutlinedFn</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Args</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name>None</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitFunctionProlog</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>virtual</name> <name>Address</name></type> <name>getAddressOfLocalVariable</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>markAsGlobalTarget</name><parameter_list>(<parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>void</name> <macro><name>emitDeferredTargetDecls</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>void</name></type>
<name>adjustTargetSpecificDataForLambdas</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPExecutableDirective</name> <operator>&amp;</operator><name>D</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<function_decl><type><name>virtual</name> <name>void</name></type> <name>processRequiresDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPRequiresDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>AtomicOrdering</name> <macro><name>getDefaultMemoryOrdering</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<function_decl><type><name>virtual</name> <name>bool</name></type> <name>hasAllocateAttributeForGlobalVar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>, <parameter><decl><type><name>LangAS</name> <modifier>&amp;</modifier></type><name>AS</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>bool</name> <macro><name>hasRequiresUnifiedSharedMemory</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isNontemporalDecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><name>VD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<function_decl><type><name>Address</name></type> <name>emitLastprivateConditionalInit</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>)</parameter_list>;</function_decl>














<function_decl><type><name>virtual</name> <name>void</name></type> <name>checkAndEmitLastprivateConditional</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>)</parameter_list>;</function_decl>





















<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>checkAndEmitSharedLastprivateConditional</name><argument_list>(
<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>OMPExecutableDirective</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>DenseSet</name><argument_list type="generic">&lt;<argument><expr><name><name>CanonicalDeclPtr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>IgnoredDecls</name></expr></argument>)</argument_list></decl>;</decl_stmt>





<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitLastprivateConditionalFinalUpdate</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><name>LValue</name></type> <name>PrivLVal</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>




<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>, <argument><expr><name>Address</name></expr></argument>&gt;</argument_list></name>
<macro><name>emitDependClause</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>ArrayRef&lt;OMPTaskDataTy::DependData&gt; Dependencies</argument>,
<argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;</expr_stmt>





<decl_stmt><decl><type><name>Address</name></type> <name>emitDepobjDependClause</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPTaskDataTy</name><operator>::</operator><name>DependData</name> <operator>&amp;</operator><name>Dependencies</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>emitDestroyClause</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>DepobjLVal</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>emitUpdateClause</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>LValue</name></type> <name>DepobjLVal</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDependClauseKind</name></type> <name>NewDepKind</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>emitUsesAllocatorsInit</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Allocator</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>AllocatorTraits</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>emitUsesAllocatorsFini</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Allocator</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>bool</name></type> <name>isLocalVarInUntiedTask</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name> <name>CGOpenMPSIMDRuntime</name></type> <name>final</name> <range>: <expr><name>public</name> <name>CGOpenMPRuntime</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>CGOpenMPSIMDRuntime</name><argument_list>(<argument><expr><name>CodeGenModule</name> <operator>&amp;</operator><name>CGM</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>CGOpenMPRuntime</name><argument_list>(<argument>CGM</argument>)</argument_list></macro> <block>{}</block>
<operator>~</operator><macro><name>CGOpenMPSIMDRuntime</name><argument_list>()</argument_list></macro> <name>override</name> <block>{}</block>









<name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator>
<macro><name>emitParallelOutlinedFunction</name><argument_list>(<argument>const OMPExecutableDirective &amp;D</argument>,
<argument>const VarDecl *ThreadIDVar</argument>,
<argument>OpenMPDirectiveKind InnermostKind</argument>,
<argument>const RegionCodeGenTy &amp;CodeGen</argument>)</argument_list></macro> <name>override</name></expr>;









<expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator>
<macro><name>emitTeamsOutlinedFunction</name><argument_list>(<argument>const OMPExecutableDirective &amp;D</argument>,
<argument>const VarDecl *ThreadIDVar</argument>,
<argument>OpenMPDirectiveKind InnermostKind</argument>,
<argument>const RegionCodeGenTy &amp;CodeGen</argument>)</argument_list></macro> <name>override</name></expr>;
















<expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><macro><name>emitTaskOutlinedFunction</name><argument_list>(
<argument>const OMPExecutableDirective &amp;D</argument>, <argument>const VarDecl *ThreadIDVar</argument>,
<argument>const VarDecl *PartIDVar</argument>, <argument>const VarDecl *TaskTVar</argument>,
<argument>OpenMPDirectiveKind InnermostKind</argument>, <argument>const RegionCodeGenTy &amp;CodeGen</argument>,
<argument>bool Tied</argument>, <argument>unsigned &amp;NumberOfParts</argument>)</argument_list></macro> <name>override</name></expr>;











<expr><name>void</name> <macro><name>emitParallelCall</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>llvm::Function *OutlinedFn</argument>,
<argument>ArrayRef&lt;llvm::Value *&gt; CapturedVars</argument>,
<argument>const Expr *IfCond</argument>)</argument_list></macro> <name>override</name></expr>;






<expr><name>void</name> <macro><name>emitCriticalRegion</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>StringRef CriticalName</argument>,
<argument>const RegionCodeGenTy &amp;CriticalOpGen</argument>,
<argument>SourceLocation Loc</argument>,
<argument>const Expr *Hint = nullptr</argument>)</argument_list></macro> <name>override</name></expr>;




<expr><name>void</name> <macro><name>emitMasterRegion</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>const RegionCodeGenTy &amp;MasterOpGen</argument>,
<argument>SourceLocation Loc</argument>)</argument_list></macro> <name>override</name></expr>;




<expr><name>void</name> <macro><name>emitMaskedRegion</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>const RegionCodeGenTy &amp;MaskedOpGen</argument>, <argument>SourceLocation Loc</argument>,
<argument>const Expr *Filter = nullptr</argument>)</argument_list></macro> <name>override</name></expr>;






<expr><name>void</name> <macro><name>emitTaskyieldCall</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <name>override</name></expr>;




<expr><name>void</name> <macro><name>emitTaskgroupRegion</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>const RegionCodeGenTy &amp;TaskgroupOpGen</argument>,
<argument>SourceLocation Loc</argument>)</argument_list></macro> <name>override</name></expr>;




<expr><name>void</name> <macro><name>emitSingleRegion</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>const RegionCodeGenTy &amp;SingleOpGen</argument>, <argument>SourceLocation Loc</argument>,
<argument>ArrayRef&lt;const Expr *&gt; CopyprivateVars</argument>,
<argument>ArrayRef&lt;const Expr *&gt; DestExprs</argument>,
<argument>ArrayRef&lt;const Expr *&gt; SrcExprs</argument>,
<argument>ArrayRef&lt;const Expr *&gt; AssignmentOps</argument>)</argument_list></macro> <name>override</name></expr>;




<expr><name>void</name> <macro><name>emitOrderedRegion</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>const RegionCodeGenTy &amp;OrderedOpGen</argument>,
<argument>SourceLocation Loc</argument>, <argument>bool IsThreads</argument>)</argument_list></macro> <name>override</name></expr>;









<expr><name>void</name> <macro><name>emitBarrierCall</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>OpenMPDirectiveKind Kind</argument>, <argument>bool EmitChecks = true</argument>,
<argument>bool ForceSimpleCall = false</argument>)</argument_list></macro> <name>override</name></expr>;

















<expr><name>void</name> <macro><name>emitForDispatchInit</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>const OpenMPScheduleTy &amp;ScheduleKind</argument>,
<argument>unsigned IVSize</argument>, <argument>bool IVSigned</argument>, <argument>bool Ordered</argument>,
<argument>const DispatchRTInput &amp;DispatchValues</argument>)</argument_list></macro> <name>override</name></expr>;
















<expr><name>void</name> <macro><name>emitForStaticInit</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>OpenMPDirectiveKind DKind</argument>,
<argument>const OpenMPScheduleTy &amp;ScheduleKind</argument>,
<argument>const StaticRTInput &amp;Values</argument>)</argument_list></macro> <name>override</name></expr>;







<expr><name>void</name> <macro><name>emitDistributeStaticInit</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>OpenMPDistScheduleClauseKind SchedKind</argument>,
<argument>const StaticRTInput &amp;Values</argument>)</argument_list></macro> <name>override</name></expr>;









<expr><name>void</name> <macro><name>emitForOrderedIterationEnd</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>unsigned IVSize</argument>, <argument>bool IVSigned</argument>)</argument_list></macro> <name>override</name></expr>;








<expr><name>void</name> <macro><name>emitForStaticFinish</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>OpenMPDirectiveKind DKind</argument>)</argument_list></macro> <name>override</name></expr>;















<expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>emitForNext</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>unsigned IVSize</argument>, <argument>bool IVSigned</argument>, <argument>Address IL</argument>,
<argument>Address LB</argument>, <argument>Address UB</argument>, <argument>Address ST</argument>)</argument_list></macro> <name>override</name></expr>;





<expr><name>void</name> <macro><name>emitNumThreadsClause</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>llvm::Value *NumThreads</argument>,
<argument>SourceLocation Loc</argument>)</argument_list></macro> <name>override</name></expr>;



<expr><name>void</name> <macro><name>emitProcBindClause</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>llvm::omp::ProcBindKind ProcBind</argument>,
<argument>SourceLocation Loc</argument>)</argument_list></macro> <name>override</name></expr>;







<expr><name>Address</name> <macro><name>getAddrOfThreadPrivate</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>const VarDecl *VD</argument>,
<argument>Address VDAddr</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <name>override</name></expr>;









<expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator>
<macro><name>emitThreadPrivateVarDefinition</name><argument_list>(<argument>const VarDecl *VD</argument>, <argument>Address VDAddr</argument>,
<argument>SourceLocation Loc</argument>, <argument>bool PerformInit</argument>,
<argument>CodeGenFunction *CGF = nullptr</argument>)</argument_list></macro> <name>override</name></expr>;





<expr><name>Address</name> <macro><name>getAddrOfArtificialThreadPrivate</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>QualType VarType</argument>,
<argument>StringRef Name</argument>)</argument_list></macro> <name>override</name></expr>;



<expr><name>void</name> <macro><name>emitFlush</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>ArrayRef&lt;const Expr *&gt; Vars</argument>,
<argument>SourceLocation Loc</argument>, <argument>llvm::AtomicOrdering AO</argument>)</argument_list></macro> <name>override</name></expr>;




























<expr><name>void</name> <macro><name>emitTaskCall</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>const OMPExecutableDirective &amp;D</argument>,
<argument>llvm::Function *TaskFunction</argument>, <argument>QualType SharedsTy</argument>,
<argument>Address Shareds</argument>, <argument>const Expr *IfCond</argument>,
<argument>const OMPTaskDataTy &amp;Data</argument>)</argument_list></macro> <name>override</name></expr>;






























<expr><name>void</name> <macro><name>emitTaskLoopCall</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>const OMPLoopDirective &amp;D</argument>, <argument>llvm::Function *TaskFunction</argument>,
<argument>QualType SharedsTy</argument>, <argument>Address Shareds</argument>, <argument>const Expr *IfCond</argument>,
<argument>const OMPTaskDataTy &amp;Data</argument>)</argument_list></macro> <name>override</name></expr>;











































<expr><name>void</name> <macro><name>emitReduction</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>ArrayRef&lt;const Expr *&gt; Privates</argument>,
<argument>ArrayRef&lt;const Expr *&gt; LHSExprs</argument>,
<argument>ArrayRef&lt;const Expr *&gt; RHSExprs</argument>,
<argument>ArrayRef&lt;const Expr *&gt; ReductionOps</argument>,
<argument>ReductionOptionsTy Options</argument>)</argument_list></macro> <name>override</name></expr>;





































<expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>emitTaskReductionInit</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>ArrayRef&lt;const Expr *&gt; LHSExprs</argument>,
<argument>ArrayRef&lt;const Expr *&gt; RHSExprs</argument>,
<argument>const OMPTaskDataTy &amp;Data</argument>)</argument_list></macro> <name>override</name></expr>;





<expr><name>void</name> <macro><name>emitTaskReductionFini</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>bool IsWorksharingReduction</argument>)</argument_list></macro> <name>override</name></expr>;








<expr><name>void</name> <macro><name>emitTaskReductionFixups</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>ReductionCodeGen &amp;RCG</argument>, <argument>unsigned N</argument>)</argument_list></macro> <name>override</name></expr>;






<expr><name>Address</name> <macro><name>getTaskReductionItem</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>llvm::Value *ReductionsPtr</argument>,
<argument>LValue SharedLVal</argument>)</argument_list></macro> <name>override</name></expr>;


<expr><name>void</name> <macro><name>emitTaskwaitCall</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <name>override</name></expr>;





<expr><name>void</name> <macro><name>emitCancellationPointCall</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>OpenMPDirectiveKind CancelRegion</argument>)</argument_list></macro> <name>override</name></expr>;






<expr><name>void</name> <macro><name>emitCancelCall</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation Loc</argument>,
<argument>const Expr *IfCond</argument>,
<argument>OpenMPDirectiveKind CancelRegion</argument>)</argument_list></macro> <name>override</name></expr>;










<expr><name>void</name> <macro><name>emitTargetOutlinedFunction</name><argument_list>(<argument>const OMPExecutableDirective &amp;D</argument>,
<argument>StringRef ParentName</argument>,
<argument>llvm::Function *&amp;OutlinedFn</argument>,
<argument>llvm::Constant *&amp;OutlinedFnID</argument>,
<argument>bool IsOffloadEntry</argument>,
<argument>const RegionCodeGenTy &amp;CodeGen</argument>)</argument_list></macro> <name>override</name></expr>;











<expr><name>void</name> <macro><name>emitTargetCall</name><argument_list>(
<argument>CodeGenFunction &amp;CGF</argument>, <argument>const OMPExecutableDirective &amp;D</argument>,
<argument>llvm::Function *OutlinedFn</argument>, <argument>llvm::Value *OutlinedFnID</argument>, <argument>const Expr *IfCond</argument>,
<argument>llvm::PointerIntPair&lt;const Expr *</argument>, <argument><literal type="number">2</literal></argument>, <argument>OpenMPDeviceClauseModifier&gt; Device</argument>,
<argument>llvm::function_ref&lt;llvm::Value *(CodeGenFunction &amp;CGF,
const OMPLoopDirective &amp;D)&gt;
SizeEmitter</argument>)</argument_list></macro> <name>override</name></expr>;





<expr><name>bool</name> <macro><name>emitTargetFunctions</name><argument_list>(<argument>GlobalDecl GD</argument>)</argument_list></macro> <name>override</name></expr>;




<expr><name>bool</name> <macro><name>emitTargetGlobalVariable</name><argument_list>(<argument>GlobalDecl GD</argument>)</argument_list></macro> <name>override</name></expr>;




<expr><name>bool</name> <macro><name>emitTargetGlobal</name><argument_list>(<argument>GlobalDecl GD</argument>)</argument_list></macro> <name>override</name></expr>;









<expr><name>void</name> <macro><name>emitTeamsCall</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>const OMPExecutableDirective &amp;D</argument>,
<argument>SourceLocation Loc</argument>, <argument>llvm::Function *OutlinedFn</argument>,
<argument>ArrayRef&lt;llvm::Value *&gt; CapturedVars</argument>)</argument_list></macro> <name>override</name></expr>;






<expr><name>void</name> <macro><name>emitNumTeamsClause</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>const Expr *NumTeams</argument>,
<argument>const Expr *ThreadLimit</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <name>override</name></expr>;









<expr><name>void</name> <macro><name>emitTargetDataCalls</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>const OMPExecutableDirective &amp;D</argument>, <argument>const Expr *IfCond</argument>,
<argument>const Expr *Device</argument>, <argument>const RegionCodeGenTy &amp;CodeGen</argument>,
<argument>TargetDataInfo &amp;Info</argument>)</argument_list></macro> <name>override</name></expr>;








<expr><name>void</name> <macro><name>emitTargetDataStandAloneCall</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>const OMPExecutableDirective &amp;D</argument>,
<argument>const Expr *IfCond</argument>,
<argument>const Expr *Device</argument>)</argument_list></macro> <name>override</name></expr>;



<expr><name>void</name> <macro><name>emitDoacrossInit</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>const OMPLoopDirective &amp;D</argument>,
<argument>ArrayRef&lt;Expr *&gt; NumIterations</argument>)</argument_list></macro> <name>override</name></expr>;



<expr><name>void</name> <macro><name>emitDoacrossOrdered</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>const OMPDependClause *C</argument>)</argument_list></macro> <name>override</name></expr>;





<expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><macro><name>translateParameter</name><argument_list>(<argument>const FieldDecl *FD</argument>,
<argument>const VarDecl *NativeParam</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;





<expr><name>Address</name> <macro><name>getParameterAddress</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>const VarDecl *NativeParam</argument>,
<argument>const VarDecl *TargetParam</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;


<expr><name>Address</name> <macro><name>getAddressOfLocalVariable</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>const VarDecl *VD</argument>)</argument_list></macro> <name>override</name> <block>{
<return>return <expr><name>Address</name><operator>::</operator><call><name>invalid</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;

}</block></expr></range></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt></block_content></block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
