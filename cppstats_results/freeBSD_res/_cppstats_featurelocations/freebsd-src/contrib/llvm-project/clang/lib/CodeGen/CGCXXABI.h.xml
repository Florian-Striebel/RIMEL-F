<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/lib/CodeGen/CGCXXABI.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_LIB_CODEGEN_CGCXXABI_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_LIB_CODEGEN_CGCXXABI_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"CodeGenFunction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/CodeGen/CodeGenABITypes.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>Constant</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CallInst</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>CastExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXConstructorDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXDestructorDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXMethodDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXRecordDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FieldDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MangleContext</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>CodeGen</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>CGCallee</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CodeGenFunction</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CodeGenModule</name></decl>;</decl_stmt>
<struct_decl>struct <name>CatchTypeInfo</name>;</struct_decl>


<decl_stmt><decl><type><name>class</name></type> <name>CGCXXABI</name> <block>{<block_content>
<label><name>protected</name>:</label>
<decl_stmt><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MangleContext</name></expr></argument>&gt;</argument_list></name> <name>MangleCtx</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CGCXXABI</name><argument_list>(<argument><expr><name>CodeGenModule</name> <operator>&amp;</operator><name>CGM</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>CGM</name><argument_list>(<argument><expr><name>CGM</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>MangleCtx</name><argument_list>(<argument>CGM.getContext().createMangleContext()</argument>)</argument_list></macro> <expr><block>{}</block>

<name>protected</name><operator>:</operator>
<name>ImplicitParamDecl</name> <operator>*</operator><macro><name>getThisDecl</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>CGF</name><operator>.</operator><name>CXXABIThisDecl</name></name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>getThisValue</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>CGF</name><operator>.</operator><name>CXXABIThisValue</name></name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>Address</name></type> <name>getThisAddress</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>Address</name><argument_list>(<argument><expr><name><name>CGF</name><operator>.</operator><name>CXXABIThisValue</name></name></expr></argument>, <argument><expr><name><name>CGF</name><operator>.</operator><name>CXXABIThisAlignment</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>ErrorUnsupportedABI</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>S</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>GetBogusMemberPointer</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro></expr>;</expr_stmt>

<function><type><name>ImplicitParamDecl</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>getStructorImplicitParamDecl</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name><name>CGF</name><operator>.</operator><name>CXXStructorImplicitParamDecl</name></name></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><operator>&amp;</operator><macro><name>getStructorImplicitParamValue</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>CGF</name><operator>.</operator><name>CXXStructorImplicitParamValue</name></name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>loadIncomingCXXThis</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>setCXXABIThisValue</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>ThisPtr</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>ASTContext</name> <operator>&amp;</operator><macro><name>getContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>CGM</name><operator>.</operator><name>getContext</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>requiresArrayCookie</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXDeleteExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>eltType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>virtual</name> <name>bool</name></type> <name>requiresArrayCookie</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXNewExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>isThisCompleteObject</name><argument_list>(<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>)</argument_list> const <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>

<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>CGCXXABI</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<function><type><name>MangleContext</name> <modifier>&amp;</modifier></type><name>getMangleContext</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><operator>*</operator><name>MangleCtx</name></expr>;</return>
</block_content>}</block></function>







<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>HasThisReturn</name><argument_list>(<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><name>false</name></expr>;</return> </block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>hasMostDerivedReturn</name><argument_list>(<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>)</argument_list> const <block>{<block_content> <return>return <expr><name>false</name></expr>;</return> </block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>useSinitAndSterm</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block></expr></expr_stmt>









<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>canCallMismatchedFunctionType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block></expr></expr_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>classifyReturnType</name><argument_list>(<argument><expr><name>CGFunctionInfo</name> <operator>&amp;</operator><name>FI</name></expr></argument>)</argument_list> const <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<enum>enum <name>RecordArgABI</name> <block>{


<decl><name>RAA_Default</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,




<decl><name>RAA_DirectInMemory</name></decl>,


<decl><name>RAA_Indirect</name></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>virtual</name> <name>RecordArgABI</name></type> <name>getRecordArgABI</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list> const <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>isSRetParameterAfterThis</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block></expr></expr_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type>
<name>isPermittedToBeHomogeneousAggregate</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator>
<call><name>ConvertMemberPointerType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MemberPointerType</name> <operator>*</operator><name>MPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<decl_stmt><decl><type><name>virtual</name> <name>CGCallee</name></type> <name>EmitLoadOfMemberFunctionPointer</name><argument_list>(
<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>E</name></expr></argument>, <argument><expr><name>Address</name> <name>This</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><operator>&amp;</operator><name>ThisPtrForCall</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>MemPtr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MemberPointerType</name> <operator>*</operator><name>MPT</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator>
<macro><name>EmitMemberDataPointerAddress</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>const Expr *E</argument>,
<argument>Address Base</argument>, <argument>llvm::Value *MemPtr</argument>,
<argument>const MemberPointerType *MPT</argument>)</argument_list></macro></expr>;</expr_stmt>



<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><call><name>EmitMemberPointerConversion</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CastExpr</name> <operator>*</operator><name>E</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><call><name>EmitMemberPointerConversion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CastExpr</name> <operator>*</operator><name>E</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>Src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<function_decl><type><name>virtual</name> <name>bool</name></type> <name>isZeroInitializable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MemberPointerType</name> <modifier>*</modifier></type><name>MPT</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>isMemberPointerConvertible</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MemberPointerType</name> <operator>*</operator><name>MPT</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><call><name>EmitNullMemberPointer</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MemberPointerType</name> <operator>*</operator><name>MPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><call><name>EmitMemberFunctionPointer</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXMethodDecl</name> <operator>*</operator><name>MD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>EmitMemberDataPointer</name><argument_list>(<argument>const MemberPointerType *MPT</argument>,
<argument>CharUnits offset</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>EmitMemberPointer</name><argument_list>(<argument>const APValue &amp;MP</argument>, <argument>QualType MPT</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator>
<macro><name>EmitMemberPointerComparison</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>llvm::Value *L</argument>,
<argument>llvm::Value *R</argument>,
<argument>const MemberPointerType *MPT</argument>,
<argument>bool Inequality</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator>
<call><name>EmitMemberPointerIsNotNull</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>MemPtr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MemberPointerType</name> <operator>*</operator><name>MPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>protected</name>:</label>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><call><name>getMemberPointerAdjustment</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CastExpr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>public</name>:</label>
<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitVirtualObjectDelete</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXDeleteExpr</name> <modifier>*</modifier></type><name>DE</name></decl></parameter>,
<parameter><decl><type><name>Address</name></type> <name>Ptr</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ElementType</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>Dtor</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitRethrow</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNoReturn</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitThrow</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXThrowExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator><macro><name>getThrowInfo</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block></expr></expr_stmt>




<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>canSpeculativelyEmitVTable</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list> const <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitBeginCatch</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXCatchStmt</name> <modifier>*</modifier></type><name>C</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>CallInst</name> <operator>*</operator>
<call><name>emitTerminateForUnexpectedException</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Exn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><macro><name>getAddrOfRTTIDescriptor</name><argument_list>(<argument>QualType Ty</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<function_decl><type><name>virtual</name> <name>CatchTypeInfo</name></type>
<name>getAddrOfCXXCatchHandlerType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>CatchHandlerType</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
<function_decl><type><name>virtual</name> <name>CatchTypeInfo</name></type> <name>getCatchAllTypeInfo</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>shouldTypeidBeNullChecked</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IsDeref</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>SrcRecordTy</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
<function_decl><type><name>virtual</name> <name>void</name></type> <name>EmitBadTypeidCall</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitTypeid</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>QualType SrcRecordTy</argument>,
<argument>Address ThisPtr</argument>,
<argument>llvm::Type *StdTypeInfoPtrTy</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>shouldDynamicCastCallBeNullChecked</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>SrcIsPtr</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>SrcRecordTy</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator>
<macro><name>EmitDynamicCastCall</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>Address Value</argument>,
<argument>QualType SrcRecordTy</argument>, <argument>QualType DestTy</argument>,
<argument>QualType DestRecordTy</argument>, <argument>llvm::BasicBlock *CastEnd</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitDynamicCastToVoid</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>Address Value</argument>,
<argument>QualType SrcRecordTy</argument>,
<argument>QualType DestTy</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>EmitBadCastCall</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>GetVirtualBaseClassOffset</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>Address This</argument>,
<argument>const CXXRecordDecl *ClassDecl</argument>,
<argument>const CXXRecordDecl *BaseClassDecl</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><call><name>EmitCtorCompleteObjectHandler</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<function><type><name>virtual</name> <name>void</name></type>
<name>initializeHiddenVirtualInheritanceMembers</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>EmitCXXConstructors</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>






<struct>struct <name>AddedStructorArgs</name> <block>{
<struct>struct <name>Arg</name> <block>{
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>Value</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>Type</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name></type> <name>Prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name></type> <name>Suffix</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>AddedStructorArgs</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<expr_stmt><expr><call><name>AddedStructorArgs</name><argument_list>(<argument><expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <name>P</name></expr></argument>, <argument><expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <name>S</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Prefix</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Suffix</name><argument_list>(<argument>std::move(S)</argument>)</argument_list></macro> <expr><block>{}</block>
<specifier>static</specifier> <name>AddedStructorArgs</name> <macro><name>prefix</name><argument_list>(<argument>SmallVector&lt;Arg</argument>, <argument><literal type="number">1</literal>&gt; Args</argument>)</argument_list></macro> <block>{
<return>return <expr><block>{<expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Args</name></expr></argument>)</argument_list></call></expr>, <expr><block>{}</block></expr>}</block></expr>;</return>
}</block></expr></expr_stmt>
<function><type><specifier>static</specifier> <name>AddedStructorArgs</name></type> <name>suffix</name><parameter_list>(<parameter><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><block>{<expr><block>{}</block></expr>, <expr><name>std</name><operator>::</operator><macro><name>move</name><argument_list>(<argument>Args</argument>)</argument_list></macro></expr>}</block></expr>;</return>
</block_content>}</block></function>
}</block>;</struct>



<struct>struct <name>AddedStructorArgCounts</name> <block>{
<decl_stmt><decl><type><name>unsigned</name></type> <name>Prefix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>Suffix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>AddedStructorArgCounts</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<macro><name>AddedStructorArgCounts</name><argument_list>(<argument>unsigned P</argument>, <argument>unsigned S</argument>)</argument_list></macro> : <expr_stmt><expr><call><name>Prefix</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Suffix</name><argument_list>(<argument>S</argument>)</argument_list></macro> <expr><block>{}</block>
<specifier>static</specifier> <name>AddedStructorArgCounts</name> <macro><name>prefix</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro> <block>{ <return>return <expr><block>{<expr><name>N</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>;</return> }</block></expr></expr_stmt>
<function><type><specifier>static</specifier> <name>AddedStructorArgCounts</name></type> <name>suffix</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>N</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><name>N</name></expr>}</block></expr>;</return> </block_content>}</block></function>
}</block>;</struct>




<function_decl><type><name>virtual</name> <name>AddedStructorArgCounts</name></type>
<name>buildStructorSignature</name><parameter_list>(<parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>CanQualType</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>ArgTys</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>




<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>useThunkForDtorVariant</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXDestructorDecl</name> <operator>*</operator><name>Dtor</name></expr></argument>,
<argument><expr><name>CXXDtorType</name> <name>DT</name></expr></argument>)</argument_list> const <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>setCXXDestructorDLLStorage</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>GlobalValue</name> <operator>*</operator><name>GV</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CXXDestructorDecl</name> <operator>*</operator><name>Dtor</name></expr></argument>,
<argument><expr><name>CXXDtorType</name> <name>DT</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>GlobalValue</name><operator>::</operator><name>LinkageTypes</name>
<macro><name>getCXXDestructorLinkage</name><argument_list>(<argument>GVALinkage Linkage</argument>, <argument>const CXXDestructorDecl *Dtor</argument>,
<argument>CXXDtorType DT</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>EmitCXXDestructors</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>





<function><type><name>virtual</name> <specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type>
<name>getThisArgumentTypeForMethod</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>MD</name><operator>-&gt;</operator><name>getParent</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><name>virtual</name> <name>Address</name></type>
<name>adjustThisArgumentForVirtualFunctionCall</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>,
<parameter><decl><type><name>Address</name></type> <name>This</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>VirtualCall</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>This</name></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>buildThisParam</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>FunctionArgList</name> <modifier>&amp;</modifier></type><name>Params</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>virtual</name> <name>void</name></type> <name>addImplicitStructorParams</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>ResTy</name></decl></parameter>,
<parameter><decl><type><name>FunctionArgList</name> <modifier>&amp;</modifier></type><name>Params</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>



<function><type><name>virtual</name> <name>CharUnits</name></type> <name>getVirtualFunctionPrologueThisAdjustment</name><parameter_list>(<parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>CharUnits</name><operator>::</operator><call><name>Zero</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>EmitInstanceFunctionProlog</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<function_decl><type><name>virtual</name> <name>AddedStructorArgs</name></type>
<name>getImplicitConstructorArgs</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>CXXCtorType</name></type> <name>Type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ForVirtualBase</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Delegating</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>





<function_decl><type><name>AddedStructorArgCounts</name></type>
<name>addImplicitConstructorArgs</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>CXXCtorType</name></type> <name>Type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ForVirtualBase</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Delegating</name></decl></parameter>, <parameter><decl><type><name>CallArgList</name> <modifier>&amp;</modifier></type><name>Args</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator>
<macro><name>getCXXDestructorImplicitParam</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>const CXXDestructorDecl *DD</argument>, <argument>CXXDtorType Type</argument>,
<argument>bool ForVirtualBase</argument>, <argument>bool Delegating</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>EmitDestructorCall</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>DD</name></decl></parameter>, <parameter><decl><type><name>CXXDtorType</name></type> <name>Type</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ForVirtualBase</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Delegating</name></decl></parameter>,
<parameter><decl><type><name>Address</name></type> <name>This</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ThisTy</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitVTableDefinitions</name><parameter_list>(<parameter><decl><type><name>CodeGenVTables</name> <modifier>&amp;</modifier></type><name>CGVT</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type>
<name>isVirtualOffsetNeededForVTableField</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><name>CodeGenFunction</name><operator>::</operator><name>VPtr</name> <name>Vptr</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<function_decl><type><name>virtual</name> <name>bool</name></type> <name>doStructorsInitializeVPtrs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>VTableClass</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator>
<macro><name>getVTableAddressPoint</name><argument_list>(<argument>BaseSubobject Base</argument>,
<argument>const CXXRecordDecl *VTableClass</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>



<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator>
<macro><name>getVTableAddressPointInStructor</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>const CXXRecordDecl *RD</argument>,
<argument>BaseSubobject Base</argument>,
<argument>const CXXRecordDecl *NearestVBase</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>



<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator>
<macro><name>getVTableAddressPointForConstExpr</name><argument_list>(<argument>BaseSubobject Base</argument>,
<argument>const CXXRecordDecl *VTableClass</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>



<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator><macro><name>getAddrOfVTable</name><argument_list>(<argument>const CXXRecordDecl *RD</argument>,
<argument>CharUnits VPtrOffset</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>CGCallee</name></type> <name>getVirtualFunctionPointer</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>, <argument><expr><name>Address</name> <name>This</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Type</name> <operator>*</operator><name>Ty</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>DeleteOrMemberCallExpr</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXDeleteExpr</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>CXXMemberCallExpr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>EmitVirtualDestructorCall</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>const CXXDestructorDecl *Dtor</argument>,
<argument>CXXDtorType DtorType</argument>,
<argument>Address This</argument>,
<argument>DeleteOrMemberCallExpr E</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<function><type><name>virtual</name> <name>void</name></type> <name>adjustCallArgsForDestructorThunk</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>,
<parameter><decl><type><name>CallArgList</name> <modifier>&amp;</modifier></type><name>CallArgs</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>




<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitVirtualInheritanceTables</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>exportThunk</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>setThunkLinkage</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Thunk</name></expr></argument>, <argument><expr><name>bool</name> <name>ForVTable</name></expr></argument>,
<argument><expr><name>GlobalDecl</name> <name>GD</name></expr></argument>, <argument><expr><name>bool</name> <name>ReturnAdjustment</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>performThisAdjustment</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>Address This</argument>,
<argument>const ThisAdjustment &amp;TA</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>performReturnAdjustment</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>,
<argument>Address Ret</argument>,
<argument>const ReturnAdjustment &amp;RA</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<function_decl><type><name>virtual</name> <name>void</name></type> <name>EmitReturnFromThunk</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><name>RValue</name></type> <name>RV</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ResultType</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>virtual</name> <name>size_t</name></type> <name>getSrcArgforCopyCtor</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXConstructorDecl</name> <operator>*</operator></expr></argument>,
<argument><expr><name>FunctionArgList</name> <operator>&amp;</operator><name>Args</name></expr></argument>)</argument_list> const <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>virtual</name> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CharUnits</name></expr></argument>&gt;</argument_list></name> <call><name>getVBPtrOffsets</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function_decl><type><name>virtual</name> <name>StringRef</name></type> <name>GetPureVirtualCallName</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<function_decl><type><name>virtual</name> <name>StringRef</name></type> <name>GetDeletedVirtualCallName</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>












<function_decl><type><name>virtual</name> <name>CharUnits</name></type> <name>GetArrayCookieSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXNewExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>










<decl_stmt><decl><type><name>virtual</name> <name>Address</name></type> <name>InitializeArrayCookie</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>,
<argument><expr><name>Address</name> <name>NewPtr</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>NumElements</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CXXNewExpr</name> <operator>*</operator><name>expr</name></expr></argument>,
<argument><expr><name>QualType</name> <name>ElementType</name></expr></argument>)</argument_list></decl>;</decl_stmt>














<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>ReadArrayCookie</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><name>Address</name> <name>Ptr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CXXDeleteExpr</name> <operator>*</operator><name>expr</name></expr></argument>,
<argument><expr><name>QualType</name> <name>ElementType</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><operator>&amp;</operator><name>NumElements</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><operator>&amp;</operator><name>AllocPtr</name></expr></argument>, <argument><expr><name>CharUnits</name> <operator>&amp;</operator><name>CookieSize</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>virtual</name> <name>bool</name></type> <name>NeedsVTTParameter</name><parameter_list>(<parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>protected</name>:</label>



<function_decl><type><name>virtual</name> <name>CharUnits</name></type> <name>getArrayCookieSizeImpl</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>elementType</name></decl></parameter>)</parameter_list>;</function_decl>










<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><macro><name>readArrayCookieImpl</name><argument_list>(<argument>CodeGenFunction &amp;IGF</argument>, <argument>Address ptr</argument>,
<argument>CharUnits cookieSize</argument>)</argument_list></macro></expr>;</expr_stmt>

<label><name>public</name>:</label>











<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>EmitGuardedInit</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator><name>DeclPtr</name></expr></argument>,
<argument><expr><name>bool</name> <name>PerformInit</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>






<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>registerGlobalDtor</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>FunctionCallee</name> <name>Dtor</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Constant</name> <operator>*</operator><name>Addr</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>












<function_decl><type><name>virtual</name> <name>void</name></type> <name>EmitThreadLocalInitFuncs</name><parameter_list>(
<parameter><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>CXXThreadLocals</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>CXXThreadLocalInits</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>CXXThreadLocalInitVars</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>



<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>usesThreadWrapperFunction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>)</argument_list> const <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>




<function_decl><type><name>virtual</name> <name>LValue</name></type> <name>EmitThreadLocalVarDeclLValue</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>LValType</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>



<function_decl><type><name>virtual</name> <name>void</name></type> <name>emitCXXStructor</name><parameter_list>(<parameter><decl><type><name>GlobalDecl</name></type> <name>GD</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>




<expr_stmt><expr><name>virtual</name> <name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<macro><name>LoadVTablePtr</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>Address This</argument>,
<argument>const CXXRecordDecl *RD</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<function_decl><type><name>CGCXXABI</name> <modifier>*</modifier></type><name>CreateItaniumCXXABI</name><parameter_list>(<parameter><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>CGCXXABI</name> <modifier>*</modifier></type><name>CreateMicrosoftCXXABI</name><parameter_list>(<parameter><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name><name>struct</name> <name>CatchRetScope</name></name></type> <name>final</name> <range>: <expr><name>EHScopeStack</name><operator>::</operator><name>Cleanup</name> <block>{
<expr><name>llvm</name><operator>::</operator><name>CatchPadInst</name> <operator>*</operator><name>CPI</name></expr>;

<expr><call><name>CatchRetScope</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>CatchPadInst</name> <operator>*</operator><name>CPI</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>CPI</name><argument_list>(<argument>CPI</argument>)</argument_list></macro> <block>{}</block>

<name>void</name> <macro><name>Emit</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>Flags flags</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><name>llvm</name><operator>::</operator><name>BasicBlock</name> <operator>*</operator><name>BB</name> <operator>=</operator> <call><name><name>CGF</name><operator>.</operator><name>createBasicBlock</name></name><argument_list>(<argument><expr><literal type="string">"catchret.dest"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>CGF</name><operator>.</operator><name>Builder</name><operator>.</operator><name>CreateCatchRet</name></name><argument_list>(<argument><expr><name>CPI</name></expr></argument>, <argument><expr><name>BB</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>CGF</name><operator>.</operator><name>EmitBlock</name></name><argument_list>(<argument><expr><name>BB</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>
}</block></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
