<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/lib/CodeGen/CGDebugInfo.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_LIB_CODEGEN_CGDEBUGINFO_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_LIB_CODEGEN_CGDEBUGINFO_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"CGBuilder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExternalASTSource.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/PrettyPrinter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeOrdering.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/CodeGenOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Module.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/IR/DIBuilder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/IR/DebugInfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/IR/ValueHandle.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Allocator.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>MDNode</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>ClassTemplateSpecializationDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>GlobalDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ModuleMap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCInterfaceDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCIvarDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UsingDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VarDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>DynamicInitKind</name> <range>: <expr><name>unsigned</name></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>CodeGen</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>CodeGenModule</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CodeGenFunction</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CGBlockInfo</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>CGDebugInfo</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ApplyDebugLocation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>SaveAndRestoreLocation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CodeGenModule</name> <modifier>&amp;</modifier></type><name>CGM</name></decl>;</decl_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>codegenoptions</name><operator>::</operator><name>DebugInfoKind</name> <name>DebugKind</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>DebugTypeExtRefs</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>DIBuilder</name> <name>DBuilder</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>DICompileUnit</name> <operator>*</operator><name>TheCU</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ModuleMap</name> <modifier>*</modifier></type><name>ClangModuleMap</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ASTSourceDescriptor</name></type> <name>PCHDescriptor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>CurLoc</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>MDNode</name> <operator>*</operator><name>CurInlinedAt</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>VTablePtrType</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>ClassTy</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>DICompositeType</name> <operator>*</operator><name>ObjTy</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>SelTy</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMAGE_TYPE</name><parameter_list>(<parameter><type><name>ImgType</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>, <parameter><type><name>SingletonId</name></type></parameter>, <parameter><type><name>Access</name></type></parameter>, <parameter><type><name>Suffix</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>llvm::DIType *SingletonId = nullptr;</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenCLImageTypes.def"</cpp:file></cpp:include>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>OCLSamplerDITy</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>OCLEventDITy</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>OCLClkEventDITy</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>OCLQueueDITy</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>OCLNDRangeDITy</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>OCLReserveIDDITy</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXT_OPAQUE_TYPE</name><parameter_list>(<parameter><type><name>ExtType</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>, <parameter><type><name>Ext</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>llvm::DIType *Id##Ty = nullptr;</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenCLExtensionTypes.def"</cpp:file></cpp:include>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>TrackingMDRef</name></expr></argument>&gt;</argument_list></name> <name>TypeCache</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>greater</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>DebugPrefixMap</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallDenseMap</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Metadata</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>SizeExprCache</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>class</name> <name>PrintingCallbacks</name></type> <name>final</name> <range>: <expr><name>public</name> <name>clang</name><operator>::</operator><name>PrintingCallbacks</name> <block>{
<expr><specifier>const</specifier> <name>CGDebugInfo</name> <operator>&amp;</operator><name>Self</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>PrintingCallbacks</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CGDebugInfo</name> <operator>&amp;</operator><name>Self</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>Self</name><argument_list>(<argument>Self</argument>)</argument_list></macro> <block>{}</block>
<name>std</name><operator>::</operator><name>string</name> <macro><name>remapPath</name><argument_list>(<argument>StringRef Path</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>Self</name><operator>.</operator><name>remapDIPath</name></name><argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;
<expr><name>PrintingCallbacks</name> <name>PrintCB</name> <operator>=</operator> <block>{<expr><operator>*</operator><name>this</name></expr>}</block></expr>;

struct <expr><name>ObjCInterfaceCacheEntry</name> <block>{
<expr><specifier>const</specifier> <name>ObjCInterfaceType</name> <operator>*</operator><name>Type</name></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>Decl</name></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>Unit</name></expr>;
<expr><call><name>ObjCInterfaceCacheEntry</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCInterfaceType</name> <operator>*</operator><name>Type</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>Decl</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>Unit</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Type</name><argument_list>(<argument><expr><name>Type</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Decl</name><argument_list>(<argument><expr><name>Decl</name></expr></argument>)</argument_list></call></expr>, <macro><name>Unit</name><argument_list>(<argument>Unit</argument>)</argument_list></macro> <expr><block>{}</block></expr>
}</block></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ObjCInterfaceCacheEntry</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>&gt;</argument_list></name> <name>ObjCInterfaceCache</name></expr>;




<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <operator>*</operator></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>DISubprogram</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>ObjCMethodCache</name></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Module</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>TrackingMDRef</name></expr></argument>&gt;</argument_list></name> <name>ModuleCache</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>RetainedTypes</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>TagType</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>TrackingMDRef</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>ReplaceMap</name></expr>;



<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>DeclaratorDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>TrackingMDRef</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>FwdDeclReplaceMap</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name><name>TypedTrackingMDRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>DIScope</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>LexicalBlockStack</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>TrackingMDRef</name></expr></argument>&gt;</argument_list></name> <name>RegionMap</name></expr>;



<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>FnBeginRegionCount</name></expr>;



<expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name> <name>DebugInfoNames</name></expr>;
<expr><name>StringRef</name> <name>CWDName</name></expr>;

<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>TrackingMDRef</name></expr></argument>&gt;</argument_list></name> <name>DIFileCache</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>TrackingMDRef</name></expr></argument>&gt;</argument_list></name> <name>SPCache</name></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>TrackingMDRef</name></expr></argument>&gt;</argument_list></name> <name>DeclCache</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>NamespaceDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>TrackingMDRef</name></expr></argument>&gt;</argument_list></name> <name>NamespaceCache</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>NamespaceAliasDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>TrackingMDRef</name></expr></argument>&gt;</argument_list></name>
<name>NamespaceAliasCache</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name><name>TypedTrackingMDRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>DIDerivedType</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>StaticDataMemberCache</name></expr>;

<expr><name>using</name> <name>ParamDecl2StmtTy</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ParmVarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>Param2DILocTy</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ParmVarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DILocalVariable</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;


<expr><name>ParamDecl2StmtTy</name> <name>CoroutineParameterMappings</name></expr>;

<expr><name>Param2DILocTy</name> <name>ParamDbgMappings</name></expr>;





<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>BuiltinType</name> <operator>*</operator><name>Ty</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ComplexType</name> <operator>*</operator><name>Ty</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>AutoType</name> <operator>*</operator><name>Ty</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ExtIntType</name> <operator>*</operator><name>Ty</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><macro><name>CreateQualifiedType</name><argument_list>(<argument>QualType Ty</argument>, <argument>llvm::DIFile *Fg</argument>)</argument_list></macro></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TypedefType</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>Fg</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TemplateSpecializationType</name> <operator>*</operator><name>Ty</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>Fg</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCObjectPointerType</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>PointerType</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>BlockPointerType</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionType</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></call></expr>;

<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RecordType</name> <operator>*</operator><name>Tyg</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateTypeDefinition</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RecordType</name> <operator>*</operator><name>Ty</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DICompositeType</name> <operator>*</operator><call><name>CreateLimitedType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RecordType</name> <operator>*</operator><name>Ty</name></expr></argument>)</argument_list></call></expr>;
<expr><name>void</name> <call><name>CollectContainingType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DICompositeType</name> <operator>*</operator><name>CT</name></expr></argument>)</argument_list></call></expr>;

<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCInterfaceType</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateTypeDefinition</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCInterfaceType</name> <operator>*</operator><name>Ty</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></call></expr>;

<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCObjectType</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCTypeParamType</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>Unit</name></expr></argument>)</argument_list></call></expr>;

<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VectorType</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ConstantMatrixType</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ArrayType</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LValueReferenceType</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RValueReferenceType</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>Unit</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MemberPointerType</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>AtomicType</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>PipeType</name> <operator>*</operator><name>Ty</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></call></expr>;

<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateEnumType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>EnumType</name> <operator>*</operator><name>Ty</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateTypeDefinition</name><argument_list>(<argument><expr><specifier>const</specifier> <name>EnumType</name> <operator>*</operator><name>Ty</name></expr></argument>)</argument_list></call></expr>;






<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>CreateSelfType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>QualType</name> <operator>&amp;</operator><name>QualTy</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>Ty</name></expr></argument>)</argument_list></call></expr>;




<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>getTypeOrNull</name><argument_list>(<argument><expr><specifier>const</specifier> <name>QualType</name></expr></argument>)</argument_list></call></expr>;




<expr><name>llvm</name><operator>::</operator><name>DISubroutineType</name> <operator>*</operator><macro><name>getOrCreateMethodType</name><argument_list>(<argument>const CXXMethodDecl *Method</argument>,
<argument>llvm::DIFile *F</argument>, <argument>bool decl</argument>)</argument_list></macro></expr>;
<expr><name>llvm</name><operator>::</operator><name>DISubroutineType</name> <operator>*</operator>
<macro><name>getOrCreateInstanceMethodType</name><argument_list>(<argument>QualType ThisPtr</argument>, <argument>const FunctionProtoType *Func</argument>,
<argument>llvm::DIFile *Unit</argument>, <argument>bool decl</argument>)</argument_list></macro></expr>;
<expr><name>llvm</name><operator>::</operator><name>DISubroutineType</name> <operator>*</operator>
<macro><name>getOrCreateFunctionType</name><argument_list>(<argument>const Decl *D</argument>, <argument>QualType FnType</argument>, <argument>llvm::DIFile *F</argument>)</argument_list></macro></expr>;

<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>getOrCreateVTablePtrType</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></call></expr>;


<expr><name>llvm</name><operator>::</operator><name>DINamespace</name> <operator>*</operator><call><name>getOrCreateNamespace</name><argument_list>(<argument><expr><specifier>const</specifier> <name>NamespaceDecl</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><macro><name>CreatePointerLikeType</name><argument_list>(<argument>llvm::dwarf::Tag Tag</argument>, <argument>const Type *Ty</argument>,
<argument>QualType PointeeTy</argument>, <argument>llvm::DIFile *F</argument>)</argument_list></macro></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><macro><name>getOrCreateStructPtrType</name><argument_list>(<argument>StringRef Name</argument>, <argument>llvm::DIType *&amp;Cache</argument>)</argument_list></macro></expr>;



<expr><name>llvm</name><operator>::</operator><name>DISubprogram</name> <operator>*</operator><call><name>CreateCXXMemberFunction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXMethodDecl</name> <operator>*</operator><name>Method</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>RecordTy</name></expr></argument>)</argument_list></call></expr>;




<expr><name>void</name> <call><name>CollectCXXMemberFunctions</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>Decl</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Metadata</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>E</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list></call></expr>;




<expr><name>void</name> <call><name>CollectCXXBases</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>Decl</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Metadata</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>EltTys</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>RecordTy</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <macro><name>CollectCXXBasesAux</name><argument_list>(
<argument>const CXXRecordDecl *RD</argument>, <argument>llvm::DIFile *Unit</argument>,
<argument>SmallVectorImpl&lt;llvm::Metadata *&gt; &amp;EltTys</argument>, <argument>llvm::DIType *RecordTy</argument>,
<argument>const CXXRecordDecl::base_class_const_range &amp;Bases</argument>,
<argument>llvm::DenseSet&lt;CanonicalDeclPtr&lt;const CXXRecordDecl&gt;&gt; &amp;SeenTypes</argument>,
<argument>llvm::DINode::DIFlags StartingFlags</argument>)</argument_list></macro></expr>;


<expr><name>llvm</name><operator>::</operator><name>DINodeArray</name> <call><name>CollectTemplateParams</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TemplateParameterList</name> <operator>*</operator><name>TPList</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <name>TAList</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>Unit</name></expr></argument>)</argument_list></call></expr>;


<expr><name>llvm</name><operator>::</operator><name>DINodeArray</name> <call><name>CollectFunctionTemplateParams</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>FD</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>Unit</name></expr></argument>)</argument_list></call></expr>;



<expr><name>llvm</name><operator>::</operator><name>DINodeArray</name> <call><name>CollectVarTemplateParams</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>Unit</name></expr></argument>)</argument_list></call></expr>;



<expr><name>llvm</name><operator>::</operator><name>DINodeArray</name>
<call><name>CollectCXXTemplateParams</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ClassTemplateSpecializationDecl</name> <operator>*</operator><name>TS</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>)</argument_list></call></expr>;

<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><macro><name>createFieldType</name><argument_list>(<argument>StringRef name</argument>, <argument>QualType type</argument>,
<argument>SourceLocation loc</argument>, <argument>AccessSpecifier AS</argument>,
<argument>uint64_t offsetInBits</argument>, <argument>uint32_t AlignInBits</argument>,
<argument>llvm::DIFile *tunit</argument>, <argument>llvm::DIScope *scope</argument>,
<argument>const RecordDecl *RD = nullptr</argument>)</argument_list></macro></expr>;

<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><macro><name>createFieldType</name><argument_list>(<argument>StringRef name</argument>, <argument>QualType type</argument>,
<argument>SourceLocation loc</argument>, <argument>AccessSpecifier AS</argument>,
<argument>uint64_t offsetInBits</argument>, <argument>llvm::DIFile *tunit</argument>,
<argument>llvm::DIScope *scope</argument>,
<argument>const RecordDecl *RD = nullptr</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>createFieldType</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>, <argument><expr><name>AS</name></expr></argument>, <argument><expr><name>offsetInBits</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tunit</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>,
<argument><expr><name>RD</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><call><name>createBitFieldType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><name>BitFieldDecl</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DIScope</name> <operator>*</operator><name>RecordTy</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>RecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <call><name>CollectRecordLambdaFields</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>CXXDecl</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Metadata</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>E</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>RecordTy</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>DIDerivedType</name> <operator>*</operator><call><name>CreateRecordStaticField</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>Var</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>RecordTy</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>RecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list></call></expr>;
<expr><name>void</name> <macro><name>CollectRecordNormalField</name><argument_list>(<argument>const FieldDecl *Field</argument>, <argument>uint64_t OffsetInBits</argument>,
<argument>llvm::DIFile *F</argument>,
<argument>SmallVectorImpl&lt;llvm::Metadata *&gt; &amp;E</argument>,
<argument>llvm::DIType *RecordTy</argument>, <argument>const RecordDecl *RD</argument>)</argument_list></macro></expr>;
<expr><name>void</name> <call><name>CollectRecordNestedType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TypeDecl</name> <operator>*</operator><name>RD</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Metadata</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>E</name></expr></argument>)</argument_list></call></expr>;
<expr><name>void</name> <call><name>CollectRecordFields</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RecordDecl</name> <operator>*</operator><name>Decl</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Metadata</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>E</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DICompositeType</name> <operator>*</operator><name>RecordTy</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <call><name>CollectVTableInfo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>Decl</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><name>F</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Metadata</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>EltTys</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <macro><name>CreateLexicalBlock</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;







<expr><name>void</name> <macro><name>AppendAddressSpaceXDeref</name><argument_list>(<argument>unsigned AddressSpace</argument>,
<argument>SmallVectorImpl&lt;int64_t&gt; &amp;Expr</argument>)</argument_list></macro> <specifier>const</specifier></expr>;





<expr><name>uint64_t</name> <macro><name>collectDefaultElementTypesForBlockPointer</name><argument_list>(
<argument>const BlockPointerType *Ty</argument>, <argument>llvm::DIFile *Unit</argument>,
<argument>llvm::DIDerivedType *DescTy</argument>, <argument>unsigned LineNo</argument>,
<argument>SmallVectorImpl&lt;llvm::Metadata *&gt; &amp;EltTys</argument>)</argument_list></macro></expr>;



<expr><name>void</name> <macro><name>collectDefaultFieldsForBlockLiteralDeclare</name><argument_list>(
<argument>const CGBlockInfo &amp;Block</argument>, <argument>const ASTContext &amp;Context</argument>, <argument>SourceLocation Loc</argument>,
<argument>const llvm::StructLayout &amp;BlockLayout</argument>, <argument>llvm::DIFile *Unit</argument>,
<argument>SmallVectorImpl&lt;llvm::Metadata *&gt; &amp;Fields</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>CGDebugInfo</name><argument_list>(<argument><expr><name>CodeGenModule</name> <operator>&amp;</operator><name>CGM</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>~</operator><call><name>CGDebugInfo</name><argument_list>()</argument_list></call></expr>;

<expr><name>void</name> <call><name>finalize</name><argument_list>()</argument_list></call></expr>;


<expr><name>std</name><operator>::</operator><name>string</name> <macro><name>remapDIPath</name><argument_list>(<argument>StringRef</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>void</name> <macro><name>registerVLASizeExpression</name><argument_list>(<argument>QualType Ty</argument>, <argument>llvm::Metadata *SizeExpr</argument>)</argument_list></macro> <block>{
<expr><name><name>SizeExprCache</name><index>[<expr><name>Ty</name></expr>]</index></name> <operator>=</operator> <name>SizeExpr</name></expr>;
}</block>




<name>void</name> <macro><name>setDwoId</name><argument_list>(<argument>uint64_t Signature</argument>)</argument_list></macro></expr>;




<expr><name>void</name> <macro><name>setModuleMap</name><argument_list>(<argument>ModuleMap &amp;MMap</argument>)</argument_list></macro> <block>{ <expr><name>ClangModuleMap</name> <operator>=</operator> <operator>&amp;</operator><name>MMap</name></expr>; }</block>




<name>void</name> <macro><name>setPCHDescriptor</name><argument_list>(<argument>ASTSourceDescriptor PCH</argument>)</argument_list></macro> <block>{ <expr><name>PCHDescriptor</name> <operator>=</operator> <name>PCH</name></expr>; }</block>




<name>void</name> <macro><name>setLocation</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;



<expr><name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CurLoc</name></expr>;</return> }</block>



<name>void</name> <macro><name>setInlinedAt</name><argument_list>(<argument>llvm::MDNode *InlinedAt</argument>)</argument_list></macro> <block>{ <expr><name>CurInlinedAt</name> <operator>=</operator> <name>InlinedAt</name></expr>; }</block>


<name>llvm</name><operator>::</operator><name>MDNode</name> <operator>*</operator><macro><name>getInlinedAt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CurInlinedAt</name></expr>;</return> }</block>


<name>llvm</name><operator>::</operator><name>DebugLoc</name> <macro><name>SourceLocToDebugLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;




<expr><name>void</name> <macro><name>EmitLocation</name><argument_list>(<argument>CGBuilderTy &amp;Builder</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;





<expr><name>void</name> <macro><name>emitFunctionStart</name><argument_list>(<argument>GlobalDecl GD</argument>, <argument>SourceLocation Loc</argument>,
<argument>SourceLocation ScopeLoc</argument>, <argument>QualType FnType</argument>,
<argument>llvm::Function *Fn</argument>, <argument>bool CurFnIsThunk</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <macro><name>EmitInlineFunctionStart</name><argument_list>(<argument>CGBuilderTy &amp;Builder</argument>, <argument>GlobalDecl GD</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <call><name>EmitInlineFunctionEnd</name><argument_list>(<argument><expr><name>CGBuilderTy</name> <operator>&amp;</operator><name>Builder</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <macro><name>EmitFunctionDecl</name><argument_list>(<argument>GlobalDecl GD</argument>, <argument>SourceLocation Loc</argument>,
<argument>QualType FnType</argument>, <argument>llvm::Function *Fn = nullptr</argument>)</argument_list></macro></expr>;



<expr><name>void</name> <macro><name>EmitFuncDeclForCallSite</name><argument_list>(<argument>llvm::CallBase *CallOrInvoke</argument>,
<argument>QualType CalleeType</argument>,
<argument>const FunctionDecl *CalleeDecl</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <call><name>EmitFunctionEnd</name><argument_list>(<argument><expr><name>CGBuilderTy</name> <operator>&amp;</operator><name>Builder</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Function</name> <operator>*</operator><name>Fn</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <macro><name>EmitLexicalBlockStart</name><argument_list>(<argument>CGBuilderTy &amp;Builder</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;



<expr><name>void</name> <macro><name>EmitLexicalBlockEnd</name><argument_list>(<argument>CGBuilderTy &amp;Builder</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;





<expr><name>llvm</name><operator>::</operator><name>DILocalVariable</name> <operator>*</operator>
<macro><name>EmitDeclareOfAutoVariable</name><argument_list>(<argument>const VarDecl *Decl</argument>, <argument>llvm::Value *AI</argument>,
<argument>CGBuilderTy &amp;Builder</argument>,
<argument>const bool UsePointerValue = false</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <call><name>EmitLabel</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LabelDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>CGBuilderTy</name> <operator>&amp;</operator><name>Builder</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <call><name>EmitDeclareOfBlockDeclRefVariable</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>variable</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Value</name> <operator>*</operator><name>storage</name></expr></argument>, <argument><expr><name>CGBuilderTy</name> <operator>&amp;</operator><name>Builder</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CGBlockInfo</name> <operator>&amp;</operator><name>blockInfo</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Instruction</name> <operator>*</operator><name>InsertPoint</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;



<expr><name>llvm</name><operator>::</operator><name>DILocalVariable</name> <operator>*</operator><macro><name>EmitDeclareOfArgVariable</name><argument_list>(<argument>const VarDecl *Decl</argument>,
<argument>llvm::Value *AI</argument>,
<argument>unsigned ArgNo</argument>,
<argument>CGBuilderTy &amp;Builder</argument>)</argument_list></macro></expr>;



<expr><name>void</name> <macro><name>EmitDeclareOfBlockLiteralArgVariable</name><argument_list>(<argument>const CGBlockInfo &amp;block</argument>,
<argument>StringRef Name</argument>, <argument>unsigned ArgNo</argument>,
<argument>llvm::AllocaInst *LocalAddr</argument>,
<argument>CGBuilderTy &amp;Builder</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <call><name>EmitGlobalVariable</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator><name>GV</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>Decl</name></expr></argument>)</argument_list></call></expr>;


<expr><name>void</name> <call><name>EmitGlobalVariable</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><name>VD</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>APValue</name> <operator>&amp;</operator><name>Init</name></expr></argument>)</argument_list></call></expr>;


<expr><name>void</name> <call><name>EmitExternalVariable</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>GlobalVariable</name> <operator>*</operator><name>GV</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>Decl</name></expr></argument>)</argument_list></call></expr>;


<expr><name>void</name> <call><name>EmitUsingDirective</name><argument_list>(<argument><expr><specifier>const</specifier> <name>UsingDirectiveDecl</name> <operator>&amp;</operator><name>UD</name></expr></argument>)</argument_list></call></expr>;


<expr><name>void</name> <macro><name>EmitExplicitCastType</name><argument_list>(<argument>QualType Ty</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <macro><name>EmitAndRetainType</name><argument_list>(<argument>QualType Ty</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <call><name>EmitUsingShadowDecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>UsingShadowDecl</name> <operator>&amp;</operator><name>USD</name></expr></argument>)</argument_list></call></expr>;


<expr><name>void</name> <call><name>EmitUsingDecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>UsingDecl</name> <operator>&amp;</operator><name>UD</name></expr></argument>)</argument_list></call></expr>;


<expr><name>void</name> <call><name>EmitUsingEnumDecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>UsingEnumDecl</name> <operator>&amp;</operator><name>UD</name></expr></argument>)</argument_list></call></expr>;


<expr><name>void</name> <call><name>EmitImportDecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ImportDecl</name> <operator>&amp;</operator><name>ID</name></expr></argument>)</argument_list></call></expr>;


<expr><name>llvm</name><operator>::</operator><name>DIImportedEntity</name> <operator>*</operator><call><name>EmitNamespaceAlias</name><argument_list>(<argument><expr><specifier>const</specifier> <name>NamespaceAliasDecl</name> <operator>&amp;</operator><name>NA</name></expr></argument>)</argument_list></call></expr>;


<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><macro><name>getOrCreateRecordType</name><argument_list>(<argument>QualType Ty</argument>, <argument>SourceLocation L</argument>)</argument_list></macro></expr>;


<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><macro><name>getOrCreateInterfaceType</name><argument_list>(<argument>QualType Ty</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;


<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><macro><name>getOrCreateStandaloneType</name><argument_list>(<argument>QualType Ty</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <macro><name>addHeapAllocSiteMetadata</name><argument_list>(<argument>llvm::CallBase *CallSite</argument>, <argument>QualType AllocatedTy</argument>,
<argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <call><name>completeType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>EnumDecl</name> <operator>*</operator><name>ED</name></expr></argument>)</argument_list></call></expr>;
<expr><name>void</name> <call><name>completeType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list></call></expr>;
<expr><name>void</name> <call><name>completeRequiredType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list></call></expr>;
<expr><name>void</name> <call><name>completeClassData</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list></call></expr>;
<expr><name>void</name> <call><name>completeClass</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list></call></expr>;

<expr><name>void</name> <call><name>completeTemplateDefinition</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ClassTemplateSpecializationDecl</name> <operator>&amp;</operator><name>SD</name></expr></argument>)</argument_list></call></expr>;
<expr><name>void</name> <call><name>completeUnusedClass</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>&amp;</operator><name>D</name></expr></argument>)</argument_list></call></expr>;



<expr><name>llvm</name><operator>::</operator><name>DIMacro</name> <operator>*</operator><macro><name>CreateMacro</name><argument_list>(<argument>llvm::DIMacroFile *Parent</argument>, <argument>unsigned MType</argument>,
<argument>SourceLocation LineLoc</argument>, <argument>StringRef Name</argument>,
<argument>StringRef Value</argument>)</argument_list></macro></expr>;


<expr><name>llvm</name><operator>::</operator><name>DIMacroFile</name> <operator>*</operator><macro><name>CreateTempMacroFile</name><argument_list>(<argument>llvm::DIMacroFile *Parent</argument>,
<argument>SourceLocation LineLoc</argument>,
<argument>SourceLocation FileLoc</argument>)</argument_list></macro></expr>;

<expr><name>Param2DILocTy</name> <operator>&amp;</operator><macro><name>getParamDbgMappings</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>ParamDbgMappings</name></expr>;</return> }</block>
<name>ParamDecl2StmtTy</name> <operator>&amp;</operator><macro><name>getCoroutineParameterMappings</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>CoroutineParameterMappings</name></expr>;</return>
}</block>

<name>private</name><operator>:</operator>



<name>llvm</name><operator>::</operator><name>DILocalVariable</name> <operator>*</operator><macro><name>EmitDeclare</name><argument_list>(<argument>const VarDecl *decl</argument>, <argument>llvm::Value *AI</argument>,
<argument>llvm::Optional&lt;unsigned&gt; ArgNo</argument>,
<argument>CGBuilderTy &amp;Builder</argument>,
<argument>const bool UsePointerValue = false</argument>)</argument_list></macro></expr>;

struct <expr><name>BlockByRefType</name> <block>{

<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>BlockByRefWrapper</name></expr>;

<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><name>WrappedType</name></expr>;
}</block></expr>;

<expr><name>std</name><operator>::</operator><name>string</name> <macro><name>GetName</name><argument_list>(<argument>const Decl*</argument>, <argument>bool Qualified = false</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>BlockByRefType</name> <call><name>EmitTypeForVarWithBlocksAttr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>,
<argument><expr><name>uint64_t</name> <operator>*</operator><name>OffSet</name></expr></argument>)</argument_list></call></expr>;


<expr><name>llvm</name><operator>::</operator><name>DIScope</name> <operator>*</operator><call><name>getDeclContextDescriptor</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;

<expr><name>llvm</name><operator>::</operator><name>DIScope</name> <operator>*</operator><call><name>getContextDescriptor</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>Context</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DIScope</name> <operator>*</operator><name>Default</name></expr></argument>)</argument_list></call></expr>;

<expr><name>llvm</name><operator>::</operator><name>DIScope</name> <operator>*</operator><call><name>getCurrentContextDescriptor</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>Decl</name></expr></argument>)</argument_list></call></expr>;


<expr><name>llvm</name><operator>::</operator><name>DICompositeType</name> <operator>*</operator><call><name>getOrCreateRecordFwdDecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RecordType</name> <operator>*</operator></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DIScope</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;


<expr><name>StringRef</name> <call><name>getCurrentDirname</name><argument_list>()</argument_list></call></expr>;


<expr><name>void</name> <call><name>CreateCompileUnit</name><argument_list>()</argument_list></call></expr>;


<expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name><operator>::</operator><name>ChecksumKind</name></expr></argument>&gt;</argument_list></name>
<macro><name>computeChecksum</name><argument_list>(<argument>FileID FID</argument>, <argument>SmallString&lt;<literal type="number">32</literal>&gt; &amp;Checksum</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <macro><name>getSource</name><argument_list>(<argument>const SourceManager &amp;SM</argument>, <argument>FileID FID</argument>)</argument_list></macro></expr>;



<expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><macro><name>getOrCreateFile</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;


<expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator>
<macro><name>createFile</name><argument_list>(<argument>StringRef FileName</argument>,
<argument>Optional&lt;llvm::DIFile::ChecksumInfo&lt;StringRef&gt;&gt; CSInfo</argument>,
<argument>Optional&lt;StringRef&gt; Source</argument>)</argument_list></macro></expr>;


<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><macro><name>getOrCreateType</name><argument_list>(<argument>QualType Ty</argument>, <argument>llvm::DIFile *Fg</argument>)</argument_list></macro></expr>;



<expr><name>llvm</name><operator>::</operator><name>DIModule</name> <operator>*</operator><macro><name>getOrCreateModuleRef</name><argument_list>(<argument>ASTSourceDescriptor Mod</argument>,
<argument>bool CreateSkeletonCU</argument>)</argument_list></macro></expr>;


<expr><name>llvm</name><operator>::</operator><name>DIModule</name> <operator>*</operator><call><name>getParentModuleOrNull</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;



<expr><name>llvm</name><operator>::</operator><name>DICompositeType</name> <operator>*</operator><call><name>getOrCreateLimitedType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RecordType</name> <operator>*</operator><name>Ty</name></expr></argument>)</argument_list></call></expr>;


<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><macro><name>CreateTypeNode</name><argument_list>(<argument>QualType Ty</argument>, <argument>llvm::DIFile *Fg</argument>)</argument_list></macro></expr>;


<expr><name>llvm</name><operator>::</operator><name>DIType</name> <operator>*</operator><macro><name>CreateMemberType</name><argument_list>(<argument>llvm::DIFile *Unit</argument>, <argument>QualType FType</argument>,
<argument>StringRef Name</argument>, <argument>uint64_t *Offset</argument>)</argument_list></macro></expr>;



<expr><name>llvm</name><operator>::</operator><name>DINode</name> <operator>*</operator><call><name>getDeclarationOrDefinition</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;



<expr><name>llvm</name><operator>::</operator><name>DISubprogram</name> <operator>*</operator><call><name>getFunctionDeclaration</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;







<expr><name>llvm</name><operator>::</operator><name>DISubprogram</name> <operator>*</operator>
<macro><name>getObjCMethodDeclaration</name><argument_list>(<argument>const Decl *D</argument>, <argument>llvm::DISubroutineType *FnType</argument>,
<argument>unsigned LineNo</argument>, <argument>llvm::DINode::DIFlags Flags</argument>,
<argument>llvm::DISubprogram::DISPFlags SPFlags</argument>)</argument_list></macro></expr>;





<expr><name>llvm</name><operator>::</operator><name>DIDerivedType</name> <operator>*</operator>
<call><name>getOrCreateStaticDataMemberDeclarationOrNull</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;


<expr><name>llvm</name><operator>::</operator><name>DISubprogram</name> <operator>*</operator><macro><name>getFunctionFwdDeclOrStub</name><argument_list>(<argument>GlobalDecl GD</argument>, <argument>bool Stub</argument>)</argument_list></macro></expr>;



<expr><name>llvm</name><operator>::</operator><name>DISubprogram</name> <operator>*</operator><macro><name>getFunctionForwardDeclaration</name><argument_list>(<argument>GlobalDecl GD</argument>)</argument_list></macro></expr>;



<expr><name>llvm</name><operator>::</operator><name>DISubprogram</name> <operator>*</operator><macro><name>getFunctionStub</name><argument_list>(<argument>GlobalDecl GD</argument>)</argument_list></macro></expr>;



<expr><name>llvm</name><operator>::</operator><name>DIGlobalVariable</name> <operator>*</operator>
<call><name>getGlobalVariableForwardDeclaration</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>)</argument_list></call></expr>;








<expr><name>llvm</name><operator>::</operator><name>DIGlobalVariableExpression</name> <operator>*</operator>
<macro><name>CollectAnonRecordDecls</name><argument_list>(<argument>const RecordDecl *RD</argument>, <argument>llvm::DIFile *Unit</argument>,
<argument>unsigned LineNo</argument>, <argument>StringRef LinkageName</argument>,
<argument>llvm::GlobalVariable *Var</argument>, <argument>llvm::DIScope *DContext</argument>)</argument_list></macro></expr>;




<expr><name>llvm</name><operator>::</operator><name>DINode</name><operator>::</operator><name>DIFlags</name> <macro><name>getCallSiteRelatedAttrs</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>PrintingPolicy</name> <macro><name>getPrintingPolicy</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>StringRef</name> <call><name>getFunctionName</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>FD</name></expr></argument>)</argument_list></call></expr>;



<expr><name>StringRef</name> <call><name>getObjCMethodName</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCMethodDecl</name> <operator>*</operator><name>FD</name></expr></argument>)</argument_list></call></expr>;



<expr><name>StringRef</name> <macro><name>getSelectorName</name><argument_list>(<argument>Selector S</argument>)</argument_list></macro></expr>;


<expr><name>StringRef</name> <call><name>getClassName</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>)</argument_list></call></expr>;


<expr><name>StringRef</name> <call><name>getVTableName</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>*</operator><name>Decl</name></expr></argument>)</argument_list></call></expr>;



<expr><name>StringRef</name> <macro><name>getDynamicInitializerName</name><argument_list>(<argument>const VarDecl *VD</argument>,
<argument>DynamicInitKind StubKind</argument>,
<argument>llvm::Function *InitFn</argument>)</argument_list></macro></expr>;



<expr><name>unsigned</name> <macro><name>getLineNumber</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro></expr>;




<expr><name>unsigned</name> <macro><name>getColumnNumber</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>bool Force = false</argument>)</argument_list></macro></expr>;



<expr><name>void</name> <macro><name>collectFunctionDeclProps</name><argument_list>(<argument>GlobalDecl GD</argument>, <argument>llvm::DIFile *Unit</argument>,
<argument>StringRef &amp;Name</argument>, <argument>StringRef &amp;LinkageName</argument>,
<argument>llvm::DIScope *&amp;FDContext</argument>,
<argument>llvm::DINodeArray &amp;TParamsArray</argument>,
<argument>llvm::DINode::DIFlags &amp;Flags</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <call><name>collectVarDeclProps</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>DIFile</name> <operator>*</operator><operator>&amp;</operator><name>Unit</name></expr></argument>,
<argument><expr><name>unsigned</name> <operator>&amp;</operator><name>LineNo</name></expr></argument>, <argument><expr><name>QualType</name> <operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><name>StringRef</name> <operator>&amp;</operator><name>Name</name></expr></argument>,
<argument><expr><name>StringRef</name> <operator>&amp;</operator><name>LinkageName</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>MDTuple</name> <operator>*</operator><operator>&amp;</operator><name>TemplateParameters</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>DIScope</name> <operator>*</operator><operator>&amp;</operator><name>VDContext</name></expr></argument>)</argument_list></call></expr>;




<expr><name>StringRef</name> <macro><name>internString</name><argument_list>(<argument>StringRef A</argument>, <argument>StringRef B = StringRef()</argument>)</argument_list></macro> <block>{
<expr><name>char</name> <operator>*</operator><name>Data</name> <operator>=</operator> <name><name>DebugInfoNames</name><operator>.</operator><name>Allocate</name></name><operator>&lt;</operator><name>char</name><operator>&gt;</operator><operator>(</operator><call><name><name>A</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>B</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>A</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>std</name><operator>::</operator><call><name>memcpy</name><argument_list>(<argument><expr><name>Data</name></expr></argument>, <argument><expr><call><name><name>A</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>A</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>B</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>std</name><operator>::</operator><call><name>memcpy</name><argument_list>(<argument><expr><name>Data</name> <operator>+</operator> <call><name><name>A</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>B</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>B</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></range></decl></decl_stmt>
<return>return <expr><call><name>StringRef</name><argument_list>(<argument><expr><name>Data</name></expr></argument>, <argument><expr><call><name><name>A</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <call><name><name>B</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>ApplyDebugLocation</name> <block>{<block_content>
<label><name>private</name>:</label>
<function_decl><type><name>void</name></type> <name>init</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>TemporaryLocation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>DefaultToEmpty</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<macro><name>ApplyDebugLocation</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>bool DefaultToEmpty</argument>,
<argument>SourceLocation TemporaryLocation</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>DebugLoc</name> <name>OriginalLocation</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>CodeGenFunction</name> <modifier>*</modifier></type><name>CGF</name></decl>;</decl_stmt>

<label><name>public</name>:</label>

<macro><name>ApplyDebugLocation</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>SourceLocation TemporaryLocation</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>ApplyDebugLocation</name><argument_list>(<argument><expr><name>CodeGenFunction</name> <operator>&amp;</operator><name>CGF</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>ApplyDebugLocation</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>llvm::DebugLoc Loc</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>ApplyDebugLocation</name><argument_list>(<argument><expr><name>ApplyDebugLocation</name> <operator>&amp;&amp;</operator><name>Other</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>CGF</name><argument_list>(<argument>Other.CGF</argument>)</argument_list></macro> <block>{
<expr><name><name>Other</name><operator>.</operator><name>CGF</name></name> <operator>=</operator> <name>nullptr</name></expr>;
}</block>
<name>ApplyDebugLocation</name> <operator>&amp;</operator><name>operator</name><operator>=</operator><operator>(</operator><name>ApplyDebugLocation</name> <operator>&amp;&amp;</operator><operator>)</operator> <operator>=</operator> default</expr>;</expr_stmt>

<expr_stmt><expr><operator>~</operator><call><name>ApplyDebugLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>












<function><type><specifier>static</specifier> <name>ApplyDebugLocation</name></type> <name>CreateArtificial</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>ApplyDebugLocation</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>ApplyDebugLocation</name></type>
<name>CreateDefaultArtificial</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemporaryLocation</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>ApplyDebugLocation</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>TemporaryLocation</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>ApplyDebugLocation</name></type> <name>CreateEmpty</name><parameter_list>(<parameter><decl><type><name>CodeGenFunction</name> <modifier>&amp;</modifier></type><name>CGF</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>ApplyDebugLocation</name><argument_list>(<argument><expr><name>CGF</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>ApplyInlineDebugLocation</name> <block>{<block_content>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>SavedLocation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CodeGenFunction</name> <modifier>*</modifier></type><name>CGF</name></decl>;</decl_stmt>

<label><name>public</name>:</label>



<macro><name>ApplyInlineDebugLocation</name><argument_list>(<argument>CodeGenFunction &amp;CGF</argument>, <argument>GlobalDecl InlinedFn</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><operator>~</operator><call><name>ApplyInlineDebugLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

</block_content>}</block></decl></decl_stmt>
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
